import { c as isPathAbsolute, h as getAnyExtensionFromPath, p as normalizePath, l as joinPaths, e as getDirectoryPath, m as resolvePath, r as resolveModule, f as getBaseFileName, v as hasTrailingDirectorySeparator, u as ensureTrailingDirectorySeparator } from './module-resolver-4ba9918f.js';

// noop logger shouldn't be used in browser
function formatLog(log) {
    return JSON.stringify(log);
}

const LogLevels = {
    trace: 10,
    warning: 40,
    error: 50,
};
const defaultOptions$2 = {
    level: "trace",
};
function createLogger(options) {
    const config = { ...defaultOptions$2, ...options };
    function log(log) {
        if (LogLevels[config.level] <= LogLevels[log.level]) {
            config.sink.log(processLog(log));
        }
    }
    return {
        log,
        trace: (message) => log({ level: "trace", message }),
        warn: (message) => log({ level: "warning", message }),
        error: (message) => log({ level: "error", message }),
    };
}
function processLog(log) {
    return {
        level: log.level,
        code: log.code,
        message: log.message,
        sourceLocation: getSourceLocation(log.target, { locateId: true }),
    };
}

/**
 * AST types
 */
var SyntaxKind;
(function (SyntaxKind) {
    SyntaxKind[SyntaxKind["TypeSpecScript"] = 0] = "TypeSpecScript";
    /** @deprecated Use TypeSpecScript */
    SyntaxKind[SyntaxKind["CadlScript"] = 0] = "CadlScript";
    SyntaxKind[SyntaxKind["JsSourceFile"] = 1] = "JsSourceFile";
    SyntaxKind[SyntaxKind["ImportStatement"] = 2] = "ImportStatement";
    SyntaxKind[SyntaxKind["Identifier"] = 3] = "Identifier";
    SyntaxKind[SyntaxKind["AugmentDecoratorStatement"] = 4] = "AugmentDecoratorStatement";
    SyntaxKind[SyntaxKind["DecoratorExpression"] = 5] = "DecoratorExpression";
    SyntaxKind[SyntaxKind["DirectiveExpression"] = 6] = "DirectiveExpression";
    SyntaxKind[SyntaxKind["MemberExpression"] = 7] = "MemberExpression";
    SyntaxKind[SyntaxKind["NamespaceStatement"] = 8] = "NamespaceStatement";
    SyntaxKind[SyntaxKind["UsingStatement"] = 9] = "UsingStatement";
    SyntaxKind[SyntaxKind["OperationStatement"] = 10] = "OperationStatement";
    SyntaxKind[SyntaxKind["OperationSignatureDeclaration"] = 11] = "OperationSignatureDeclaration";
    SyntaxKind[SyntaxKind["OperationSignatureReference"] = 12] = "OperationSignatureReference";
    SyntaxKind[SyntaxKind["ModelStatement"] = 13] = "ModelStatement";
    SyntaxKind[SyntaxKind["ModelExpression"] = 14] = "ModelExpression";
    SyntaxKind[SyntaxKind["ModelProperty"] = 15] = "ModelProperty";
    SyntaxKind[SyntaxKind["ModelSpreadProperty"] = 16] = "ModelSpreadProperty";
    SyntaxKind[SyntaxKind["ScalarStatement"] = 17] = "ScalarStatement";
    SyntaxKind[SyntaxKind["InterfaceStatement"] = 18] = "InterfaceStatement";
    SyntaxKind[SyntaxKind["UnionStatement"] = 19] = "UnionStatement";
    SyntaxKind[SyntaxKind["UnionVariant"] = 20] = "UnionVariant";
    SyntaxKind[SyntaxKind["EnumStatement"] = 21] = "EnumStatement";
    SyntaxKind[SyntaxKind["EnumMember"] = 22] = "EnumMember";
    SyntaxKind[SyntaxKind["EnumSpreadMember"] = 23] = "EnumSpreadMember";
    SyntaxKind[SyntaxKind["AliasStatement"] = 24] = "AliasStatement";
    SyntaxKind[SyntaxKind["DecoratorDeclarationStatement"] = 25] = "DecoratorDeclarationStatement";
    SyntaxKind[SyntaxKind["FunctionDeclarationStatement"] = 26] = "FunctionDeclarationStatement";
    SyntaxKind[SyntaxKind["FunctionParameter"] = 27] = "FunctionParameter";
    SyntaxKind[SyntaxKind["UnionExpression"] = 28] = "UnionExpression";
    SyntaxKind[SyntaxKind["IntersectionExpression"] = 29] = "IntersectionExpression";
    SyntaxKind[SyntaxKind["TupleExpression"] = 30] = "TupleExpression";
    SyntaxKind[SyntaxKind["ArrayExpression"] = 31] = "ArrayExpression";
    SyntaxKind[SyntaxKind["StringLiteral"] = 32] = "StringLiteral";
    SyntaxKind[SyntaxKind["NumericLiteral"] = 33] = "NumericLiteral";
    SyntaxKind[SyntaxKind["BooleanLiteral"] = 34] = "BooleanLiteral";
    SyntaxKind[SyntaxKind["StringTemplateExpression"] = 35] = "StringTemplateExpression";
    SyntaxKind[SyntaxKind["StringTemplateHead"] = 36] = "StringTemplateHead";
    SyntaxKind[SyntaxKind["StringTemplateMiddle"] = 37] = "StringTemplateMiddle";
    SyntaxKind[SyntaxKind["StringTemplateTail"] = 38] = "StringTemplateTail";
    SyntaxKind[SyntaxKind["StringTemplateSpan"] = 39] = "StringTemplateSpan";
    SyntaxKind[SyntaxKind["ExternKeyword"] = 40] = "ExternKeyword";
    SyntaxKind[SyntaxKind["VoidKeyword"] = 41] = "VoidKeyword";
    SyntaxKind[SyntaxKind["NeverKeyword"] = 42] = "NeverKeyword";
    SyntaxKind[SyntaxKind["UnknownKeyword"] = 43] = "UnknownKeyword";
    SyntaxKind[SyntaxKind["ValueOfExpression"] = 44] = "ValueOfExpression";
    SyntaxKind[SyntaxKind["TypeReference"] = 45] = "TypeReference";
    SyntaxKind[SyntaxKind["ProjectionReference"] = 46] = "ProjectionReference";
    SyntaxKind[SyntaxKind["TemplateParameterDeclaration"] = 47] = "TemplateParameterDeclaration";
    SyntaxKind[SyntaxKind["EmptyStatement"] = 48] = "EmptyStatement";
    SyntaxKind[SyntaxKind["InvalidStatement"] = 49] = "InvalidStatement";
    SyntaxKind[SyntaxKind["LineComment"] = 50] = "LineComment";
    SyntaxKind[SyntaxKind["BlockComment"] = 51] = "BlockComment";
    SyntaxKind[SyntaxKind["Doc"] = 52] = "Doc";
    SyntaxKind[SyntaxKind["DocText"] = 53] = "DocText";
    SyntaxKind[SyntaxKind["DocParamTag"] = 54] = "DocParamTag";
    SyntaxKind[SyntaxKind["DocReturnsTag"] = 55] = "DocReturnsTag";
    SyntaxKind[SyntaxKind["DocErrorsTag"] = 56] = "DocErrorsTag";
    SyntaxKind[SyntaxKind["DocTemplateTag"] = 57] = "DocTemplateTag";
    SyntaxKind[SyntaxKind["DocUnknownTag"] = 58] = "DocUnknownTag";
    SyntaxKind[SyntaxKind["Projection"] = 59] = "Projection";
    SyntaxKind[SyntaxKind["ProjectionParameterDeclaration"] = 60] = "ProjectionParameterDeclaration";
    SyntaxKind[SyntaxKind["ProjectionModelSelector"] = 61] = "ProjectionModelSelector";
    SyntaxKind[SyntaxKind["ProjectionModelPropertySelector"] = 62] = "ProjectionModelPropertySelector";
    SyntaxKind[SyntaxKind["ProjectionOperationSelector"] = 63] = "ProjectionOperationSelector";
    SyntaxKind[SyntaxKind["ProjectionUnionSelector"] = 64] = "ProjectionUnionSelector";
    SyntaxKind[SyntaxKind["ProjectionUnionVariantSelector"] = 65] = "ProjectionUnionVariantSelector";
    SyntaxKind[SyntaxKind["ProjectionInterfaceSelector"] = 66] = "ProjectionInterfaceSelector";
    SyntaxKind[SyntaxKind["ProjectionEnumSelector"] = 67] = "ProjectionEnumSelector";
    SyntaxKind[SyntaxKind["ProjectionEnumMemberSelector"] = 68] = "ProjectionEnumMemberSelector";
    SyntaxKind[SyntaxKind["ProjectionExpressionStatement"] = 69] = "ProjectionExpressionStatement";
    SyntaxKind[SyntaxKind["ProjectionIfExpression"] = 70] = "ProjectionIfExpression";
    SyntaxKind[SyntaxKind["ProjectionBlockExpression"] = 71] = "ProjectionBlockExpression";
    SyntaxKind[SyntaxKind["ProjectionMemberExpression"] = 72] = "ProjectionMemberExpression";
    SyntaxKind[SyntaxKind["ProjectionLogicalExpression"] = 73] = "ProjectionLogicalExpression";
    SyntaxKind[SyntaxKind["ProjectionEqualityExpression"] = 74] = "ProjectionEqualityExpression";
    SyntaxKind[SyntaxKind["ProjectionUnaryExpression"] = 75] = "ProjectionUnaryExpression";
    SyntaxKind[SyntaxKind["ProjectionRelationalExpression"] = 76] = "ProjectionRelationalExpression";
    SyntaxKind[SyntaxKind["ProjectionArithmeticExpression"] = 77] = "ProjectionArithmeticExpression";
    SyntaxKind[SyntaxKind["ProjectionCallExpression"] = 78] = "ProjectionCallExpression";
    SyntaxKind[SyntaxKind["ProjectionLambdaExpression"] = 79] = "ProjectionLambdaExpression";
    SyntaxKind[SyntaxKind["ProjectionLambdaParameterDeclaration"] = 80] = "ProjectionLambdaParameterDeclaration";
    SyntaxKind[SyntaxKind["ProjectionModelExpression"] = 81] = "ProjectionModelExpression";
    SyntaxKind[SyntaxKind["ProjectionModelProperty"] = 82] = "ProjectionModelProperty";
    SyntaxKind[SyntaxKind["ProjectionModelSpreadProperty"] = 83] = "ProjectionModelSpreadProperty";
    SyntaxKind[SyntaxKind["ProjectionSpreadProperty"] = 84] = "ProjectionSpreadProperty";
    SyntaxKind[SyntaxKind["ProjectionTupleExpression"] = 85] = "ProjectionTupleExpression";
    SyntaxKind[SyntaxKind["ProjectionStatement"] = 86] = "ProjectionStatement";
    SyntaxKind[SyntaxKind["ProjectionDecoratorReferenceExpression"] = 87] = "ProjectionDecoratorReferenceExpression";
    SyntaxKind[SyntaxKind["Return"] = 88] = "Return";
    SyntaxKind[SyntaxKind["JsNamespaceDeclaration"] = 89] = "JsNamespaceDeclaration";
})(SyntaxKind || (SyntaxKind = {}));
var IdentifierKind;
(function (IdentifierKind) {
    IdentifierKind[IdentifierKind["TypeReference"] = 0] = "TypeReference";
    IdentifierKind[IdentifierKind["Decorator"] = 1] = "Decorator";
    IdentifierKind[IdentifierKind["Function"] = 2] = "Function";
    IdentifierKind[IdentifierKind["Using"] = 3] = "Using";
    IdentifierKind[IdentifierKind["Declaration"] = 4] = "Declaration";
    IdentifierKind[IdentifierKind["Other"] = 5] = "Other";
})(IdentifierKind || (IdentifierKind = {}));
/** Used to explicitly specify that a diagnostic has no target. */
const NoTarget = Symbol.for("NoTarget");
var ListenerFlow;
(function (ListenerFlow) {
    /**
     * Do not navigate any containing or referenced type.
     */
    ListenerFlow[ListenerFlow["NoRecursion"] = 1] = "NoRecursion";
})(ListenerFlow || (ListenerFlow = {}));

/**
 * Create a new diagnostics creator.
 * @param diagnostics Map of the potential diagnostics.
 * @param libraryName Optional name of the library if in the scope of a library.
 * @returns @see DiagnosticCreator
 */
function createDiagnosticCreator(diagnostics, libraryName) {
    const errorMessage = libraryName
        ? `It must match one of the code defined in the library '${libraryName}'`
        : "It must match one of the code defined in the compiler.";
    function createDiagnostic(diagnostic) {
        var _a;
        const diagnosticDef = diagnostics[diagnostic.code];
        if (!diagnosticDef) {
            const codeStr = Object.keys(diagnostics)
                .map((x) => ` - ${x}`)
                .join("\n");
            const code = String(diagnostic.code);
            throw new Error(`Unexpected diagnostic code '${code}'. ${errorMessage}. Defined codes:\n${codeStr}`);
        }
        const message = diagnosticDef.messages[(_a = diagnostic.messageId) !== null && _a !== void 0 ? _a : "default"];
        if (!message) {
            const codeStr = Object.keys(diagnosticDef.messages)
                .map((x) => ` - ${x}`)
                .join("\n");
            const messageId = String(diagnostic.messageId);
            const code = String(diagnostic.code);
            throw new Error(`Unexpected message id '${messageId}'. ${errorMessage} for code '${code}'. Defined codes:\n${codeStr}`);
        }
        const messageStr = typeof message === "string" ? message : message(diagnostic.format);
        return {
            code: libraryName ? `${libraryName}/${String(diagnostic.code)}` : diagnostic.code.toString(),
            severity: diagnosticDef.severity,
            message: messageStr,
            target: diagnostic.target,
        };
    }
    function reportDiagnostic(program, diagnostic) {
        const diag = createDiagnostic(diagnostic);
        program.reportDiagnostic(diag);
    }
    return {
        diagnostics,
        createDiagnostic,
        reportDiagnostic,
    };
}
/**
 * Represents a failure while interpreting a projection.
 */
class ProjectionError extends Error {
    constructor(message) {
        super(message);
        this.name = "ProjectionError";
    }
}
function logDiagnostics(diagnostics, logger) {
    for (const diagnostic of diagnostics) {
        logger.log({
            level: diagnostic.severity,
            message: diagnostic.message,
            code: diagnostic.code,
            sourceLocation: getSourceLocation(diagnostic.target, { locateId: true }),
        });
    }
}
function formatDiagnostic(diagnostic) {
    return formatLog({
        code: diagnostic.code,
        level: diagnostic.severity,
        message: diagnostic.message,
        sourceLocation: getSourceLocation(diagnostic.target, { locateId: true }),
    });
}
function createSourceFile(text, path) {
    let lineStarts = undefined;
    return {
        text,
        path,
        getLineStarts,
        getLineAndCharacterOfPosition,
    };
    function getLineStarts() {
        return (lineStarts = lineStarts !== null && lineStarts !== void 0 ? lineStarts : scanLineStarts(text));
    }
    function getLineAndCharacterOfPosition(position) {
        const starts = getLineStarts();
        let line = binarySearch(starts, position);
        // When binarySearch returns < 0 indicating that the value was not found, it
        // returns the bitwise complement of the index where the value would need to
        // be inserted to keep the array sorted. So flipping the bits back to this
        // positive index tells us what the line number would be if we were to
        // create a new line starting at the given position, and subtracting 1 from
        // that therefore gives us the line number we're after.
        if (line < 0) {
            line = ~line - 1;
        }
        return {
            line,
            character: position - starts[line],
        };
    }
}
function getSourceLocation(target, options = {}) {
    if (target === NoTarget || target === undefined) {
        return undefined;
    }
    if ("file" in target) {
        return target;
    }
    if (!("kind" in target)) {
        // symbol
        if (target.flags & 524288 /* SymbolFlags.Using */) {
            target = target.symbolSource;
        }
        if (!target.declarations[0]) {
            return createSyntheticSourceLocation();
        }
        return getSourceLocationOfNode(target.declarations[0], options);
    }
    else if (typeof target.kind === "number") {
        // node
        return getSourceLocationOfNode(target, options);
    }
    else {
        // type
        const targetNode = target.node;
        if (targetNode) {
            return getSourceLocationOfNode(targetNode, options);
        }
        return createSyntheticSourceLocation();
    }
}
function createSyntheticSourceLocation(loc = "<unknown location>") {
    return {
        file: createSourceFile("", loc),
        pos: 0,
        end: 0,
        isSynthetic: true,
    };
}
function getSourceLocationOfNode(node, options) {
    let root = node;
    while (root.parent !== undefined) {
        root = root.parent;
    }
    if (root.kind !== SyntaxKind.TypeSpecScript && root.kind !== SyntaxKind.JsSourceFile) {
        return createSyntheticSourceLocation(node.flags & 8 /* NodeFlags.Synthetic */
            ? undefined
            : "<unknown location - cannot obtain source location of unbound node - file bug at https://github.com/microsoft/typespec>");
    }
    if (options.locateId && "id" in node && node.id !== undefined) {
        node = node.id;
    }
    return {
        file: root.file,
        pos: node.pos,
        end: node.end,
    };
}
/**
 * Verbose output is enabled by default for runs in mocha explorer in VS Code,
 * where the output is nicely associated with the individual test, and disabled
 * by default for command line runs where we don't want to spam the console.
 *
 * If the steps taken to produce the message are expensive, pass a callback
 * instead of producing the message then passing it here only to be dropped
 * when verbose output is disabled.
 */
function logVerboseTestOutput(messageOrCallback) {
    if (process.env.TYPESPEC_VERBOSE_TEST_OUTPUT) {
        if (typeof messageOrCallback === "string") {
            // eslint-disable-next-line no-console
            console.log(messageOrCallback);
        }
        else {
            // eslint-disable-next-line no-console
            messageOrCallback(console.log);
        }
    }
}
/**
 * Use this to report bugs in the compiler, and not errors in the source code
 * being compiled.
 *
 * @param condition Throw if this is not true.
 *
 * @param message Error message.
 *
 * @param target Optional location in source code that might give a clue about
 *               what got the compiler off track.
 */
function compilerAssert(condition, message, target) {
    if (condition) {
        return;
    }
    if (target) {
        let location;
        try {
            location = getSourceLocation(target);
        }
        catch (err) { }
        if (location) {
            const pos = location.file.getLineAndCharacterOfPosition(location.pos);
            const file = location.file.path;
            const line = pos.line + 1;
            const col = pos.character + 1;
            message += `\nOccurred while compiling code in ${file} near line ${line}, column ${col}`;
        }
    }
    throw new Error(message);
}
function scanLineStarts(text) {
    const starts = [];
    let start = 0;
    let pos = 0;
    while (pos < text.length) {
        const ch = text.charCodeAt(pos);
        pos++;
        switch (ch) {
            case 13 /* CharCode.CarriageReturn */:
                if (text.charCodeAt(pos) === 10 /* CharCode.LineFeed */) {
                    pos++;
                }
            // fallthrough
            case 10 /* CharCode.LineFeed */:
                starts.push(start);
                start = pos;
                break;
        }
    }
    starts.push(start);
    return starts;
}
/**
 * Search sorted array of numbers for the given value. If found, return index
 * in array where value was found. If not found, return a negative number that
 * is the bitwise complement of the index where value would need to be inserted
 * to keep the array sorted.
 */
function binarySearch(array, value) {
    let low = 0;
    let high = array.length - 1;
    while (low <= high) {
        const middle = low + ((high - low) >> 1);
        const v = array[middle];
        if (v < value) {
            low = middle + 1;
        }
        else if (v > value) {
            high = middle - 1;
        }
        else {
            return middle;
        }
    }
    return ~low;
}
/**
 * Assert that the input type has one of the kinds provided
 */
function assertType(typeDescription, t, ...kinds) {
    if (kinds.indexOf(t.kind) === -1) {
        throw new ProjectionError(`Expected ${typeDescription} to be type ${kinds.join(", ")}`);
    }
}
/**
 * Report a deprecated diagnostic.
 * @param program TypeSpec Program.
 * @param message Message describing the deprecation.
 * @param target Target of the deprecation.
 */
function reportDeprecated(program, message, target) {
    reportDiagnostic(program, {
        code: "deprecated",
        format: {
            message,
        },
        target,
    });
}
/**
 * Create a new instance of the @see DiagnosticCollector.
 */
function createDiagnosticCollector() {
    const diagnostics = [];
    return {
        diagnostics,
        add,
        pipe,
        wrap,
    };
    function add(diagnostic) {
        diagnostics.push(diagnostic);
    }
    function pipe(result) {
        const [value, diags] = result;
        for (const diag of diags) {
            diagnostics.push(diag);
        }
        return value;
    }
    function wrap(value) {
        return [value, diagnostics];
    }
}
/**
 * Ignore the diagnostics emitted by the diagnostic accessor pattern and just return the actual result.
 * @param result: Accessor pattern tuple result including the actual result and the list of diagnostics.
 * @returns Actual result.
 */
function ignoreDiagnostics(result) {
    return result[0];
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function getAugmentedNamespace(n) {
  if (n.__esModule) return n;
  var f = n.default;
	if (typeof f == "function") {
		var a = function a () {
			if (this instanceof a) {
        return Reflect.construct(f, arguments, this.constructor);
			}
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

var ajv = {exports: {}};

var core$2 = {};

var validate = {};

var boolSchema = {};

var errors = {};

var codegen = {};

var code$1 = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
	class _CodeOrName {
	}
	exports._CodeOrName = _CodeOrName;
	exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
	class Name extends _CodeOrName {
	    constructor(s) {
	        super();
	        if (!exports.IDENTIFIER.test(s))
	            throw new Error("CodeGen: name must be a valid identifier");
	        this.str = s;
	    }
	    toString() {
	        return this.str;
	    }
	    emptyStr() {
	        return false;
	    }
	    get names() {
	        return { [this.str]: 1 };
	    }
	}
	exports.Name = Name;
	class _Code extends _CodeOrName {
	    constructor(code) {
	        super();
	        this._items = typeof code === "string" ? [code] : code;
	    }
	    toString() {
	        return this.str;
	    }
	    emptyStr() {
	        if (this._items.length > 1)
	            return false;
	        const item = this._items[0];
	        return item === "" || item === '""';
	    }
	    get str() {
	        var _a;
	        return ((_a = this._str) !== null && _a !== void 0 ? _a : (this._str = this._items.reduce((s, c) => `${s}${c}`, "")));
	    }
	    get names() {
	        var _a;
	        return ((_a = this._names) !== null && _a !== void 0 ? _a : (this._names = this._items.reduce((names, c) => {
	            if (c instanceof Name)
	                names[c.str] = (names[c.str] || 0) + 1;
	            return names;
	        }, {})));
	    }
	}
	exports._Code = _Code;
	exports.nil = new _Code("");
	function _(strs, ...args) {
	    const code = [strs[0]];
	    let i = 0;
	    while (i < args.length) {
	        addCodeArg(code, args[i]);
	        code.push(strs[++i]);
	    }
	    return new _Code(code);
	}
	exports._ = _;
	const plus = new _Code("+");
	function str(strs, ...args) {
	    const expr = [safeStringify(strs[0])];
	    let i = 0;
	    while (i < args.length) {
	        expr.push(plus);
	        addCodeArg(expr, args[i]);
	        expr.push(plus, safeStringify(strs[++i]));
	    }
	    optimize(expr);
	    return new _Code(expr);
	}
	exports.str = str;
	function addCodeArg(code, arg) {
	    if (arg instanceof _Code)
	        code.push(...arg._items);
	    else if (arg instanceof Name)
	        code.push(arg);
	    else
	        code.push(interpolate(arg));
	}
	exports.addCodeArg = addCodeArg;
	function optimize(expr) {
	    let i = 1;
	    while (i < expr.length - 1) {
	        if (expr[i] === plus) {
	            const res = mergeExprItems(expr[i - 1], expr[i + 1]);
	            if (res !== undefined) {
	                expr.splice(i - 1, 3, res);
	                continue;
	            }
	            expr[i++] = "+";
	        }
	        i++;
	    }
	}
	function mergeExprItems(a, b) {
	    if (b === '""')
	        return a;
	    if (a === '""')
	        return b;
	    if (typeof a == "string") {
	        if (b instanceof Name || a[a.length - 1] !== '"')
	            return;
	        if (typeof b != "string")
	            return `${a.slice(0, -1)}${b}"`;
	        if (b[0] === '"')
	            return a.slice(0, -1) + b.slice(1);
	        return;
	    }
	    if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
	        return `"${a}${b.slice(1)}`;
	    return;
	}
	function strConcat(c1, c2) {
	    return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str `${c1}${c2}`;
	}
	exports.strConcat = strConcat;
	// TODO do not allow arrays here
	function interpolate(x) {
	    return typeof x == "number" || typeof x == "boolean" || x === null
	        ? x
	        : safeStringify(Array.isArray(x) ? x.join(",") : x);
	}
	function stringify(x) {
	    return new _Code(safeStringify(x));
	}
	exports.stringify = stringify;
	function safeStringify(x) {
	    return JSON.stringify(x)
	        .replace(/\u2028/g, "\\u2028")
	        .replace(/\u2029/g, "\\u2029");
	}
	exports.safeStringify = safeStringify;
	function getProperty(key) {
	    return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _ `[${key}]`;
	}
	exports.getProperty = getProperty;
	//Does best effort to format the name properly
	function getEsmExportName(key) {
	    if (typeof key == "string" && exports.IDENTIFIER.test(key)) {
	        return new _Code(`${key}`);
	    }
	    throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
	}
	exports.getEsmExportName = getEsmExportName;
	function regexpCode(rx) {
	    return new _Code(rx.toString());
	}
	exports.regexpCode = regexpCode;
	
} (code$1));

var scope = {};

var hasRequiredScope;

function requireScope () {
	if (hasRequiredScope) return scope;
	hasRequiredScope = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
		const code_1 = code$1;
		class ValueError extends Error {
		    constructor(name) {
		        super(`CodeGen: "code" for ${name} not defined`);
		        this.value = name.value;
		    }
		}
		var UsedValueState;
		(function (UsedValueState) {
		    UsedValueState[UsedValueState["Started"] = 0] = "Started";
		    UsedValueState[UsedValueState["Completed"] = 1] = "Completed";
		})(UsedValueState = exports.UsedValueState || (exports.UsedValueState = {}));
		exports.varKinds = {
		    const: new code_1.Name("const"),
		    let: new code_1.Name("let"),
		    var: new code_1.Name("var"),
		};
		class Scope {
		    constructor({ prefixes, parent } = {}) {
		        this._names = {};
		        this._prefixes = prefixes;
		        this._parent = parent;
		    }
		    toName(nameOrPrefix) {
		        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
		    }
		    name(prefix) {
		        return new code_1.Name(this._newName(prefix));
		    }
		    _newName(prefix) {
		        const ng = this._names[prefix] || this._nameGroup(prefix);
		        return `${prefix}${ng.index++}`;
		    }
		    _nameGroup(prefix) {
		        var _a, _b;
		        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || (this._prefixes && !this._prefixes.has(prefix))) {
		            throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
		        }
		        return (this._names[prefix] = { prefix, index: 0 });
		    }
		}
		exports.Scope = Scope;
		class ValueScopeName extends code_1.Name {
		    constructor(prefix, nameStr) {
		        super(nameStr);
		        this.prefix = prefix;
		    }
		    setValue(value, { property, itemIndex }) {
		        this.value = value;
		        this.scopePath = (0, code_1._) `.${new code_1.Name(property)}[${itemIndex}]`;
		    }
		}
		exports.ValueScopeName = ValueScopeName;
		const line = (0, code_1._) `\n`;
		class ValueScope extends Scope {
		    constructor(opts) {
		        super(opts);
		        this._values = {};
		        this._scope = opts.scope;
		        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
		    }
		    get() {
		        return this._scope;
		    }
		    name(prefix) {
		        return new ValueScopeName(prefix, this._newName(prefix));
		    }
		    value(nameOrPrefix, value) {
		        var _a;
		        if (value.ref === undefined)
		            throw new Error("CodeGen: ref must be passed in value");
		        const name = this.toName(nameOrPrefix);
		        const { prefix } = name;
		        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
		        let vs = this._values[prefix];
		        if (vs) {
		            const _name = vs.get(valueKey);
		            if (_name)
		                return _name;
		        }
		        else {
		            vs = this._values[prefix] = new Map();
		        }
		        vs.set(valueKey, name);
		        const s = this._scope[prefix] || (this._scope[prefix] = []);
		        const itemIndex = s.length;
		        s[itemIndex] = value.ref;
		        name.setValue(value, { property: prefix, itemIndex });
		        return name;
		    }
		    getValue(prefix, keyOrRef) {
		        const vs = this._values[prefix];
		        if (!vs)
		            return;
		        return vs.get(keyOrRef);
		    }
		    scopeRefs(scopeName, values = this._values) {
		        return this._reduceValues(values, (name) => {
		            if (name.scopePath === undefined)
		                throw new Error(`CodeGen: name "${name}" has no value`);
		            return (0, code_1._) `${scopeName}${name.scopePath}`;
		        });
		    }
		    scopeCode(values = this._values, usedValues, getCode) {
		        return this._reduceValues(values, (name) => {
		            if (name.value === undefined)
		                throw new Error(`CodeGen: name "${name}" has no value`);
		            return name.value.code;
		        }, usedValues, getCode);
		    }
		    _reduceValues(values, valueCode, usedValues = {}, getCode) {
		        let code = code_1.nil;
		        for (const prefix in values) {
		            const vs = values[prefix];
		            if (!vs)
		                continue;
		            const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map());
		            vs.forEach((name) => {
		                if (nameSet.has(name))
		                    return;
		                nameSet.set(name, UsedValueState.Started);
		                let c = valueCode(name);
		                if (c) {
		                    const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
		                    code = (0, code_1._) `${code}${def} ${name} = ${c};${this.opts._n}`;
		                }
		                else if ((c = getCode === null || getCode === void 0 ? void 0 : getCode(name))) {
		                    code = (0, code_1._) `${code}${c}${this.opts._n}`;
		                }
		                else {
		                    throw new ValueError(name);
		                }
		                nameSet.set(name, UsedValueState.Completed);
		            });
		        }
		        return code;
		    }
		}
		exports.ValueScope = ValueScope;
		
	} (scope));
	return scope;
}

var hasRequiredCodegen;

function requireCodegen () {
	if (hasRequiredCodegen) return codegen;
	hasRequiredCodegen = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
		const code_1 = code$1;
		const scope_1 = requireScope();
		var code_2 = code$1;
		Object.defineProperty(exports, "_", { enumerable: true, get: function () { return code_2._; } });
		Object.defineProperty(exports, "str", { enumerable: true, get: function () { return code_2.str; } });
		Object.defineProperty(exports, "strConcat", { enumerable: true, get: function () { return code_2.strConcat; } });
		Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return code_2.nil; } });
		Object.defineProperty(exports, "getProperty", { enumerable: true, get: function () { return code_2.getProperty; } });
		Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return code_2.stringify; } });
		Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function () { return code_2.regexpCode; } });
		Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return code_2.Name; } });
		var scope_2 = requireScope();
		Object.defineProperty(exports, "Scope", { enumerable: true, get: function () { return scope_2.Scope; } });
		Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function () { return scope_2.ValueScope; } });
		Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function () { return scope_2.ValueScopeName; } });
		Object.defineProperty(exports, "varKinds", { enumerable: true, get: function () { return scope_2.varKinds; } });
		exports.operators = {
		    GT: new code_1._Code(">"),
		    GTE: new code_1._Code(">="),
		    LT: new code_1._Code("<"),
		    LTE: new code_1._Code("<="),
		    EQ: new code_1._Code("==="),
		    NEQ: new code_1._Code("!=="),
		    NOT: new code_1._Code("!"),
		    OR: new code_1._Code("||"),
		    AND: new code_1._Code("&&"),
		    ADD: new code_1._Code("+"),
		};
		class Node {
		    optimizeNodes() {
		        return this;
		    }
		    optimizeNames(_names, _constants) {
		        return this;
		    }
		}
		class Def extends Node {
		    constructor(varKind, name, rhs) {
		        super();
		        this.varKind = varKind;
		        this.name = name;
		        this.rhs = rhs;
		    }
		    render({ es5, _n }) {
		        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
		        const rhs = this.rhs === undefined ? "" : ` = ${this.rhs}`;
		        return `${varKind} ${this.name}${rhs};` + _n;
		    }
		    optimizeNames(names, constants) {
		        if (!names[this.name.str])
		            return;
		        if (this.rhs)
		            this.rhs = optimizeExpr(this.rhs, names, constants);
		        return this;
		    }
		    get names() {
		        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
		    }
		}
		class Assign extends Node {
		    constructor(lhs, rhs, sideEffects) {
		        super();
		        this.lhs = lhs;
		        this.rhs = rhs;
		        this.sideEffects = sideEffects;
		    }
		    render({ _n }) {
		        return `${this.lhs} = ${this.rhs};` + _n;
		    }
		    optimizeNames(names, constants) {
		        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
		            return;
		        this.rhs = optimizeExpr(this.rhs, names, constants);
		        return this;
		    }
		    get names() {
		        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
		        return addExprNames(names, this.rhs);
		    }
		}
		class AssignOp extends Assign {
		    constructor(lhs, op, rhs, sideEffects) {
		        super(lhs, rhs, sideEffects);
		        this.op = op;
		    }
		    render({ _n }) {
		        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
		    }
		}
		class Label extends Node {
		    constructor(label) {
		        super();
		        this.label = label;
		        this.names = {};
		    }
		    render({ _n }) {
		        return `${this.label}:` + _n;
		    }
		}
		class Break extends Node {
		    constructor(label) {
		        super();
		        this.label = label;
		        this.names = {};
		    }
		    render({ _n }) {
		        const label = this.label ? ` ${this.label}` : "";
		        return `break${label};` + _n;
		    }
		}
		class Throw extends Node {
		    constructor(error) {
		        super();
		        this.error = error;
		    }
		    render({ _n }) {
		        return `throw ${this.error};` + _n;
		    }
		    get names() {
		        return this.error.names;
		    }
		}
		class AnyCode extends Node {
		    constructor(code) {
		        super();
		        this.code = code;
		    }
		    render({ _n }) {
		        return `${this.code};` + _n;
		    }
		    optimizeNodes() {
		        return `${this.code}` ? this : undefined;
		    }
		    optimizeNames(names, constants) {
		        this.code = optimizeExpr(this.code, names, constants);
		        return this;
		    }
		    get names() {
		        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
		    }
		}
		class ParentNode extends Node {
		    constructor(nodes = []) {
		        super();
		        this.nodes = nodes;
		    }
		    render(opts) {
		        return this.nodes.reduce((code, n) => code + n.render(opts), "");
		    }
		    optimizeNodes() {
		        const { nodes } = this;
		        let i = nodes.length;
		        while (i--) {
		            const n = nodes[i].optimizeNodes();
		            if (Array.isArray(n))
		                nodes.splice(i, 1, ...n);
		            else if (n)
		                nodes[i] = n;
		            else
		                nodes.splice(i, 1);
		        }
		        return nodes.length > 0 ? this : undefined;
		    }
		    optimizeNames(names, constants) {
		        const { nodes } = this;
		        let i = nodes.length;
		        while (i--) {
		            // iterating backwards improves 1-pass optimization
		            const n = nodes[i];
		            if (n.optimizeNames(names, constants))
		                continue;
		            subtractNames(names, n.names);
		            nodes.splice(i, 1);
		        }
		        return nodes.length > 0 ? this : undefined;
		    }
		    get names() {
		        return this.nodes.reduce((names, n) => addNames(names, n.names), {});
		    }
		}
		class BlockNode extends ParentNode {
		    render(opts) {
		        return "{" + opts._n + super.render(opts) + "}" + opts._n;
		    }
		}
		class Root extends ParentNode {
		}
		class Else extends BlockNode {
		}
		Else.kind = "else";
		class If extends BlockNode {
		    constructor(condition, nodes) {
		        super(nodes);
		        this.condition = condition;
		    }
		    render(opts) {
		        let code = `if(${this.condition})` + super.render(opts);
		        if (this.else)
		            code += "else " + this.else.render(opts);
		        return code;
		    }
		    optimizeNodes() {
		        super.optimizeNodes();
		        const cond = this.condition;
		        if (cond === true)
		            return this.nodes; // else is ignored here
		        let e = this.else;
		        if (e) {
		            const ns = e.optimizeNodes();
		            e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
		        }
		        if (e) {
		            if (cond === false)
		                return e instanceof If ? e : e.nodes;
		            if (this.nodes.length)
		                return this;
		            return new If(not(cond), e instanceof If ? [e] : e.nodes);
		        }
		        if (cond === false || !this.nodes.length)
		            return undefined;
		        return this;
		    }
		    optimizeNames(names, constants) {
		        var _a;
		        this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
		        if (!(super.optimizeNames(names, constants) || this.else))
		            return;
		        this.condition = optimizeExpr(this.condition, names, constants);
		        return this;
		    }
		    get names() {
		        const names = super.names;
		        addExprNames(names, this.condition);
		        if (this.else)
		            addNames(names, this.else.names);
		        return names;
		    }
		}
		If.kind = "if";
		class For extends BlockNode {
		}
		For.kind = "for";
		class ForLoop extends For {
		    constructor(iteration) {
		        super();
		        this.iteration = iteration;
		    }
		    render(opts) {
		        return `for(${this.iteration})` + super.render(opts);
		    }
		    optimizeNames(names, constants) {
		        if (!super.optimizeNames(names, constants))
		            return;
		        this.iteration = optimizeExpr(this.iteration, names, constants);
		        return this;
		    }
		    get names() {
		        return addNames(super.names, this.iteration.names);
		    }
		}
		class ForRange extends For {
		    constructor(varKind, name, from, to) {
		        super();
		        this.varKind = varKind;
		        this.name = name;
		        this.from = from;
		        this.to = to;
		    }
		    render(opts) {
		        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
		        const { name, from, to } = this;
		        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
		    }
		    get names() {
		        const names = addExprNames(super.names, this.from);
		        return addExprNames(names, this.to);
		    }
		}
		class ForIter extends For {
		    constructor(loop, varKind, name, iterable) {
		        super();
		        this.loop = loop;
		        this.varKind = varKind;
		        this.name = name;
		        this.iterable = iterable;
		    }
		    render(opts) {
		        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
		    }
		    optimizeNames(names, constants) {
		        if (!super.optimizeNames(names, constants))
		            return;
		        this.iterable = optimizeExpr(this.iterable, names, constants);
		        return this;
		    }
		    get names() {
		        return addNames(super.names, this.iterable.names);
		    }
		}
		class Func extends BlockNode {
		    constructor(name, args, async) {
		        super();
		        this.name = name;
		        this.args = args;
		        this.async = async;
		    }
		    render(opts) {
		        const _async = this.async ? "async " : "";
		        return `${_async}function ${this.name}(${this.args})` + super.render(opts);
		    }
		}
		Func.kind = "func";
		class Return extends ParentNode {
		    render(opts) {
		        return "return " + super.render(opts);
		    }
		}
		Return.kind = "return";
		class Try extends BlockNode {
		    render(opts) {
		        let code = "try" + super.render(opts);
		        if (this.catch)
		            code += this.catch.render(opts);
		        if (this.finally)
		            code += this.finally.render(opts);
		        return code;
		    }
		    optimizeNodes() {
		        var _a, _b;
		        super.optimizeNodes();
		        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
		        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
		        return this;
		    }
		    optimizeNames(names, constants) {
		        var _a, _b;
		        super.optimizeNames(names, constants);
		        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
		        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
		        return this;
		    }
		    get names() {
		        const names = super.names;
		        if (this.catch)
		            addNames(names, this.catch.names);
		        if (this.finally)
		            addNames(names, this.finally.names);
		        return names;
		    }
		}
		class Catch extends BlockNode {
		    constructor(error) {
		        super();
		        this.error = error;
		    }
		    render(opts) {
		        return `catch(${this.error})` + super.render(opts);
		    }
		}
		Catch.kind = "catch";
		class Finally extends BlockNode {
		    render(opts) {
		        return "finally" + super.render(opts);
		    }
		}
		Finally.kind = "finally";
		class CodeGen {
		    constructor(extScope, opts = {}) {
		        this._values = {};
		        this._blockStarts = [];
		        this._constants = {};
		        this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
		        this._extScope = extScope;
		        this._scope = new scope_1.Scope({ parent: extScope });
		        this._nodes = [new Root()];
		    }
		    toString() {
		        return this._root.render(this.opts);
		    }
		    // returns unique name in the internal scope
		    name(prefix) {
		        return this._scope.name(prefix);
		    }
		    // reserves unique name in the external scope
		    scopeName(prefix) {
		        return this._extScope.name(prefix);
		    }
		    // reserves unique name in the external scope and assigns value to it
		    scopeValue(prefixOrName, value) {
		        const name = this._extScope.value(prefixOrName, value);
		        const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set());
		        vs.add(name);
		        return name;
		    }
		    getScopeValue(prefix, keyOrRef) {
		        return this._extScope.getValue(prefix, keyOrRef);
		    }
		    // return code that assigns values in the external scope to the names that are used internally
		    // (same names that were returned by gen.scopeName or gen.scopeValue)
		    scopeRefs(scopeName) {
		        return this._extScope.scopeRefs(scopeName, this._values);
		    }
		    scopeCode() {
		        return this._extScope.scopeCode(this._values);
		    }
		    _def(varKind, nameOrPrefix, rhs, constant) {
		        const name = this._scope.toName(nameOrPrefix);
		        if (rhs !== undefined && constant)
		            this._constants[name.str] = rhs;
		        this._leafNode(new Def(varKind, name, rhs));
		        return name;
		    }
		    // `const` declaration (`var` in es5 mode)
		    const(nameOrPrefix, rhs, _constant) {
		        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
		    }
		    // `let` declaration with optional assignment (`var` in es5 mode)
		    let(nameOrPrefix, rhs, _constant) {
		        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
		    }
		    // `var` declaration with optional assignment
		    var(nameOrPrefix, rhs, _constant) {
		        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
		    }
		    // assignment code
		    assign(lhs, rhs, sideEffects) {
		        return this._leafNode(new Assign(lhs, rhs, sideEffects));
		    }
		    // `+=` code
		    add(lhs, rhs) {
		        return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
		    }
		    // appends passed SafeExpr to code or executes Block
		    code(c) {
		        if (typeof c == "function")
		            c();
		        else if (c !== code_1.nil)
		            this._leafNode(new AnyCode(c));
		        return this;
		    }
		    // returns code for object literal for the passed argument list of key-value pairs
		    object(...keyValues) {
		        const code = ["{"];
		        for (const [key, value] of keyValues) {
		            if (code.length > 1)
		                code.push(",");
		            code.push(key);
		            if (key !== value || this.opts.es5) {
		                code.push(":");
		                (0, code_1.addCodeArg)(code, value);
		            }
		        }
		        code.push("}");
		        return new code_1._Code(code);
		    }
		    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
		    if(condition, thenBody, elseBody) {
		        this._blockNode(new If(condition));
		        if (thenBody && elseBody) {
		            this.code(thenBody).else().code(elseBody).endIf();
		        }
		        else if (thenBody) {
		            this.code(thenBody).endIf();
		        }
		        else if (elseBody) {
		            throw new Error('CodeGen: "else" body without "then" body');
		        }
		        return this;
		    }
		    // `else if` clause - invalid without `if` or after `else` clauses
		    elseIf(condition) {
		        return this._elseNode(new If(condition));
		    }
		    // `else` clause - only valid after `if` or `else if` clauses
		    else() {
		        return this._elseNode(new Else());
		    }
		    // end `if` statement (needed if gen.if was used only with condition)
		    endIf() {
		        return this._endBlockNode(If, Else);
		    }
		    _for(node, forBody) {
		        this._blockNode(node);
		        if (forBody)
		            this.code(forBody).endFor();
		        return this;
		    }
		    // a generic `for` clause (or statement if `forBody` is passed)
		    for(iteration, forBody) {
		        return this._for(new ForLoop(iteration), forBody);
		    }
		    // `for` statement for a range of values
		    forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
		        const name = this._scope.toName(nameOrPrefix);
		        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
		    }
		    // `for-of` statement (in es5 mode replace with a normal for loop)
		    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
		        const name = this._scope.toName(nameOrPrefix);
		        if (this.opts.es5) {
		            const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
		            return this.forRange("_i", 0, (0, code_1._) `${arr}.length`, (i) => {
		                this.var(name, (0, code_1._) `${arr}[${i}]`);
		                forBody(name);
		            });
		        }
		        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
		    }
		    // `for-in` statement.
		    // With option `ownProperties` replaced with a `for-of` loop for object keys
		    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
		        if (this.opts.ownProperties) {
		            return this.forOf(nameOrPrefix, (0, code_1._) `Object.keys(${obj})`, forBody);
		        }
		        const name = this._scope.toName(nameOrPrefix);
		        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
		    }
		    // end `for` loop
		    endFor() {
		        return this._endBlockNode(For);
		    }
		    // `label` statement
		    label(label) {
		        return this._leafNode(new Label(label));
		    }
		    // `break` statement
		    break(label) {
		        return this._leafNode(new Break(label));
		    }
		    // `return` statement
		    return(value) {
		        const node = new Return();
		        this._blockNode(node);
		        this.code(value);
		        if (node.nodes.length !== 1)
		            throw new Error('CodeGen: "return" should have one node');
		        return this._endBlockNode(Return);
		    }
		    // `try` statement
		    try(tryBody, catchCode, finallyCode) {
		        if (!catchCode && !finallyCode)
		            throw new Error('CodeGen: "try" without "catch" and "finally"');
		        const node = new Try();
		        this._blockNode(node);
		        this.code(tryBody);
		        if (catchCode) {
		            const error = this.name("e");
		            this._currNode = node.catch = new Catch(error);
		            catchCode(error);
		        }
		        if (finallyCode) {
		            this._currNode = node.finally = new Finally();
		            this.code(finallyCode);
		        }
		        return this._endBlockNode(Catch, Finally);
		    }
		    // `throw` statement
		    throw(error) {
		        return this._leafNode(new Throw(error));
		    }
		    // start self-balancing block
		    block(body, nodeCount) {
		        this._blockStarts.push(this._nodes.length);
		        if (body)
		            this.code(body).endBlock(nodeCount);
		        return this;
		    }
		    // end the current self-balancing block
		    endBlock(nodeCount) {
		        const len = this._blockStarts.pop();
		        if (len === undefined)
		            throw new Error("CodeGen: not in self-balancing block");
		        const toClose = this._nodes.length - len;
		        if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {
		            throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
		        }
		        this._nodes.length = len;
		        return this;
		    }
		    // `function` heading (or definition if funcBody is passed)
		    func(name, args = code_1.nil, async, funcBody) {
		        this._blockNode(new Func(name, args, async));
		        if (funcBody)
		            this.code(funcBody).endFunc();
		        return this;
		    }
		    // end function definition
		    endFunc() {
		        return this._endBlockNode(Func);
		    }
		    optimize(n = 1) {
		        while (n-- > 0) {
		            this._root.optimizeNodes();
		            this._root.optimizeNames(this._root.names, this._constants);
		        }
		    }
		    _leafNode(node) {
		        this._currNode.nodes.push(node);
		        return this;
		    }
		    _blockNode(node) {
		        this._currNode.nodes.push(node);
		        this._nodes.push(node);
		    }
		    _endBlockNode(N1, N2) {
		        const n = this._currNode;
		        if (n instanceof N1 || (N2 && n instanceof N2)) {
		            this._nodes.pop();
		            return this;
		        }
		        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
		    }
		    _elseNode(node) {
		        const n = this._currNode;
		        if (!(n instanceof If)) {
		            throw new Error('CodeGen: "else" without "if"');
		        }
		        this._currNode = n.else = node;
		        return this;
		    }
		    get _root() {
		        return this._nodes[0];
		    }
		    get _currNode() {
		        const ns = this._nodes;
		        return ns[ns.length - 1];
		    }
		    set _currNode(node) {
		        const ns = this._nodes;
		        ns[ns.length - 1] = node;
		    }
		}
		exports.CodeGen = CodeGen;
		function addNames(names, from) {
		    for (const n in from)
		        names[n] = (names[n] || 0) + (from[n] || 0);
		    return names;
		}
		function addExprNames(names, from) {
		    return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
		}
		function optimizeExpr(expr, names, constants) {
		    if (expr instanceof code_1.Name)
		        return replaceName(expr);
		    if (!canOptimize(expr))
		        return expr;
		    return new code_1._Code(expr._items.reduce((items, c) => {
		        if (c instanceof code_1.Name)
		            c = replaceName(c);
		        if (c instanceof code_1._Code)
		            items.push(...c._items);
		        else
		            items.push(c);
		        return items;
		    }, []));
		    function replaceName(n) {
		        const c = constants[n.str];
		        if (c === undefined || names[n.str] !== 1)
		            return n;
		        delete names[n.str];
		        return c;
		    }
		    function canOptimize(e) {
		        return (e instanceof code_1._Code &&
		            e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== undefined));
		    }
		}
		function subtractNames(names, from) {
		    for (const n in from)
		        names[n] = (names[n] || 0) - (from[n] || 0);
		}
		function not(x) {
		    return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._) `!${par(x)}`;
		}
		exports.not = not;
		const andCode = mappend(exports.operators.AND);
		// boolean AND (&&) expression with the passed arguments
		function and(...args) {
		    return args.reduce(andCode);
		}
		exports.and = and;
		const orCode = mappend(exports.operators.OR);
		// boolean OR (||) expression with the passed arguments
		function or(...args) {
		    return args.reduce(orCode);
		}
		exports.or = or;
		function mappend(op) {
		    return (x, y) => (x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._) `${par(x)} ${op} ${par(y)}`);
		}
		function par(x) {
		    return x instanceof code_1.Name ? x : (0, code_1._) `(${x})`;
		}
		
	} (codegen));
	return codegen;
}

var util$1 = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;
	const codegen_1 = requireCodegen();
	const code_1 = code$1;
	// TODO refactor to use Set
	function toHash(arr) {
	    const hash = {};
	    for (const item of arr)
	        hash[item] = true;
	    return hash;
	}
	exports.toHash = toHash;
	function alwaysValidSchema(it, schema) {
	    if (typeof schema == "boolean")
	        return schema;
	    if (Object.keys(schema).length === 0)
	        return true;
	    checkUnknownRules(it, schema);
	    return !schemaHasRules(schema, it.self.RULES.all);
	}
	exports.alwaysValidSchema = alwaysValidSchema;
	function checkUnknownRules(it, schema = it.schema) {
	    const { opts, self } = it;
	    if (!opts.strictSchema)
	        return;
	    if (typeof schema === "boolean")
	        return;
	    const rules = self.RULES.keywords;
	    for (const key in schema) {
	        if (!rules[key])
	            checkStrictMode(it, `unknown keyword: "${key}"`);
	    }
	}
	exports.checkUnknownRules = checkUnknownRules;
	function schemaHasRules(schema, rules) {
	    if (typeof schema == "boolean")
	        return !schema;
	    for (const key in schema)
	        if (rules[key])
	            return true;
	    return false;
	}
	exports.schemaHasRules = schemaHasRules;
	function schemaHasRulesButRef(schema, RULES) {
	    if (typeof schema == "boolean")
	        return !schema;
	    for (const key in schema)
	        if (key !== "$ref" && RULES.all[key])
	            return true;
	    return false;
	}
	exports.schemaHasRulesButRef = schemaHasRulesButRef;
	function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
	    if (!$data) {
	        if (typeof schema == "number" || typeof schema == "boolean")
	            return schema;
	        if (typeof schema == "string")
	            return (0, codegen_1._) `${schema}`;
	    }
	    return (0, codegen_1._) `${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
	}
	exports.schemaRefOrVal = schemaRefOrVal;
	function unescapeFragment(str) {
	    return unescapeJsonPointer(decodeURIComponent(str));
	}
	exports.unescapeFragment = unescapeFragment;
	function escapeFragment(str) {
	    return encodeURIComponent(escapeJsonPointer(str));
	}
	exports.escapeFragment = escapeFragment;
	function escapeJsonPointer(str) {
	    if (typeof str == "number")
	        return `${str}`;
	    return str.replace(/~/g, "~0").replace(/\//g, "~1");
	}
	exports.escapeJsonPointer = escapeJsonPointer;
	function unescapeJsonPointer(str) {
	    return str.replace(/~1/g, "/").replace(/~0/g, "~");
	}
	exports.unescapeJsonPointer = unescapeJsonPointer;
	function eachItem(xs, f) {
	    if (Array.isArray(xs)) {
	        for (const x of xs)
	            f(x);
	    }
	    else {
	        f(xs);
	    }
	}
	exports.eachItem = eachItem;
	function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName, }) {
	    return (gen, from, to, toName) => {
	        const res = to === undefined
	            ? from
	            : to instanceof codegen_1.Name
	                ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)
	                : from instanceof codegen_1.Name
	                    ? (mergeToName(gen, to, from), from)
	                    : mergeValues(from, to);
	        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
	    };
	}
	exports.mergeEvaluated = {
	    props: makeMergeEvaluated({
	        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => {
	            gen.if((0, codegen_1._) `${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._) `${to} || {}`).code((0, codegen_1._) `Object.assign(${to}, ${from})`));
	        }),
	        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => {
	            if (from === true) {
	                gen.assign(to, true);
	            }
	            else {
	                gen.assign(to, (0, codegen_1._) `${to} || {}`);
	                setEvaluated(gen, to, from);
	            }
	        }),
	        mergeValues: (from, to) => (from === true ? true : { ...from, ...to }),
	        resultToName: evaluatedPropsToName,
	    }),
	    items: makeMergeEvaluated({
	        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._) `${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
	        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._) `${to} > ${from} ? ${to} : ${from}`)),
	        mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),
	        resultToName: (gen, items) => gen.var("items", items),
	    }),
	};
	function evaluatedPropsToName(gen, ps) {
	    if (ps === true)
	        return gen.var("props", true);
	    const props = gen.var("props", (0, codegen_1._) `{}`);
	    if (ps !== undefined)
	        setEvaluated(gen, props, ps);
	    return props;
	}
	exports.evaluatedPropsToName = evaluatedPropsToName;
	function setEvaluated(gen, props, ps) {
	    Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._) `${props}${(0, codegen_1.getProperty)(p)}`, true));
	}
	exports.setEvaluated = setEvaluated;
	const snippets = {};
	function useFunc(gen, f) {
	    return gen.scopeValue("func", {
	        ref: f,
	        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code)),
	    });
	}
	exports.useFunc = useFunc;
	var Type;
	(function (Type) {
	    Type[Type["Num"] = 0] = "Num";
	    Type[Type["Str"] = 1] = "Str";
	})(Type = exports.Type || (exports.Type = {}));
	function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
	    // let path
	    if (dataProp instanceof codegen_1.Name) {
	        const isNumber = dataPropType === Type.Num;
	        return jsPropertySyntax
	            ? isNumber
	                ? (0, codegen_1._) `"[" + ${dataProp} + "]"`
	                : (0, codegen_1._) `"['" + ${dataProp} + "']"`
	            : isNumber
	                ? (0, codegen_1._) `"/" + ${dataProp}`
	                : (0, codegen_1._) `"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`; // TODO maybe use global escapePointer
	    }
	    return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
	}
	exports.getErrorPath = getErrorPath;
	function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
	    if (!mode)
	        return;
	    msg = `strict mode: ${msg}`;
	    if (mode === true)
	        throw new Error(msg);
	    it.self.logger.warn(msg);
	}
	exports.checkStrictMode = checkStrictMode;
	
} (util$1));

var names = {};

var hasRequiredNames;

function requireNames () {
	if (hasRequiredNames) return names;
	hasRequiredNames = 1;
	Object.defineProperty(names, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const names$1 = {
	    // validation function arguments
	    data: new codegen_1.Name("data"),
	    // args passed from referencing schema
	    valCxt: new codegen_1.Name("valCxt"),
	    instancePath: new codegen_1.Name("instancePath"),
	    parentData: new codegen_1.Name("parentData"),
	    parentDataProperty: new codegen_1.Name("parentDataProperty"),
	    rootData: new codegen_1.Name("rootData"),
	    dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
	    // function scoped variables
	    vErrors: new codegen_1.Name("vErrors"),
	    errors: new codegen_1.Name("errors"),
	    this: new codegen_1.Name("this"),
	    // "globals"
	    self: new codegen_1.Name("self"),
	    scope: new codegen_1.Name("scope"),
	    // JTD serialize/parse name for JSON string and position
	    json: new codegen_1.Name("json"),
	    jsonPos: new codegen_1.Name("jsonPos"),
	    jsonLen: new codegen_1.Name("jsonLen"),
	    jsonPart: new codegen_1.Name("jsonPart"),
	};
	names.default = names$1;
	
	return names;
}

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
	const codegen_1 = requireCodegen();
	const util_1 = util$1;
	const names_1 = requireNames();
	exports.keywordError = {
	    message: ({ keyword }) => (0, codegen_1.str) `must pass "${keyword}" keyword validation`,
	};
	exports.keyword$DataError = {
	    message: ({ keyword, schemaType }) => schemaType
	        ? (0, codegen_1.str) `"${keyword}" keyword must be ${schemaType} ($data)`
	        : (0, codegen_1.str) `"${keyword}" keyword is invalid ($data)`,
	};
	function reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {
	    const { it } = cxt;
	    const { gen, compositeRule, allErrors } = it;
	    const errObj = errorObjectCode(cxt, error, errorPaths);
	    if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : (compositeRule || allErrors)) {
	        addError(gen, errObj);
	    }
	    else {
	        returnErrors(it, (0, codegen_1._) `[${errObj}]`);
	    }
	}
	exports.reportError = reportError;
	function reportExtraError(cxt, error = exports.keywordError, errorPaths) {
	    const { it } = cxt;
	    const { gen, compositeRule, allErrors } = it;
	    const errObj = errorObjectCode(cxt, error, errorPaths);
	    addError(gen, errObj);
	    if (!(compositeRule || allErrors)) {
	        returnErrors(it, names_1.default.vErrors);
	    }
	}
	exports.reportExtraError = reportExtraError;
	function resetErrorsCount(gen, errsCount) {
	    gen.assign(names_1.default.errors, errsCount);
	    gen.if((0, codegen_1._) `${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._) `${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
	}
	exports.resetErrorsCount = resetErrorsCount;
	function extendErrors({ gen, keyword, schemaValue, data, errsCount, it, }) {
	    /* istanbul ignore if */
	    if (errsCount === undefined)
	        throw new Error("ajv implementation error");
	    const err = gen.name("err");
	    gen.forRange("i", errsCount, names_1.default.errors, (i) => {
	        gen.const(err, (0, codegen_1._) `${names_1.default.vErrors}[${i}]`);
	        gen.if((0, codegen_1._) `${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._) `${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
	        gen.assign((0, codegen_1._) `${err}.schemaPath`, (0, codegen_1.str) `${it.errSchemaPath}/${keyword}`);
	        if (it.opts.verbose) {
	            gen.assign((0, codegen_1._) `${err}.schema`, schemaValue);
	            gen.assign((0, codegen_1._) `${err}.data`, data);
	        }
	    });
	}
	exports.extendErrors = extendErrors;
	function addError(gen, errObj) {
	    const err = gen.const("err", errObj);
	    gen.if((0, codegen_1._) `${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._) `[${err}]`), (0, codegen_1._) `${names_1.default.vErrors}.push(${err})`);
	    gen.code((0, codegen_1._) `${names_1.default.errors}++`);
	}
	function returnErrors(it, errs) {
	    const { gen, validateName, schemaEnv } = it;
	    if (schemaEnv.$async) {
	        gen.throw((0, codegen_1._) `new ${it.ValidationError}(${errs})`);
	    }
	    else {
	        gen.assign((0, codegen_1._) `${validateName}.errors`, errs);
	        gen.return(false);
	    }
	}
	const E = {
	    keyword: new codegen_1.Name("keyword"),
	    schemaPath: new codegen_1.Name("schemaPath"),
	    params: new codegen_1.Name("params"),
	    propertyName: new codegen_1.Name("propertyName"),
	    message: new codegen_1.Name("message"),
	    schema: new codegen_1.Name("schema"),
	    parentSchema: new codegen_1.Name("parentSchema"),
	};
	function errorObjectCode(cxt, error, errorPaths) {
	    const { createErrors } = cxt.it;
	    if (createErrors === false)
	        return (0, codegen_1._) `{}`;
	    return errorObject(cxt, error, errorPaths);
	}
	function errorObject(cxt, error, errorPaths = {}) {
	    const { gen, it } = cxt;
	    const keyValues = [
	        errorInstancePath(it, errorPaths),
	        errorSchemaPath(cxt, errorPaths),
	    ];
	    extraErrorProps(cxt, error, keyValues);
	    return gen.object(...keyValues);
	}
	function errorInstancePath({ errorPath }, { instancePath }) {
	    const instPath = instancePath
	        ? (0, codegen_1.str) `${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}`
	        : errorPath;
	    return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
	}
	function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
	    let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str) `${errSchemaPath}/${keyword}`;
	    if (schemaPath) {
	        schPath = (0, codegen_1.str) `${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
	    }
	    return [E.schemaPath, schPath];
	}
	function extraErrorProps(cxt, { params, message }, keyValues) {
	    const { keyword, data, schemaValue, it } = cxt;
	    const { opts, propertyName, topSchemaRef, schemaPath } = it;
	    keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._) `{}`]);
	    if (opts.messages) {
	        keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
	    }
	    if (opts.verbose) {
	        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._) `${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
	    }
	    if (propertyName)
	        keyValues.push([E.propertyName, propertyName]);
	}
	
} (errors));

var hasRequiredBoolSchema;

function requireBoolSchema () {
	if (hasRequiredBoolSchema) return boolSchema;
	hasRequiredBoolSchema = 1;
	Object.defineProperty(boolSchema, "__esModule", { value: true });
	boolSchema.boolOrEmptySchema = boolSchema.topBoolOrEmptySchema = void 0;
	const errors_1 = errors;
	const codegen_1 = requireCodegen();
	const names_1 = requireNames();
	const boolError = {
	    message: "boolean schema is false",
	};
	function topBoolOrEmptySchema(it) {
	    const { gen, schema, validateName } = it;
	    if (schema === false) {
	        falseSchemaError(it, false);
	    }
	    else if (typeof schema == "object" && schema.$async === true) {
	        gen.return(names_1.default.data);
	    }
	    else {
	        gen.assign((0, codegen_1._) `${validateName}.errors`, null);
	        gen.return(true);
	    }
	}
	boolSchema.topBoolOrEmptySchema = topBoolOrEmptySchema;
	function boolOrEmptySchema(it, valid) {
	    const { gen, schema } = it;
	    if (schema === false) {
	        gen.var(valid, false); // TODO var
	        falseSchemaError(it);
	    }
	    else {
	        gen.var(valid, true); // TODO var
	    }
	}
	boolSchema.boolOrEmptySchema = boolOrEmptySchema;
	function falseSchemaError(it, overrideAllErrors) {
	    const { gen, data } = it;
	    // TODO maybe some other interface should be used for non-keyword validation errors...
	    const cxt = {
	        gen,
	        keyword: "false schema",
	        data,
	        schema: false,
	        schemaCode: false,
	        schemaValue: false,
	        params: {},
	        it,
	    };
	    (0, errors_1.reportError)(cxt, boolError, undefined, overrideAllErrors);
	}
	
	return boolSchema;
}

var dataType = {};

var rules = {};

Object.defineProperty(rules, "__esModule", { value: true });
rules.getRules = rules.isJSONType = void 0;
const _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
const jsonTypes = new Set(_jsonTypes);
function isJSONType(x) {
    return typeof x == "string" && jsonTypes.has(x);
}
rules.isJSONType = isJSONType;
function getRules() {
    const groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] },
    };
    return {
        types: { ...groups, integer: true, boolean: true, null: true },
        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
        post: { rules: [] },
        all: {},
        keywords: {},
    };
}
rules.getRules = getRules;

var applicability = {};

Object.defineProperty(applicability, "__esModule", { value: true });
applicability.shouldUseRule = applicability.shouldUseGroup = applicability.schemaHasRulesForType = void 0;
function schemaHasRulesForType({ schema, self }, type) {
    const group = self.RULES.types[type];
    return group && group !== true && shouldUseGroup(schema, group);
}
applicability.schemaHasRulesForType = schemaHasRulesForType;
function shouldUseGroup(schema, group) {
    return group.rules.some((rule) => shouldUseRule(schema, rule));
}
applicability.shouldUseGroup = shouldUseGroup;
function shouldUseRule(schema, rule) {
    var _a;
    return (schema[rule.keyword] !== undefined ||
        ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== undefined)));
}
applicability.shouldUseRule = shouldUseRule;

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;
	const rules_1 = rules;
	const applicability_1 = applicability;
	const errors_1 = errors;
	const codegen_1 = requireCodegen();
	const util_1 = util$1;
	var DataType;
	(function (DataType) {
	    DataType[DataType["Correct"] = 0] = "Correct";
	    DataType[DataType["Wrong"] = 1] = "Wrong";
	})(DataType = exports.DataType || (exports.DataType = {}));
	function getSchemaTypes(schema) {
	    const types = getJSONTypes(schema.type);
	    const hasNull = types.includes("null");
	    if (hasNull) {
	        if (schema.nullable === false)
	            throw new Error("type: null contradicts nullable: false");
	    }
	    else {
	        if (!types.length && schema.nullable !== undefined) {
	            throw new Error('"nullable" cannot be used without "type"');
	        }
	        if (schema.nullable === true)
	            types.push("null");
	    }
	    return types;
	}
	exports.getSchemaTypes = getSchemaTypes;
	function getJSONTypes(ts) {
	    const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
	    if (types.every(rules_1.isJSONType))
	        return types;
	    throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
	}
	exports.getJSONTypes = getJSONTypes;
	function coerceAndCheckDataType(it, types) {
	    const { gen, data, opts } = it;
	    const coerceTo = coerceToTypes(types, opts.coerceTypes);
	    const checkTypes = types.length > 0 &&
	        !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));
	    if (checkTypes) {
	        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
	        gen.if(wrongType, () => {
	            if (coerceTo.length)
	                coerceData(it, types, coerceTo);
	            else
	                reportTypeError(it);
	        });
	    }
	    return checkTypes;
	}
	exports.coerceAndCheckDataType = coerceAndCheckDataType;
	const COERCIBLE = new Set(["string", "number", "integer", "boolean", "null"]);
	function coerceToTypes(types, coerceTypes) {
	    return coerceTypes
	        ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === "array" && t === "array"))
	        : [];
	}
	function coerceData(it, types, coerceTo) {
	    const { gen, data, opts } = it;
	    const dataType = gen.let("dataType", (0, codegen_1._) `typeof ${data}`);
	    const coerced = gen.let("coerced", (0, codegen_1._) `undefined`);
	    if (opts.coerceTypes === "array") {
	        gen.if((0, codegen_1._) `${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen
	            .assign(data, (0, codegen_1._) `${data}[0]`)
	            .assign(dataType, (0, codegen_1._) `typeof ${data}`)
	            .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
	    }
	    gen.if((0, codegen_1._) `${coerced} !== undefined`);
	    for (const t of coerceTo) {
	        if (COERCIBLE.has(t) || (t === "array" && opts.coerceTypes === "array")) {
	            coerceSpecificType(t);
	        }
	    }
	    gen.else();
	    reportTypeError(it);
	    gen.endIf();
	    gen.if((0, codegen_1._) `${coerced} !== undefined`, () => {
	        gen.assign(data, coerced);
	        assignParentData(it, coerced);
	    });
	    function coerceSpecificType(t) {
	        switch (t) {
	            case "string":
	                gen
	                    .elseIf((0, codegen_1._) `${dataType} == "number" || ${dataType} == "boolean"`)
	                    .assign(coerced, (0, codegen_1._) `"" + ${data}`)
	                    .elseIf((0, codegen_1._) `${data} === null`)
	                    .assign(coerced, (0, codegen_1._) `""`);
	                return;
	            case "number":
	                gen
	                    .elseIf((0, codegen_1._) `${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`)
	                    .assign(coerced, (0, codegen_1._) `+${data}`);
	                return;
	            case "integer":
	                gen
	                    .elseIf((0, codegen_1._) `${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`)
	                    .assign(coerced, (0, codegen_1._) `+${data}`);
	                return;
	            case "boolean":
	                gen
	                    .elseIf((0, codegen_1._) `${data} === "false" || ${data} === 0 || ${data} === null`)
	                    .assign(coerced, false)
	                    .elseIf((0, codegen_1._) `${data} === "true" || ${data} === 1`)
	                    .assign(coerced, true);
	                return;
	            case "null":
	                gen.elseIf((0, codegen_1._) `${data} === "" || ${data} === 0 || ${data} === false`);
	                gen.assign(coerced, null);
	                return;
	            case "array":
	                gen
	                    .elseIf((0, codegen_1._) `${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`)
	                    .assign(coerced, (0, codegen_1._) `[${data}]`);
	        }
	    }
	}
	function assignParentData({ gen, parentData, parentDataProperty }, expr) {
	    // TODO use gen.property
	    gen.if((0, codegen_1._) `${parentData} !== undefined`, () => gen.assign((0, codegen_1._) `${parentData}[${parentDataProperty}]`, expr));
	}
	function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
	    const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
	    let cond;
	    switch (dataType) {
	        case "null":
	            return (0, codegen_1._) `${data} ${EQ} null`;
	        case "array":
	            cond = (0, codegen_1._) `Array.isArray(${data})`;
	            break;
	        case "object":
	            cond = (0, codegen_1._) `${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
	            break;
	        case "integer":
	            cond = numCond((0, codegen_1._) `!(${data} % 1) && !isNaN(${data})`);
	            break;
	        case "number":
	            cond = numCond();
	            break;
	        default:
	            return (0, codegen_1._) `typeof ${data} ${EQ} ${dataType}`;
	    }
	    return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
	    function numCond(_cond = codegen_1.nil) {
	        return (0, codegen_1.and)((0, codegen_1._) `typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._) `isFinite(${data})` : codegen_1.nil);
	    }
	}
	exports.checkDataType = checkDataType;
	function checkDataTypes(dataTypes, data, strictNums, correct) {
	    if (dataTypes.length === 1) {
	        return checkDataType(dataTypes[0], data, strictNums, correct);
	    }
	    let cond;
	    const types = (0, util_1.toHash)(dataTypes);
	    if (types.array && types.object) {
	        const notObj = (0, codegen_1._) `typeof ${data} != "object"`;
	        cond = types.null ? notObj : (0, codegen_1._) `!${data} || ${notObj}`;
	        delete types.null;
	        delete types.array;
	        delete types.object;
	    }
	    else {
	        cond = codegen_1.nil;
	    }
	    if (types.number)
	        delete types.integer;
	    for (const t in types)
	        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
	    return cond;
	}
	exports.checkDataTypes = checkDataTypes;
	const typeError = {
	    message: ({ schema }) => `must be ${schema}`,
	    params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._) `{type: ${schema}}` : (0, codegen_1._) `{type: ${schemaValue}}`,
	};
	function reportTypeError(it) {
	    const cxt = getTypeErrorContext(it);
	    (0, errors_1.reportError)(cxt, typeError);
	}
	exports.reportTypeError = reportTypeError;
	function getTypeErrorContext(it) {
	    const { gen, data, schema } = it;
	    const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
	    return {
	        gen,
	        keyword: "type",
	        data,
	        schema: schema.type,
	        schemaCode,
	        schemaValue: schemaCode,
	        parentSchema: schema,
	        params: {},
	        it,
	    };
	}
	
} (dataType));

var defaults = {};

var hasRequiredDefaults;

function requireDefaults () {
	if (hasRequiredDefaults) return defaults;
	hasRequiredDefaults = 1;
	Object.defineProperty(defaults, "__esModule", { value: true });
	defaults.assignDefaults = void 0;
	const codegen_1 = requireCodegen();
	const util_1 = util$1;
	function assignDefaults(it, ty) {
	    const { properties, items } = it.schema;
	    if (ty === "object" && properties) {
	        for (const key in properties) {
	            assignDefault(it, key, properties[key].default);
	        }
	    }
	    else if (ty === "array" && Array.isArray(items)) {
	        items.forEach((sch, i) => assignDefault(it, i, sch.default));
	    }
	}
	defaults.assignDefaults = assignDefaults;
	function assignDefault(it, prop, defaultValue) {
	    const { gen, compositeRule, data, opts } = it;
	    if (defaultValue === undefined)
	        return;
	    const childData = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(prop)}`;
	    if (compositeRule) {
	        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
	        return;
	    }
	    let condition = (0, codegen_1._) `${childData} === undefined`;
	    if (opts.useDefaults === "empty") {
	        condition = (0, codegen_1._) `${condition} || ${childData} === null || ${childData} === ""`;
	    }
	    // `${childData} === undefined` +
	    // (opts.useDefaults === "empty" ? ` || ${childData} === null || ${childData} === ""` : "")
	    gen.if(condition, (0, codegen_1._) `${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
	}
	
	return defaults;
}

var keyword = {};

var code = {};

var hasRequiredCode;

function requireCode () {
	if (hasRequiredCode) return code;
	hasRequiredCode = 1;
	Object.defineProperty(code, "__esModule", { value: true });
	code.validateUnion = code.validateArray = code.usePattern = code.callValidateCode = code.schemaProperties = code.allSchemaProperties = code.noPropertyInData = code.propertyInData = code.isOwnProperty = code.hasPropFunc = code.reportMissingProp = code.checkMissingProp = code.checkReportMissingProp = void 0;
	const codegen_1 = requireCodegen();
	const util_1 = util$1;
	const names_1 = requireNames();
	const util_2 = util$1;
	function checkReportMissingProp(cxt, prop) {
	    const { gen, data, it } = cxt;
	    gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
	        cxt.setParams({ missingProperty: (0, codegen_1._) `${prop}` }, true);
	        cxt.error();
	    });
	}
	code.checkReportMissingProp = checkReportMissingProp;
	function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
	    return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._) `${missing} = ${prop}`)));
	}
	code.checkMissingProp = checkMissingProp;
	function reportMissingProp(cxt, missing) {
	    cxt.setParams({ missingProperty: missing }, true);
	    cxt.error();
	}
	code.reportMissingProp = reportMissingProp;
	function hasPropFunc(gen) {
	    return gen.scopeValue("func", {
	        // eslint-disable-next-line @typescript-eslint/unbound-method
	        ref: Object.prototype.hasOwnProperty,
	        code: (0, codegen_1._) `Object.prototype.hasOwnProperty`,
	    });
	}
	code.hasPropFunc = hasPropFunc;
	function isOwnProperty(gen, data, property) {
	    return (0, codegen_1._) `${hasPropFunc(gen)}.call(${data}, ${property})`;
	}
	code.isOwnProperty = isOwnProperty;
	function propertyInData(gen, data, property, ownProperties) {
	    const cond = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
	    return ownProperties ? (0, codegen_1._) `${cond} && ${isOwnProperty(gen, data, property)}` : cond;
	}
	code.propertyInData = propertyInData;
	function noPropertyInData(gen, data, property, ownProperties) {
	    const cond = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(property)} === undefined`;
	    return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
	}
	code.noPropertyInData = noPropertyInData;
	function allSchemaProperties(schemaMap) {
	    return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
	}
	code.allSchemaProperties = allSchemaProperties;
	function schemaProperties(it, schemaMap) {
	    return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
	}
	code.schemaProperties = schemaProperties;
	function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
	    const dataAndSchema = passSchema ? (0, codegen_1._) `${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
	    const valCxt = [
	        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
	        [names_1.default.parentData, it.parentData],
	        [names_1.default.parentDataProperty, it.parentDataProperty],
	        [names_1.default.rootData, names_1.default.rootData],
	    ];
	    if (it.opts.dynamicRef)
	        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
	    const args = (0, codegen_1._) `${dataAndSchema}, ${gen.object(...valCxt)}`;
	    return context !== codegen_1.nil ? (0, codegen_1._) `${func}.call(${context}, ${args})` : (0, codegen_1._) `${func}(${args})`;
	}
	code.callValidateCode = callValidateCode;
	const newRegExp = (0, codegen_1._) `new RegExp`;
	function usePattern({ gen, it: { opts } }, pattern) {
	    const u = opts.unicodeRegExp ? "u" : "";
	    const { regExp } = opts.code;
	    const rx = regExp(pattern, u);
	    return gen.scopeValue("pattern", {
	        key: rx.toString(),
	        ref: rx,
	        code: (0, codegen_1._) `${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`,
	    });
	}
	code.usePattern = usePattern;
	function validateArray(cxt) {
	    const { gen, data, keyword, it } = cxt;
	    const valid = gen.name("valid");
	    if (it.allErrors) {
	        const validArr = gen.let("valid", true);
	        validateItems(() => gen.assign(validArr, false));
	        return validArr;
	    }
	    gen.var(valid, true);
	    validateItems(() => gen.break());
	    return valid;
	    function validateItems(notValid) {
	        const len = gen.const("len", (0, codegen_1._) `${data}.length`);
	        gen.forRange("i", 0, len, (i) => {
	            cxt.subschema({
	                keyword,
	                dataProp: i,
	                dataPropType: util_1.Type.Num,
	            }, valid);
	            gen.if((0, codegen_1.not)(valid), notValid);
	        });
	    }
	}
	code.validateArray = validateArray;
	function validateUnion(cxt) {
	    const { gen, schema, keyword, it } = cxt;
	    /* istanbul ignore if */
	    if (!Array.isArray(schema))
	        throw new Error("ajv implementation error");
	    const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
	    if (alwaysValid && !it.opts.unevaluated)
	        return;
	    const valid = gen.let("valid", false);
	    const schValid = gen.name("_valid");
	    gen.block(() => schema.forEach((_sch, i) => {
	        const schCxt = cxt.subschema({
	            keyword,
	            schemaProp: i,
	            compositeRule: true,
	        }, schValid);
	        gen.assign(valid, (0, codegen_1._) `${valid} || ${schValid}`);
	        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
	        // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)
	        // or if all properties and items were evaluated (it.props === true && it.items === true)
	        if (!merged)
	            gen.if((0, codegen_1.not)(valid));
	    }));
	    cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
	}
	code.validateUnion = validateUnion;
	
	return code;
}

var hasRequiredKeyword;

function requireKeyword () {
	if (hasRequiredKeyword) return keyword;
	hasRequiredKeyword = 1;
	Object.defineProperty(keyword, "__esModule", { value: true });
	keyword.validateKeywordUsage = keyword.validSchemaType = keyword.funcKeywordCode = keyword.macroKeywordCode = void 0;
	const codegen_1 = requireCodegen();
	const names_1 = requireNames();
	const code_1 = requireCode();
	const errors_1 = errors;
	function macroKeywordCode(cxt, def) {
	    const { gen, keyword, schema, parentSchema, it } = cxt;
	    const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
	    const schemaRef = useKeyword(gen, keyword, macroSchema);
	    if (it.opts.validateSchema !== false)
	        it.self.validateSchema(macroSchema, true);
	    const valid = gen.name("valid");
	    cxt.subschema({
	        schema: macroSchema,
	        schemaPath: codegen_1.nil,
	        errSchemaPath: `${it.errSchemaPath}/${keyword}`,
	        topSchemaRef: schemaRef,
	        compositeRule: true,
	    }, valid);
	    cxt.pass(valid, () => cxt.error(true));
	}
	keyword.macroKeywordCode = macroKeywordCode;
	function funcKeywordCode(cxt, def) {
	    var _a;
	    const { gen, keyword, schema, parentSchema, $data, it } = cxt;
	    checkAsyncKeyword(it, def);
	    const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
	    const validateRef = useKeyword(gen, keyword, validate);
	    const valid = gen.let("valid");
	    cxt.block$data(valid, validateKeyword);
	    cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);
	    function validateKeyword() {
	        if (def.errors === false) {
	            assignValid();
	            if (def.modifying)
	                modifyData(cxt);
	            reportErrs(() => cxt.error());
	        }
	        else {
	            const ruleErrs = def.async ? validateAsync() : validateSync();
	            if (def.modifying)
	                modifyData(cxt);
	            reportErrs(() => addErrs(cxt, ruleErrs));
	        }
	    }
	    function validateAsync() {
	        const ruleErrs = gen.let("ruleErrs", null);
	        gen.try(() => assignValid((0, codegen_1._) `await `), (e) => gen.assign(valid, false).if((0, codegen_1._) `${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._) `${e}.errors`), () => gen.throw(e)));
	        return ruleErrs;
	    }
	    function validateSync() {
	        const validateErrs = (0, codegen_1._) `${validateRef}.errors`;
	        gen.assign(validateErrs, null);
	        assignValid(codegen_1.nil);
	        return validateErrs;
	    }
	    function assignValid(_await = def.async ? (0, codegen_1._) `await ` : codegen_1.nil) {
	        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
	        const passSchema = !(("compile" in def && !$data) || def.schema === false);
	        gen.assign(valid, (0, codegen_1._) `${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
	    }
	    function reportErrs(errors) {
	        var _a;
	        gen.if((0, codegen_1.not)((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);
	    }
	}
	keyword.funcKeywordCode = funcKeywordCode;
	function modifyData(cxt) {
	    const { gen, data, it } = cxt;
	    gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._) `${it.parentData}[${it.parentDataProperty}]`));
	}
	function addErrs(cxt, errs) {
	    const { gen } = cxt;
	    gen.if((0, codegen_1._) `Array.isArray(${errs})`, () => {
	        gen
	            .assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`)
	            .assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);
	        (0, errors_1.extendErrors)(cxt);
	    }, () => cxt.error());
	}
	function checkAsyncKeyword({ schemaEnv }, def) {
	    if (def.async && !schemaEnv.$async)
	        throw new Error("async keyword in sync schema");
	}
	function useKeyword(gen, keyword, result) {
	    if (result === undefined)
	        throw new Error(`keyword "${keyword}" failed to compile`);
	    return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
	}
	function validSchemaType(schema, schemaType, allowUndefined = false) {
	    // TODO add tests
	    return (!schemaType.length ||
	        schemaType.some((st) => st === "array"
	            ? Array.isArray(schema)
	            : st === "object"
	                ? schema && typeof schema == "object" && !Array.isArray(schema)
	                : typeof schema == st || (allowUndefined && typeof schema == "undefined")));
	}
	keyword.validSchemaType = validSchemaType;
	function validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {
	    /* istanbul ignore if */
	    if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
	        throw new Error("ajv implementation error");
	    }
	    const deps = def.dependencies;
	    if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
	        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
	    }
	    if (def.validateSchema) {
	        const valid = def.validateSchema(schema[keyword]);
	        if (!valid) {
	            const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` +
	                self.errorsText(def.validateSchema.errors);
	            if (opts.validateSchema === "log")
	                self.logger.error(msg);
	            else
	                throw new Error(msg);
	        }
	    }
	}
	keyword.validateKeywordUsage = validateKeywordUsage;
	
	return keyword;
}

var subschema = {};

var hasRequiredSubschema;

function requireSubschema () {
	if (hasRequiredSubschema) return subschema;
	hasRequiredSubschema = 1;
	Object.defineProperty(subschema, "__esModule", { value: true });
	subschema.extendSubschemaMode = subschema.extendSubschemaData = subschema.getSubschema = void 0;
	const codegen_1 = requireCodegen();
	const util_1 = util$1;
	function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
	    if (keyword !== undefined && schema !== undefined) {
	        throw new Error('both "keyword" and "schema" passed, only one allowed');
	    }
	    if (keyword !== undefined) {
	        const sch = it.schema[keyword];
	        return schemaProp === undefined
	            ? {
	                schema: sch,
	                schemaPath: (0, codegen_1._) `${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
	                errSchemaPath: `${it.errSchemaPath}/${keyword}`,
	            }
	            : {
	                schema: sch[schemaProp],
	                schemaPath: (0, codegen_1._) `${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
	                errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`,
	            };
	    }
	    if (schema !== undefined) {
	        if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {
	            throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
	        }
	        return {
	            schema,
	            schemaPath,
	            topSchemaRef,
	            errSchemaPath,
	        };
	    }
	    throw new Error('either "keyword" or "schema" must be passed');
	}
	subschema.getSubschema = getSubschema;
	function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
	    if (data !== undefined && dataProp !== undefined) {
	        throw new Error('both "data" and "dataProp" passed, only one allowed');
	    }
	    const { gen } = it;
	    if (dataProp !== undefined) {
	        const { errorPath, dataPathArr, opts } = it;
	        const nextData = gen.let("data", (0, codegen_1._) `${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
	        dataContextProps(nextData);
	        subschema.errorPath = (0, codegen_1.str) `${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
	        subschema.parentDataProperty = (0, codegen_1._) `${dataProp}`;
	        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
	    }
	    if (data !== undefined) {
	        const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true); // replaceable if used once?
	        dataContextProps(nextData);
	        if (propertyName !== undefined)
	            subschema.propertyName = propertyName;
	        // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr
	    }
	    if (dataTypes)
	        subschema.dataTypes = dataTypes;
	    function dataContextProps(_nextData) {
	        subschema.data = _nextData;
	        subschema.dataLevel = it.dataLevel + 1;
	        subschema.dataTypes = [];
	        it.definedProperties = new Set();
	        subschema.parentData = it.data;
	        subschema.dataNames = [...it.dataNames, _nextData];
	    }
	}
	subschema.extendSubschemaData = extendSubschemaData;
	function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
	    if (compositeRule !== undefined)
	        subschema.compositeRule = compositeRule;
	    if (createErrors !== undefined)
	        subschema.createErrors = createErrors;
	    if (allErrors !== undefined)
	        subschema.allErrors = allErrors;
	    subschema.jtdDiscriminator = jtdDiscriminator; // not inherited
	    subschema.jtdMetadata = jtdMetadata; // not inherited
	}
	subschema.extendSubschemaMode = extendSubschemaMode;
	
	return subschema;
}

var resolve$1 = {};

// do not edit .js files directly - edit src/index.jst



var fastDeepEqual = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }



    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      var key = keys[i];

      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  // true if both NaN, false otherwise
  return a!==a && b!==b;
};

var jsonSchemaTraverse = {exports: {}};

var traverse$1 = jsonSchemaTraverse.exports = function (schema, opts, cb) {
  // Legacy support for v0.3.1 and earlier.
  if (typeof opts == 'function') {
    cb = opts;
    opts = {};
  }

  cb = opts.cb || cb;
  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};
  var post = cb.post || function() {};

  _traverse(opts, pre, post, schema, '', schema);
};


traverse$1.keywords = {
  additionalItems: true,
  items: true,
  contains: true,
  additionalProperties: true,
  propertyNames: true,
  not: true,
  if: true,
  then: true,
  else: true
};

traverse$1.arrayKeywords = {
  items: true,
  allOf: true,
  anyOf: true,
  oneOf: true
};

traverse$1.propsKeywords = {
  $defs: true,
  definitions: true,
  properties: true,
  patternProperties: true,
  dependencies: true
};

traverse$1.skipKeywords = {
  default: true,
  enum: true,
  const: true,
  required: true,
  maximum: true,
  minimum: true,
  exclusiveMaximum: true,
  exclusiveMinimum: true,
  multipleOf: true,
  maxLength: true,
  minLength: true,
  pattern: true,
  format: true,
  maxItems: true,
  minItems: true,
  uniqueItems: true,
  maxProperties: true,
  minProperties: true
};


function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {
    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    for (var key in schema) {
      var sch = schema[key];
      if (Array.isArray(sch)) {
        if (key in traverse$1.arrayKeywords) {
          for (var i=0; i<sch.length; i++)
            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);
        }
      } else if (key in traverse$1.propsKeywords) {
        if (sch && typeof sch == 'object') {
          for (var prop in sch)
            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
        }
      } else if (key in traverse$1.keywords || (opts.allKeys && !(key in traverse$1.skipKeywords))) {
        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);
      }
    }
    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
  }
}


function escapeJsonPtr(str) {
  return str.replace(/~/g, '~0').replace(/\//g, '~1');
}

var jsonSchemaTraverseExports = jsonSchemaTraverse.exports;

Object.defineProperty(resolve$1, "__esModule", { value: true });
resolve$1.getSchemaRefs = resolve$1.resolveUrl = resolve$1.normalizeId = resolve$1._getFullPath = resolve$1.getFullPath = resolve$1.inlineRef = void 0;
const util_1$l = util$1;
const equal$2 = fastDeepEqual;
const traverse = jsonSchemaTraverseExports;
// TODO refactor to use keyword definitions
const SIMPLE_INLINED = new Set([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum",
    "const",
]);
function inlineRef(schema, limit = true) {
    if (typeof schema == "boolean")
        return true;
    if (limit === true)
        return !hasRef(schema);
    if (!limit)
        return false;
    return countKeys(schema) <= limit;
}
resolve$1.inlineRef = inlineRef;
const REF_KEYWORDS = new Set([
    "$ref",
    "$recursiveRef",
    "$recursiveAnchor",
    "$dynamicRef",
    "$dynamicAnchor",
]);
function hasRef(schema) {
    for (const key in schema) {
        if (REF_KEYWORDS.has(key))
            return true;
        const sch = schema[key];
        if (Array.isArray(sch) && sch.some(hasRef))
            return true;
        if (typeof sch == "object" && hasRef(sch))
            return true;
    }
    return false;
}
function countKeys(schema) {
    let count = 0;
    for (const key in schema) {
        if (key === "$ref")
            return Infinity;
        count++;
        if (SIMPLE_INLINED.has(key))
            continue;
        if (typeof schema[key] == "object") {
            (0, util_1$l.eachItem)(schema[key], (sch) => (count += countKeys(sch)));
        }
        if (count === Infinity)
            return Infinity;
    }
    return count;
}
function getFullPath(resolver, id = "", normalize) {
    if (normalize !== false)
        id = normalizeId(id);
    const p = resolver.parse(id);
    return _getFullPath(resolver, p);
}
resolve$1.getFullPath = getFullPath;
function _getFullPath(resolver, p) {
    const serialized = resolver.serialize(p);
    return serialized.split("#")[0] + "#";
}
resolve$1._getFullPath = _getFullPath;
const TRAILING_SLASH_HASH = /#\/?$/;
function normalizeId(id) {
    return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
}
resolve$1.normalizeId = normalizeId;
function resolveUrl(resolver, baseId, id) {
    id = normalizeId(id);
    return resolver.resolve(baseId, id);
}
resolve$1.resolveUrl = resolveUrl;
const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
function getSchemaRefs(schema, baseId) {
    if (typeof schema == "boolean")
        return {};
    const { schemaId, uriResolver } = this.opts;
    const schId = normalizeId(schema[schemaId] || baseId);
    const baseIds = { "": schId };
    const pathPrefix = getFullPath(uriResolver, schId, false);
    const localRefs = {};
    const schemaRefs = new Set();
    traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
        if (parentJsonPtr === undefined)
            return;
        const fullPath = pathPrefix + jsonPtr;
        let baseId = baseIds[parentJsonPtr];
        if (typeof sch[schemaId] == "string")
            baseId = addRef.call(this, sch[schemaId]);
        addAnchor.call(this, sch.$anchor);
        addAnchor.call(this, sch.$dynamicAnchor);
        baseIds[jsonPtr] = baseId;
        function addRef(ref) {
            // eslint-disable-next-line @typescript-eslint/unbound-method
            const _resolve = this.opts.uriResolver.resolve;
            ref = normalizeId(baseId ? _resolve(baseId, ref) : ref);
            if (schemaRefs.has(ref))
                throw ambiguos(ref);
            schemaRefs.add(ref);
            let schOrRef = this.refs[ref];
            if (typeof schOrRef == "string")
                schOrRef = this.refs[schOrRef];
            if (typeof schOrRef == "object") {
                checkAmbiguosRef(sch, schOrRef.schema, ref);
            }
            else if (ref !== normalizeId(fullPath)) {
                if (ref[0] === "#") {
                    checkAmbiguosRef(sch, localRefs[ref], ref);
                    localRefs[ref] = sch;
                }
                else {
                    this.refs[ref] = fullPath;
                }
            }
            return ref;
        }
        function addAnchor(anchor) {
            if (typeof anchor == "string") {
                if (!ANCHOR.test(anchor))
                    throw new Error(`invalid anchor "${anchor}"`);
                addRef.call(this, `#${anchor}`);
            }
        }
    });
    return localRefs;
    function checkAmbiguosRef(sch1, sch2, ref) {
        if (sch2 !== undefined && !equal$2(sch1, sch2))
            throw ambiguos(ref);
    }
    function ambiguos(ref) {
        return new Error(`reference "${ref}" resolves to more than one schema`);
    }
}
resolve$1.getSchemaRefs = getSchemaRefs;

var hasRequiredValidate;

function requireValidate () {
	if (hasRequiredValidate) return validate;
	hasRequiredValidate = 1;
	Object.defineProperty(validate, "__esModule", { value: true });
	validate.getData = validate.KeywordCxt = validate.validateFunctionCode = void 0;
	const boolSchema_1 = requireBoolSchema();
	const dataType_1 = dataType;
	const applicability_1 = applicability;
	const dataType_2 = dataType;
	const defaults_1 = requireDefaults();
	const keyword_1 = requireKeyword();
	const subschema_1 = requireSubschema();
	const codegen_1 = requireCodegen();
	const names_1 = requireNames();
	const resolve_1 = resolve$1;
	const util_1 = util$1;
	const errors_1 = errors;
	// schema compilation - generates validation function, subschemaCode (below) is used for subschemas
	function validateFunctionCode(it) {
	    if (isSchemaObj(it)) {
	        checkKeywords(it);
	        if (schemaCxtHasRules(it)) {
	            topSchemaObjCode(it);
	            return;
	        }
	    }
	    validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
	}
	validate.validateFunctionCode = validateFunctionCode;
	function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
	    if (opts.code.es5) {
	        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
	            gen.code((0, codegen_1._) `"use strict"; ${funcSourceUrl(schema, opts)}`);
	            destructureValCxtES5(gen, opts);
	            gen.code(body);
	        });
	    }
	    else {
	        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
	    }
	}
	function destructureValCxt(opts) {
	    return (0, codegen_1._) `{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._) `, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
	}
	function destructureValCxtES5(gen, opts) {
	    gen.if(names_1.default.valCxt, () => {
	        gen.var(names_1.default.instancePath, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.instancePath}`);
	        gen.var(names_1.default.parentData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentData}`);
	        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
	        gen.var(names_1.default.rootData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.rootData}`);
	        if (opts.dynamicRef)
	            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
	    }, () => {
	        gen.var(names_1.default.instancePath, (0, codegen_1._) `""`);
	        gen.var(names_1.default.parentData, (0, codegen_1._) `undefined`);
	        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `undefined`);
	        gen.var(names_1.default.rootData, names_1.default.data);
	        if (opts.dynamicRef)
	            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `{}`);
	    });
	}
	function topSchemaObjCode(it) {
	    const { schema, opts, gen } = it;
	    validateFunction(it, () => {
	        if (opts.$comment && schema.$comment)
	            commentKeyword(it);
	        checkNoDefault(it);
	        gen.let(names_1.default.vErrors, null);
	        gen.let(names_1.default.errors, 0);
	        if (opts.unevaluated)
	            resetEvaluated(it);
	        typeAndKeywords(it);
	        returnResults(it);
	    });
	    return;
	}
	function resetEvaluated(it) {
	    // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated
	    const { gen, validateName } = it;
	    it.evaluated = gen.const("evaluated", (0, codegen_1._) `${validateName}.evaluated`);
	    gen.if((0, codegen_1._) `${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._) `${it.evaluated}.props`, (0, codegen_1._) `undefined`));
	    gen.if((0, codegen_1._) `${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._) `${it.evaluated}.items`, (0, codegen_1._) `undefined`));
	}
	function funcSourceUrl(schema, opts) {
	    const schId = typeof schema == "object" && schema[opts.schemaId];
	    return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._) `/*# sourceURL=${schId} */` : codegen_1.nil;
	}
	// schema compilation - this function is used recursively to generate code for sub-schemas
	function subschemaCode(it, valid) {
	    if (isSchemaObj(it)) {
	        checkKeywords(it);
	        if (schemaCxtHasRules(it)) {
	            subSchemaObjCode(it, valid);
	            return;
	        }
	    }
	    (0, boolSchema_1.boolOrEmptySchema)(it, valid);
	}
	function schemaCxtHasRules({ schema, self }) {
	    if (typeof schema == "boolean")
	        return !schema;
	    for (const key in schema)
	        if (self.RULES.all[key])
	            return true;
	    return false;
	}
	function isSchemaObj(it) {
	    return typeof it.schema != "boolean";
	}
	function subSchemaObjCode(it, valid) {
	    const { schema, gen, opts } = it;
	    if (opts.$comment && schema.$comment)
	        commentKeyword(it);
	    updateContext(it);
	    checkAsyncSchema(it);
	    const errsCount = gen.const("_errs", names_1.default.errors);
	    typeAndKeywords(it, errsCount);
	    // TODO var
	    gen.var(valid, (0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);
	}
	function checkKeywords(it) {
	    (0, util_1.checkUnknownRules)(it);
	    checkRefsAndKeywords(it);
	}
	function typeAndKeywords(it, errsCount) {
	    if (it.opts.jtd)
	        return schemaKeywords(it, [], false, errsCount);
	    const types = (0, dataType_1.getSchemaTypes)(it.schema);
	    const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);
	    schemaKeywords(it, types, !checkedTypes, errsCount);
	}
	function checkRefsAndKeywords(it) {
	    const { schema, errSchemaPath, opts, self } = it;
	    if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {
	        self.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
	    }
	}
	function checkNoDefault(it) {
	    const { schema, opts } = it;
	    if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {
	        (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
	    }
	}
	function updateContext(it) {
	    const schId = it.schema[it.opts.schemaId];
	    if (schId)
	        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
	}
	function checkAsyncSchema(it) {
	    if (it.schema.$async && !it.schemaEnv.$async)
	        throw new Error("async schema in sync schema");
	}
	function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
	    const msg = schema.$comment;
	    if (opts.$comment === true) {
	        gen.code((0, codegen_1._) `${names_1.default.self}.logger.log(${msg})`);
	    }
	    else if (typeof opts.$comment == "function") {
	        const schemaPath = (0, codegen_1.str) `${errSchemaPath}/$comment`;
	        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
	        gen.code((0, codegen_1._) `${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
	    }
	}
	function returnResults(it) {
	    const { gen, schemaEnv, validateName, ValidationError, opts } = it;
	    if (schemaEnv.$async) {
	        // TODO assign unevaluated
	        gen.if((0, codegen_1._) `${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._) `new ${ValidationError}(${names_1.default.vErrors})`));
	    }
	    else {
	        gen.assign((0, codegen_1._) `${validateName}.errors`, names_1.default.vErrors);
	        if (opts.unevaluated)
	            assignEvaluated(it);
	        gen.return((0, codegen_1._) `${names_1.default.errors} === 0`);
	    }
	}
	function assignEvaluated({ gen, evaluated, props, items }) {
	    if (props instanceof codegen_1.Name)
	        gen.assign((0, codegen_1._) `${evaluated}.props`, props);
	    if (items instanceof codegen_1.Name)
	        gen.assign((0, codegen_1._) `${evaluated}.items`, items);
	}
	function schemaKeywords(it, types, typeErrors, errsCount) {
	    const { gen, schema, data, allErrors, opts, self } = it;
	    const { RULES } = self;
	    if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
	        gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition)); // TODO typecast
	        return;
	    }
	    if (!opts.jtd)
	        checkStrictTypes(it, types);
	    gen.block(() => {
	        for (const group of RULES.rules)
	            groupKeywords(group);
	        groupKeywords(RULES.post);
	    });
	    function groupKeywords(group) {
	        if (!(0, applicability_1.shouldUseGroup)(schema, group))
	            return;
	        if (group.type) {
	            gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
	            iterateKeywords(it, group);
	            if (types.length === 1 && types[0] === group.type && typeErrors) {
	                gen.else();
	                (0, dataType_2.reportTypeError)(it);
	            }
	            gen.endIf();
	        }
	        else {
	            iterateKeywords(it, group);
	        }
	        // TODO make it "ok" call?
	        if (!allErrors)
	            gen.if((0, codegen_1._) `${names_1.default.errors} === ${errsCount || 0}`);
	    }
	}
	function iterateKeywords(it, group) {
	    const { gen, schema, opts: { useDefaults }, } = it;
	    if (useDefaults)
	        (0, defaults_1.assignDefaults)(it, group.type);
	    gen.block(() => {
	        for (const rule of group.rules) {
	            if ((0, applicability_1.shouldUseRule)(schema, rule)) {
	                keywordCode(it, rule.keyword, rule.definition, group.type);
	            }
	        }
	    });
	}
	function checkStrictTypes(it, types) {
	    if (it.schemaEnv.meta || !it.opts.strictTypes)
	        return;
	    checkContextTypes(it, types);
	    if (!it.opts.allowUnionTypes)
	        checkMultipleTypes(it, types);
	    checkKeywordTypes(it, it.dataTypes);
	}
	function checkContextTypes(it, types) {
	    if (!types.length)
	        return;
	    if (!it.dataTypes.length) {
	        it.dataTypes = types;
	        return;
	    }
	    types.forEach((t) => {
	        if (!includesType(it.dataTypes, t)) {
	            strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
	        }
	    });
	    narrowSchemaTypes(it, types);
	}
	function checkMultipleTypes(it, ts) {
	    if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
	        strictTypesError(it, "use allowUnionTypes to allow union type keyword");
	    }
	}
	function checkKeywordTypes(it, ts) {
	    const rules = it.self.RULES.all;
	    for (const keyword in rules) {
	        const rule = rules[keyword];
	        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
	            const { type } = rule.definition;
	            if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
	                strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
	            }
	        }
	    }
	}
	function hasApplicableType(schTs, kwdT) {
	    return schTs.includes(kwdT) || (kwdT === "number" && schTs.includes("integer"));
	}
	function includesType(ts, t) {
	    return ts.includes(t) || (t === "integer" && ts.includes("number"));
	}
	function narrowSchemaTypes(it, withTypes) {
	    const ts = [];
	    for (const t of it.dataTypes) {
	        if (includesType(withTypes, t))
	            ts.push(t);
	        else if (withTypes.includes("integer") && t === "number")
	            ts.push("integer");
	    }
	    it.dataTypes = ts;
	}
	function strictTypesError(it, msg) {
	    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
	    msg += ` at "${schemaPath}" (strictTypes)`;
	    (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
	}
	class KeywordCxt {
	    constructor(it, def, keyword) {
	        (0, keyword_1.validateKeywordUsage)(it, def, keyword);
	        this.gen = it.gen;
	        this.allErrors = it.allErrors;
	        this.keyword = keyword;
	        this.data = it.data;
	        this.schema = it.schema[keyword];
	        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
	        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);
	        this.schemaType = def.schemaType;
	        this.parentSchema = it.schema;
	        this.params = {};
	        this.it = it;
	        this.def = def;
	        if (this.$data) {
	            this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
	        }
	        else {
	            this.schemaCode = this.schemaValue;
	            if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
	                throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
	            }
	        }
	        if ("code" in def ? def.trackErrors : def.errors !== false) {
	            this.errsCount = it.gen.const("_errs", names_1.default.errors);
	        }
	    }
	    result(condition, successAction, failAction) {
	        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
	    }
	    failResult(condition, successAction, failAction) {
	        this.gen.if(condition);
	        if (failAction)
	            failAction();
	        else
	            this.error();
	        if (successAction) {
	            this.gen.else();
	            successAction();
	            if (this.allErrors)
	                this.gen.endIf();
	        }
	        else {
	            if (this.allErrors)
	                this.gen.endIf();
	            else
	                this.gen.else();
	        }
	    }
	    pass(condition, failAction) {
	        this.failResult((0, codegen_1.not)(condition), undefined, failAction);
	    }
	    fail(condition) {
	        if (condition === undefined) {
	            this.error();
	            if (!this.allErrors)
	                this.gen.if(false); // this branch will be removed by gen.optimize
	            return;
	        }
	        this.gen.if(condition);
	        this.error();
	        if (this.allErrors)
	            this.gen.endIf();
	        else
	            this.gen.else();
	    }
	    fail$data(condition) {
	        if (!this.$data)
	            return this.fail(condition);
	        const { schemaCode } = this;
	        this.fail((0, codegen_1._) `${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
	    }
	    error(append, errorParams, errorPaths) {
	        if (errorParams) {
	            this.setParams(errorParams);
	            this._error(append, errorPaths);
	            this.setParams({});
	            return;
	        }
	        this._error(append, errorPaths);
	    }
	    _error(append, errorPaths) {
	        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
	    }
	    $dataError() {
	        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
	    }
	    reset() {
	        if (this.errsCount === undefined)
	            throw new Error('add "trackErrors" to keyword definition');
	        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
	    }
	    ok(cond) {
	        if (!this.allErrors)
	            this.gen.if(cond);
	    }
	    setParams(obj, assign) {
	        if (assign)
	            Object.assign(this.params, obj);
	        else
	            this.params = obj;
	    }
	    block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
	        this.gen.block(() => {
	            this.check$data(valid, $dataValid);
	            codeBlock();
	        });
	    }
	    check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
	        if (!this.$data)
	            return;
	        const { gen, schemaCode, schemaType, def } = this;
	        gen.if((0, codegen_1.or)((0, codegen_1._) `${schemaCode} === undefined`, $dataValid));
	        if (valid !== codegen_1.nil)
	            gen.assign(valid, true);
	        if (schemaType.length || def.validateSchema) {
	            gen.elseIf(this.invalid$data());
	            this.$dataError();
	            if (valid !== codegen_1.nil)
	                gen.assign(valid, false);
	        }
	        gen.else();
	    }
	    invalid$data() {
	        const { gen, schemaCode, schemaType, def, it } = this;
	        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
	        function wrong$DataType() {
	            if (schemaType.length) {
	                /* istanbul ignore if */
	                if (!(schemaCode instanceof codegen_1.Name))
	                    throw new Error("ajv implementation error");
	                const st = Array.isArray(schemaType) ? schemaType : [schemaType];
	                return (0, codegen_1._) `${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
	            }
	            return codegen_1.nil;
	        }
	        function invalid$DataSchema() {
	            if (def.validateSchema) {
	                const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema }); // TODO value.code for standalone
	                return (0, codegen_1._) `!${validateSchemaRef}(${schemaCode})`;
	            }
	            return codegen_1.nil;
	        }
	    }
	    subschema(appl, valid) {
	        const subschema = (0, subschema_1.getSubschema)(this.it, appl);
	        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
	        (0, subschema_1.extendSubschemaMode)(subschema, appl);
	        const nextContext = { ...this.it, ...subschema, items: undefined, props: undefined };
	        subschemaCode(nextContext, valid);
	        return nextContext;
	    }
	    mergeEvaluated(schemaCxt, toName) {
	        const { it, gen } = this;
	        if (!it.opts.unevaluated)
	            return;
	        if (it.props !== true && schemaCxt.props !== undefined) {
	            it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
	        }
	        if (it.items !== true && schemaCxt.items !== undefined) {
	            it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
	        }
	    }
	    mergeValidEvaluated(schemaCxt, valid) {
	        const { it, gen } = this;
	        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
	            gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
	            return true;
	        }
	    }
	}
	validate.KeywordCxt = KeywordCxt;
	function keywordCode(it, keyword, def, ruleType) {
	    const cxt = new KeywordCxt(it, def, keyword);
	    if ("code" in def) {
	        def.code(cxt, ruleType);
	    }
	    else if (cxt.$data && def.validate) {
	        (0, keyword_1.funcKeywordCode)(cxt, def);
	    }
	    else if ("macro" in def) {
	        (0, keyword_1.macroKeywordCode)(cxt, def);
	    }
	    else if (def.compile || def.validate) {
	        (0, keyword_1.funcKeywordCode)(cxt, def);
	    }
	}
	const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
	const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
	function getData($data, { dataLevel, dataNames, dataPathArr }) {
	    let jsonPointer;
	    let data;
	    if ($data === "")
	        return names_1.default.rootData;
	    if ($data[0] === "/") {
	        if (!JSON_POINTER.test($data))
	            throw new Error(`Invalid JSON-pointer: ${$data}`);
	        jsonPointer = $data;
	        data = names_1.default.rootData;
	    }
	    else {
	        const matches = RELATIVE_JSON_POINTER.exec($data);
	        if (!matches)
	            throw new Error(`Invalid JSON-pointer: ${$data}`);
	        const up = +matches[1];
	        jsonPointer = matches[2];
	        if (jsonPointer === "#") {
	            if (up >= dataLevel)
	                throw new Error(errorMsg("property/index", up));
	            return dataPathArr[dataLevel - up];
	        }
	        if (up > dataLevel)
	            throw new Error(errorMsg("data", up));
	        data = dataNames[dataLevel - up];
	        if (!jsonPointer)
	            return data;
	    }
	    let expr = data;
	    const segments = jsonPointer.split("/");
	    for (const segment of segments) {
	        if (segment) {
	            data = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
	            expr = (0, codegen_1._) `${expr} && ${data}`;
	        }
	    }
	    return expr;
	    function errorMsg(pointerType, up) {
	        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
	    }
	}
	validate.getData = getData;
	
	return validate;
}

var validation_error = {};

var hasRequiredValidation_error;

function requireValidation_error () {
	if (hasRequiredValidation_error) return validation_error;
	hasRequiredValidation_error = 1;
	Object.defineProperty(validation_error, "__esModule", { value: true });
	class ValidationError extends Error {
	    constructor(errors) {
	        super("validation failed");
	        this.errors = errors;
	        this.ajv = this.validation = true;
	    }
	}
	validation_error.default = ValidationError;
	
	return validation_error;
}

var ref_error = {};

var hasRequiredRef_error;

function requireRef_error () {
	if (hasRequiredRef_error) return ref_error;
	hasRequiredRef_error = 1;
	Object.defineProperty(ref_error, "__esModule", { value: true });
	const resolve_1 = resolve$1;
	class MissingRefError extends Error {
	    constructor(resolver, baseId, ref, msg) {
	        super(msg || `can't resolve reference ${ref} from id ${baseId}`);
	        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
	        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
	    }
	}
	ref_error.default = MissingRefError;
	
	return ref_error;
}

var compile$1 = {};

Object.defineProperty(compile$1, "__esModule", { value: true });
compile$1.resolveSchema = compile$1.getCompilingSchema = compile$1.resolveRef = compile$1.compileSchema = compile$1.SchemaEnv = void 0;
const codegen_1$m = requireCodegen();
const validation_error_1 = requireValidation_error();
const names_1$2 = requireNames();
const resolve_1 = resolve$1;
const util_1$k = util$1;
const validate_1$1 = requireValidate();
class SchemaEnv {
    constructor(env) {
        var _a;
        this.refs = {};
        this.dynamicAnchors = {};
        let schema;
        if (typeof env.schema == "object")
            schema = env.schema;
        this.schema = env.schema;
        this.schemaId = env.schemaId;
        this.root = env.root || this;
        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
        this.schemaPath = env.schemaPath;
        this.localRefs = env.localRefs;
        this.meta = env.meta;
        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
        this.refs = {};
    }
}
compile$1.SchemaEnv = SchemaEnv;
// let codeSize = 0
// let nodeCount = 0
// Compiles schema in SchemaEnv
function compileSchema(sch) {
    // TODO refactor - remove compilations
    const _sch = getCompilingSchema.call(this, sch);
    if (_sch)
        return _sch;
    const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId); // TODO if getFullPath removed 1 tests fails
    const { es5, lines } = this.opts.code;
    const { ownProperties } = this.opts;
    const gen = new codegen_1$m.CodeGen(this.scope, { es5, lines, ownProperties });
    let _ValidationError;
    if (sch.$async) {
        _ValidationError = gen.scopeValue("Error", {
            ref: validation_error_1.default,
            code: (0, codegen_1$m._) `require("ajv/dist/runtime/validation_error").default`,
        });
    }
    const validateName = gen.scopeName("validate");
    sch.validateName = validateName;
    const schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1$2.default.data,
        parentData: names_1$2.default.parentData,
        parentDataProperty: names_1$2.default.parentDataProperty,
        dataNames: [names_1$2.default.data],
        dataPathArr: [codegen_1$m.nil],
        dataLevel: 0,
        dataTypes: [],
        definedProperties: new Set(),
        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true
            ? { ref: sch.schema, code: (0, codegen_1$m.stringify)(sch.schema) }
            : { ref: sch.schema }),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1$m.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1$m._) `""`,
        opts: this.opts,
        self: this,
    };
    let sourceCode;
    try {
        this._compilations.add(sch);
        (0, validate_1$1.validateFunctionCode)(schemaCxt);
        gen.optimize(this.opts.code.optimize);
        // gen.optimize(1)
        const validateCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1$2.default.scope)}return ${validateCode}`;
        // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))
        if (this.opts.code.process)
            sourceCode = this.opts.code.process(sourceCode, sch);
        // console.log("\n\n\n *** \n", sourceCode)
        const makeValidate = new Function(`${names_1$2.default.self}`, `${names_1$2.default.scope}`, sourceCode);
        const validate = makeValidate(this, this.scope.get());
        this.scope.value(validateName, { ref: validate });
        validate.errors = null;
        validate.schema = sch.schema;
        validate.schemaEnv = sch;
        if (sch.$async)
            validate.$async = true;
        if (this.opts.code.source === true) {
            validate.source = { validateName, validateCode, scopeValues: gen._values };
        }
        if (this.opts.unevaluated) {
            const { props, items } = schemaCxt;
            validate.evaluated = {
                props: props instanceof codegen_1$m.Name ? undefined : props,
                items: items instanceof codegen_1$m.Name ? undefined : items,
                dynamicProps: props instanceof codegen_1$m.Name,
                dynamicItems: items instanceof codegen_1$m.Name,
            };
            if (validate.source)
                validate.source.evaluated = (0, codegen_1$m.stringify)(validate.evaluated);
        }
        sch.validate = validate;
        return sch;
    }
    catch (e) {
        delete sch.validate;
        delete sch.validateName;
        if (sourceCode)
            this.logger.error("Error compiling schema, function code:", sourceCode);
        // console.log("\n\n\n *** \n", sourceCode, this.opts)
        throw e;
    }
    finally {
        this._compilations.delete(sch);
    }
}
compile$1.compileSchema = compileSchema;
function resolveRef(root, baseId, ref) {
    var _a;
    ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
    const schOrFunc = root.refs[ref];
    if (schOrFunc)
        return schOrFunc;
    let _sch = resolve.call(this, root, ref);
    if (_sch === undefined) {
        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref]; // TODO maybe localRefs should hold SchemaEnv
        const { schemaId } = this.opts;
        if (schema)
            _sch = new SchemaEnv({ schema, schemaId, root, baseId });
    }
    if (_sch === undefined)
        return;
    return (root.refs[ref] = inlineOrCompile.call(this, _sch));
}
compile$1.resolveRef = resolveRef;
function inlineOrCompile(sch) {
    if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
        return sch.schema;
    return sch.validate ? sch : compileSchema.call(this, sch);
}
// Index of schema compilation in the currently compiled list
function getCompilingSchema(schEnv) {
    for (const sch of this._compilations) {
        if (sameSchemaEnv(sch, schEnv))
            return sch;
    }
}
compile$1.getCompilingSchema = getCompilingSchema;
function sameSchemaEnv(s1, s2) {
    return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
}
// resolve and compile the references ($ref)
// TODO returns AnySchemaObject (if the schema can be inlined) or validation function
function resolve(root, // information about the root schema for the current schema
ref // reference to resolve
) {
    let sch;
    while (typeof (sch = this.refs[ref]) == "string")
        ref = sch;
    return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
}
// Resolve schema, its root and baseId
function resolveSchema(root, // root object with properties schema, refs TODO below SchemaEnv is assigned to it
ref // reference to resolve
) {
    const p = this.opts.uriResolver.parse(ref);
    const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
    let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, undefined);
    // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests
    if (Object.keys(root.schema).length > 0 && refPath === baseId) {
        return getJsonPointer.call(this, p, root);
    }
    const id = (0, resolve_1.normalizeId)(refPath);
    const schOrRef = this.refs[id] || this.schemas[id];
    if (typeof schOrRef == "string") {
        const sch = resolveSchema.call(this, root, schOrRef);
        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
            return;
        return getJsonPointer.call(this, p, sch);
    }
    if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
        return;
    if (!schOrRef.validate)
        compileSchema.call(this, schOrRef);
    if (id === (0, resolve_1.normalizeId)(ref)) {
        const { schema } = schOrRef;
        const { schemaId } = this.opts;
        const schId = schema[schemaId];
        if (schId)
            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        return new SchemaEnv({ schema, schemaId, root, baseId });
    }
    return getJsonPointer.call(this, p, schOrRef);
}
compile$1.resolveSchema = resolveSchema;
const PREVENT_SCOPE_CHANGE = new Set([
    "properties",
    "patternProperties",
    "enum",
    "dependencies",
    "definitions",
]);
function getJsonPointer(parsedRef, { baseId, schema, root }) {
    var _a;
    if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
        return;
    for (const part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema === "boolean")
            return;
        const partSchema = schema[(0, util_1$k.unescapeFragment)(part)];
        if (partSchema === undefined)
            return;
        schema = partSchema;
        // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?
        const schId = typeof schema === "object" && schema[this.opts.schemaId];
        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        }
    }
    let env;
    if (typeof schema != "boolean" && schema.$ref && !(0, util_1$k.schemaHasRulesButRef)(schema, this.RULES)) {
        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
        env = resolveSchema.call(this, root, $ref);
    }
    // even though resolution failed we need to return SchemaEnv to throw exception
    // so that compileAsync loads missing schema.
    const { schemaId } = this.opts;
    env = env || new SchemaEnv({ schema, schemaId, root, baseId });
    if (env.schema !== env.root.schema)
        return env;
    return undefined;
}

var $id$1 = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
var description = "Meta-schema for $data reference (JSON AnySchema extension proposal)";
var type$1 = "object";
var required$1 = [
	"$data"
];
var properties$2 = {
	$data: {
		type: "string",
		anyOf: [
			{
				format: "relative-json-pointer"
			},
			{
				format: "json-pointer"
			}
		]
	}
};
var additionalProperties$1 = false;
var require$$9 = {
	$id: $id$1,
	description: description,
	type: type$1,
	required: required$1,
	properties: properties$2,
	additionalProperties: additionalProperties$1
};

var uri$1 = {};

var uri_all = {exports: {}};

/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */

(function (module, exports) {
	(function (global, factory) {
		factory(exports) ;
	}(commonjsGlobal, (function (exports) {
	function merge() {
	    for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
	        sets[_key] = arguments[_key];
	    }

	    if (sets.length > 1) {
	        sets[0] = sets[0].slice(0, -1);
	        var xl = sets.length - 1;
	        for (var x = 1; x < xl; ++x) {
	            sets[x] = sets[x].slice(1, -1);
	        }
	        sets[xl] = sets[xl].slice(1);
	        return sets.join('');
	    } else {
	        return sets[0];
	    }
	}
	function subexp(str) {
	    return "(?:" + str + ")";
	}
	function typeOf(o) {
	    return o === undefined ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
	}
	function toUpperCase(str) {
	    return str.toUpperCase();
	}
	function toArray(obj) {
	    return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
	}
	function assign(target, source) {
	    var obj = target;
	    if (source) {
	        for (var key in source) {
	            obj[key] = source[key];
	        }
	    }
	    return obj;
	}

	function buildExps(isIRI) {
	    var ALPHA$$ = "[A-Za-z]",
	        DIGIT$$ = "[0-9]",
	        HEXDIG$$ = merge(DIGIT$$, "[A-Fa-f]"),
	        PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)),
	        //expanded
	    GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]",
	        SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]",
	        RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),
	        UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]",
	        //subset, excludes bidi control characters
	    IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]",
	        //subset
	    UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$);
	        subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*");
	        subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]")) + "*");
	        var DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$),
	        //relaxed parsing rules
	    IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$),
	        H16$ = subexp(HEXDIG$$ + "{1,4}"),
	        LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$),
	        IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$),
	        //                           6( h16 ":" ) ls32
	    IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$),
	        //                      "::" 5( h16 ":" ) ls32
	    IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$),
	        //[               h16 ] "::" 4( h16 ":" ) ls32
	    IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$),
	        //[ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
	    IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$),
	        //[ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
	    IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$),
	        //[ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
	    IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$),
	        //[ *4( h16 ":" ) h16 ] "::"              ls32
	    IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$),
	        //[ *5( h16 ":" ) h16 ] "::"              h16
	    IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"),
	        //[ *6( h16 ":" ) h16 ] "::"
	    IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")),
	        ZONEID$ = subexp(subexp(UNRESERVED$$ + "|" + PCT_ENCODED$) + "+");
	        //RFC 6874, with relaxed parsing rules
	    subexp("[vV]" + HEXDIG$$ + "+\\." + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]") + "+");
	        //RFC 6874
	    subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$)) + "*");
	        var PCHAR$ = subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@]"));
	        subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\@]")) + "+");
	        subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*");
	    return {
	        NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
	        NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
	        NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
	        NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
	        NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
	        NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
	        NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
	        ESCAPE: new RegExp(merge("[^]", UNRESERVED$$, SUB_DELIMS$$), "g"),
	        UNRESERVED: new RegExp(UNRESERVED$$, "g"),
	        OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$, RESERVED$$), "g"),
	        PCT_ENCODED: new RegExp(PCT_ENCODED$, "g"),
	        IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
	        IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$") //RFC 6874, with relaxed parsing rules
	    };
	}
	var URI_PROTOCOL = buildExps(false);

	var IRI_PROTOCOL = buildExps(true);

	var slicedToArray = function () {
	  function sliceIterator(arr, i) {
	    var _arr = [];
	    var _n = true;
	    var _d = false;
	    var _e = undefined;

	    try {
	      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
	        _arr.push(_s.value);

	        if (i && _arr.length === i) break;
	      }
	    } catch (err) {
	      _d = true;
	      _e = err;
	    } finally {
	      try {
	        if (!_n && _i["return"]) _i["return"]();
	      } finally {
	        if (_d) throw _e;
	      }
	    }

	    return _arr;
	  }

	  return function (arr, i) {
	    if (Array.isArray(arr)) {
	      return arr;
	    } else if (Symbol.iterator in Object(arr)) {
	      return sliceIterator(arr, i);
	    } else {
	      throw new TypeError("Invalid attempt to destructure non-iterable instance");
	    }
	  };
	}();













	var toConsumableArray = function (arr) {
	  if (Array.isArray(arr)) {
	    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

	    return arr2;
	  } else {
	    return Array.from(arr);
	  }
	};

	/** Highest positive signed 32-bit float value */

	var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	var base = 36;
	var tMin = 1;
	var tMax = 26;
	var skew = 38;
	var damp = 700;
	var initialBias = 72;
	var initialN = 128; // 0x80
	var delimiter = '-'; // '\x2D'

	/** Regular expressions */
	var regexPunycode = /^xn--/;
	var regexNonASCII = /[^\0-\x7E]/; // non-ASCII chars
	var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

	/** Error messages */
	var errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	};

	/** Convenience shortcuts */
	var baseMinusTMin = base - tMin;
	var floor = Math.floor;
	var stringFromCharCode = String.fromCharCode;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error$1(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var result = [];
		var length = array.length;
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [];
		var counter = 0;
		var length = string.length;
		while (counter < length) {
			var value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// It's a high surrogate, and there is a next character.
				var extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) {
					// Low surrogate.
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// It's an unmatched surrogate; only append this code unit, in case the
					// next code unit is the high surrogate of a surrogate pair.
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	var ucs2encode = function ucs2encode(array) {
		return String.fromCodePoint.apply(String, toConsumableArray(array));
	};

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	var basicToDigit = function basicToDigit(codePoint) {
		if (codePoint - 0x30 < 0x0A) {
			return codePoint - 0x16;
		}
		if (codePoint - 0x41 < 0x1A) {
			return codePoint - 0x41;
		}
		if (codePoint - 0x61 < 0x1A) {
			return codePoint - 0x61;
		}
		return base;
	};

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	var digitToBasic = function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	};

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	var adapt = function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	};

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	var decode = function decode(input) {
		// Don't use UCS-2.
		var output = [];
		var inputLength = input.length;
		var i = 0;
		var n = initialN;
		var bias = initialBias;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		var basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (var j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error$1('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (var index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			var oldi = i;
			for (var w = 1, k = base;; /* no condition */k += base) {

				if (index >= inputLength) {
					error$1('invalid-input');
				}

				var digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error$1('overflow');
				}

				i += digit * w;
				var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

				if (digit < t) {
					break;
				}

				var baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error$1('overflow');
				}

				w *= baseMinusT;
			}

			var out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error$1('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output.
			output.splice(i++, 0, n);
		}

		return String.fromCodePoint.apply(String, output);
	};

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	var encode = function encode(input) {
		var output = [];

		// Convert the input in UCS-2 to an array of Unicode code points.
		input = ucs2decode(input);

		// Cache the length.
		var inputLength = input.length;

		// Initialize the state.
		var n = initialN;
		var delta = 0;
		var bias = initialBias;

		// Handle the basic code points.
		var _iteratorNormalCompletion = true;
		var _didIteratorError = false;
		var _iteratorError = undefined;

		try {
			for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
				var _currentValue2 = _step.value;

				if (_currentValue2 < 0x80) {
					output.push(stringFromCharCode(_currentValue2));
				}
			}
		} catch (err) {
			_didIteratorError = true;
			_iteratorError = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion && _iterator.return) {
					_iterator.return();
				}
			} finally {
				if (_didIteratorError) {
					throw _iteratorError;
				}
			}
		}

		var basicLength = output.length;
		var handledCPCount = basicLength;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string with a delimiter unless it's empty.
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			var m = maxInt;
			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
				for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var currentValue = _step2.value;

					if (currentValue >= n && currentValue < m) {
						m = currentValue;
					}
				}

				// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
				// but guard against overflow.
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
						_iterator2.return();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}

			var handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error$1('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			var _iteratorNormalCompletion3 = true;
			var _didIteratorError3 = false;
			var _iteratorError3 = undefined;

			try {
				for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
					var _currentValue = _step3.value;

					if (_currentValue < n && ++delta > maxInt) {
						error$1('overflow');
					}
					if (_currentValue == n) {
						// Represent delta as a generalized variable-length integer.
						var q = delta;
						for (var k = base;; /* no condition */k += base) {
							var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
							if (q < t) {
								break;
							}
							var qMinusT = q - t;
							var baseMinusT = base - t;
							output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
							q = floor(qMinusT / baseMinusT);
						}

						output.push(stringFromCharCode(digitToBasic(q, 0)));
						bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
						delta = 0;
						++handledCPCount;
					}
				}
			} catch (err) {
				_didIteratorError3 = true;
				_iteratorError3 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion3 && _iterator3.return) {
						_iterator3.return();
					}
				} finally {
					if (_didIteratorError3) {
						throw _iteratorError3;
					}
				}
			}

			++delta;
			++n;
		}
		return output.join('');
	};

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	var toUnicode = function toUnicode(input) {
		return mapDomain(input, function (string) {
			return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
		});
	};

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	var toASCII = function toASCII(input) {
		return mapDomain(input, function (string) {
			return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
		});
	};

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	var punycode = {
		/**
	  * A string representing the current Punycode.js version number.
	  * @memberOf punycode
	  * @type String
	  */
		'version': '2.1.0',
		/**
	  * An object of methods to convert from JavaScript's internal character
	  * representation (UCS-2) to Unicode code points, and back.
	  * @see <https://mathiasbynens.be/notes/javascript-encoding>
	  * @memberOf punycode
	  * @type Object
	  */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/**
	 * URI.js
	 *
	 * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.
	 * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
	 * @see http://github.com/garycourt/uri-js
	 */
	/**
	 * Copyright 2011 Gary Court. All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without modification, are
	 * permitted provided that the following conditions are met:
	 *
	 *    1. Redistributions of source code must retain the above copyright notice, this list of
	 *       conditions and the following disclaimer.
	 *
	 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
	 *       of conditions and the following disclaimer in the documentation and/or other materials
	 *       provided with the distribution.
	 *
	 * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED
	 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
	 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
	 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
	 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
	 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
	 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
	 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 *
	 * The views and conclusions contained in the software and documentation are those of the
	 * authors and should not be interpreted as representing official policies, either expressed
	 * or implied, of Gary Court.
	 */
	var SCHEMES = {};
	function pctEncChar(chr) {
	    var c = chr.charCodeAt(0);
	    var e = void 0;
	    if (c < 16) e = "%0" + c.toString(16).toUpperCase();else if (c < 128) e = "%" + c.toString(16).toUpperCase();else if (c < 2048) e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();else e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
	    return e;
	}
	function pctDecChars(str) {
	    var newStr = "";
	    var i = 0;
	    var il = str.length;
	    while (i < il) {
	        var c = parseInt(str.substr(i + 1, 2), 16);
	        if (c < 128) {
	            newStr += String.fromCharCode(c);
	            i += 3;
	        } else if (c >= 194 && c < 224) {
	            if (il - i >= 6) {
	                var c2 = parseInt(str.substr(i + 4, 2), 16);
	                newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
	            } else {
	                newStr += str.substr(i, 6);
	            }
	            i += 6;
	        } else if (c >= 224) {
	            if (il - i >= 9) {
	                var _c = parseInt(str.substr(i + 4, 2), 16);
	                var c3 = parseInt(str.substr(i + 7, 2), 16);
	                newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
	            } else {
	                newStr += str.substr(i, 9);
	            }
	            i += 9;
	        } else {
	            newStr += str.substr(i, 3);
	            i += 3;
	        }
	    }
	    return newStr;
	}
	function _normalizeComponentEncoding(components, protocol) {
	    function decodeUnreserved(str) {
	        var decStr = pctDecChars(str);
	        return !decStr.match(protocol.UNRESERVED) ? str : decStr;
	    }
	    if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, "");
	    if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
	    if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
	    if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
	    if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
	    if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
	    return components;
	}

	function _stripLeadingZeros(str) {
	    return str.replace(/^0*(.*)/, "$1") || "0";
	}
	function _normalizeIPv4(host, protocol) {
	    var matches = host.match(protocol.IPV4ADDRESS) || [];

	    var _matches = slicedToArray(matches, 2),
	        address = _matches[1];

	    if (address) {
	        return address.split(".").map(_stripLeadingZeros).join(".");
	    } else {
	        return host;
	    }
	}
	function _normalizeIPv6(host, protocol) {
	    var matches = host.match(protocol.IPV6ADDRESS) || [];

	    var _matches2 = slicedToArray(matches, 3),
	        address = _matches2[1],
	        zone = _matches2[2];

	    if (address) {
	        var _address$toLowerCase$ = address.toLowerCase().split('::').reverse(),
	            _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),
	            last = _address$toLowerCase$2[0],
	            first = _address$toLowerCase$2[1];

	        var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
	        var lastFields = last.split(":").map(_stripLeadingZeros);
	        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
	        var fieldCount = isLastFieldIPv4Address ? 7 : 8;
	        var lastFieldsStart = lastFields.length - fieldCount;
	        var fields = Array(fieldCount);
	        for (var x = 0; x < fieldCount; ++x) {
	            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';
	        }
	        if (isLastFieldIPv4Address) {
	            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
	        }
	        var allZeroFields = fields.reduce(function (acc, field, index) {
	            if (!field || field === "0") {
	                var lastLongest = acc[acc.length - 1];
	                if (lastLongest && lastLongest.index + lastLongest.length === index) {
	                    lastLongest.length++;
	                } else {
	                    acc.push({ index: index, length: 1 });
	                }
	            }
	            return acc;
	        }, []);
	        var longestZeroFields = allZeroFields.sort(function (a, b) {
	            return b.length - a.length;
	        })[0];
	        var newHost = void 0;
	        if (longestZeroFields && longestZeroFields.length > 1) {
	            var newFirst = fields.slice(0, longestZeroFields.index);
	            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
	            newHost = newFirst.join(":") + "::" + newLast.join(":");
	        } else {
	            newHost = fields.join(":");
	        }
	        if (zone) {
	            newHost += "%" + zone;
	        }
	        return newHost;
	    } else {
	        return host;
	    }
	}
	var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
	var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === undefined;
	function parse(uriString) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    var components = {};
	    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
	    if (options.reference === "suffix") uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
	    var matches = uriString.match(URI_PARSE);
	    if (matches) {
	        if (NO_MATCH_IS_UNDEFINED) {
	            //store each component
	            components.scheme = matches[1];
	            components.userinfo = matches[3];
	            components.host = matches[4];
	            components.port = parseInt(matches[5], 10);
	            components.path = matches[6] || "";
	            components.query = matches[7];
	            components.fragment = matches[8];
	            //fix port number
	            if (isNaN(components.port)) {
	                components.port = matches[5];
	            }
	        } else {
	            //IE FIX for improper RegExp matching
	            //store each component
	            components.scheme = matches[1] || undefined;
	            components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : undefined;
	            components.host = uriString.indexOf("//") !== -1 ? matches[4] : undefined;
	            components.port = parseInt(matches[5], 10);
	            components.path = matches[6] || "";
	            components.query = uriString.indexOf("?") !== -1 ? matches[7] : undefined;
	            components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : undefined;
	            //fix port number
	            if (isNaN(components.port)) {
	                components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : undefined;
	            }
	        }
	        if (components.host) {
	            //normalize IP hosts
	            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
	        }
	        //determine reference type
	        if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {
	            components.reference = "same-document";
	        } else if (components.scheme === undefined) {
	            components.reference = "relative";
	        } else if (components.fragment === undefined) {
	            components.reference = "absolute";
	        } else {
	            components.reference = "uri";
	        }
	        //check for reference errors
	        if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
	            components.error = components.error || "URI is not a " + options.reference + " reference.";
	        }
	        //find scheme handler
	        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
	        //check if scheme can't handle IRIs
	        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
	            //if host component is a domain name
	            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
	                //convert Unicode IDN -> ASCII IDN
	                try {
	                    components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
	                } catch (e) {
	                    components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
	                }
	            }
	            //convert IRI -> URI
	            _normalizeComponentEncoding(components, URI_PROTOCOL);
	        } else {
	            //normalize encodings
	            _normalizeComponentEncoding(components, protocol);
	        }
	        //perform scheme specific parsing
	        if (schemeHandler && schemeHandler.parse) {
	            schemeHandler.parse(components, options);
	        }
	    } else {
	        components.error = components.error || "URI can not be parsed.";
	    }
	    return components;
	}

	function _recomposeAuthority(components, options) {
	    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
	    var uriTokens = [];
	    if (components.userinfo !== undefined) {
	        uriTokens.push(components.userinfo);
	        uriTokens.push("@");
	    }
	    if (components.host !== undefined) {
	        //normalize IP hosts, add brackets and escape zone separator for IPv6
	        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {
	            return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
	        }));
	    }
	    if (typeof components.port === "number" || typeof components.port === "string") {
	        uriTokens.push(":");
	        uriTokens.push(String(components.port));
	    }
	    return uriTokens.length ? uriTokens.join("") : undefined;
	}

	var RDS1 = /^\.\.?\//;
	var RDS2 = /^\/\.(\/|$)/;
	var RDS3 = /^\/\.\.(\/|$)/;
	var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
	function removeDotSegments(input) {
	    var output = [];
	    while (input.length) {
	        if (input.match(RDS1)) {
	            input = input.replace(RDS1, "");
	        } else if (input.match(RDS2)) {
	            input = input.replace(RDS2, "/");
	        } else if (input.match(RDS3)) {
	            input = input.replace(RDS3, "/");
	            output.pop();
	        } else if (input === "." || input === "..") {
	            input = "";
	        } else {
	            var im = input.match(RDS5);
	            if (im) {
	                var s = im[0];
	                input = input.slice(s.length);
	                output.push(s);
	            } else {
	                throw new Error("Unexpected dot segment condition");
	            }
	        }
	    }
	    return output.join("");
	}

	function serialize(components) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
	    var uriTokens = [];
	    //find scheme handler
	    var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
	    //perform scheme specific serialization
	    if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
	    if (components.host) {
	        //if host component is an IPv6 address
	        if (protocol.IPV6ADDRESS.test(components.host)) ;
	        //TODO: normalize IPv6 address as per RFC 5952

	        //if host component is a domain name
	        else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
	                //convert IDN via punycode
	                try {
	                    components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
	                } catch (e) {
	                    components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
	                }
	            }
	    }
	    //normalize encoding
	    _normalizeComponentEncoding(components, protocol);
	    if (options.reference !== "suffix" && components.scheme) {
	        uriTokens.push(components.scheme);
	        uriTokens.push(":");
	    }
	    var authority = _recomposeAuthority(components, options);
	    if (authority !== undefined) {
	        if (options.reference !== "suffix") {
	            uriTokens.push("//");
	        }
	        uriTokens.push(authority);
	        if (components.path && components.path.charAt(0) !== "/") {
	            uriTokens.push("/");
	        }
	    }
	    if (components.path !== undefined) {
	        var s = components.path;
	        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
	            s = removeDotSegments(s);
	        }
	        if (authority === undefined) {
	            s = s.replace(/^\/\//, "/%2F"); //don't allow the path to start with "//"
	        }
	        uriTokens.push(s);
	    }
	    if (components.query !== undefined) {
	        uriTokens.push("?");
	        uriTokens.push(components.query);
	    }
	    if (components.fragment !== undefined) {
	        uriTokens.push("#");
	        uriTokens.push(components.fragment);
	    }
	    return uriTokens.join(""); //merge tokens into a string
	}

	function resolveComponents(base, relative) {
	    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	    var skipNormalization = arguments[3];

	    var target = {};
	    if (!skipNormalization) {
	        base = parse(serialize(base, options), options); //normalize base components
	        relative = parse(serialize(relative, options), options); //normalize relative components
	    }
	    options = options || {};
	    if (!options.tolerant && relative.scheme) {
	        target.scheme = relative.scheme;
	        //target.authority = relative.authority;
	        target.userinfo = relative.userinfo;
	        target.host = relative.host;
	        target.port = relative.port;
	        target.path = removeDotSegments(relative.path || "");
	        target.query = relative.query;
	    } else {
	        if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
	            //target.authority = relative.authority;
	            target.userinfo = relative.userinfo;
	            target.host = relative.host;
	            target.port = relative.port;
	            target.path = removeDotSegments(relative.path || "");
	            target.query = relative.query;
	        } else {
	            if (!relative.path) {
	                target.path = base.path;
	                if (relative.query !== undefined) {
	                    target.query = relative.query;
	                } else {
	                    target.query = base.query;
	                }
	            } else {
	                if (relative.path.charAt(0) === "/") {
	                    target.path = removeDotSegments(relative.path);
	                } else {
	                    if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {
	                        target.path = "/" + relative.path;
	                    } else if (!base.path) {
	                        target.path = relative.path;
	                    } else {
	                        target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
	                    }
	                    target.path = removeDotSegments(target.path);
	                }
	                target.query = relative.query;
	            }
	            //target.authority = base.authority;
	            target.userinfo = base.userinfo;
	            target.host = base.host;
	            target.port = base.port;
	        }
	        target.scheme = base.scheme;
	    }
	    target.fragment = relative.fragment;
	    return target;
	}

	function resolve(baseURI, relativeURI, options) {
	    var schemelessOptions = assign({ scheme: 'null' }, options);
	    return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
	}

	function normalize(uri, options) {
	    if (typeof uri === "string") {
	        uri = serialize(parse(uri, options), options);
	    } else if (typeOf(uri) === "object") {
	        uri = parse(serialize(uri, options), options);
	    }
	    return uri;
	}

	function equal(uriA, uriB, options) {
	    if (typeof uriA === "string") {
	        uriA = serialize(parse(uriA, options), options);
	    } else if (typeOf(uriA) === "object") {
	        uriA = serialize(uriA, options);
	    }
	    if (typeof uriB === "string") {
	        uriB = serialize(parse(uriB, options), options);
	    } else if (typeOf(uriB) === "object") {
	        uriB = serialize(uriB, options);
	    }
	    return uriA === uriB;
	}

	function escapeComponent(str, options) {
	    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
	}

	function unescapeComponent(str, options) {
	    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
	}

	var handler = {
	    scheme: "http",
	    domainHost: true,
	    parse: function parse(components, options) {
	        //report missing host
	        if (!components.host) {
	            components.error = components.error || "HTTP URIs must have a host.";
	        }
	        return components;
	    },
	    serialize: function serialize(components, options) {
	        var secure = String(components.scheme).toLowerCase() === "https";
	        //normalize the default port
	        if (components.port === (secure ? 443 : 80) || components.port === "") {
	            components.port = undefined;
	        }
	        //normalize the empty path
	        if (!components.path) {
	            components.path = "/";
	        }
	        //NOTE: We do not parse query strings for HTTP URIs
	        //as WWW Form Url Encoded query strings are part of the HTML4+ spec,
	        //and not the HTTP spec.
	        return components;
	    }
	};

	var handler$1 = {
	    scheme: "https",
	    domainHost: handler.domainHost,
	    parse: handler.parse,
	    serialize: handler.serialize
	};

	function isSecure(wsComponents) {
	    return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
	}
	//RFC 6455
	var handler$2 = {
	    scheme: "ws",
	    domainHost: true,
	    parse: function parse(components, options) {
	        var wsComponents = components;
	        //indicate if the secure flag is set
	        wsComponents.secure = isSecure(wsComponents);
	        //construct resouce name
	        wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');
	        wsComponents.path = undefined;
	        wsComponents.query = undefined;
	        return wsComponents;
	    },
	    serialize: function serialize(wsComponents, options) {
	        //normalize the default port
	        if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
	            wsComponents.port = undefined;
	        }
	        //ensure scheme matches secure flag
	        if (typeof wsComponents.secure === 'boolean') {
	            wsComponents.scheme = wsComponents.secure ? 'wss' : 'ws';
	            wsComponents.secure = undefined;
	        }
	        //reconstruct path from resource name
	        if (wsComponents.resourceName) {
	            var _wsComponents$resourc = wsComponents.resourceName.split('?'),
	                _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2),
	                path = _wsComponents$resourc2[0],
	                query = _wsComponents$resourc2[1];

	            wsComponents.path = path && path !== '/' ? path : undefined;
	            wsComponents.query = query;
	            wsComponents.resourceName = undefined;
	        }
	        //forbid fragment component
	        wsComponents.fragment = undefined;
	        return wsComponents;
	    }
	};

	var handler$3 = {
	    scheme: "wss",
	    domainHost: handler$2.domainHost,
	    parse: handler$2.parse,
	    serialize: handler$2.serialize
	};

	var O = {};
	//RFC 3986
	var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + ("\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" ) + "]";
	var HEXDIG$$ = "[0-9A-Fa-f]"; //case-insensitive
	var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)); //expanded
	//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =
	//const ATEXT$$ = "[A-Za-z0-9\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~]";
	//const WSP$$ = "[\\x20\\x09]";
	//const OBS_QTEXT$$ = "[\\x01-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]";  //(%d1-8 / %d11-12 / %d14-31 / %d127)
	//const QTEXT$$ = merge("[\\x21\\x23-\\x5B\\x5D-\\x7E]", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext
	//const VCHAR$$ = "[\\x21-\\x7E]";
	//const WSP$$ = "[\\x20\\x09]";
	//const OBS_QP$ = subexp("\\\\" + merge("[\\x00\\x0D\\x0A]", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext
	//const FWS$ = subexp(subexp(WSP$$ + "*" + "\\x0D\\x0A") + "?" + WSP$$ + "+");
	//const QUOTED_PAIR$ = subexp(subexp("\\\\" + subexp(VCHAR$$ + "|" + WSP$$)) + "|" + OBS_QP$);
	//const QUOTED_STRING$ = subexp('\\"' + subexp(FWS$ + "?" + QCONTENT$) + "*" + FWS$ + "?" + '\\"');
	var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
	var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
	var VCHAR$$ = merge(QTEXT$$, "[\\\"\\\\]");
	var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
	var UNRESERVED = new RegExp(UNRESERVED$$, "g");
	var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
	var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
	var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
	var NOT_HFVALUE = NOT_HFNAME;
	function decodeUnreserved(str) {
	    var decStr = pctDecChars(str);
	    return !decStr.match(UNRESERVED) ? str : decStr;
	}
	var handler$4 = {
	    scheme: "mailto",
	    parse: function parse$$1(components, options) {
	        var mailtoComponents = components;
	        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
	        mailtoComponents.path = undefined;
	        if (mailtoComponents.query) {
	            var unknownHeaders = false;
	            var headers = {};
	            var hfields = mailtoComponents.query.split("&");
	            for (var x = 0, xl = hfields.length; x < xl; ++x) {
	                var hfield = hfields[x].split("=");
	                switch (hfield[0]) {
	                    case "to":
	                        var toAddrs = hfield[1].split(",");
	                        for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
	                            to.push(toAddrs[_x]);
	                        }
	                        break;
	                    case "subject":
	                        mailtoComponents.subject = unescapeComponent(hfield[1], options);
	                        break;
	                    case "body":
	                        mailtoComponents.body = unescapeComponent(hfield[1], options);
	                        break;
	                    default:
	                        unknownHeaders = true;
	                        headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
	                        break;
	                }
	            }
	            if (unknownHeaders) mailtoComponents.headers = headers;
	        }
	        mailtoComponents.query = undefined;
	        for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
	            var addr = to[_x2].split("@");
	            addr[0] = unescapeComponent(addr[0]);
	            if (!options.unicodeSupport) {
	                //convert Unicode IDN -> ASCII IDN
	                try {
	                    addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
	                } catch (e) {
	                    mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
	                }
	            } else {
	                addr[1] = unescapeComponent(addr[1], options).toLowerCase();
	            }
	            to[_x2] = addr.join("@");
	        }
	        return mailtoComponents;
	    },
	    serialize: function serialize$$1(mailtoComponents, options) {
	        var components = mailtoComponents;
	        var to = toArray(mailtoComponents.to);
	        if (to) {
	            for (var x = 0, xl = to.length; x < xl; ++x) {
	                var toAddr = String(to[x]);
	                var atIdx = toAddr.lastIndexOf("@");
	                var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
	                var domain = toAddr.slice(atIdx + 1);
	                //convert IDN via punycode
	                try {
	                    domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
	                } catch (e) {
	                    components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
	                }
	                to[x] = localPart + "@" + domain;
	            }
	            components.path = to.join(",");
	        }
	        var headers = mailtoComponents.headers = mailtoComponents.headers || {};
	        if (mailtoComponents.subject) headers["subject"] = mailtoComponents.subject;
	        if (mailtoComponents.body) headers["body"] = mailtoComponents.body;
	        var fields = [];
	        for (var name in headers) {
	            if (headers[name] !== O[name]) {
	                fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
	            }
	        }
	        if (fields.length) {
	            components.query = fields.join("&");
	        }
	        return components;
	    }
	};

	var URN_PARSE = /^([^\:]+)\:(.*)/;
	//RFC 2141
	var handler$5 = {
	    scheme: "urn",
	    parse: function parse$$1(components, options) {
	        var matches = components.path && components.path.match(URN_PARSE);
	        var urnComponents = components;
	        if (matches) {
	            var scheme = options.scheme || urnComponents.scheme || "urn";
	            var nid = matches[1].toLowerCase();
	            var nss = matches[2];
	            var urnScheme = scheme + ":" + (options.nid || nid);
	            var schemeHandler = SCHEMES[urnScheme];
	            urnComponents.nid = nid;
	            urnComponents.nss = nss;
	            urnComponents.path = undefined;
	            if (schemeHandler) {
	                urnComponents = schemeHandler.parse(urnComponents, options);
	            }
	        } else {
	            urnComponents.error = urnComponents.error || "URN can not be parsed.";
	        }
	        return urnComponents;
	    },
	    serialize: function serialize$$1(urnComponents, options) {
	        var scheme = options.scheme || urnComponents.scheme || "urn";
	        var nid = urnComponents.nid;
	        var urnScheme = scheme + ":" + (options.nid || nid);
	        var schemeHandler = SCHEMES[urnScheme];
	        if (schemeHandler) {
	            urnComponents = schemeHandler.serialize(urnComponents, options);
	        }
	        var uriComponents = urnComponents;
	        var nss = urnComponents.nss;
	        uriComponents.path = (nid || options.nid) + ":" + nss;
	        return uriComponents;
	    }
	};

	var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
	//RFC 4122
	var handler$6 = {
	    scheme: "urn:uuid",
	    parse: function parse(urnComponents, options) {
	        var uuidComponents = urnComponents;
	        uuidComponents.uuid = uuidComponents.nss;
	        uuidComponents.nss = undefined;
	        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
	            uuidComponents.error = uuidComponents.error || "UUID is not valid.";
	        }
	        return uuidComponents;
	    },
	    serialize: function serialize(uuidComponents, options) {
	        var urnComponents = uuidComponents;
	        //normalize UUID
	        urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
	        return urnComponents;
	    }
	};

	SCHEMES[handler.scheme] = handler;
	SCHEMES[handler$1.scheme] = handler$1;
	SCHEMES[handler$2.scheme] = handler$2;
	SCHEMES[handler$3.scheme] = handler$3;
	SCHEMES[handler$4.scheme] = handler$4;
	SCHEMES[handler$5.scheme] = handler$5;
	SCHEMES[handler$6.scheme] = handler$6;

	exports.SCHEMES = SCHEMES;
	exports.pctEncChar = pctEncChar;
	exports.pctDecChars = pctDecChars;
	exports.parse = parse;
	exports.removeDotSegments = removeDotSegments;
	exports.serialize = serialize;
	exports.resolveComponents = resolveComponents;
	exports.resolve = resolve;
	exports.normalize = normalize;
	exports.equal = equal;
	exports.escapeComponent = escapeComponent;
	exports.unescapeComponent = unescapeComponent;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));
	
} (uri_all, uri_all.exports));

var uri_allExports = uri_all.exports;

Object.defineProperty(uri$1, "__esModule", { value: true });
const uri = uri_allExports;
uri.code = 'require("ajv/dist/runtime/uri").default';
uri$1.default = uri;

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
	var validate_1 = requireValidate();
	Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function () { return validate_1.KeywordCxt; } });
	var codegen_1 = requireCodegen();
	Object.defineProperty(exports, "_", { enumerable: true, get: function () { return codegen_1._; } });
	Object.defineProperty(exports, "str", { enumerable: true, get: function () { return codegen_1.str; } });
	Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return codegen_1.stringify; } });
	Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return codegen_1.nil; } });
	Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return codegen_1.Name; } });
	Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function () { return codegen_1.CodeGen; } });
	const validation_error_1 = requireValidation_error();
	const ref_error_1 = requireRef_error();
	const rules_1 = rules;
	const compile_1 = compile$1;
	const codegen_2 = requireCodegen();
	const resolve_1 = resolve$1;
	const dataType_1 = dataType;
	const util_1 = util$1;
	const $dataRefSchema = require$$9;
	const uri_1 = uri$1;
	const defaultRegExp = (str, flags) => new RegExp(str, flags);
	defaultRegExp.code = "new RegExp";
	const META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
	const EXT_SCOPE_NAMES = new Set([
	    "validate",
	    "serialize",
	    "parse",
	    "wrapper",
	    "root",
	    "schema",
	    "keyword",
	    "pattern",
	    "formats",
	    "validate$data",
	    "func",
	    "obj",
	    "Error",
	]);
	const removedOptions = {
	    errorDataPath: "",
	    format: "`validateFormats: false` can be used instead.",
	    nullable: '"nullable" keyword is supported by default.',
	    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
	    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
	    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
	    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
	    sourceCode: "Use option `code: {source: true}`",
	    strictDefaults: "It is default now, see option `strict`.",
	    strictKeywords: "It is default now, see option `strict`.",
	    uniqueItems: '"uniqueItems" keyword is always validated.',
	    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
	    cache: "Map is used as cache, schema object as key.",
	    serialize: "Map is used as cache, schema object as key.",
	    ajvErrors: "It is default now.",
	};
	const deprecatedOptions = {
	    ignoreKeywordsWithRef: "",
	    jsPropertySyntax: "",
	    unicode: '"minLength"/"maxLength" account for unicode characters by default.',
	};
	const MAX_EXPRESSION = 200;
	// eslint-disable-next-line complexity
	function requiredOptions(o) {
	    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
	    const s = o.strict;
	    const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
	    const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;
	    const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
	    const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
	    return {
	        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
	        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
	        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
	        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
	        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
	        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
	        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
	        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
	        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
	        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
	        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
	        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
	        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
	        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
	        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
	        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
	        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
	        uriResolver: uriResolver,
	    };
	}
	class Ajv {
	    constructor(opts = {}) {
	        this.schemas = {};
	        this.refs = {};
	        this.formats = {};
	        this._compilations = new Set();
	        this._loading = {};
	        this._cache = new Map();
	        opts = this.opts = { ...opts, ...requiredOptions(opts) };
	        const { es5, lines } = this.opts.code;
	        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
	        this.logger = getLogger(opts.logger);
	        const formatOpt = opts.validateFormats;
	        opts.validateFormats = false;
	        this.RULES = (0, rules_1.getRules)();
	        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
	        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
	        this._metaOpts = getMetaSchemaOptions.call(this);
	        if (opts.formats)
	            addInitialFormats.call(this);
	        this._addVocabularies();
	        this._addDefaultMetaSchema();
	        if (opts.keywords)
	            addInitialKeywords.call(this, opts.keywords);
	        if (typeof opts.meta == "object")
	            this.addMetaSchema(opts.meta);
	        addInitialSchemas.call(this);
	        opts.validateFormats = formatOpt;
	    }
	    _addVocabularies() {
	        this.addKeyword("$async");
	    }
	    _addDefaultMetaSchema() {
	        const { $data, meta, schemaId } = this.opts;
	        let _dataRefSchema = $dataRefSchema;
	        if (schemaId === "id") {
	            _dataRefSchema = { ...$dataRefSchema };
	            _dataRefSchema.id = _dataRefSchema.$id;
	            delete _dataRefSchema.$id;
	        }
	        if (meta && $data)
	            this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
	    }
	    defaultMeta() {
	        const { meta, schemaId } = this.opts;
	        return (this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : undefined);
	    }
	    validate(schemaKeyRef, // key, ref or schema object
	    data // to be validated
	    ) {
	        let v;
	        if (typeof schemaKeyRef == "string") {
	            v = this.getSchema(schemaKeyRef);
	            if (!v)
	                throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
	        }
	        else {
	            v = this.compile(schemaKeyRef);
	        }
	        const valid = v(data);
	        if (!("$async" in v))
	            this.errors = v.errors;
	        return valid;
	    }
	    compile(schema, _meta) {
	        const sch = this._addSchema(schema, _meta);
	        return (sch.validate || this._compileSchemaEnv(sch));
	    }
	    compileAsync(schema, meta) {
	        if (typeof this.opts.loadSchema != "function") {
	            throw new Error("options.loadSchema should be a function");
	        }
	        const { loadSchema } = this.opts;
	        return runCompileAsync.call(this, schema, meta);
	        async function runCompileAsync(_schema, _meta) {
	            await loadMetaSchema.call(this, _schema.$schema);
	            const sch = this._addSchema(_schema, _meta);
	            return sch.validate || _compileAsync.call(this, sch);
	        }
	        async function loadMetaSchema($ref) {
	            if ($ref && !this.getSchema($ref)) {
	                await runCompileAsync.call(this, { $ref }, true);
	            }
	        }
	        async function _compileAsync(sch) {
	            try {
	                return this._compileSchemaEnv(sch);
	            }
	            catch (e) {
	                if (!(e instanceof ref_error_1.default))
	                    throw e;
	                checkLoaded.call(this, e);
	                await loadMissingSchema.call(this, e.missingSchema);
	                return _compileAsync.call(this, sch);
	            }
	        }
	        function checkLoaded({ missingSchema: ref, missingRef }) {
	            if (this.refs[ref]) {
	                throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
	            }
	        }
	        async function loadMissingSchema(ref) {
	            const _schema = await _loadSchema.call(this, ref);
	            if (!this.refs[ref])
	                await loadMetaSchema.call(this, _schema.$schema);
	            if (!this.refs[ref])
	                this.addSchema(_schema, ref, meta);
	        }
	        async function _loadSchema(ref) {
	            const p = this._loading[ref];
	            if (p)
	                return p;
	            try {
	                return await (this._loading[ref] = loadSchema(ref));
	            }
	            finally {
	                delete this._loading[ref];
	            }
	        }
	    }
	    // Adds schema to the instance
	    addSchema(schema, // If array is passed, `key` will be ignored
	    key, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
	    _meta, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
	    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.
	    ) {
	        if (Array.isArray(schema)) {
	            for (const sch of schema)
	                this.addSchema(sch, undefined, _meta, _validateSchema);
	            return this;
	        }
	        let id;
	        if (typeof schema === "object") {
	            const { schemaId } = this.opts;
	            id = schema[schemaId];
	            if (id !== undefined && typeof id != "string") {
	                throw new Error(`schema ${schemaId} must be string`);
	            }
	        }
	        key = (0, resolve_1.normalizeId)(key || id);
	        this._checkUnique(key);
	        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
	        return this;
	    }
	    // Add schema that will be used to validate other schemas
	    // options in META_IGNORE_OPTIONS are alway set to false
	    addMetaSchema(schema, key, // schema key
	    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema
	    ) {
	        this.addSchema(schema, key, true, _validateSchema);
	        return this;
	    }
	    //  Validate schema against its meta-schema
	    validateSchema(schema, throwOrLogError) {
	        if (typeof schema == "boolean")
	            return true;
	        let $schema;
	        $schema = schema.$schema;
	        if ($schema !== undefined && typeof $schema != "string") {
	            throw new Error("$schema must be a string");
	        }
	        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
	        if (!$schema) {
	            this.logger.warn("meta-schema not available");
	            this.errors = null;
	            return true;
	        }
	        const valid = this.validate($schema, schema);
	        if (!valid && throwOrLogError) {
	            const message = "schema is invalid: " + this.errorsText();
	            if (this.opts.validateSchema === "log")
	                this.logger.error(message);
	            else
	                throw new Error(message);
	        }
	        return valid;
	    }
	    // Get compiled schema by `key` or `ref`.
	    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
	    getSchema(keyRef) {
	        let sch;
	        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
	            keyRef = sch;
	        if (sch === undefined) {
	            const { schemaId } = this.opts;
	            const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
	            sch = compile_1.resolveSchema.call(this, root, keyRef);
	            if (!sch)
	                return;
	            this.refs[keyRef] = sch;
	        }
	        return (sch.validate || this._compileSchemaEnv(sch));
	    }
	    // Remove cached schema(s).
	    // If no parameter is passed all schemas but meta-schemas are removed.
	    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
	    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
	    removeSchema(schemaKeyRef) {
	        if (schemaKeyRef instanceof RegExp) {
	            this._removeAllSchemas(this.schemas, schemaKeyRef);
	            this._removeAllSchemas(this.refs, schemaKeyRef);
	            return this;
	        }
	        switch (typeof schemaKeyRef) {
	            case "undefined":
	                this._removeAllSchemas(this.schemas);
	                this._removeAllSchemas(this.refs);
	                this._cache.clear();
	                return this;
	            case "string": {
	                const sch = getSchEnv.call(this, schemaKeyRef);
	                if (typeof sch == "object")
	                    this._cache.delete(sch.schema);
	                delete this.schemas[schemaKeyRef];
	                delete this.refs[schemaKeyRef];
	                return this;
	            }
	            case "object": {
	                const cacheKey = schemaKeyRef;
	                this._cache.delete(cacheKey);
	                let id = schemaKeyRef[this.opts.schemaId];
	                if (id) {
	                    id = (0, resolve_1.normalizeId)(id);
	                    delete this.schemas[id];
	                    delete this.refs[id];
	                }
	                return this;
	            }
	            default:
	                throw new Error("ajv.removeSchema: invalid parameter");
	        }
	    }
	    // add "vocabulary" - a collection of keywords
	    addVocabulary(definitions) {
	        for (const def of definitions)
	            this.addKeyword(def);
	        return this;
	    }
	    addKeyword(kwdOrDef, def // deprecated
	    ) {
	        let keyword;
	        if (typeof kwdOrDef == "string") {
	            keyword = kwdOrDef;
	            if (typeof def == "object") {
	                this.logger.warn("these parameters are deprecated, see docs for addKeyword");
	                def.keyword = keyword;
	            }
	        }
	        else if (typeof kwdOrDef == "object" && def === undefined) {
	            def = kwdOrDef;
	            keyword = def.keyword;
	            if (Array.isArray(keyword) && !keyword.length) {
	                throw new Error("addKeywords: keyword must be string or non-empty array");
	            }
	        }
	        else {
	            throw new Error("invalid addKeywords parameters");
	        }
	        checkKeyword.call(this, keyword, def);
	        if (!def) {
	            (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
	            return this;
	        }
	        keywordMetaschema.call(this, def);
	        const definition = {
	            ...def,
	            type: (0, dataType_1.getJSONTypes)(def.type),
	            schemaType: (0, dataType_1.getJSONTypes)(def.schemaType),
	        };
	        (0, util_1.eachItem)(keyword, definition.type.length === 0
	            ? (k) => addRule.call(this, k, definition)
	            : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
	        return this;
	    }
	    getKeyword(keyword) {
	        const rule = this.RULES.all[keyword];
	        return typeof rule == "object" ? rule.definition : !!rule;
	    }
	    // Remove keyword
	    removeKeyword(keyword) {
	        // TODO return type should be Ajv
	        const { RULES } = this;
	        delete RULES.keywords[keyword];
	        delete RULES.all[keyword];
	        for (const group of RULES.rules) {
	            const i = group.rules.findIndex((rule) => rule.keyword === keyword);
	            if (i >= 0)
	                group.rules.splice(i, 1);
	        }
	        return this;
	    }
	    // Add format
	    addFormat(name, format) {
	        if (typeof format == "string")
	            format = new RegExp(format);
	        this.formats[name] = format;
	        return this;
	    }
	    errorsText(errors = this.errors, // optional array of validation errors
	    { separator = ", ", dataVar = "data" } = {} // optional options with properties `separator` and `dataVar`
	    ) {
	        if (!errors || errors.length === 0)
	            return "No errors";
	        return errors
	            .map((e) => `${dataVar}${e.instancePath} ${e.message}`)
	            .reduce((text, msg) => text + separator + msg);
	    }
	    $dataMetaSchema(metaSchema, keywordsJsonPointers) {
	        const rules = this.RULES.all;
	        metaSchema = JSON.parse(JSON.stringify(metaSchema));
	        for (const jsonPointer of keywordsJsonPointers) {
	            const segments = jsonPointer.split("/").slice(1); // first segment is an empty string
	            let keywords = metaSchema;
	            for (const seg of segments)
	                keywords = keywords[seg];
	            for (const key in rules) {
	                const rule = rules[key];
	                if (typeof rule != "object")
	                    continue;
	                const { $data } = rule.definition;
	                const schema = keywords[key];
	                if ($data && schema)
	                    keywords[key] = schemaOrData(schema);
	            }
	        }
	        return metaSchema;
	    }
	    _removeAllSchemas(schemas, regex) {
	        for (const keyRef in schemas) {
	            const sch = schemas[keyRef];
	            if (!regex || regex.test(keyRef)) {
	                if (typeof sch == "string") {
	                    delete schemas[keyRef];
	                }
	                else if (sch && !sch.meta) {
	                    this._cache.delete(sch.schema);
	                    delete schemas[keyRef];
	                }
	            }
	        }
	    }
	    _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
	        let id;
	        const { schemaId } = this.opts;
	        if (typeof schema == "object") {
	            id = schema[schemaId];
	        }
	        else {
	            if (this.opts.jtd)
	                throw new Error("schema must be object");
	            else if (typeof schema != "boolean")
	                throw new Error("schema must be object or boolean");
	        }
	        let sch = this._cache.get(schema);
	        if (sch !== undefined)
	            return sch;
	        baseId = (0, resolve_1.normalizeId)(id || baseId);
	        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
	        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
	        this._cache.set(sch.schema, sch);
	        if (addSchema && !baseId.startsWith("#")) {
	            // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)
	            if (baseId)
	                this._checkUnique(baseId);
	            this.refs[baseId] = sch;
	        }
	        if (validateSchema)
	            this.validateSchema(schema, true);
	        return sch;
	    }
	    _checkUnique(id) {
	        if (this.schemas[id] || this.refs[id]) {
	            throw new Error(`schema with key or id "${id}" already exists`);
	        }
	    }
	    _compileSchemaEnv(sch) {
	        if (sch.meta)
	            this._compileMetaSchema(sch);
	        else
	            compile_1.compileSchema.call(this, sch);
	        /* istanbul ignore if */
	        if (!sch.validate)
	            throw new Error("ajv implementation error");
	        return sch.validate;
	    }
	    _compileMetaSchema(sch) {
	        const currentOpts = this.opts;
	        this.opts = this._metaOpts;
	        try {
	            compile_1.compileSchema.call(this, sch);
	        }
	        finally {
	            this.opts = currentOpts;
	        }
	    }
	}
	exports.default = Ajv;
	Ajv.ValidationError = validation_error_1.default;
	Ajv.MissingRefError = ref_error_1.default;
	function checkOptions(checkOpts, options, msg, log = "error") {
	    for (const key in checkOpts) {
	        const opt = key;
	        if (opt in options)
	            this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
	    }
	}
	function getSchEnv(keyRef) {
	    keyRef = (0, resolve_1.normalizeId)(keyRef); // TODO tests fail without this line
	    return this.schemas[keyRef] || this.refs[keyRef];
	}
	function addInitialSchemas() {
	    const optsSchemas = this.opts.schemas;
	    if (!optsSchemas)
	        return;
	    if (Array.isArray(optsSchemas))
	        this.addSchema(optsSchemas);
	    else
	        for (const key in optsSchemas)
	            this.addSchema(optsSchemas[key], key);
	}
	function addInitialFormats() {
	    for (const name in this.opts.formats) {
	        const format = this.opts.formats[name];
	        if (format)
	            this.addFormat(name, format);
	    }
	}
	function addInitialKeywords(defs) {
	    if (Array.isArray(defs)) {
	        this.addVocabulary(defs);
	        return;
	    }
	    this.logger.warn("keywords option as map is deprecated, pass array");
	    for (const keyword in defs) {
	        const def = defs[keyword];
	        if (!def.keyword)
	            def.keyword = keyword;
	        this.addKeyword(def);
	    }
	}
	function getMetaSchemaOptions() {
	    const metaOpts = { ...this.opts };
	    for (const opt of META_IGNORE_OPTIONS)
	        delete metaOpts[opt];
	    return metaOpts;
	}
	const noLogs = { log() { }, warn() { }, error() { } };
	function getLogger(logger) {
	    if (logger === false)
	        return noLogs;
	    if (logger === undefined)
	        return console;
	    if (logger.log && logger.warn && logger.error)
	        return logger;
	    throw new Error("logger must implement log, warn and error methods");
	}
	const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
	function checkKeyword(keyword, def) {
	    const { RULES } = this;
	    (0, util_1.eachItem)(keyword, (kwd) => {
	        if (RULES.keywords[kwd])
	            throw new Error(`Keyword ${kwd} is already defined`);
	        if (!KEYWORD_NAME.test(kwd))
	            throw new Error(`Keyword ${kwd} has invalid name`);
	    });
	    if (!def)
	        return;
	    if (def.$data && !("code" in def || "validate" in def)) {
	        throw new Error('$data keyword must have "code" or "validate" function');
	    }
	}
	function addRule(keyword, definition, dataType) {
	    var _a;
	    const post = definition === null || definition === void 0 ? void 0 : definition.post;
	    if (dataType && post)
	        throw new Error('keyword with "post" flag cannot have "type"');
	    const { RULES } = this;
	    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
	    if (!ruleGroup) {
	        ruleGroup = { type: dataType, rules: [] };
	        RULES.rules.push(ruleGroup);
	    }
	    RULES.keywords[keyword] = true;
	    if (!definition)
	        return;
	    const rule = {
	        keyword,
	        definition: {
	            ...definition,
	            type: (0, dataType_1.getJSONTypes)(definition.type),
	            schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType),
	        },
	    };
	    if (definition.before)
	        addBeforeRule.call(this, ruleGroup, rule, definition.before);
	    else
	        ruleGroup.rules.push(rule);
	    RULES.all[keyword] = rule;
	    (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
	}
	function addBeforeRule(ruleGroup, rule, before) {
	    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
	    if (i >= 0) {
	        ruleGroup.rules.splice(i, 0, rule);
	    }
	    else {
	        ruleGroup.rules.push(rule);
	        this.logger.warn(`rule ${before} is not defined`);
	    }
	}
	function keywordMetaschema(def) {
	    let { metaSchema } = def;
	    if (metaSchema === undefined)
	        return;
	    if (def.$data && this.opts.$data)
	        metaSchema = schemaOrData(metaSchema);
	    def.validateSchema = this.compile(metaSchema, true);
	}
	const $dataRef = {
	    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
	};
	function schemaOrData(schema) {
	    return { anyOf: [schema, $dataRef] };
	}
	
} (core$2));

var draft7 = {};

var core$1 = {};

var id = {};

Object.defineProperty(id, "__esModule", { value: true });
const def$s = {
    keyword: "id",
    code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
    },
};
id.default = def$s;

var ref = {};

Object.defineProperty(ref, "__esModule", { value: true });
ref.callRef = ref.getValidate = void 0;
const ref_error_1 = requireRef_error();
const code_1$8 = requireCode();
const codegen_1$l = requireCodegen();
const names_1$1 = requireNames();
const compile_1$1 = compile$1;
const util_1$j = util$1;
const def$r = {
    keyword: "$ref",
    schemaType: "string",
    code(cxt) {
        const { gen, schema: $ref, it } = cxt;
        const { baseId, schemaEnv: env, validateName, opts, self } = it;
        const { root } = env;
        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
            return callRootRef();
        const schOrEnv = compile_1$1.resolveRef.call(self, root, baseId, $ref);
        if (schOrEnv === undefined)
            throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
        if (schOrEnv instanceof compile_1$1.SchemaEnv)
            return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
            if (env === root)
                return callRef(cxt, validateName, env, env.$async);
            const rootName = gen.scopeValue("root", { ref: root });
            return callRef(cxt, (0, codegen_1$l._) `${rootName}.validate`, root, root.$async);
        }
        function callValidate(sch) {
            const v = getValidate(cxt, sch);
            callRef(cxt, v, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
            const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1$l.stringify)(sch) } : { ref: sch });
            const valid = gen.name("valid");
            const schCxt = cxt.subschema({
                schema: sch,
                dataTypes: [],
                schemaPath: codegen_1$l.nil,
                topSchemaRef: schName,
                errSchemaPath: $ref,
            }, valid);
            cxt.mergeEvaluated(schCxt);
            cxt.ok(valid);
        }
    },
};
function getValidate(cxt, sch) {
    const { gen } = cxt;
    return sch.validate
        ? gen.scopeValue("validate", { ref: sch.validate })
        : (0, codegen_1$l._) `${gen.scopeValue("wrapper", { ref: sch })}.validate`;
}
ref.getValidate = getValidate;
function callRef(cxt, v, sch, $async) {
    const { gen, it } = cxt;
    const { allErrors, schemaEnv: env, opts } = it;
    const passCxt = opts.passContext ? names_1$1.default.this : codegen_1$l.nil;
    if ($async)
        callAsyncRef();
    else
        callSyncRef();
    function callAsyncRef() {
        if (!env.$async)
            throw new Error("async schema referenced by sync schema");
        const valid = gen.let("valid");
        gen.try(() => {
            gen.code((0, codegen_1$l._) `await ${(0, code_1$8.callValidateCode)(cxt, v, passCxt)}`);
            addEvaluatedFrom(v); // TODO will not work with async, it has to be returned with the result
            if (!allErrors)
                gen.assign(valid, true);
        }, (e) => {
            gen.if((0, codegen_1$l._) `!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
            addErrorsFrom(e);
            if (!allErrors)
                gen.assign(valid, false);
        });
        cxt.ok(valid);
    }
    function callSyncRef() {
        cxt.result((0, code_1$8.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
    }
    function addErrorsFrom(source) {
        const errs = (0, codegen_1$l._) `${source}.errors`;
        gen.assign(names_1$1.default.vErrors, (0, codegen_1$l._) `${names_1$1.default.vErrors} === null ? ${errs} : ${names_1$1.default.vErrors}.concat(${errs})`); // TODO tagged
        gen.assign(names_1$1.default.errors, (0, codegen_1$l._) `${names_1$1.default.vErrors}.length`);
    }
    function addEvaluatedFrom(source) {
        var _a;
        if (!it.opts.unevaluated)
            return;
        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
        // TODO refactor
        if (it.props !== true) {
            if (schEvaluated && !schEvaluated.dynamicProps) {
                if (schEvaluated.props !== undefined) {
                    it.props = util_1$j.mergeEvaluated.props(gen, schEvaluated.props, it.props);
                }
            }
            else {
                const props = gen.var("props", (0, codegen_1$l._) `${source}.evaluated.props`);
                it.props = util_1$j.mergeEvaluated.props(gen, props, it.props, codegen_1$l.Name);
            }
        }
        if (it.items !== true) {
            if (schEvaluated && !schEvaluated.dynamicItems) {
                if (schEvaluated.items !== undefined) {
                    it.items = util_1$j.mergeEvaluated.items(gen, schEvaluated.items, it.items);
                }
            }
            else {
                const items = gen.var("items", (0, codegen_1$l._) `${source}.evaluated.items`);
                it.items = util_1$j.mergeEvaluated.items(gen, items, it.items, codegen_1$l.Name);
            }
        }
    }
}
ref.callRef = callRef;
ref.default = def$r;

Object.defineProperty(core$1, "__esModule", { value: true });
const id_1 = id;
const ref_1 = ref;
const core = [
    "$schema",
    "$id",
    "$defs",
    "$vocabulary",
    { keyword: "$comment" },
    "definitions",
    id_1.default,
    ref_1.default,
];
core$1.default = core;

var validation$1 = {};

var limitNumber = {};

Object.defineProperty(limitNumber, "__esModule", { value: true });
const codegen_1$k = requireCodegen();
const ops = codegen_1$k.operators;
const KWDs = {
    maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
    minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
    exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
    exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE },
};
const error$k = {
    message: ({ keyword, schemaCode }) => (0, codegen_1$k.str) `must be ${KWDs[keyword].okStr} ${schemaCode}`,
    params: ({ keyword, schemaCode }) => (0, codegen_1$k._) `{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`,
};
const def$q = {
    keyword: Object.keys(KWDs),
    type: "number",
    schemaType: "number",
    $data: true,
    error: error$k,
    code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        cxt.fail$data((0, codegen_1$k._) `${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
    },
};
limitNumber.default = def$q;

var multipleOf = {};

Object.defineProperty(multipleOf, "__esModule", { value: true });
const codegen_1$j = requireCodegen();
const error$j = {
    message: ({ schemaCode }) => (0, codegen_1$j.str) `must be multiple of ${schemaCode}`,
    params: ({ schemaCode }) => (0, codegen_1$j._) `{multipleOf: ${schemaCode}}`,
};
const def$p = {
    keyword: "multipleOf",
    type: "number",
    schemaType: "number",
    $data: true,
    error: error$j,
    code(cxt) {
        const { gen, data, schemaCode, it } = cxt;
        // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)
        const prec = it.opts.multipleOfPrecision;
        const res = gen.let("res");
        const invalid = prec
            ? (0, codegen_1$j._) `Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`
            : (0, codegen_1$j._) `${res} !== parseInt(${res})`;
        cxt.fail$data((0, codegen_1$j._) `(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
    },
};
multipleOf.default = def$p;

var limitLength = {};

var ucs2length$1 = {};

Object.defineProperty(ucs2length$1, "__esModule", { value: true });
// https://mathiasbynens.be/notes/javascript-encoding
// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode
function ucs2length(str) {
    const len = str.length;
    let length = 0;
    let pos = 0;
    let value;
    while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 0xd800 && value <= 0xdbff && pos < len) {
            // high surrogate, and there is a next character
            value = str.charCodeAt(pos);
            if ((value & 0xfc00) === 0xdc00)
                pos++; // low surrogate
        }
    }
    return length;
}
ucs2length$1.default = ucs2length;
ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';

Object.defineProperty(limitLength, "__esModule", { value: true });
const codegen_1$i = requireCodegen();
const util_1$i = util$1;
const ucs2length_1 = ucs2length$1;
const error$i = {
    message({ keyword, schemaCode }) {
        const comp = keyword === "maxLength" ? "more" : "fewer";
        return (0, codegen_1$i.str) `must NOT have ${comp} than ${schemaCode} characters`;
    },
    params: ({ schemaCode }) => (0, codegen_1$i._) `{limit: ${schemaCode}}`,
};
const def$o = {
    keyword: ["maxLength", "minLength"],
    type: "string",
    schemaType: "number",
    $data: true,
    error: error$i,
    code(cxt) {
        const { keyword, data, schemaCode, it } = cxt;
        const op = keyword === "maxLength" ? codegen_1$i.operators.GT : codegen_1$i.operators.LT;
        const len = it.opts.unicode === false ? (0, codegen_1$i._) `${data}.length` : (0, codegen_1$i._) `${(0, util_1$i.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
        cxt.fail$data((0, codegen_1$i._) `${len} ${op} ${schemaCode}`);
    },
};
limitLength.default = def$o;

var pattern = {};

Object.defineProperty(pattern, "__esModule", { value: true });
const code_1$7 = requireCode();
const codegen_1$h = requireCodegen();
const error$h = {
    message: ({ schemaCode }) => (0, codegen_1$h.str) `must match pattern "${schemaCode}"`,
    params: ({ schemaCode }) => (0, codegen_1$h._) `{pattern: ${schemaCode}}`,
};
const def$n = {
    keyword: "pattern",
    type: "string",
    schemaType: "string",
    $data: true,
    error: error$h,
    code(cxt) {
        const { data, $data, schema, schemaCode, it } = cxt;
        // TODO regexp should be wrapped in try/catchs
        const u = it.opts.unicodeRegExp ? "u" : "";
        const regExp = $data ? (0, codegen_1$h._) `(new RegExp(${schemaCode}, ${u}))` : (0, code_1$7.usePattern)(cxt, schema);
        cxt.fail$data((0, codegen_1$h._) `!${regExp}.test(${data})`);
    },
};
pattern.default = def$n;

var limitProperties = {};

Object.defineProperty(limitProperties, "__esModule", { value: true });
const codegen_1$g = requireCodegen();
const error$g = {
    message({ keyword, schemaCode }) {
        const comp = keyword === "maxProperties" ? "more" : "fewer";
        return (0, codegen_1$g.str) `must NOT have ${comp} than ${schemaCode} properties`;
    },
    params: ({ schemaCode }) => (0, codegen_1$g._) `{limit: ${schemaCode}}`,
};
const def$m = {
    keyword: ["maxProperties", "minProperties"],
    type: "object",
    schemaType: "number",
    $data: true,
    error: error$g,
    code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxProperties" ? codegen_1$g.operators.GT : codegen_1$g.operators.LT;
        cxt.fail$data((0, codegen_1$g._) `Object.keys(${data}).length ${op} ${schemaCode}`);
    },
};
limitProperties.default = def$m;

var required = {};

Object.defineProperty(required, "__esModule", { value: true });
const code_1$6 = requireCode();
const codegen_1$f = requireCodegen();
const util_1$h = util$1;
const error$f = {
    message: ({ params: { missingProperty } }) => (0, codegen_1$f.str) `must have required property '${missingProperty}'`,
    params: ({ params: { missingProperty } }) => (0, codegen_1$f._) `{missingProperty: ${missingProperty}}`,
};
const def$l = {
    keyword: "required",
    type: "object",
    schemaType: "array",
    $data: true,
    error: error$f,
    code(cxt) {
        const { gen, schema, schemaCode, data, $data, it } = cxt;
        const { opts } = it;
        if (!$data && schema.length === 0)
            return;
        const useLoop = schema.length >= opts.loopRequired;
        if (it.allErrors)
            allErrorsMode();
        else
            exitOnErrorMode();
        if (opts.strictRequired) {
            const props = cxt.parentSchema.properties;
            const { definedProperties } = cxt.it;
            for (const requiredKey of schema) {
                if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === undefined && !definedProperties.has(requiredKey)) {
                    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
                    const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
                    (0, util_1$h.checkStrictMode)(it, msg, it.opts.strictRequired);
                }
            }
        }
        function allErrorsMode() {
            if (useLoop || $data) {
                cxt.block$data(codegen_1$f.nil, loopAllRequired);
            }
            else {
                for (const prop of schema) {
                    (0, code_1$6.checkReportMissingProp)(cxt, prop);
                }
            }
        }
        function exitOnErrorMode() {
            const missing = gen.let("missing");
            if (useLoop || $data) {
                const valid = gen.let("valid", true);
                cxt.block$data(valid, () => loopUntilMissing(missing, valid));
                cxt.ok(valid);
            }
            else {
                gen.if((0, code_1$6.checkMissingProp)(cxt, schema, missing));
                (0, code_1$6.reportMissingProp)(cxt, missing);
                gen.else();
            }
        }
        function loopAllRequired() {
            gen.forOf("prop", schemaCode, (prop) => {
                cxt.setParams({ missingProperty: prop });
                gen.if((0, code_1$6.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
            });
        }
        function loopUntilMissing(missing, valid) {
            cxt.setParams({ missingProperty: missing });
            gen.forOf(missing, schemaCode, () => {
                gen.assign(valid, (0, code_1$6.propertyInData)(gen, data, missing, opts.ownProperties));
                gen.if((0, codegen_1$f.not)(valid), () => {
                    cxt.error();
                    gen.break();
                });
            }, codegen_1$f.nil);
        }
    },
};
required.default = def$l;

var limitItems = {};

Object.defineProperty(limitItems, "__esModule", { value: true });
const codegen_1$e = requireCodegen();
const error$e = {
    message({ keyword, schemaCode }) {
        const comp = keyword === "maxItems" ? "more" : "fewer";
        return (0, codegen_1$e.str) `must NOT have ${comp} than ${schemaCode} items`;
    },
    params: ({ schemaCode }) => (0, codegen_1$e._) `{limit: ${schemaCode}}`,
};
const def$k = {
    keyword: ["maxItems", "minItems"],
    type: "array",
    schemaType: "number",
    $data: true,
    error: error$e,
    code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxItems" ? codegen_1$e.operators.GT : codegen_1$e.operators.LT;
        cxt.fail$data((0, codegen_1$e._) `${data}.length ${op} ${schemaCode}`);
    },
};
limitItems.default = def$k;

var uniqueItems = {};

var equal$1 = {};

Object.defineProperty(equal$1, "__esModule", { value: true });
// https://github.com/ajv-validator/ajv/issues/889
const equal = fastDeepEqual;
equal.code = 'require("ajv/dist/runtime/equal").default';
equal$1.default = equal;

Object.defineProperty(uniqueItems, "__esModule", { value: true });
const dataType_1 = dataType;
const codegen_1$d = requireCodegen();
const util_1$g = util$1;
const equal_1$2 = equal$1;
const error$d = {
    message: ({ params: { i, j } }) => (0, codegen_1$d.str) `must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
    params: ({ params: { i, j } }) => (0, codegen_1$d._) `{i: ${i}, j: ${j}}`,
};
const def$j = {
    keyword: "uniqueItems",
    type: "array",
    schemaType: "boolean",
    $data: true,
    error: error$d,
    code(cxt) {
        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
        if (!$data && !schema)
            return;
        const valid = gen.let("valid");
        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, (0, codegen_1$d._) `${schemaCode} === false`);
        cxt.ok(valid);
        function validateUniqueItems() {
            const i = gen.let("i", (0, codegen_1$d._) `${data}.length`);
            const j = gen.let("j");
            cxt.setParams({ i, j });
            gen.assign(valid, true);
            gen.if((0, codegen_1$d._) `${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
        }
        function canOptimize() {
            return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
        }
        function loopN(i, j) {
            const item = gen.name("item");
            const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
            const indices = gen.const("indices", (0, codegen_1$d._) `{}`);
            gen.for((0, codegen_1$d._) `;${i}--;`, () => {
                gen.let(item, (0, codegen_1$d._) `${data}[${i}]`);
                gen.if(wrongType, (0, codegen_1$d._) `continue`);
                if (itemTypes.length > 1)
                    gen.if((0, codegen_1$d._) `typeof ${item} == "string"`, (0, codegen_1$d._) `${item} += "_"`);
                gen
                    .if((0, codegen_1$d._) `typeof ${indices}[${item}] == "number"`, () => {
                    gen.assign(j, (0, codegen_1$d._) `${indices}[${item}]`);
                    cxt.error();
                    gen.assign(valid, false).break();
                })
                    .code((0, codegen_1$d._) `${indices}[${item}] = ${i}`);
            });
        }
        function loopN2(i, j) {
            const eql = (0, util_1$g.useFunc)(gen, equal_1$2.default);
            const outer = gen.name("outer");
            gen.label(outer).for((0, codegen_1$d._) `;${i}--;`, () => gen.for((0, codegen_1$d._) `${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1$d._) `${eql}(${data}[${i}], ${data}[${j}])`, () => {
                cxt.error();
                gen.assign(valid, false).break(outer);
            })));
        }
    },
};
uniqueItems.default = def$j;

var _const = {};

Object.defineProperty(_const, "__esModule", { value: true });
const codegen_1$c = requireCodegen();
const util_1$f = util$1;
const equal_1$1 = equal$1;
const error$c = {
    message: "must be equal to constant",
    params: ({ schemaCode }) => (0, codegen_1$c._) `{allowedValue: ${schemaCode}}`,
};
const def$i = {
    keyword: "const",
    $data: true,
    error: error$c,
    code(cxt) {
        const { gen, data, $data, schemaCode, schema } = cxt;
        if ($data || (schema && typeof schema == "object")) {
            cxt.fail$data((0, codegen_1$c._) `!${(0, util_1$f.useFunc)(gen, equal_1$1.default)}(${data}, ${schemaCode})`);
        }
        else {
            cxt.fail((0, codegen_1$c._) `${schema} !== ${data}`);
        }
    },
};
_const.default = def$i;

var _enum = {};

Object.defineProperty(_enum, "__esModule", { value: true });
const codegen_1$b = requireCodegen();
const util_1$e = util$1;
const equal_1 = equal$1;
const error$b = {
    message: "must be equal to one of the allowed values",
    params: ({ schemaCode }) => (0, codegen_1$b._) `{allowedValues: ${schemaCode}}`,
};
const def$h = {
    keyword: "enum",
    schemaType: "array",
    $data: true,
    error: error$b,
    code(cxt) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        if (!$data && schema.length === 0)
            throw new Error("enum must have non-empty array");
        const useLoop = schema.length >= it.opts.loopEnum;
        let eql;
        const getEql = () => (eql !== null && eql !== void 0 ? eql : (eql = (0, util_1$e.useFunc)(gen, equal_1.default)));
        let valid;
        if (useLoop || $data) {
            valid = gen.let("valid");
            cxt.block$data(valid, loopEnum);
        }
        else {
            /* istanbul ignore if */
            if (!Array.isArray(schema))
                throw new Error("ajv implementation error");
            const vSchema = gen.const("vSchema", schemaCode);
            valid = (0, codegen_1$b.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
        }
        cxt.pass(valid);
        function loopEnum() {
            gen.assign(valid, false);
            gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1$b._) `${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
        }
        function equalCode(vSchema, i) {
            const sch = schema[i];
            return typeof sch === "object" && sch !== null
                ? (0, codegen_1$b._) `${getEql()}(${data}, ${vSchema}[${i}])`
                : (0, codegen_1$b._) `${data} === ${sch}`;
        }
    },
};
_enum.default = def$h;

Object.defineProperty(validation$1, "__esModule", { value: true });
const limitNumber_1 = limitNumber;
const multipleOf_1 = multipleOf;
const limitLength_1 = limitLength;
const pattern_1 = pattern;
const limitProperties_1 = limitProperties;
const required_1 = required;
const limitItems_1 = limitItems;
const uniqueItems_1 = uniqueItems;
const const_1 = _const;
const enum_1 = _enum;
const validation = [
    // number
    limitNumber_1.default,
    multipleOf_1.default,
    // string
    limitLength_1.default,
    pattern_1.default,
    // object
    limitProperties_1.default,
    required_1.default,
    // array
    limitItems_1.default,
    uniqueItems_1.default,
    // any
    { keyword: "type", schemaType: ["string", "array"] },
    { keyword: "nullable", schemaType: "boolean" },
    const_1.default,
    enum_1.default,
];
validation$1.default = validation;

var applicator = {};

var additionalItems = {};

Object.defineProperty(additionalItems, "__esModule", { value: true });
additionalItems.validateAdditionalItems = void 0;
const codegen_1$a = requireCodegen();
const util_1$d = util$1;
const error$a = {
    message: ({ params: { len } }) => (0, codegen_1$a.str) `must NOT have more than ${len} items`,
    params: ({ params: { len } }) => (0, codegen_1$a._) `{limit: ${len}}`,
};
const def$g = {
    keyword: "additionalItems",
    type: "array",
    schemaType: ["boolean", "object"],
    before: "uniqueItems",
    error: error$a,
    code(cxt) {
        const { parentSchema, it } = cxt;
        const { items } = parentSchema;
        if (!Array.isArray(items)) {
            (0, util_1$d.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
            return;
        }
        validateAdditionalItems(cxt, items);
    },
};
function validateAdditionalItems(cxt, items) {
    const { gen, schema, data, keyword, it } = cxt;
    it.items = true;
    const len = gen.const("len", (0, codegen_1$a._) `${data}.length`);
    if (schema === false) {
        cxt.setParams({ len: items.length });
        cxt.pass((0, codegen_1$a._) `${len} <= ${items.length}`);
    }
    else if (typeof schema == "object" && !(0, util_1$d.alwaysValidSchema)(it, schema)) {
        const valid = gen.var("valid", (0, codegen_1$a._) `${len} <= ${items.length}`); // TODO var
        gen.if((0, codegen_1$a.not)(valid), () => validateItems(valid));
        cxt.ok(valid);
    }
    function validateItems(valid) {
        gen.forRange("i", items.length, len, (i) => {
            cxt.subschema({ keyword, dataProp: i, dataPropType: util_1$d.Type.Num }, valid);
            if (!it.allErrors)
                gen.if((0, codegen_1$a.not)(valid), () => gen.break());
        });
    }
}
additionalItems.validateAdditionalItems = validateAdditionalItems;
additionalItems.default = def$g;

var prefixItems = {};

var items = {};

Object.defineProperty(items, "__esModule", { value: true });
items.validateTuple = void 0;
const codegen_1$9 = requireCodegen();
const util_1$c = util$1;
const code_1$5 = requireCode();
const def$f = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "array", "boolean"],
    before: "uniqueItems",
    code(cxt) {
        const { schema, it } = cxt;
        if (Array.isArray(schema))
            return validateTuple(cxt, "additionalItems", schema);
        it.items = true;
        if ((0, util_1$c.alwaysValidSchema)(it, schema))
            return;
        cxt.ok((0, code_1$5.validateArray)(cxt));
    },
};
function validateTuple(cxt, extraItems, schArr = cxt.schema) {
    const { gen, parentSchema, data, keyword, it } = cxt;
    checkStrictTuple(parentSchema);
    if (it.opts.unevaluated && schArr.length && it.items !== true) {
        it.items = util_1$c.mergeEvaluated.items(gen, schArr.length, it.items);
    }
    const valid = gen.name("valid");
    const len = gen.const("len", (0, codegen_1$9._) `${data}.length`);
    schArr.forEach((sch, i) => {
        if ((0, util_1$c.alwaysValidSchema)(it, sch))
            return;
        gen.if((0, codegen_1$9._) `${len} > ${i}`, () => cxt.subschema({
            keyword,
            schemaProp: i,
            dataProp: i,
        }, valid));
        cxt.ok(valid);
    });
    function checkStrictTuple(sch) {
        const { opts, errSchemaPath } = it;
        const l = schArr.length;
        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
        if (opts.strictTuples && !fullTuple) {
            const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
            (0, util_1$c.checkStrictMode)(it, msg, opts.strictTuples);
        }
    }
}
items.validateTuple = validateTuple;
items.default = def$f;

Object.defineProperty(prefixItems, "__esModule", { value: true });
const items_1$1 = items;
const def$e = {
    keyword: "prefixItems",
    type: "array",
    schemaType: ["array"],
    before: "uniqueItems",
    code: (cxt) => (0, items_1$1.validateTuple)(cxt, "items"),
};
prefixItems.default = def$e;

var items2020 = {};

Object.defineProperty(items2020, "__esModule", { value: true });
const codegen_1$8 = requireCodegen();
const util_1$b = util$1;
const code_1$4 = requireCode();
const additionalItems_1$1 = additionalItems;
const error$9 = {
    message: ({ params: { len } }) => (0, codegen_1$8.str) `must NOT have more than ${len} items`,
    params: ({ params: { len } }) => (0, codegen_1$8._) `{limit: ${len}}`,
};
const def$d = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    error: error$9,
    code(cxt) {
        const { schema, parentSchema, it } = cxt;
        const { prefixItems } = parentSchema;
        it.items = true;
        if ((0, util_1$b.alwaysValidSchema)(it, schema))
            return;
        if (prefixItems)
            (0, additionalItems_1$1.validateAdditionalItems)(cxt, prefixItems);
        else
            cxt.ok((0, code_1$4.validateArray)(cxt));
    },
};
items2020.default = def$d;

var contains = {};

Object.defineProperty(contains, "__esModule", { value: true });
const codegen_1$7 = requireCodegen();
const util_1$a = util$1;
const error$8 = {
    message: ({ params: { min, max } }) => max === undefined
        ? (0, codegen_1$7.str) `must contain at least ${min} valid item(s)`
        : (0, codegen_1$7.str) `must contain at least ${min} and no more than ${max} valid item(s)`,
    params: ({ params: { min, max } }) => max === undefined ? (0, codegen_1$7._) `{minContains: ${min}}` : (0, codegen_1$7._) `{minContains: ${min}, maxContains: ${max}}`,
};
const def$c = {
    keyword: "contains",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    trackErrors: true,
    error: error$8,
    code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        let min;
        let max;
        const { minContains, maxContains } = parentSchema;
        if (it.opts.next) {
            min = minContains === undefined ? 1 : minContains;
            max = maxContains;
        }
        else {
            min = 1;
        }
        const len = gen.const("len", (0, codegen_1$7._) `${data}.length`);
        cxt.setParams({ min, max });
        if (max === undefined && min === 0) {
            (0, util_1$a.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
            return;
        }
        if (max !== undefined && min > max) {
            (0, util_1$a.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
            cxt.fail();
            return;
        }
        if ((0, util_1$a.alwaysValidSchema)(it, schema)) {
            let cond = (0, codegen_1$7._) `${len} >= ${min}`;
            if (max !== undefined)
                cond = (0, codegen_1$7._) `${cond} && ${len} <= ${max}`;
            cxt.pass(cond);
            return;
        }
        it.items = true;
        const valid = gen.name("valid");
        if (max === undefined && min === 1) {
            validateItems(valid, () => gen.if(valid, () => gen.break()));
        }
        else if (min === 0) {
            gen.let(valid, true);
            if (max !== undefined)
                gen.if((0, codegen_1$7._) `${data}.length > 0`, validateItemsWithCount);
        }
        else {
            gen.let(valid, false);
            validateItemsWithCount();
        }
        cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
            const schValid = gen.name("_valid");
            const count = gen.let("count", 0);
            validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
        }
        function validateItems(_valid, block) {
            gen.forRange("i", 0, len, (i) => {
                cxt.subschema({
                    keyword: "contains",
                    dataProp: i,
                    dataPropType: util_1$a.Type.Num,
                    compositeRule: true,
                }, _valid);
                block();
            });
        }
        function checkLimits(count) {
            gen.code((0, codegen_1$7._) `${count}++`);
            if (max === undefined) {
                gen.if((0, codegen_1$7._) `${count} >= ${min}`, () => gen.assign(valid, true).break());
            }
            else {
                gen.if((0, codegen_1$7._) `${count} > ${max}`, () => gen.assign(valid, false).break());
                if (min === 1)
                    gen.assign(valid, true);
                else
                    gen.if((0, codegen_1$7._) `${count} >= ${min}`, () => gen.assign(valid, true));
            }
        }
    },
};
contains.default = def$c;

var dependencies = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
	const codegen_1 = requireCodegen();
	const util_1 = util$1;
	const code_1 = requireCode();
	exports.error = {
	    message: ({ params: { property, depsCount, deps } }) => {
	        const property_ies = depsCount === 1 ? "property" : "properties";
	        return (0, codegen_1.str) `must have ${property_ies} ${deps} when property ${property} is present`;
	    },
	    params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._) `{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`, // TODO change to reference
	};
	const def = {
	    keyword: "dependencies",
	    type: "object",
	    schemaType: "object",
	    error: exports.error,
	    code(cxt) {
	        const [propDeps, schDeps] = splitDependencies(cxt);
	        validatePropertyDeps(cxt, propDeps);
	        validateSchemaDeps(cxt, schDeps);
	    },
	};
	function splitDependencies({ schema }) {
	    const propertyDeps = {};
	    const schemaDeps = {};
	    for (const key in schema) {
	        if (key === "__proto__")
	            continue;
	        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
	        deps[key] = schema[key];
	    }
	    return [propertyDeps, schemaDeps];
	}
	function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
	    const { gen, data, it } = cxt;
	    if (Object.keys(propertyDeps).length === 0)
	        return;
	    const missing = gen.let("missing");
	    for (const prop in propertyDeps) {
	        const deps = propertyDeps[prop];
	        if (deps.length === 0)
	            continue;
	        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
	        cxt.setParams({
	            property: prop,
	            depsCount: deps.length,
	            deps: deps.join(", "),
	        });
	        if (it.allErrors) {
	            gen.if(hasProperty, () => {
	                for (const depProp of deps) {
	                    (0, code_1.checkReportMissingProp)(cxt, depProp);
	                }
	            });
	        }
	        else {
	            gen.if((0, codegen_1._) `${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
	            (0, code_1.reportMissingProp)(cxt, missing);
	            gen.else();
	        }
	    }
	}
	exports.validatePropertyDeps = validatePropertyDeps;
	function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
	    const { gen, data, keyword, it } = cxt;
	    const valid = gen.name("valid");
	    for (const prop in schemaDeps) {
	        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
	            continue;
	        gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties), () => {
	            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
	            cxt.mergeValidEvaluated(schCxt, valid);
	        }, () => gen.var(valid, true) // TODO var
	        );
	        cxt.ok(valid);
	    }
	}
	exports.validateSchemaDeps = validateSchemaDeps;
	exports.default = def;
	
} (dependencies));

var propertyNames = {};

Object.defineProperty(propertyNames, "__esModule", { value: true });
const codegen_1$6 = requireCodegen();
const util_1$9 = util$1;
const error$7 = {
    message: "property name must be valid",
    params: ({ params }) => (0, codegen_1$6._) `{propertyName: ${params.propertyName}}`,
};
const def$b = {
    keyword: "propertyNames",
    type: "object",
    schemaType: ["object", "boolean"],
    error: error$7,
    code(cxt) {
        const { gen, schema, data, it } = cxt;
        if ((0, util_1$9.alwaysValidSchema)(it, schema))
            return;
        const valid = gen.name("valid");
        gen.forIn("key", data, (key) => {
            cxt.setParams({ propertyName: key });
            cxt.subschema({
                keyword: "propertyNames",
                data: key,
                dataTypes: ["string"],
                propertyName: key,
                compositeRule: true,
            }, valid);
            gen.if((0, codegen_1$6.not)(valid), () => {
                cxt.error(true);
                if (!it.allErrors)
                    gen.break();
            });
        });
        cxt.ok(valid);
    },
};
propertyNames.default = def$b;

var additionalProperties = {};

Object.defineProperty(additionalProperties, "__esModule", { value: true });
const code_1$3 = requireCode();
const codegen_1$5 = requireCodegen();
const names_1 = requireNames();
const util_1$8 = util$1;
const error$6 = {
    message: "must NOT have additional properties",
    params: ({ params }) => (0, codegen_1$5._) `{additionalProperty: ${params.additionalProperty}}`,
};
const def$a = {
    keyword: "additionalProperties",
    type: ["object"],
    schemaType: ["boolean", "object"],
    allowUndefined: true,
    trackErrors: true,
    error: error$6,
    code(cxt) {
        const { gen, schema, parentSchema, data, errsCount, it } = cxt;
        /* istanbul ignore if */
        if (!errsCount)
            throw new Error("ajv implementation error");
        const { allErrors, opts } = it;
        it.props = true;
        if (opts.removeAdditional !== "all" && (0, util_1$8.alwaysValidSchema)(it, schema))
            return;
        const props = (0, code_1$3.allSchemaProperties)(parentSchema.properties);
        const patProps = (0, code_1$3.allSchemaProperties)(parentSchema.patternProperties);
        checkAdditionalProperties();
        cxt.ok((0, codegen_1$5._) `${errsCount} === ${names_1.default.errors}`);
        function checkAdditionalProperties() {
            gen.forIn("key", data, (key) => {
                if (!props.length && !patProps.length)
                    additionalPropertyCode(key);
                else
                    gen.if(isAdditional(key), () => additionalPropertyCode(key));
            });
        }
        function isAdditional(key) {
            let definedProp;
            if (props.length > 8) {
                // TODO maybe an option instead of hard-coded 8?
                const propsSchema = (0, util_1$8.schemaRefOrVal)(it, parentSchema.properties, "properties");
                definedProp = (0, code_1$3.isOwnProperty)(gen, propsSchema, key);
            }
            else if (props.length) {
                definedProp = (0, codegen_1$5.or)(...props.map((p) => (0, codegen_1$5._) `${key} === ${p}`));
            }
            else {
                definedProp = codegen_1$5.nil;
            }
            if (patProps.length) {
                definedProp = (0, codegen_1$5.or)(definedProp, ...patProps.map((p) => (0, codegen_1$5._) `${(0, code_1$3.usePattern)(cxt, p)}.test(${key})`));
            }
            return (0, codegen_1$5.not)(definedProp);
        }
        function deleteAdditional(key) {
            gen.code((0, codegen_1$5._) `delete ${data}[${key}]`);
        }
        function additionalPropertyCode(key) {
            if (opts.removeAdditional === "all" || (opts.removeAdditional && schema === false)) {
                deleteAdditional(key);
                return;
            }
            if (schema === false) {
                cxt.setParams({ additionalProperty: key });
                cxt.error();
                if (!allErrors)
                    gen.break();
                return;
            }
            if (typeof schema == "object" && !(0, util_1$8.alwaysValidSchema)(it, schema)) {
                const valid = gen.name("valid");
                if (opts.removeAdditional === "failing") {
                    applyAdditionalSchema(key, valid, false);
                    gen.if((0, codegen_1$5.not)(valid), () => {
                        cxt.reset();
                        deleteAdditional(key);
                    });
                }
                else {
                    applyAdditionalSchema(key, valid);
                    if (!allErrors)
                        gen.if((0, codegen_1$5.not)(valid), () => gen.break());
                }
            }
        }
        function applyAdditionalSchema(key, valid, errors) {
            const subschema = {
                keyword: "additionalProperties",
                dataProp: key,
                dataPropType: util_1$8.Type.Str,
            };
            if (errors === false) {
                Object.assign(subschema, {
                    compositeRule: true,
                    createErrors: false,
                    allErrors: false,
                });
            }
            cxt.subschema(subschema, valid);
        }
    },
};
additionalProperties.default = def$a;

var properties$1 = {};

Object.defineProperty(properties$1, "__esModule", { value: true });
const validate_1 = requireValidate();
const code_1$2 = requireCode();
const util_1$7 = util$1;
const additionalProperties_1$1 = additionalProperties;
const def$9 = {
    keyword: "properties",
    type: "object",
    schemaType: "object",
    code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === undefined) {
            additionalProperties_1$1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1$1.default, "additionalProperties"));
        }
        const allProps = (0, code_1$2.allSchemaProperties)(schema);
        for (const prop of allProps) {
            it.definedProperties.add(prop);
        }
        if (it.opts.unevaluated && allProps.length && it.props !== true) {
            it.props = util_1$7.mergeEvaluated.props(gen, (0, util_1$7.toHash)(allProps), it.props);
        }
        const properties = allProps.filter((p) => !(0, util_1$7.alwaysValidSchema)(it, schema[p]));
        if (properties.length === 0)
            return;
        const valid = gen.name("valid");
        for (const prop of properties) {
            if (hasDefault(prop)) {
                applyPropertySchema(prop);
            }
            else {
                gen.if((0, code_1$2.propertyInData)(gen, data, prop, it.opts.ownProperties));
                applyPropertySchema(prop);
                if (!it.allErrors)
                    gen.else().var(valid, true);
                gen.endIf();
            }
            cxt.it.definedProperties.add(prop);
            cxt.ok(valid);
        }
        function hasDefault(prop) {
            return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined;
        }
        function applyPropertySchema(prop) {
            cxt.subschema({
                keyword: "properties",
                schemaProp: prop,
                dataProp: prop,
            }, valid);
        }
    },
};
properties$1.default = def$9;

var patternProperties = {};

Object.defineProperty(patternProperties, "__esModule", { value: true });
const code_1$1 = requireCode();
const codegen_1$4 = requireCodegen();
const util_1$6 = util$1;
const util_2 = util$1;
const def$8 = {
    keyword: "patternProperties",
    type: "object",
    schemaType: "object",
    code(cxt) {
        const { gen, schema, data, parentSchema, it } = cxt;
        const { opts } = it;
        const patterns = (0, code_1$1.allSchemaProperties)(schema);
        const alwaysValidPatterns = patterns.filter((p) => (0, util_1$6.alwaysValidSchema)(it, schema[p]));
        if (patterns.length === 0 ||
            (alwaysValidPatterns.length === patterns.length &&
                (!it.opts.unevaluated || it.props === true))) {
            return;
        }
        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
        const valid = gen.name("valid");
        if (it.props !== true && !(it.props instanceof codegen_1$4.Name)) {
            it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
        }
        const { props } = it;
        validatePatternProperties();
        function validatePatternProperties() {
            for (const pat of patterns) {
                if (checkProperties)
                    checkMatchingProperties(pat);
                if (it.allErrors) {
                    validateProperties(pat);
                }
                else {
                    gen.var(valid, true); // TODO var
                    validateProperties(pat);
                    gen.if(valid);
                }
            }
        }
        function checkMatchingProperties(pat) {
            for (const prop in checkProperties) {
                if (new RegExp(pat).test(prop)) {
                    (0, util_1$6.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
                }
            }
        }
        function validateProperties(pat) {
            gen.forIn("key", data, (key) => {
                gen.if((0, codegen_1$4._) `${(0, code_1$1.usePattern)(cxt, pat)}.test(${key})`, () => {
                    const alwaysValid = alwaysValidPatterns.includes(pat);
                    if (!alwaysValid) {
                        cxt.subschema({
                            keyword: "patternProperties",
                            schemaProp: pat,
                            dataProp: key,
                            dataPropType: util_2.Type.Str,
                        }, valid);
                    }
                    if (it.opts.unevaluated && props !== true) {
                        gen.assign((0, codegen_1$4._) `${props}[${key}]`, true);
                    }
                    else if (!alwaysValid && !it.allErrors) {
                        // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)
                        // or if all properties were evaluated (props === true)
                        gen.if((0, codegen_1$4.not)(valid), () => gen.break());
                    }
                });
            });
        }
    },
};
patternProperties.default = def$8;

var not = {};

Object.defineProperty(not, "__esModule", { value: true });
const util_1$5 = util$1;
const def$7 = {
    keyword: "not",
    schemaType: ["object", "boolean"],
    trackErrors: true,
    code(cxt) {
        const { gen, schema, it } = cxt;
        if ((0, util_1$5.alwaysValidSchema)(it, schema)) {
            cxt.fail();
            return;
        }
        const valid = gen.name("valid");
        cxt.subschema({
            keyword: "not",
            compositeRule: true,
            createErrors: false,
            allErrors: false,
        }, valid);
        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
    },
    error: { message: "must NOT be valid" },
};
not.default = def$7;

var anyOf = {};

Object.defineProperty(anyOf, "__esModule", { value: true });
const code_1 = requireCode();
const def$6 = {
    keyword: "anyOf",
    schemaType: "array",
    trackErrors: true,
    code: code_1.validateUnion,
    error: { message: "must match a schema in anyOf" },
};
anyOf.default = def$6;

var oneOf = {};

Object.defineProperty(oneOf, "__esModule", { value: true });
const codegen_1$3 = requireCodegen();
const util_1$4 = util$1;
const error$5 = {
    message: "must match exactly one schema in oneOf",
    params: ({ params }) => (0, codegen_1$3._) `{passingSchemas: ${params.passing}}`,
};
const def$5 = {
    keyword: "oneOf",
    schemaType: "array",
    trackErrors: true,
    error: error$5,
    code(cxt) {
        const { gen, schema, parentSchema, it } = cxt;
        /* istanbul ignore if */
        if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
        if (it.opts.discriminator && parentSchema.discriminator)
            return;
        const schArr = schema;
        const valid = gen.let("valid", false);
        const passing = gen.let("passing", null);
        const schValid = gen.name("_valid");
        cxt.setParams({ passing });
        // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas
        gen.block(validateOneOf);
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
        function validateOneOf() {
            schArr.forEach((sch, i) => {
                let schCxt;
                if ((0, util_1$4.alwaysValidSchema)(it, sch)) {
                    gen.var(schValid, true);
                }
                else {
                    schCxt = cxt.subschema({
                        keyword: "oneOf",
                        schemaProp: i,
                        compositeRule: true,
                    }, schValid);
                }
                if (i > 0) {
                    gen
                        .if((0, codegen_1$3._) `${schValid} && ${valid}`)
                        .assign(valid, false)
                        .assign(passing, (0, codegen_1$3._) `[${passing}, ${i}]`)
                        .else();
                }
                gen.if(schValid, () => {
                    gen.assign(valid, true);
                    gen.assign(passing, i);
                    if (schCxt)
                        cxt.mergeEvaluated(schCxt, codegen_1$3.Name);
                });
            });
        }
    },
};
oneOf.default = def$5;

var allOf = {};

Object.defineProperty(allOf, "__esModule", { value: true });
const util_1$3 = util$1;
const def$4 = {
    keyword: "allOf",
    schemaType: "array",
    code(cxt) {
        const { gen, schema, it } = cxt;
        /* istanbul ignore if */
        if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
        const valid = gen.name("valid");
        schema.forEach((sch, i) => {
            if ((0, util_1$3.alwaysValidSchema)(it, sch))
                return;
            const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
            cxt.ok(valid);
            cxt.mergeEvaluated(schCxt);
        });
    },
};
allOf.default = def$4;

var _if = {};

Object.defineProperty(_if, "__esModule", { value: true });
const codegen_1$2 = requireCodegen();
const util_1$2 = util$1;
const error$4 = {
    message: ({ params }) => (0, codegen_1$2.str) `must match "${params.ifClause}" schema`,
    params: ({ params }) => (0, codegen_1$2._) `{failingKeyword: ${params.ifClause}}`,
};
const def$3 = {
    keyword: "if",
    schemaType: ["object", "boolean"],
    trackErrors: true,
    error: error$4,
    code(cxt) {
        const { gen, parentSchema, it } = cxt;
        if (parentSchema.then === undefined && parentSchema.else === undefined) {
            (0, util_1$2.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
        }
        const hasThen = hasSchema(it, "then");
        const hasElse = hasSchema(it, "else");
        if (!hasThen && !hasElse)
            return;
        const valid = gen.let("valid", true);
        const schValid = gen.name("_valid");
        validateIf();
        cxt.reset();
        if (hasThen && hasElse) {
            const ifClause = gen.let("ifClause");
            cxt.setParams({ ifClause });
            gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        }
        else if (hasThen) {
            gen.if(schValid, validateClause("then"));
        }
        else {
            gen.if((0, codegen_1$2.not)(schValid), validateClause("else"));
        }
        cxt.pass(valid, () => cxt.error(true));
        function validateIf() {
            const schCxt = cxt.subschema({
                keyword: "if",
                compositeRule: true,
                createErrors: false,
                allErrors: false,
            }, schValid);
            cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword, ifClause) {
            return () => {
                const schCxt = cxt.subschema({ keyword }, schValid);
                gen.assign(valid, schValid);
                cxt.mergeValidEvaluated(schCxt, valid);
                if (ifClause)
                    gen.assign(ifClause, (0, codegen_1$2._) `${keyword}`);
                else
                    cxt.setParams({ ifClause: keyword });
            };
        }
    },
};
function hasSchema(it, keyword) {
    const schema = it.schema[keyword];
    return schema !== undefined && !(0, util_1$2.alwaysValidSchema)(it, schema);
}
_if.default = def$3;

var thenElse = {};

Object.defineProperty(thenElse, "__esModule", { value: true });
const util_1$1 = util$1;
const def$2 = {
    keyword: ["then", "else"],
    schemaType: ["object", "boolean"],
    code({ keyword, parentSchema, it }) {
        if (parentSchema.if === undefined)
            (0, util_1$1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
    },
};
thenElse.default = def$2;

Object.defineProperty(applicator, "__esModule", { value: true });
const additionalItems_1 = additionalItems;
const prefixItems_1 = prefixItems;
const items_1 = items;
const items2020_1 = items2020;
const contains_1 = contains;
const dependencies_1 = dependencies;
const propertyNames_1 = propertyNames;
const additionalProperties_1 = additionalProperties;
const properties_1 = properties$1;
const patternProperties_1 = patternProperties;
const not_1 = not;
const anyOf_1 = anyOf;
const oneOf_1 = oneOf;
const allOf_1 = allOf;
const if_1 = _if;
const thenElse_1 = thenElse;
function getApplicator(draft2020 = false) {
    const applicator = [
        // any
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        // object
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1.default,
        properties_1.default,
        patternProperties_1.default,
    ];
    // array
    if (draft2020)
        applicator.push(prefixItems_1.default, items2020_1.default);
    else
        applicator.push(additionalItems_1.default, items_1.default);
    applicator.push(contains_1.default);
    return applicator;
}
applicator.default = getApplicator;

var format$2 = {};

var format$1 = {};

Object.defineProperty(format$1, "__esModule", { value: true });
const codegen_1$1 = requireCodegen();
const error$3 = {
    message: ({ schemaCode }) => (0, codegen_1$1.str) `must match format "${schemaCode}"`,
    params: ({ schemaCode }) => (0, codegen_1$1._) `{format: ${schemaCode}}`,
};
const def$1 = {
    keyword: "format",
    type: ["number", "string"],
    schemaType: "string",
    $data: true,
    error: error$3,
    code(cxt, ruleType) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        const { opts, errSchemaPath, schemaEnv, self } = it;
        if (!opts.validateFormats)
            return;
        if ($data)
            validate$DataFormat();
        else
            validateFormat();
        function validate$DataFormat() {
            const fmts = gen.scopeValue("formats", {
                ref: self.formats,
                code: opts.code.formats,
            });
            const fDef = gen.const("fDef", (0, codegen_1$1._) `${fmts}[${schemaCode}]`);
            const fType = gen.let("fType");
            const format = gen.let("format");
            // TODO simplify
            gen.if((0, codegen_1$1._) `typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1$1._) `${fDef}.type || "string"`).assign(format, (0, codegen_1$1._) `${fDef}.validate`), () => gen.assign(fType, (0, codegen_1$1._) `"string"`).assign(format, fDef));
            cxt.fail$data((0, codegen_1$1.or)(unknownFmt(), invalidFmt()));
            function unknownFmt() {
                if (opts.strictSchema === false)
                    return codegen_1$1.nil;
                return (0, codegen_1$1._) `${schemaCode} && !${format}`;
            }
            function invalidFmt() {
                const callFormat = schemaEnv.$async
                    ? (0, codegen_1$1._) `(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`
                    : (0, codegen_1$1._) `${format}(${data})`;
                const validData = (0, codegen_1$1._) `(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
                return (0, codegen_1$1._) `${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
            }
        }
        function validateFormat() {
            const formatDef = self.formats[schema];
            if (!formatDef) {
                unknownFormat();
                return;
            }
            if (formatDef === true)
                return;
            const [fmtType, format, fmtRef] = getFormat(formatDef);
            if (fmtType === ruleType)
                cxt.pass(validCondition());
            function unknownFormat() {
                if (opts.strictSchema === false) {
                    self.logger.warn(unknownMsg());
                    return;
                }
                throw new Error(unknownMsg());
                function unknownMsg() {
                    return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
                }
            }
            function getFormat(fmtDef) {
                const code = fmtDef instanceof RegExp
                    ? (0, codegen_1$1.regexpCode)(fmtDef)
                    : opts.code.formats
                        ? (0, codegen_1$1._) `${opts.code.formats}${(0, codegen_1$1.getProperty)(schema)}`
                        : undefined;
                const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
                if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
                    return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1$1._) `${fmt}.validate`];
                }
                return ["string", fmtDef, fmt];
            }
            function validCondition() {
                if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
                    if (!schemaEnv.$async)
                        throw new Error("async format in sync schema");
                    return (0, codegen_1$1._) `await ${fmtRef}(${data})`;
                }
                return typeof format == "function" ? (0, codegen_1$1._) `${fmtRef}(${data})` : (0, codegen_1$1._) `${fmtRef}.test(${data})`;
            }
        }
    },
};
format$1.default = def$1;

Object.defineProperty(format$2, "__esModule", { value: true });
const format_1$1 = format$1;
const format = [format_1$1.default];
format$2.default = format;

var metadata = {};

Object.defineProperty(metadata, "__esModule", { value: true });
metadata.contentVocabulary = metadata.metadataVocabulary = void 0;
metadata.metadataVocabulary = [
    "title",
    "description",
    "default",
    "deprecated",
    "readOnly",
    "writeOnly",
    "examples",
];
metadata.contentVocabulary = [
    "contentMediaType",
    "contentEncoding",
    "contentSchema",
];

Object.defineProperty(draft7, "__esModule", { value: true });
const core_1 = core$1;
const validation_1 = validation$1;
const applicator_1 = applicator;
const format_1 = format$2;
const metadata_1 = metadata;
const draft7Vocabularies = [
    core_1.default,
    validation_1.default,
    (0, applicator_1.default)(),
    format_1.default,
    metadata_1.metadataVocabulary,
    metadata_1.contentVocabulary,
];
draft7.default = draft7Vocabularies;

var discriminator = {};

var types = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.DiscrError = void 0;
	(function (DiscrError) {
	    DiscrError["Tag"] = "tag";
	    DiscrError["Mapping"] = "mapping";
	})(exports.DiscrError || (exports.DiscrError = {}));
	
} (types));

Object.defineProperty(discriminator, "__esModule", { value: true });
const codegen_1 = requireCodegen();
const types_1 = types;
const compile_1 = compile$1;
const util_1 = util$1;
const error$2 = {
    message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag
        ? `tag "${tagName}" must be string`
        : `value of tag "${tagName}" must be in oneOf`,
    params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._) `{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,
};
const def = {
    keyword: "discriminator",
    type: "object",
    schemaType: "object",
    error: error$2,
    code(cxt) {
        const { gen, data, schema, parentSchema, it } = cxt;
        const { oneOf } = parentSchema;
        if (!it.opts.discriminator) {
            throw new Error("discriminator: requires discriminator option");
        }
        const tagName = schema.propertyName;
        if (typeof tagName != "string")
            throw new Error("discriminator: requires propertyName");
        if (schema.mapping)
            throw new Error("discriminator: mapping is not supported");
        if (!oneOf)
            throw new Error("discriminator: requires oneOf keyword");
        const valid = gen.let("valid", false);
        const tag = gen.const("tag", (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(tagName)}`);
        gen.if((0, codegen_1._) `typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
        cxt.ok(valid);
        function validateMapping() {
            const mapping = getMapping();
            gen.if(false);
            for (const tagValue in mapping) {
                gen.elseIf((0, codegen_1._) `${tag} === ${tagValue}`);
                gen.assign(valid, applyTagSchema(mapping[tagValue]));
            }
            gen.else();
            cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
            gen.endIf();
        }
        function applyTagSchema(schemaProp) {
            const _valid = gen.name("valid");
            const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
            cxt.mergeEvaluated(schCxt, codegen_1.Name);
            return _valid;
        }
        function getMapping() {
            var _a;
            const oneOfMapping = {};
            const topRequired = hasRequired(parentSchema);
            let tagRequired = true;
            for (let i = 0; i < oneOf.length; i++) {
                let sch = oneOf[i];
                if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
                    sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, sch === null || sch === void 0 ? void 0 : sch.$ref);
                    if (sch instanceof compile_1.SchemaEnv)
                        sch = sch.schema;
                }
                const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
                if (typeof propSch != "object") {
                    throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
                }
                tagRequired = tagRequired && (topRequired || hasRequired(sch));
                addMappings(propSch, i);
            }
            if (!tagRequired)
                throw new Error(`discriminator: "${tagName}" must be required`);
            return oneOfMapping;
            function hasRequired({ required }) {
                return Array.isArray(required) && required.includes(tagName);
            }
            function addMappings(sch, i) {
                if (sch.const) {
                    addMapping(sch.const, i);
                }
                else if (sch.enum) {
                    for (const tagValue of sch.enum) {
                        addMapping(tagValue, i);
                    }
                }
                else {
                    throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
                }
            }
            function addMapping(tagValue, i) {
                if (typeof tagValue != "string" || tagValue in oneOfMapping) {
                    throw new Error(`discriminator: "${tagName}" values must be unique strings`);
                }
                oneOfMapping[tagValue] = i;
            }
        }
    },
};
discriminator.default = def;

var $schema = "http://json-schema.org/draft-07/schema#";
var $id = "http://json-schema.org/draft-07/schema#";
var title = "Core schema meta-schema";
var definitions = {
	schemaArray: {
		type: "array",
		minItems: 1,
		items: {
			$ref: "#"
		}
	},
	nonNegativeInteger: {
		type: "integer",
		minimum: 0
	},
	nonNegativeIntegerDefault0: {
		allOf: [
			{
				$ref: "#/definitions/nonNegativeInteger"
			},
			{
				"default": 0
			}
		]
	},
	simpleTypes: {
		"enum": [
			"array",
			"boolean",
			"integer",
			"null",
			"number",
			"object",
			"string"
		]
	},
	stringArray: {
		type: "array",
		items: {
			type: "string"
		},
		uniqueItems: true,
		"default": [
		]
	}
};
var type = [
	"object",
	"boolean"
];
var properties = {
	$id: {
		type: "string",
		format: "uri-reference"
	},
	$schema: {
		type: "string",
		format: "uri"
	},
	$ref: {
		type: "string",
		format: "uri-reference"
	},
	$comment: {
		type: "string"
	},
	title: {
		type: "string"
	},
	description: {
		type: "string"
	},
	"default": true,
	readOnly: {
		type: "boolean",
		"default": false
	},
	examples: {
		type: "array",
		items: true
	},
	multipleOf: {
		type: "number",
		exclusiveMinimum: 0
	},
	maximum: {
		type: "number"
	},
	exclusiveMaximum: {
		type: "number"
	},
	minimum: {
		type: "number"
	},
	exclusiveMinimum: {
		type: "number"
	},
	maxLength: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minLength: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	pattern: {
		type: "string",
		format: "regex"
	},
	additionalItems: {
		$ref: "#"
	},
	items: {
		anyOf: [
			{
				$ref: "#"
			},
			{
				$ref: "#/definitions/schemaArray"
			}
		],
		"default": true
	},
	maxItems: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minItems: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	uniqueItems: {
		type: "boolean",
		"default": false
	},
	contains: {
		$ref: "#"
	},
	maxProperties: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minProperties: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	required: {
		$ref: "#/definitions/stringArray"
	},
	additionalProperties: {
		$ref: "#"
	},
	definitions: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	properties: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	patternProperties: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		propertyNames: {
			format: "regex"
		},
		"default": {
		}
	},
	dependencies: {
		type: "object",
		additionalProperties: {
			anyOf: [
				{
					$ref: "#"
				},
				{
					$ref: "#/definitions/stringArray"
				}
			]
		}
	},
	propertyNames: {
		$ref: "#"
	},
	"const": true,
	"enum": {
		type: "array",
		items: true,
		minItems: 1,
		uniqueItems: true
	},
	type: {
		anyOf: [
			{
				$ref: "#/definitions/simpleTypes"
			},
			{
				type: "array",
				items: {
					$ref: "#/definitions/simpleTypes"
				},
				minItems: 1,
				uniqueItems: true
			}
		]
	},
	format: {
		type: "string"
	},
	contentMediaType: {
		type: "string"
	},
	contentEncoding: {
		type: "string"
	},
	"if": {
		$ref: "#"
	},
	then: {
		$ref: "#"
	},
	"else": {
		$ref: "#"
	},
	allOf: {
		$ref: "#/definitions/schemaArray"
	},
	anyOf: {
		$ref: "#/definitions/schemaArray"
	},
	oneOf: {
		$ref: "#/definitions/schemaArray"
	},
	not: {
		$ref: "#"
	}
};
var require$$3 = {
	$schema: $schema,
	$id: $id,
	title: title,
	definitions: definitions,
	type: type,
	properties: properties,
	"default": true
};

(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
	const core_1 = core$2;
	const draft7_1 = draft7;
	const discriminator_1 = discriminator;
	const draft7MetaSchema = require$$3;
	const META_SUPPORT_DATA = ["/properties"];
	const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
	class Ajv extends core_1.default {
	    _addVocabularies() {
	        super._addVocabularies();
	        draft7_1.default.forEach((v) => this.addVocabulary(v));
	        if (this.opts.discriminator)
	            this.addKeyword(discriminator_1.default);
	    }
	    _addDefaultMetaSchema() {
	        super._addDefaultMetaSchema();
	        if (!this.opts.meta)
	            return;
	        const metaSchema = this.opts.$data
	            ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA)
	            : draft7MetaSchema;
	        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
	        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
	    }
	    defaultMeta() {
	        return (this.opts.defaultMeta =
	            super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined));
	    }
	}
	module.exports = exports = Ajv;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Ajv;
	var validate_1 = requireValidate();
	Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function () { return validate_1.KeywordCxt; } });
	var codegen_1 = requireCodegen();
	Object.defineProperty(exports, "_", { enumerable: true, get: function () { return codegen_1._; } });
	Object.defineProperty(exports, "str", { enumerable: true, get: function () { return codegen_1.str; } });
	Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return codegen_1.stringify; } });
	Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return codegen_1.nil; } });
	Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return codegen_1.Name; } });
	Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function () { return codegen_1.CodeGen; } });
	var validation_error_1 = requireValidation_error();
	Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function () { return validation_error_1.default; } });
	var ref_error_1 = requireRef_error();
	Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function () { return ref_error_1.default; } });
	
} (ajv, ajv.exports));

var ajvExports = ajv.exports;
var Ajv = /*@__PURE__*/getDefaultExportFromCjs(ajvExports);

const ALIAS = Symbol.for('yaml.alias');
const DOC = Symbol.for('yaml.document');
const MAP = Symbol.for('yaml.map');
const PAIR = Symbol.for('yaml.pair');
const SCALAR$1 = Symbol.for('yaml.scalar');
const SEQ = Symbol.for('yaml.seq');
const NODE_TYPE = Symbol.for('yaml.node.type');
const isAlias = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === ALIAS;
const isDocument = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === DOC;
const isMap = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === MAP;
const isPair = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === PAIR;
const isScalar = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === SCALAR$1;
const isSeq = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === SEQ;
function isCollection(node) {
    if (node && typeof node === 'object')
        switch (node[NODE_TYPE]) {
            case MAP:
            case SEQ:
                return true;
        }
    return false;
}
function isNode(node) {
    if (node && typeof node === 'object')
        switch (node[NODE_TYPE]) {
            case ALIAS:
            case MAP:
            case SCALAR$1:
            case SEQ:
                return true;
        }
    return false;
}
const hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;

const BREAK = Symbol('break visit');
const SKIP = Symbol('skip children');
const REMOVE = Symbol('remove node');
/**
 * Apply a visitor to an AST node or document.
 *
 * Walks through the tree (depth-first) starting from `node`, calling a
 * `visitor` function with three arguments:
 *   - `key`: For sequence values and map `Pair`, the node's index in the
 *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.
 *     `null` for the root node.
 *   - `node`: The current node.
 *   - `path`: The ancestry of the current node.
 *
 * The return value of the visitor may be used to control the traversal:
 *   - `undefined` (default): Do nothing and continue
 *   - `visit.SKIP`: Do not visit the children of this node, continue with next
 *     sibling
 *   - `visit.BREAK`: Terminate traversal completely
 *   - `visit.REMOVE`: Remove the current node, then continue with the next one
 *   - `Node`: Replace the current node, then continue by visiting it
 *   - `number`: While iterating the items of a sequence or map, set the index
 *     of the next step. This is useful especially if the index of the current
 *     node has changed.
 *
 * If `visitor` is a single function, it will be called with all values
 * encountered in the tree, including e.g. `null` values. Alternatively,
 * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,
 * `Alias` and `Scalar` node. To define the same visitor function for more than
 * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)
 * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most
 * specific defined one will be used for each node.
 */
function visit(node, visitor) {
    const visitor_ = initVisitor(visitor);
    if (isDocument(node)) {
        const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
        if (cd === REMOVE)
            node.contents = null;
    }
    else
        visit_(null, node, visitor_, Object.freeze([]));
}
// Without the `as symbol` casts, TS declares these in the `visit`
// namespace using `var`, but then complains about that because
// `unique symbol` must be `const`.
/** Terminate visit traversal completely */
visit.BREAK = BREAK;
/** Do not visit the children of the current node */
visit.SKIP = SKIP;
/** Remove the current node */
visit.REMOVE = REMOVE;
function visit_(key, node, visitor, path) {
    const ctrl = callVisitor(key, node, visitor, path);
    if (isNode(ctrl) || isPair(ctrl)) {
        replaceNode(key, path, ctrl);
        return visit_(key, ctrl, visitor, path);
    }
    if (typeof ctrl !== 'symbol') {
        if (isCollection(node)) {
            path = Object.freeze(path.concat(node));
            for (let i = 0; i < node.items.length; ++i) {
                const ci = visit_(i, node.items[i], visitor, path);
                if (typeof ci === 'number')
                    i = ci - 1;
                else if (ci === BREAK)
                    return BREAK;
                else if (ci === REMOVE) {
                    node.items.splice(i, 1);
                    i -= 1;
                }
            }
        }
        else if (isPair(node)) {
            path = Object.freeze(path.concat(node));
            const ck = visit_('key', node.key, visitor, path);
            if (ck === BREAK)
                return BREAK;
            else if (ck === REMOVE)
                node.key = null;
            const cv = visit_('value', node.value, visitor, path);
            if (cv === BREAK)
                return BREAK;
            else if (cv === REMOVE)
                node.value = null;
        }
    }
    return ctrl;
}
function initVisitor(visitor) {
    if (typeof visitor === 'object' &&
        (visitor.Collection || visitor.Node || visitor.Value)) {
        return Object.assign({
            Alias: visitor.Node,
            Map: visitor.Node,
            Scalar: visitor.Node,
            Seq: visitor.Node
        }, visitor.Value && {
            Map: visitor.Value,
            Scalar: visitor.Value,
            Seq: visitor.Value
        }, visitor.Collection && {
            Map: visitor.Collection,
            Seq: visitor.Collection
        }, visitor);
    }
    return visitor;
}
function callVisitor(key, node, visitor, path) {
    if (typeof visitor === 'function')
        return visitor(key, node, path);
    if (isMap(node))
        return visitor.Map?.(key, node, path);
    if (isSeq(node))
        return visitor.Seq?.(key, node, path);
    if (isPair(node))
        return visitor.Pair?.(key, node, path);
    if (isScalar(node))
        return visitor.Scalar?.(key, node, path);
    if (isAlias(node))
        return visitor.Alias?.(key, node, path);
    return undefined;
}
function replaceNode(key, path, node) {
    const parent = path[path.length - 1];
    if (isCollection(parent)) {
        parent.items[key] = node;
    }
    else if (isPair(parent)) {
        if (key === 'key')
            parent.key = node;
        else
            parent.value = node;
    }
    else if (isDocument(parent)) {
        parent.contents = node;
    }
    else {
        const pt = isAlias(parent) ? 'alias' : 'scalar';
        throw new Error(`Cannot replace node with ${pt} parent`);
    }
}

const escapeChars = {
    '!': '%21',
    ',': '%2C',
    '[': '%5B',
    ']': '%5D',
    '{': '%7B',
    '}': '%7D'
};
const escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, ch => escapeChars[ch]);
class Directives {
    constructor(yaml, tags) {
        /**
         * The directives-end/doc-start marker `---`. If `null`, a marker may still be
         * included in the document's stringified representation.
         */
        this.docStart = null;
        /** The doc-end marker `...`.  */
        this.docEnd = false;
        this.yaml = Object.assign({}, Directives.defaultYaml, yaml);
        this.tags = Object.assign({}, Directives.defaultTags, tags);
    }
    clone() {
        const copy = new Directives(this.yaml, this.tags);
        copy.docStart = this.docStart;
        return copy;
    }
    /**
     * During parsing, get a Directives instance for the current document and
     * update the stream state according to the current version's spec.
     */
    atDocument() {
        const res = new Directives(this.yaml, this.tags);
        switch (this.yaml.version) {
            case '1.1':
                this.atNextDocument = true;
                break;
            case '1.2':
                this.atNextDocument = false;
                this.yaml = {
                    explicit: Directives.defaultYaml.explicit,
                    version: '1.2'
                };
                this.tags = Object.assign({}, Directives.defaultTags);
                break;
        }
        return res;
    }
    /**
     * @param onError - May be called even if the action was successful
     * @returns `true` on success
     */
    add(line, onError) {
        if (this.atNextDocument) {
            this.yaml = { explicit: Directives.defaultYaml.explicit, version: '1.1' };
            this.tags = Object.assign({}, Directives.defaultTags);
            this.atNextDocument = false;
        }
        const parts = line.trim().split(/[ \t]+/);
        const name = parts.shift();
        switch (name) {
            case '%TAG': {
                if (parts.length !== 2) {
                    onError(0, '%TAG directive should contain exactly two parts');
                    if (parts.length < 2)
                        return false;
                }
                const [handle, prefix] = parts;
                this.tags[handle] = prefix;
                return true;
            }
            case '%YAML': {
                this.yaml.explicit = true;
                if (parts.length !== 1) {
                    onError(0, '%YAML directive should contain exactly one part');
                    return false;
                }
                const [version] = parts;
                if (version === '1.1' || version === '1.2') {
                    this.yaml.version = version;
                    return true;
                }
                else {
                    const isValid = /^\d+\.\d+$/.test(version);
                    onError(6, `Unsupported YAML version ${version}`, isValid);
                    return false;
                }
            }
            default:
                onError(0, `Unknown directive ${name}`, true);
                return false;
        }
    }
    /**
     * Resolves a tag, matching handles to those defined in %TAG directives.
     *
     * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
     *   `'!local'` tag, or `null` if unresolvable.
     */
    tagName(source, onError) {
        if (source === '!')
            return '!'; // non-specific tag
        if (source[0] !== '!') {
            onError(`Not a valid tag: ${source}`);
            return null;
        }
        if (source[1] === '<') {
            const verbatim = source.slice(2, -1);
            if (verbatim === '!' || verbatim === '!!') {
                onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
                return null;
            }
            if (source[source.length - 1] !== '>')
                onError('Verbatim tags must end with a >');
            return verbatim;
        }
        const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
        if (!suffix)
            onError(`The ${source} tag has no suffix`);
        const prefix = this.tags[handle];
        if (prefix) {
            try {
                return prefix + decodeURIComponent(suffix);
            }
            catch (error) {
                onError(String(error));
                return null;
            }
        }
        if (handle === '!')
            return source; // local tag
        onError(`Could not resolve tag: ${source}`);
        return null;
    }
    /**
     * Given a fully resolved tag, returns its printable string form,
     * taking into account current tag prefixes and defaults.
     */
    tagString(tag) {
        for (const [handle, prefix] of Object.entries(this.tags)) {
            if (tag.startsWith(prefix))
                return handle + escapeTagName(tag.substring(prefix.length));
        }
        return tag[0] === '!' ? tag : `!<${tag}>`;
    }
    toString(doc) {
        const lines = this.yaml.explicit
            ? [`%YAML ${this.yaml.version || '1.2'}`]
            : [];
        const tagEntries = Object.entries(this.tags);
        let tagNames;
        if (doc && tagEntries.length > 0 && isNode(doc.contents)) {
            const tags = {};
            visit(doc.contents, (_key, node) => {
                if (isNode(node) && node.tag)
                    tags[node.tag] = true;
            });
            tagNames = Object.keys(tags);
        }
        else
            tagNames = [];
        for (const [handle, prefix] of tagEntries) {
            if (handle === '!!' && prefix === 'tag:yaml.org,2002:')
                continue;
            if (!doc || tagNames.some(tn => tn.startsWith(prefix)))
                lines.push(`%TAG ${handle} ${prefix}`);
        }
        return lines.join('\n');
    }
}
Directives.defaultYaml = { explicit: false, version: '1.2' };
Directives.defaultTags = { '!!': 'tag:yaml.org,2002:' };

/**
 * Verify that the input string is a valid anchor.
 *
 * Will throw on errors.
 */
function anchorIsValid(anchor) {
    if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
        const sa = JSON.stringify(anchor);
        const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
        throw new Error(msg);
    }
    return true;
}
function anchorNames(root) {
    const anchors = new Set();
    visit(root, {
        Value(_key, node) {
            if (node.anchor)
                anchors.add(node.anchor);
        }
    });
    return anchors;
}
/** Find a new anchor name with the given `prefix` and a one-indexed suffix. */
function findNewAnchor(prefix, exclude) {
    for (let i = 1; true; ++i) {
        const name = `${prefix}${i}`;
        if (!exclude.has(name))
            return name;
    }
}
function createNodeAnchors(doc, prefix) {
    const aliasObjects = [];
    const sourceObjects = new Map();
    let prevAnchors = null;
    return {
        onAnchor: (source) => {
            aliasObjects.push(source);
            if (!prevAnchors)
                prevAnchors = anchorNames(doc);
            const anchor = findNewAnchor(prefix, prevAnchors);
            prevAnchors.add(anchor);
            return anchor;
        },
        /**
         * With circular references, the source node is only resolved after all
         * of its child nodes are. This is why anchors are set only after all of
         * the nodes have been created.
         */
        setAnchors: () => {
            for (const source of aliasObjects) {
                const ref = sourceObjects.get(source);
                if (typeof ref === 'object' &&
                    ref.anchor &&
                    (isScalar(ref.node) || isCollection(ref.node))) {
                    ref.node.anchor = ref.anchor;
                }
                else {
                    const error = new Error('Failed to resolve repeated object (this should not happen)');
                    error.source = source;
                    throw error;
                }
            }
        },
        sourceObjects
    };
}

/**
 * Applies the JSON.parse reviver algorithm as defined in the ECMA-262 spec,
 * in section 24.5.1.1 "Runtime Semantics: InternalizeJSONProperty" of the
 * 2021 edition: https://tc39.es/ecma262/#sec-json.parse
 *
 * Includes extensions for handling Map and Set objects.
 */
function applyReviver(reviver, obj, key, val) {
    if (val && typeof val === 'object') {
        if (Array.isArray(val)) {
            for (let i = 0, len = val.length; i < len; ++i) {
                const v0 = val[i];
                const v1 = applyReviver(reviver, val, String(i), v0);
                if (v1 === undefined)
                    delete val[i];
                else if (v1 !== v0)
                    val[i] = v1;
            }
        }
        else if (val instanceof Map) {
            for (const k of Array.from(val.keys())) {
                const v0 = val.get(k);
                const v1 = applyReviver(reviver, val, k, v0);
                if (v1 === undefined)
                    val.delete(k);
                else if (v1 !== v0)
                    val.set(k, v1);
            }
        }
        else if (val instanceof Set) {
            for (const v0 of Array.from(val)) {
                const v1 = applyReviver(reviver, val, v0, v0);
                if (v1 === undefined)
                    val.delete(v0);
                else if (v1 !== v0) {
                    val.delete(v0);
                    val.add(v1);
                }
            }
        }
        else {
            for (const [k, v0] of Object.entries(val)) {
                const v1 = applyReviver(reviver, val, k, v0);
                if (v1 === undefined)
                    delete val[k];
                else if (v1 !== v0)
                    val[k] = v1;
            }
        }
    }
    return reviver.call(obj, key, val);
}

/**
 * Recursively convert any node or its contents to native JavaScript
 *
 * @param value - The input value
 * @param arg - If `value` defines a `toJSON()` method, use this
 *   as its first argument
 * @param ctx - Conversion context, originally set in Document#toJS(). If
 *   `{ keep: true }` is not set, output should be suitable for JSON
 *   stringification.
 */
function toJS(value, arg, ctx) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    if (Array.isArray(value))
        return value.map((v, i) => toJS(v, String(i), ctx));
    if (value && typeof value.toJSON === 'function') {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-call
        if (!ctx || !hasAnchor(value))
            return value.toJSON(arg, ctx);
        const data = { aliasCount: 0, count: 1, res: undefined };
        ctx.anchors.set(value, data);
        ctx.onCreate = res => {
            data.res = res;
            delete ctx.onCreate;
        };
        const res = value.toJSON(arg, ctx);
        if (ctx.onCreate)
            ctx.onCreate(res);
        return res;
    }
    if (typeof value === 'bigint' && !ctx?.keep)
        return Number(value);
    return value;
}

class NodeBase {
    constructor(type) {
        Object.defineProperty(this, NODE_TYPE, { value: type });
    }
    /** Create a copy of this node.  */
    clone() {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (this.range)
            copy.range = this.range.slice();
        return copy;
    }
    /** A plain JavaScript representation of this node. */
    toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        if (!isDocument(doc))
            throw new TypeError('A document argument is required');
        const ctx = {
            anchors: new Map(),
            doc,
            keep: true,
            mapAsMap: mapAsMap === true,
            mapKeyWarned: false,
            maxAliasCount: typeof maxAliasCount === 'number' ? maxAliasCount : 100
        };
        const res = toJS(this, '', ctx);
        if (typeof onAnchor === 'function')
            for (const { count, res } of ctx.anchors.values())
                onAnchor(res, count);
        return typeof reviver === 'function'
            ? applyReviver(reviver, { '': res }, '', res)
            : res;
    }
}

class Alias extends NodeBase {
    constructor(source) {
        super(ALIAS);
        this.source = source;
        Object.defineProperty(this, 'tag', {
            set() {
                throw new Error('Alias nodes cannot have tags');
            }
        });
    }
    /**
     * Resolve the value of this alias within `doc`, finding the last
     * instance of the `source` anchor before this node.
     */
    resolve(doc) {
        let found = undefined;
        visit(doc, {
            Node: (_key, node) => {
                if (node === this)
                    return visit.BREAK;
                if (node.anchor === this.source)
                    found = node;
            }
        });
        return found;
    }
    toJSON(_arg, ctx) {
        if (!ctx)
            return { source: this.source };
        const { anchors, doc, maxAliasCount } = ctx;
        const source = this.resolve(doc);
        if (!source) {
            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
            throw new ReferenceError(msg);
        }
        let data = anchors.get(source);
        if (!data) {
            // Resolve anchors for Node.prototype.toJS()
            toJS(source, null, ctx);
            data = anchors.get(source);
        }
        /* istanbul ignore if */
        if (!data || data.res === undefined) {
            const msg = 'This should not happen: Alias anchor was not resolved?';
            throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0) {
            data.count += 1;
            if (data.aliasCount === 0)
                data.aliasCount = getAliasCount(doc, source, anchors);
            if (data.count * data.aliasCount > maxAliasCount) {
                const msg = 'Excessive alias count indicates a resource exhaustion attack';
                throw new ReferenceError(msg);
            }
        }
        return data.res;
    }
    toString(ctx, _onComment, _onChompKeep) {
        const src = `*${this.source}`;
        if (ctx) {
            anchorIsValid(this.source);
            if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
                const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
                throw new Error(msg);
            }
            if (ctx.implicitKey)
                return `${src} `;
        }
        return src;
    }
}
function getAliasCount(doc, node, anchors) {
    if (isAlias(node)) {
        const source = node.resolve(doc);
        const anchor = anchors && source && anchors.get(source);
        return anchor ? anchor.count * anchor.aliasCount : 0;
    }
    else if (isCollection(node)) {
        let count = 0;
        for (const item of node.items) {
            const c = getAliasCount(doc, item, anchors);
            if (c > count)
                count = c;
        }
        return count;
    }
    else if (isPair(node)) {
        const kc = getAliasCount(doc, node.key, anchors);
        const vc = getAliasCount(doc, node.value, anchors);
        return Math.max(kc, vc);
    }
    return 1;
}

const isScalarValue = (value) => !value || (typeof value !== 'function' && typeof value !== 'object');
class Scalar extends NodeBase {
    constructor(value) {
        super(SCALAR$1);
        this.value = value;
    }
    toJSON(arg, ctx) {
        return ctx?.keep ? this.value : toJS(this.value, arg, ctx);
    }
    toString() {
        return String(this.value);
    }
}
Scalar.BLOCK_FOLDED = 'BLOCK_FOLDED';
Scalar.BLOCK_LITERAL = 'BLOCK_LITERAL';
Scalar.PLAIN = 'PLAIN';
Scalar.QUOTE_DOUBLE = 'QUOTE_DOUBLE';
Scalar.QUOTE_SINGLE = 'QUOTE_SINGLE';

const defaultTagPrefix = 'tag:yaml.org,2002:';
function findTagObject(value, tagName, tags) {
    if (tagName) {
        const match = tags.filter(t => t.tag === tagName);
        const tagObj = match.find(t => !t.format) ?? match[0];
        if (!tagObj)
            throw new Error(`Tag ${tagName} not found`);
        return tagObj;
    }
    return tags.find(t => t.identify?.(value) && !t.format);
}
function createNode(value, tagName, ctx) {
    if (isDocument(value))
        value = value.contents;
    if (isNode(value))
        return value;
    if (isPair(value)) {
        const map = ctx.schema[MAP].createNode?.(ctx.schema, null, ctx);
        map.items.push(value);
        return map;
    }
    if (value instanceof String ||
        value instanceof Number ||
        value instanceof Boolean ||
        (typeof BigInt !== 'undefined' && value instanceof BigInt) // not supported everywhere
    ) {
        // https://tc39.es/ecma262/#sec-serializejsonproperty
        value = value.valueOf();
    }
    const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;
    // Detect duplicate references to the same object & use Alias nodes for all
    // after first. The `ref` wrapper allows for circular references to resolve.
    let ref = undefined;
    if (aliasDuplicateObjects && value && typeof value === 'object') {
        ref = sourceObjects.get(value);
        if (ref) {
            if (!ref.anchor)
                ref.anchor = onAnchor(value);
            return new Alias(ref.anchor);
        }
        else {
            ref = { anchor: null, node: null };
            sourceObjects.set(value, ref);
        }
    }
    if (tagName?.startsWith('!!'))
        tagName = defaultTagPrefix + tagName.slice(2);
    let tagObj = findTagObject(value, tagName, schema.tags);
    if (!tagObj) {
        if (value && typeof value.toJSON === 'function') {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-call
            value = value.toJSON();
        }
        if (!value || typeof value !== 'object') {
            const node = new Scalar(value);
            if (ref)
                ref.node = node;
            return node;
        }
        tagObj =
            value instanceof Map
                ? schema[MAP]
                : Symbol.iterator in Object(value)
                    ? schema[SEQ]
                    : schema[MAP];
    }
    if (onTagObj) {
        onTagObj(tagObj);
        delete ctx.onTagObj;
    }
    const node = tagObj?.createNode
        ? tagObj.createNode(ctx.schema, value, ctx)
        : typeof tagObj?.nodeClass?.from === 'function'
            ? tagObj.nodeClass.from(ctx.schema, value, ctx)
            : new Scalar(value);
    if (tagName)
        node.tag = tagName;
    else if (!tagObj.default)
        node.tag = tagObj.tag;
    if (ref)
        ref.node = node;
    return node;
}

function collectionFromPath(schema, path, value) {
    let v = value;
    for (let i = path.length - 1; i >= 0; --i) {
        const k = path[i];
        if (typeof k === 'number' && Number.isInteger(k) && k >= 0) {
            const a = [];
            a[k] = v;
            v = a;
        }
        else {
            v = new Map([[k, v]]);
        }
    }
    return createNode(v, undefined, {
        aliasDuplicateObjects: false,
        keepUndefined: false,
        onAnchor: () => {
            throw new Error('This should not happen, please report a bug.');
        },
        schema,
        sourceObjects: new Map()
    });
}
// Type guard is intentionally a little wrong so as to be more useful,
// as it does not cover untypable empty non-string iterables (e.g. []).
const isEmptyPath = (path) => path == null ||
    (typeof path === 'object' && !!path[Symbol.iterator]().next().done);
class Collection extends NodeBase {
    constructor(type, schema) {
        super(type);
        Object.defineProperty(this, 'schema', {
            value: schema,
            configurable: true,
            enumerable: false,
            writable: true
        });
    }
    /**
     * Create a copy of this collection.
     *
     * @param schema - If defined, overwrites the original's schema
     */
    clone(schema) {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (schema)
            copy.schema = schema;
        copy.items = copy.items.map(it => isNode(it) || isPair(it) ? it.clone(schema) : it);
        if (this.range)
            copy.range = this.range.slice();
        return copy;
    }
    /**
     * Adds a value to the collection. For `!!map` and `!!omap` the value must
     * be a Pair instance or a `{ key, value }` object, which may not have a key
     * that already exists in the map.
     */
    addIn(path, value) {
        if (isEmptyPath(path))
            this.add(value);
        else {
            const [key, ...rest] = path;
            const node = this.get(key, true);
            if (isCollection(node))
                node.addIn(rest, value);
            else if (node === undefined && this.schema)
                this.set(key, collectionFromPath(this.schema, rest, value));
            else
                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
    }
    /**
     * Removes a value from the collection.
     * @returns `true` if the item was found and removed.
     */
    deleteIn(path) {
        const [key, ...rest] = path;
        if (rest.length === 0)
            return this.delete(key);
        const node = this.get(key, true);
        if (isCollection(node))
            return node.deleteIn(rest);
        else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
    /**
     * Returns item at `key`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */
    getIn(path, keepScalar) {
        const [key, ...rest] = path;
        const node = this.get(key, true);
        if (rest.length === 0)
            return !keepScalar && isScalar(node) ? node.value : node;
        else
            return isCollection(node) ? node.getIn(rest, keepScalar) : undefined;
    }
    hasAllNullValues(allowScalar) {
        return this.items.every(node => {
            if (!isPair(node))
                return false;
            const n = node.value;
            return (n == null ||
                (allowScalar &&
                    isScalar(n) &&
                    n.value == null &&
                    !n.commentBefore &&
                    !n.comment &&
                    !n.tag));
        });
    }
    /**
     * Checks if the collection includes a value with the key `key`.
     */
    hasIn(path) {
        const [key, ...rest] = path;
        if (rest.length === 0)
            return this.has(key);
        const node = this.get(key, true);
        return isCollection(node) ? node.hasIn(rest) : false;
    }
    /**
     * Sets a value in this collection. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */
    setIn(path, value) {
        const [key, ...rest] = path;
        if (rest.length === 0) {
            this.set(key, value);
        }
        else {
            const node = this.get(key, true);
            if (isCollection(node))
                node.setIn(rest, value);
            else if (node === undefined && this.schema)
                this.set(key, collectionFromPath(this.schema, rest, value));
            else
                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
    }
}
Collection.maxFlowStringSingleLineLength = 60;

/**
 * Stringifies a comment.
 *
 * Empty comment lines are left empty,
 * lines consisting of a single space are replaced by `#`,
 * and all other lines are prefixed with a `#`.
 */
const stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, '#');
function indentComment(comment, indent) {
    if (/^\n+$/.test(comment))
        return comment.substring(1);
    return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
}
const lineComment = (str, indent, comment) => str.endsWith('\n')
    ? indentComment(comment, indent)
    : comment.includes('\n')
        ? '\n' + indentComment(comment, indent)
        : (str.endsWith(' ') ? '' : ' ') + comment;

const FOLD_FLOW = 'flow';
const FOLD_BLOCK = 'block';
const FOLD_QUOTED = 'quoted';
/**
 * Tries to keep input at up to `lineWidth` characters, splitting only on spaces
 * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are
 * terminated with `\n` and started with `indent`.
 */
function foldFlowLines(text, indent, mode = 'flow', { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
    if (!lineWidth || lineWidth < 0)
        return text;
    const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
    if (text.length <= endStep)
        return text;
    const folds = [];
    const escapedFolds = {};
    let end = lineWidth - indent.length;
    if (typeof indentAtStart === 'number') {
        if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
            folds.push(0);
        else
            end = lineWidth - indentAtStart;
    }
    let split = undefined;
    let prev = undefined;
    let overflow = false;
    let i = -1;
    let escStart = -1;
    let escEnd = -1;
    if (mode === FOLD_BLOCK) {
        i = consumeMoreIndentedLines(text, i);
        if (i !== -1)
            end = i + endStep;
    }
    for (let ch; (ch = text[(i += 1)]);) {
        if (mode === FOLD_QUOTED && ch === '\\') {
            escStart = i;
            switch (text[i + 1]) {
                case 'x':
                    i += 3;
                    break;
                case 'u':
                    i += 5;
                    break;
                case 'U':
                    i += 9;
                    break;
                default:
                    i += 1;
            }
            escEnd = i;
        }
        if (ch === '\n') {
            if (mode === FOLD_BLOCK)
                i = consumeMoreIndentedLines(text, i);
            end = i + endStep;
            split = undefined;
        }
        else {
            if (ch === ' ' &&
                prev &&
                prev !== ' ' &&
                prev !== '\n' &&
                prev !== '\t') {
                // space surrounded by non-space can be replaced with newline + indent
                const next = text[i + 1];
                if (next && next !== ' ' && next !== '\n' && next !== '\t')
                    split = i;
            }
            if (i >= end) {
                if (split) {
                    folds.push(split);
                    end = split + endStep;
                    split = undefined;
                }
                else if (mode === FOLD_QUOTED) {
                    // white-space collected at end may stretch past lineWidth
                    while (prev === ' ' || prev === '\t') {
                        prev = ch;
                        ch = text[(i += 1)];
                        overflow = true;
                    }
                    // Account for newline escape, but don't break preceding escape
                    const j = i > escEnd + 1 ? i - 2 : escStart - 1;
                    // Bail out if lineWidth & minContentWidth are shorter than an escape string
                    if (escapedFolds[j])
                        return text;
                    folds.push(j);
                    escapedFolds[j] = true;
                    end = j + endStep;
                    split = undefined;
                }
                else {
                    overflow = true;
                }
            }
        }
        prev = ch;
    }
    if (overflow && onOverflow)
        onOverflow();
    if (folds.length === 0)
        return text;
    if (onFold)
        onFold();
    let res = text.slice(0, folds[0]);
    for (let i = 0; i < folds.length; ++i) {
        const fold = folds[i];
        const end = folds[i + 1] || text.length;
        if (fold === 0)
            res = `\n${indent}${text.slice(0, end)}`;
        else {
            if (mode === FOLD_QUOTED && escapedFolds[fold])
                res += `${text[fold]}\\`;
            res += `\n${indent}${text.slice(fold + 1, end)}`;
        }
    }
    return res;
}
/**
 * Presumes `i + 1` is at the start of a line
 * @returns index of last newline in more-indented block
 */
function consumeMoreIndentedLines(text, i) {
    let ch = text[i + 1];
    while (ch === ' ' || ch === '\t') {
        do {
            ch = text[(i += 1)];
        } while (ch && ch !== '\n');
        ch = text[i + 1];
    }
    return i;
}

const getFoldOptions = (ctx, isBlock) => ({
    indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
    lineWidth: ctx.options.lineWidth,
    minContentWidth: ctx.options.minContentWidth
});
// Also checks for lines starting with %, as parsing the output as YAML 1.1 will
// presume that's starting a new document.
const containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
function lineLengthOverLimit(str, lineWidth, indentLength) {
    if (!lineWidth || lineWidth < 0)
        return false;
    const limit = lineWidth - indentLength;
    const strLen = str.length;
    if (strLen <= limit)
        return false;
    for (let i = 0, start = 0; i < strLen; ++i) {
        if (str[i] === '\n') {
            if (i - start > limit)
                return true;
            start = i + 1;
            if (strLen - start <= limit)
                return false;
        }
    }
    return true;
}
function doubleQuotedString(value, ctx) {
    const json = JSON.stringify(value);
    if (ctx.options.doubleQuotedAsJSON)
        return json;
    const { implicitKey } = ctx;
    const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
    let str = '';
    let start = 0;
    for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
        if (ch === ' ' && json[i + 1] === '\\' && json[i + 2] === 'n') {
            // space before newline needs to be escaped to not be folded
            str += json.slice(start, i) + '\\ ';
            i += 1;
            start = i;
            ch = '\\';
        }
        if (ch === '\\')
            switch (json[i + 1]) {
                case 'u':
                    {
                        str += json.slice(start, i);
                        const code = json.substr(i + 2, 4);
                        switch (code) {
                            case '0000':
                                str += '\\0';
                                break;
                            case '0007':
                                str += '\\a';
                                break;
                            case '000b':
                                str += '\\v';
                                break;
                            case '001b':
                                str += '\\e';
                                break;
                            case '0085':
                                str += '\\N';
                                break;
                            case '00a0':
                                str += '\\_';
                                break;
                            case '2028':
                                str += '\\L';
                                break;
                            case '2029':
                                str += '\\P';
                                break;
                            default:
                                if (code.substr(0, 2) === '00')
                                    str += '\\x' + code.substr(2);
                                else
                                    str += json.substr(i, 6);
                        }
                        i += 5;
                        start = i + 1;
                    }
                    break;
                case 'n':
                    if (implicitKey ||
                        json[i + 2] === '"' ||
                        json.length < minMultiLineLength) {
                        i += 1;
                    }
                    else {
                        // folding will eat first newline
                        str += json.slice(start, i) + '\n\n';
                        while (json[i + 2] === '\\' &&
                            json[i + 3] === 'n' &&
                            json[i + 4] !== '"') {
                            str += '\n';
                            i += 2;
                        }
                        str += indent;
                        // space after newline needs to be escaped to not be folded
                        if (json[i + 2] === ' ')
                            str += '\\';
                        i += 1;
                        start = i + 1;
                    }
                    break;
                default:
                    i += 1;
            }
    }
    str = start ? str + json.slice(start) : json;
    return implicitKey
        ? str
        : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx, false));
}
function singleQuotedString(value, ctx) {
    if (ctx.options.singleQuote === false ||
        (ctx.implicitKey && value.includes('\n')) ||
        /[ \t]\n|\n[ \t]/.test(value) // single quoted string can't have leading or trailing whitespace around newline
    )
        return doubleQuotedString(value, ctx);
    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
    const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&\n${indent}`) + "'";
    return ctx.implicitKey
        ? res
        : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
function quotedString(value, ctx) {
    const { singleQuote } = ctx.options;
    let qs;
    if (singleQuote === false)
        qs = doubleQuotedString;
    else {
        const hasDouble = value.includes('"');
        const hasSingle = value.includes("'");
        if (hasDouble && !hasSingle)
            qs = singleQuotedString;
        else if (hasSingle && !hasDouble)
            qs = doubleQuotedString;
        else
            qs = singleQuote ? singleQuotedString : doubleQuotedString;
    }
    return qs(value, ctx);
}
// The negative lookbehind avoids a polynomial search,
// but isn't supported yet on Safari: https://caniuse.com/js-regexp-lookbehind
let blockEndNewlines;
try {
    blockEndNewlines = new RegExp('(^|(?<!\n))\n+(?!\n|$)', 'g');
}
catch {
    blockEndNewlines = /\n+(?!\n|$)/g;
}
function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
    const { blockQuote, commentString, lineWidth } = ctx.options;
    // 1. Block can't end in whitespace unless the last line is non-empty.
    // 2. Strings consisting of only whitespace are best rendered explicitly.
    if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
        return quotedString(value, ctx);
    }
    const indent = ctx.indent ||
        (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');
    const literal = blockQuote === 'literal'
        ? true
        : blockQuote === 'folded' || type === Scalar.BLOCK_FOLDED
            ? false
            : type === Scalar.BLOCK_LITERAL
                ? true
                : !lineLengthOverLimit(value, lineWidth, indent.length);
    if (!value)
        return literal ? '|\n' : '>\n';
    // determine chomping from whitespace at value end
    let chomp;
    let endStart;
    for (endStart = value.length; endStart > 0; --endStart) {
        const ch = value[endStart - 1];
        if (ch !== '\n' && ch !== '\t' && ch !== ' ')
            break;
    }
    let end = value.substring(endStart);
    const endNlPos = end.indexOf('\n');
    if (endNlPos === -1) {
        chomp = '-'; // strip
    }
    else if (value === end || endNlPos !== end.length - 1) {
        chomp = '+'; // keep
        if (onChompKeep)
            onChompKeep();
    }
    else {
        chomp = ''; // clip
    }
    if (end) {
        value = value.slice(0, -end.length);
        if (end[end.length - 1] === '\n')
            end = end.slice(0, -1);
        end = end.replace(blockEndNewlines, `$&${indent}`);
    }
    // determine indent indicator from whitespace at value start
    let startWithSpace = false;
    let startEnd;
    let startNlPos = -1;
    for (startEnd = 0; startEnd < value.length; ++startEnd) {
        const ch = value[startEnd];
        if (ch === ' ')
            startWithSpace = true;
        else if (ch === '\n')
            startNlPos = startEnd;
        else
            break;
    }
    let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
    if (start) {
        value = value.substring(start.length);
        start = start.replace(/\n+/g, `$&${indent}`);
    }
    const indentSize = indent ? '2' : '1'; // root is at -1
    let header = (literal ? '|' : '>') + (startWithSpace ? indentSize : '') + chomp;
    if (comment) {
        header += ' ' + commentString(comment.replace(/ ?[\r\n]+/g, ' '));
        if (onComment)
            onComment();
    }
    if (literal) {
        value = value.replace(/\n+/g, `$&${indent}`);
        return `${header}\n${indent}${start}${value}${end}`;
    }
    value = value
        .replace(/\n+/g, '\n$&')
        .replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, '$1$2') // more-indented lines aren't folded
        //                ^ more-ind. ^ empty     ^ capture next empty lines only at end of indent
        .replace(/\n+/g, `$&${indent}`);
    const body = foldFlowLines(`${start}${value}${end}`, indent, FOLD_BLOCK, getFoldOptions(ctx, true));
    return `${header}\n${indent}${body}`;
}
function plainString(item, ctx, onComment, onChompKeep) {
    const { type, value } = item;
    const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
    if ((implicitKey && value.includes('\n')) ||
        (inFlow && /[[\]{},]/.test(value))) {
        return quotedString(value, ctx);
    }
    if (!value ||
        /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
        // not allowed:
        // - empty string, '-' or '?'
        // - start with an indicator character (except [?:-]) or /[?-] /
        // - '\n ', ': ' or ' \n' anywhere
        // - '#' not preceded by a non-space char
        // - end with ' ' or ':'
        return implicitKey || inFlow || !value.includes('\n')
            ? quotedString(value, ctx)
            : blockString(item, ctx, onComment, onChompKeep);
    }
    if (!implicitKey &&
        !inFlow &&
        type !== Scalar.PLAIN &&
        value.includes('\n')) {
        // Where allowed & type not set explicitly, prefer block style for multiline strings
        return blockString(item, ctx, onComment, onChompKeep);
    }
    if (containsDocumentMarker(value)) {
        if (indent === '') {
            ctx.forceBlockIndent = true;
            return blockString(item, ctx, onComment, onChompKeep);
        }
        else if (implicitKey && indent === indentStep) {
            return quotedString(value, ctx);
        }
    }
    const str = value.replace(/\n+/g, `$&\n${indent}`);
    // Verify that output will be parsed as a string, as e.g. plain numbers and
    // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),
    // and others in v1.1.
    if (actualString) {
        const test = (tag) => tag.default && tag.tag !== 'tag:yaml.org,2002:str' && tag.test?.test(str);
        const { compat, tags } = ctx.doc.schema;
        if (tags.some(test) || compat?.some(test))
            return quotedString(value, ctx);
    }
    return implicitKey
        ? str
        : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
function stringifyString(item, ctx, onComment, onChompKeep) {
    const { implicitKey, inFlow } = ctx;
    const ss = typeof item.value === 'string'
        ? item
        : Object.assign({}, item, { value: String(item.value) });
    let { type } = item;
    if (type !== Scalar.QUOTE_DOUBLE) {
        // force double quotes on control characters & unpaired surrogates
        if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
            type = Scalar.QUOTE_DOUBLE;
    }
    const _stringify = (_type) => {
        switch (_type) {
            case Scalar.BLOCK_FOLDED:
            case Scalar.BLOCK_LITERAL:
                return implicitKey || inFlow
                    ? quotedString(ss.value, ctx) // blocks are not valid inside flow containers
                    : blockString(ss, ctx, onComment, onChompKeep);
            case Scalar.QUOTE_DOUBLE:
                return doubleQuotedString(ss.value, ctx);
            case Scalar.QUOTE_SINGLE:
                return singleQuotedString(ss.value, ctx);
            case Scalar.PLAIN:
                return plainString(ss, ctx, onComment, onChompKeep);
            default:
                return null;
        }
    };
    let res = _stringify(type);
    if (res === null) {
        const { defaultKeyType, defaultStringType } = ctx.options;
        const t = (implicitKey && defaultKeyType) || defaultStringType;
        res = _stringify(t);
        if (res === null)
            throw new Error(`Unsupported default string type ${t}`);
    }
    return res;
}

function createStringifyContext(doc, options) {
    const opt = Object.assign({
        blockQuote: true,
        commentString: stringifyComment,
        defaultKeyType: null,
        defaultStringType: 'PLAIN',
        directives: null,
        doubleQuotedAsJSON: false,
        doubleQuotedMinMultiLineLength: 40,
        falseStr: 'false',
        flowCollectionPadding: true,
        indentSeq: true,
        lineWidth: 80,
        minContentWidth: 20,
        nullStr: 'null',
        simpleKeys: false,
        singleQuote: null,
        trueStr: 'true',
        verifyAliasOrder: true
    }, doc.schema.toStringOptions, options);
    let inFlow;
    switch (opt.collectionStyle) {
        case 'block':
            inFlow = false;
            break;
        case 'flow':
            inFlow = true;
            break;
        default:
            inFlow = null;
    }
    return {
        anchors: new Set(),
        doc,
        flowCollectionPadding: opt.flowCollectionPadding ? ' ' : '',
        indent: '',
        indentStep: typeof opt.indent === 'number' ? ' '.repeat(opt.indent) : '  ',
        inFlow,
        options: opt
    };
}
function getTagObject(tags, item) {
    if (item.tag) {
        const match = tags.filter(t => t.tag === item.tag);
        if (match.length > 0)
            return match.find(t => t.format === item.format) ?? match[0];
    }
    let tagObj = undefined;
    let obj;
    if (isScalar(item)) {
        obj = item.value;
        const match = tags.filter(t => t.identify?.(obj));
        tagObj =
            match.find(t => t.format === item.format) ?? match.find(t => !t.format);
    }
    else {
        obj = item;
        tagObj = tags.find(t => t.nodeClass && obj instanceof t.nodeClass);
    }
    if (!tagObj) {
        const name = obj?.constructor?.name ?? typeof obj;
        throw new Error(`Tag not resolved for ${name} value`);
    }
    return tagObj;
}
// needs to be called before value stringifier to allow for circular anchor refs
function stringifyProps(node, tagObj, { anchors, doc }) {
    if (!doc.directives)
        return '';
    const props = [];
    const anchor = (isScalar(node) || isCollection(node)) && node.anchor;
    if (anchor && anchorIsValid(anchor)) {
        anchors.add(anchor);
        props.push(`&${anchor}`);
    }
    const tag = node.tag ? node.tag : tagObj.default ? null : tagObj.tag;
    if (tag)
        props.push(doc.directives.tagString(tag));
    return props.join(' ');
}
function stringify(item, ctx, onComment, onChompKeep) {
    if (isPair(item))
        return item.toString(ctx, onComment, onChompKeep);
    if (isAlias(item)) {
        if (ctx.doc.directives)
            return item.toString(ctx);
        if (ctx.resolvedAliases?.has(item)) {
            throw new TypeError(`Cannot stringify circular structure without alias nodes`);
        }
        else {
            if (ctx.resolvedAliases)
                ctx.resolvedAliases.add(item);
            else
                ctx.resolvedAliases = new Set([item]);
            item = item.resolve(ctx.doc);
        }
    }
    let tagObj = undefined;
    const node = isNode(item)
        ? item
        : ctx.doc.createNode(item, { onTagObj: o => (tagObj = o) });
    if (!tagObj)
        tagObj = getTagObject(ctx.doc.schema.tags, node);
    const props = stringifyProps(node, tagObj, ctx);
    if (props.length > 0)
        ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
    const str = typeof tagObj.stringify === 'function'
        ? tagObj.stringify(node, ctx, onComment, onChompKeep)
        : isScalar(node)
            ? stringifyString(node, ctx, onComment, onChompKeep)
            : node.toString(ctx, onComment, onChompKeep);
    if (!props)
        return str;
    return isScalar(node) || str[0] === '{' || str[0] === '['
        ? `${props} ${str}`
        : `${props}\n${ctx.indent}${str}`;
}

function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
    const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
    let keyComment = (isNode(key) && key.comment) || null;
    if (simpleKeys) {
        if (keyComment) {
            throw new Error('With simple keys, key nodes cannot have comments');
        }
        if (isCollection(key)) {
            const msg = 'With simple keys, collection cannot be used as a key value';
            throw new Error(msg);
        }
    }
    let explicitKey = !simpleKeys &&
        (!key ||
            (keyComment && value == null && !ctx.inFlow) ||
            isCollection(key) ||
            (isScalar(key)
                ? key.type === Scalar.BLOCK_FOLDED || key.type === Scalar.BLOCK_LITERAL
                : typeof key === 'object'));
    ctx = Object.assign({}, ctx, {
        allNullValues: false,
        implicitKey: !explicitKey && (simpleKeys || !allNullValues),
        indent: indent + indentStep
    });
    let keyCommentDone = false;
    let chompKeep = false;
    let str = stringify(key, ctx, () => (keyCommentDone = true), () => (chompKeep = true));
    if (!explicitKey && !ctx.inFlow && str.length > 1024) {
        if (simpleKeys)
            throw new Error('With simple keys, single line scalar must not span more than 1024 characters');
        explicitKey = true;
    }
    if (ctx.inFlow) {
        if (allNullValues || value == null) {
            if (keyCommentDone && onComment)
                onComment();
            return str === '' ? '?' : explicitKey ? `? ${str}` : str;
        }
    }
    else if ((allNullValues && !simpleKeys) || (value == null && explicitKey)) {
        str = `? ${str}`;
        if (keyComment && !keyCommentDone) {
            str += lineComment(str, ctx.indent, commentString(keyComment));
        }
        else if (chompKeep && onChompKeep)
            onChompKeep();
        return str;
    }
    if (keyCommentDone)
        keyComment = null;
    if (explicitKey) {
        if (keyComment)
            str += lineComment(str, ctx.indent, commentString(keyComment));
        str = `? ${str}\n${indent}:`;
    }
    else {
        str = `${str}:`;
        if (keyComment)
            str += lineComment(str, ctx.indent, commentString(keyComment));
    }
    let vsb, vcb, valueComment;
    if (isNode(value)) {
        vsb = !!value.spaceBefore;
        vcb = value.commentBefore;
        valueComment = value.comment;
    }
    else {
        vsb = false;
        vcb = null;
        valueComment = null;
        if (value && typeof value === 'object')
            value = doc.createNode(value);
    }
    ctx.implicitKey = false;
    if (!explicitKey && !keyComment && isScalar(value))
        ctx.indentAtStart = str.length + 1;
    chompKeep = false;
    if (!indentSeq &&
        indentStep.length >= 2 &&
        !ctx.inFlow &&
        !explicitKey &&
        isSeq(value) &&
        !value.flow &&
        !value.tag &&
        !value.anchor) {
        // If indentSeq === false, consider '- ' as part of indentation where possible
        ctx.indent = ctx.indent.substring(2);
    }
    let valueCommentDone = false;
    const valueStr = stringify(value, ctx, () => (valueCommentDone = true), () => (chompKeep = true));
    let ws = ' ';
    if (keyComment || vsb || vcb) {
        ws = vsb ? '\n' : '';
        if (vcb) {
            const cs = commentString(vcb);
            ws += `\n${indentComment(cs, ctx.indent)}`;
        }
        if (valueStr === '' && !ctx.inFlow) {
            if (ws === '\n')
                ws = '\n\n';
        }
        else {
            ws += `\n${ctx.indent}`;
        }
    }
    else if (!explicitKey && isCollection(value)) {
        const vs0 = valueStr[0];
        const nl0 = valueStr.indexOf('\n');
        const hasNewline = nl0 !== -1;
        const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
        if (hasNewline || !flow) {
            let hasPropsLine = false;
            if (hasNewline && (vs0 === '&' || vs0 === '!')) {
                let sp0 = valueStr.indexOf(' ');
                if (vs0 === '&' &&
                    sp0 !== -1 &&
                    sp0 < nl0 &&
                    valueStr[sp0 + 1] === '!') {
                    sp0 = valueStr.indexOf(' ', sp0 + 1);
                }
                if (sp0 === -1 || nl0 < sp0)
                    hasPropsLine = true;
            }
            if (!hasPropsLine)
                ws = `\n${ctx.indent}`;
        }
    }
    else if (valueStr === '' || valueStr[0] === '\n') {
        ws = '';
    }
    str += ws + valueStr;
    if (ctx.inFlow) {
        if (valueCommentDone && onComment)
            onComment();
    }
    else if (valueComment && !valueCommentDone) {
        str += lineComment(str, ctx.indent, commentString(valueComment));
    }
    else if (chompKeep && onChompKeep) {
        onChompKeep();
    }
    return str;
}

function warn(logLevel, warning) {
    if (logLevel === 'debug' || logLevel === 'warn') {
        // https://github.com/typescript-eslint/typescript-eslint/issues/7478
        // eslint-disable-next-line @typescript-eslint/prefer-optional-chain
        if (typeof process !== 'undefined' && process.emitWarning)
            process.emitWarning(warning);
        else
            console.warn(warning);
    }
}

const MERGE_KEY = '<<';
function addPairToJSMap(ctx, map, { key, value }) {
    if (ctx?.doc.schema.merge && isMergeKey(key)) {
        value = isAlias(value) ? value.resolve(ctx.doc) : value;
        if (isSeq(value))
            for (const it of value.items)
                mergeToJSMap(ctx, map, it);
        else if (Array.isArray(value))
            for (const it of value)
                mergeToJSMap(ctx, map, it);
        else
            mergeToJSMap(ctx, map, value);
    }
    else {
        const jsKey = toJS(key, '', ctx);
        if (map instanceof Map) {
            map.set(jsKey, toJS(value, jsKey, ctx));
        }
        else if (map instanceof Set) {
            map.add(jsKey);
        }
        else {
            const stringKey = stringifyKey(key, jsKey, ctx);
            const jsValue = toJS(value, stringKey, ctx);
            if (stringKey in map)
                Object.defineProperty(map, stringKey, {
                    value: jsValue,
                    writable: true,
                    enumerable: true,
                    configurable: true
                });
            else
                map[stringKey] = jsValue;
        }
    }
    return map;
}
const isMergeKey = (key) => key === MERGE_KEY ||
    (isScalar(key) &&
        key.value === MERGE_KEY &&
        (!key.type || key.type === Scalar.PLAIN));
// If the value associated with a merge key is a single mapping node, each of
// its key/value pairs is inserted into the current mapping, unless the key
// already exists in it. If the value associated with the merge key is a
// sequence, then this sequence is expected to contain mapping nodes and each
// of these nodes is merged in turn according to its order in the sequence.
// Keys in mapping nodes earlier in the sequence override keys specified in
// later mapping nodes. -- http://yaml.org/type/merge.html
function mergeToJSMap(ctx, map, value) {
    const source = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
    if (!isMap(source))
        throw new Error('Merge sources must be maps or map aliases');
    const srcMap = source.toJSON(null, ctx, Map);
    for (const [key, value] of srcMap) {
        if (map instanceof Map) {
            if (!map.has(key))
                map.set(key, value);
        }
        else if (map instanceof Set) {
            map.add(key);
        }
        else if (!Object.prototype.hasOwnProperty.call(map, key)) {
            Object.defineProperty(map, key, {
                value,
                writable: true,
                enumerable: true,
                configurable: true
            });
        }
    }
    return map;
}
function stringifyKey(key, jsKey, ctx) {
    if (jsKey === null)
        return '';
    if (typeof jsKey !== 'object')
        return String(jsKey);
    if (isNode(key) && ctx?.doc) {
        const strCtx = createStringifyContext(ctx.doc, {});
        strCtx.anchors = new Set();
        for (const node of ctx.anchors.keys())
            strCtx.anchors.add(node.anchor);
        strCtx.inFlow = true;
        strCtx.inStringifyKey = true;
        const strKey = key.toString(strCtx);
        if (!ctx.mapKeyWarned) {
            let jsonStr = JSON.stringify(strKey);
            if (jsonStr.length > 40)
                jsonStr = jsonStr.substring(0, 36) + '..."';
            warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
            ctx.mapKeyWarned = true;
        }
        return strKey;
    }
    return JSON.stringify(jsKey);
}

function createPair(key, value, ctx) {
    const k = createNode(key, undefined, ctx);
    const v = createNode(value, undefined, ctx);
    return new Pair(k, v);
}
class Pair {
    constructor(key, value = null) {
        Object.defineProperty(this, NODE_TYPE, { value: PAIR });
        this.key = key;
        this.value = value;
    }
    clone(schema) {
        let { key, value } = this;
        if (isNode(key))
            key = key.clone(schema);
        if (isNode(value))
            value = value.clone(schema);
        return new Pair(key, value);
    }
    toJSON(_, ctx) {
        const pair = ctx?.mapAsMap ? new Map() : {};
        return addPairToJSMap(ctx, pair, this);
    }
    toString(ctx, onComment, onChompKeep) {
        return ctx?.doc
            ? stringifyPair(this, ctx, onComment, onChompKeep)
            : JSON.stringify(this);
    }
}

function stringifyCollection(collection, ctx, options) {
    const flow = ctx.inFlow ?? collection.flow;
    const stringify = flow ? stringifyFlowCollection : stringifyBlockCollection;
    return stringify(collection, ctx, options);
}
function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
    const { indent, options: { commentString } } = ctx;
    const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
    let chompKeep = false; // flag for the preceding node's status
    const lines = [];
    for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment = null;
        if (isNode(item)) {
            if (!chompKeep && item.spaceBefore)
                lines.push('');
            addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
            if (item.comment)
                comment = item.comment;
        }
        else if (isPair(item)) {
            const ik = isNode(item.key) ? item.key : null;
            if (ik) {
                if (!chompKeep && ik.spaceBefore)
                    lines.push('');
                addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
            }
        }
        chompKeep = false;
        let str = stringify(item, itemCtx, () => (comment = null), () => (chompKeep = true));
        if (comment)
            str += lineComment(str, itemIndent, commentString(comment));
        if (chompKeep && comment)
            chompKeep = false;
        lines.push(blockItemPrefix + str);
    }
    let str;
    if (lines.length === 0) {
        str = flowChars.start + flowChars.end;
    }
    else {
        str = lines[0];
        for (let i = 1; i < lines.length; ++i) {
            const line = lines[i];
            str += line ? `\n${indent}${line}` : '\n';
        }
    }
    if (comment) {
        str += '\n' + indentComment(commentString(comment), indent);
        if (onComment)
            onComment();
    }
    else if (chompKeep && onChompKeep)
        onChompKeep();
    return str;
}
function stringifyFlowCollection({ comment, items }, ctx, { flowChars, itemIndent, onComment }) {
    const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
    itemIndent += indentStep;
    const itemCtx = Object.assign({}, ctx, {
        indent: itemIndent,
        inFlow: true,
        type: null
    });
    let reqNewline = false;
    let linesAtValue = 0;
    const lines = [];
    for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment = null;
        if (isNode(item)) {
            if (item.spaceBefore)
                lines.push('');
            addCommentBefore(ctx, lines, item.commentBefore, false);
            if (item.comment)
                comment = item.comment;
        }
        else if (isPair(item)) {
            const ik = isNode(item.key) ? item.key : null;
            if (ik) {
                if (ik.spaceBefore)
                    lines.push('');
                addCommentBefore(ctx, lines, ik.commentBefore, false);
                if (ik.comment)
                    reqNewline = true;
            }
            const iv = isNode(item.value) ? item.value : null;
            if (iv) {
                if (iv.comment)
                    comment = iv.comment;
                if (iv.commentBefore)
                    reqNewline = true;
            }
            else if (item.value == null && ik?.comment) {
                comment = ik.comment;
            }
        }
        if (comment)
            reqNewline = true;
        let str = stringify(item, itemCtx, () => (comment = null));
        if (i < items.length - 1)
            str += ',';
        if (comment)
            str += lineComment(str, itemIndent, commentString(comment));
        if (!reqNewline && (lines.length > linesAtValue || str.includes('\n')))
            reqNewline = true;
        lines.push(str);
        linesAtValue = lines.length;
    }
    let str;
    const { start, end } = flowChars;
    if (lines.length === 0) {
        str = start + end;
    }
    else {
        if (!reqNewline) {
            const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
            reqNewline = len > Collection.maxFlowStringSingleLineLength;
        }
        if (reqNewline) {
            str = start;
            for (const line of lines)
                str += line ? `\n${indentStep}${indent}${line}` : '\n';
            str += `\n${indent}${end}`;
        }
        else {
            str = `${start}${fcPadding}${lines.join(' ')}${fcPadding}${end}`;
        }
    }
    if (comment) {
        str += lineComment(str, indent, commentString(comment));
        if (onComment)
            onComment();
    }
    return str;
}
function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
    if (comment && chompKeep)
        comment = comment.replace(/^\n+/, '');
    if (comment) {
        const ic = indentComment(commentString(comment), indent);
        lines.push(ic.trimStart()); // Avoid double indent on first line
    }
}

function findPair(items, key) {
    const k = isScalar(key) ? key.value : key;
    for (const it of items) {
        if (isPair(it)) {
            if (it.key === key || it.key === k)
                return it;
            if (isScalar(it.key) && it.key.value === k)
                return it;
        }
    }
    return undefined;
}
class YAMLMap extends Collection {
    static get tagName() {
        return 'tag:yaml.org,2002:map';
    }
    constructor(schema) {
        super(MAP, schema);
        this.items = [];
    }
    /**
     * A generic collection parsing method that can be extended
     * to other node classes that inherit from YAMLMap
     */
    static from(schema, obj, ctx) {
        const { keepUndefined, replacer } = ctx;
        const map = new this(schema);
        const add = (key, value) => {
            if (typeof replacer === 'function')
                value = replacer.call(obj, key, value);
            else if (Array.isArray(replacer) && !replacer.includes(key))
                return;
            if (value !== undefined || keepUndefined)
                map.items.push(createPair(key, value, ctx));
        };
        if (obj instanceof Map) {
            for (const [key, value] of obj)
                add(key, value);
        }
        else if (obj && typeof obj === 'object') {
            for (const key of Object.keys(obj))
                add(key, obj[key]);
        }
        if (typeof schema.sortMapEntries === 'function') {
            map.items.sort(schema.sortMapEntries);
        }
        return map;
    }
    /**
     * Adds a value to the collection.
     *
     * @param overwrite - If not set `true`, using a key that is already in the
     *   collection will throw. Otherwise, overwrites the previous value.
     */
    add(pair, overwrite) {
        let _pair;
        if (isPair(pair))
            _pair = pair;
        else if (!pair || typeof pair !== 'object' || !('key' in pair)) {
            // In TypeScript, this never happens.
            _pair = new Pair(pair, pair?.value);
        }
        else
            _pair = new Pair(pair.key, pair.value);
        const prev = findPair(this.items, _pair.key);
        const sortEntries = this.schema?.sortMapEntries;
        if (prev) {
            if (!overwrite)
                throw new Error(`Key ${_pair.key} already set`);
            // For scalars, keep the old node & its comments and anchors
            if (isScalar(prev.value) && isScalarValue(_pair.value))
                prev.value.value = _pair.value;
            else
                prev.value = _pair.value;
        }
        else if (sortEntries) {
            const i = this.items.findIndex(item => sortEntries(_pair, item) < 0);
            if (i === -1)
                this.items.push(_pair);
            else
                this.items.splice(i, 0, _pair);
        }
        else {
            this.items.push(_pair);
        }
    }
    delete(key) {
        const it = findPair(this.items, key);
        if (!it)
            return false;
        const del = this.items.splice(this.items.indexOf(it), 1);
        return del.length > 0;
    }
    get(key, keepScalar) {
        const it = findPair(this.items, key);
        const node = it?.value;
        return (!keepScalar && isScalar(node) ? node.value : node) ?? undefined;
    }
    has(key) {
        return !!findPair(this.items, key);
    }
    set(key, value) {
        this.add(new Pair(key, value), true);
    }
    /**
     * @param ctx - Conversion context, originally set in Document#toJS()
     * @param {Class} Type - If set, forces the returned collection type
     * @returns Instance of Type, Map, or Object
     */
    toJSON(_, ctx, Type) {
        const map = Type ? new Type() : ctx?.mapAsMap ? new Map() : {};
        if (ctx?.onCreate)
            ctx.onCreate(map);
        for (const item of this.items)
            addPairToJSMap(ctx, map, item);
        return map;
    }
    toString(ctx, onComment, onChompKeep) {
        if (!ctx)
            return JSON.stringify(this);
        for (const item of this.items) {
            if (!isPair(item))
                throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
        }
        if (!ctx.allNullValues && this.hasAllNullValues(false))
            ctx = Object.assign({}, ctx, { allNullValues: true });
        return stringifyCollection(this, ctx, {
            blockItemPrefix: '',
            flowChars: { start: '{', end: '}' },
            itemIndent: ctx.indent || '',
            onChompKeep,
            onComment
        });
    }
}

const map = {
    collection: 'map',
    default: true,
    nodeClass: YAMLMap,
    tag: 'tag:yaml.org,2002:map',
    resolve(map, onError) {
        if (!isMap(map))
            onError('Expected a mapping for this tag');
        return map;
    },
    createNode: (schema, obj, ctx) => YAMLMap.from(schema, obj, ctx)
};

class YAMLSeq extends Collection {
    static get tagName() {
        return 'tag:yaml.org,2002:seq';
    }
    constructor(schema) {
        super(SEQ, schema);
        this.items = [];
    }
    add(value) {
        this.items.push(value);
    }
    /**
     * Removes a value from the collection.
     *
     * `key` must contain a representation of an integer for this to succeed.
     * It may be wrapped in a `Scalar`.
     *
     * @returns `true` if the item was found and removed.
     */
    delete(key) {
        const idx = asItemIndex(key);
        if (typeof idx !== 'number')
            return false;
        const del = this.items.splice(idx, 1);
        return del.length > 0;
    }
    get(key, keepScalar) {
        const idx = asItemIndex(key);
        if (typeof idx !== 'number')
            return undefined;
        const it = this.items[idx];
        return !keepScalar && isScalar(it) ? it.value : it;
    }
    /**
     * Checks if the collection includes a value with the key `key`.
     *
     * `key` must contain a representation of an integer for this to succeed.
     * It may be wrapped in a `Scalar`.
     */
    has(key) {
        const idx = asItemIndex(key);
        return typeof idx === 'number' && idx < this.items.length;
    }
    /**
     * Sets a value in this collection. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     *
     * If `key` does not contain a representation of an integer, this will throw.
     * It may be wrapped in a `Scalar`.
     */
    set(key, value) {
        const idx = asItemIndex(key);
        if (typeof idx !== 'number')
            throw new Error(`Expected a valid index, not ${key}.`);
        const prev = this.items[idx];
        if (isScalar(prev) && isScalarValue(value))
            prev.value = value;
        else
            this.items[idx] = value;
    }
    toJSON(_, ctx) {
        const seq = [];
        if (ctx?.onCreate)
            ctx.onCreate(seq);
        let i = 0;
        for (const item of this.items)
            seq.push(toJS(item, String(i++), ctx));
        return seq;
    }
    toString(ctx, onComment, onChompKeep) {
        if (!ctx)
            return JSON.stringify(this);
        return stringifyCollection(this, ctx, {
            blockItemPrefix: '- ',
            flowChars: { start: '[', end: ']' },
            itemIndent: (ctx.indent || '') + '  ',
            onChompKeep,
            onComment
        });
    }
    static from(schema, obj, ctx) {
        const { replacer } = ctx;
        const seq = new this(schema);
        if (obj && Symbol.iterator in Object(obj)) {
            let i = 0;
            for (let it of obj) {
                if (typeof replacer === 'function') {
                    const key = obj instanceof Set ? it : String(i++);
                    it = replacer.call(obj, key, it);
                }
                seq.items.push(createNode(it, undefined, ctx));
            }
        }
        return seq;
    }
}
function asItemIndex(key) {
    let idx = isScalar(key) ? key.value : key;
    if (idx && typeof idx === 'string')
        idx = Number(idx);
    return typeof idx === 'number' && Number.isInteger(idx) && idx >= 0
        ? idx
        : null;
}

const seq = {
    collection: 'seq',
    default: true,
    nodeClass: YAMLSeq,
    tag: 'tag:yaml.org,2002:seq',
    resolve(seq, onError) {
        if (!isSeq(seq))
            onError('Expected a sequence for this tag');
        return seq;
    },
    createNode: (schema, obj, ctx) => YAMLSeq.from(schema, obj, ctx)
};

const string$2 = {
    identify: value => typeof value === 'string',
    default: true,
    tag: 'tag:yaml.org,2002:str',
    resolve: str => str,
    stringify(item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({ actualString: true }, ctx);
        return stringifyString(item, ctx, onComment, onChompKeep);
    }
};

const nullTag = {
    identify: value => value == null,
    createNode: () => new Scalar(null),
    default: true,
    tag: 'tag:yaml.org,2002:null',
    test: /^(?:~|[Nn]ull|NULL)?$/,
    resolve: () => new Scalar(null),
    stringify: ({ source }, ctx) => typeof source === 'string' && nullTag.test.test(source)
        ? source
        : ctx.options.nullStr
};

const boolTag = {
    identify: value => typeof value === 'boolean',
    default: true,
    tag: 'tag:yaml.org,2002:bool',
    test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
    resolve: str => new Scalar(str[0] === 't' || str[0] === 'T'),
    stringify({ source, value }, ctx) {
        if (source && boolTag.test.test(source)) {
            const sv = source[0] === 't' || source[0] === 'T';
            if (value === sv)
                return source;
        }
        return value ? ctx.options.trueStr : ctx.options.falseStr;
    }
};

function stringifyNumber({ format, minFractionDigits, tag, value }) {
    if (typeof value === 'bigint')
        return String(value);
    const num = typeof value === 'number' ? value : Number(value);
    if (!isFinite(num))
        return isNaN(num) ? '.nan' : num < 0 ? '-.inf' : '.inf';
    let n = JSON.stringify(value);
    if (!format &&
        minFractionDigits &&
        (!tag || tag === 'tag:yaml.org,2002:float') &&
        /^\d/.test(n)) {
        let i = n.indexOf('.');
        if (i < 0) {
            i = n.length;
            n += '.';
        }
        let d = minFractionDigits - (n.length - i - 1);
        while (d-- > 0)
            n += '0';
    }
    return n;
}

const floatNaN$1 = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    test: /^(?:[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN))$/,
    resolve: str => str.slice(-3).toLowerCase() === 'nan'
        ? NaN
        : str[0] === '-'
            ? Number.NEGATIVE_INFINITY
            : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber
};
const floatExp$1 = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    format: 'EXP',
    test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
    resolve: str => parseFloat(str),
    stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber(node);
    }
};
const float$1 = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
    resolve(str) {
        const node = new Scalar(parseFloat(str));
        const dot = str.indexOf('.');
        if (dot !== -1 && str[str.length - 1] === '0')
            node.minFractionDigits = str.length - dot - 1;
        return node;
    },
    stringify: stringifyNumber
};

const intIdentify$2 = (value) => typeof value === 'bigint' || Number.isInteger(value);
const intResolve$1 = (str, offset, radix, { intAsBigInt }) => (intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix));
function intStringify$1(node, radix, prefix) {
    const { value } = node;
    if (intIdentify$2(value) && value >= 0)
        return prefix + value.toString(radix);
    return stringifyNumber(node);
}
const intOct$1 = {
    identify: value => intIdentify$2(value) && value >= 0,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'OCT',
    test: /^0o[0-7]+$/,
    resolve: (str, _onError, opt) => intResolve$1(str, 2, 8, opt),
    stringify: node => intStringify$1(node, 8, '0o')
};
const int$1 = {
    identify: intIdentify$2,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    test: /^[-+]?[0-9]+$/,
    resolve: (str, _onError, opt) => intResolve$1(str, 0, 10, opt),
    stringify: stringifyNumber
};
const intHex$1 = {
    identify: value => intIdentify$2(value) && value >= 0,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'HEX',
    test: /^0x[0-9a-fA-F]+$/,
    resolve: (str, _onError, opt) => intResolve$1(str, 2, 16, opt),
    stringify: node => intStringify$1(node, 16, '0x')
};

const schema$2 = [
    map,
    seq,
    string$2,
    nullTag,
    boolTag,
    intOct$1,
    int$1,
    intHex$1,
    floatNaN$1,
    floatExp$1,
    float$1
];

function intIdentify$1(value) {
    return typeof value === 'bigint' || Number.isInteger(value);
}
const stringifyJSON = ({ value }) => JSON.stringify(value);
const jsonScalars = [
    {
        identify: value => typeof value === 'string',
        default: true,
        tag: 'tag:yaml.org,2002:str',
        resolve: str => str,
        stringify: stringifyJSON
    },
    {
        identify: value => value == null,
        createNode: () => new Scalar(null),
        default: true,
        tag: 'tag:yaml.org,2002:null',
        test: /^null$/,
        resolve: () => null,
        stringify: stringifyJSON
    },
    {
        identify: value => typeof value === 'boolean',
        default: true,
        tag: 'tag:yaml.org,2002:bool',
        test: /^true|false$/,
        resolve: str => str === 'true',
        stringify: stringifyJSON
    },
    {
        identify: intIdentify$1,
        default: true,
        tag: 'tag:yaml.org,2002:int',
        test: /^-?(?:0|[1-9][0-9]*)$/,
        resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
        stringify: ({ value }) => intIdentify$1(value) ? value.toString() : JSON.stringify(value)
    },
    {
        identify: value => typeof value === 'number',
        default: true,
        tag: 'tag:yaml.org,2002:float',
        test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
        resolve: str => parseFloat(str),
        stringify: stringifyJSON
    }
];
const jsonError = {
    default: true,
    tag: '',
    test: /^/,
    resolve(str, onError) {
        onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
        return str;
    }
};
const schema$1 = [map, seq].concat(jsonScalars, jsonError);

const binary = {
    identify: value => value instanceof Uint8Array,
    default: false,
    tag: 'tag:yaml.org,2002:binary',
    /**
     * Returns a Buffer in node and an Uint8Array in browsers
     *
     * To use the resulting buffer as an image, you'll want to do something like:
     *
     *   const blob = new Blob([buffer], { type: 'image/jpeg' })
     *   document.querySelector('#photo').src = URL.createObjectURL(blob)
     */
    resolve(src, onError) {
        if (typeof Buffer === 'function') {
            return Buffer.from(src, 'base64');
        }
        else if (typeof atob === 'function') {
            // On IE 11, atob() can't handle newlines
            const str = atob(src.replace(/[\n\r]/g, ''));
            const buffer = new Uint8Array(str.length);
            for (let i = 0; i < str.length; ++i)
                buffer[i] = str.charCodeAt(i);
            return buffer;
        }
        else {
            onError('This environment does not support reading binary tags; either Buffer or atob is required');
            return src;
        }
    },
    stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
        const buf = value; // checked earlier by binary.identify()
        let str;
        if (typeof Buffer === 'function') {
            str =
                buf instanceof Buffer
                    ? buf.toString('base64')
                    : Buffer.from(buf.buffer).toString('base64');
        }
        else if (typeof btoa === 'function') {
            let s = '';
            for (let i = 0; i < buf.length; ++i)
                s += String.fromCharCode(buf[i]);
            str = btoa(s);
        }
        else {
            throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');
        }
        if (!type)
            type = Scalar.BLOCK_LITERAL;
        if (type !== Scalar.QUOTE_DOUBLE) {
            const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
            const n = Math.ceil(str.length / lineWidth);
            const lines = new Array(n);
            for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
                lines[i] = str.substr(o, lineWidth);
            }
            str = lines.join(type === Scalar.BLOCK_LITERAL ? '\n' : ' ');
        }
        return stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
    }
};

function resolvePairs(seq, onError) {
    if (isSeq(seq)) {
        for (let i = 0; i < seq.items.length; ++i) {
            let item = seq.items[i];
            if (isPair(item))
                continue;
            else if (isMap(item)) {
                if (item.items.length > 1)
                    onError('Each pair must have its own sequence indicator');
                const pair = item.items[0] || new Pair(new Scalar(null));
                if (item.commentBefore)
                    pair.key.commentBefore = pair.key.commentBefore
                        ? `${item.commentBefore}\n${pair.key.commentBefore}`
                        : item.commentBefore;
                if (item.comment) {
                    const cn = pair.value ?? pair.key;
                    cn.comment = cn.comment
                        ? `${item.comment}\n${cn.comment}`
                        : item.comment;
                }
                item = pair;
            }
            seq.items[i] = isPair(item) ? item : new Pair(item);
        }
    }
    else
        onError('Expected a sequence for this tag');
    return seq;
}
function createPairs(schema, iterable, ctx) {
    const { replacer } = ctx;
    const pairs = new YAMLSeq(schema);
    pairs.tag = 'tag:yaml.org,2002:pairs';
    let i = 0;
    if (iterable && Symbol.iterator in Object(iterable))
        for (let it of iterable) {
            if (typeof replacer === 'function')
                it = replacer.call(iterable, String(i++), it);
            let key, value;
            if (Array.isArray(it)) {
                if (it.length === 2) {
                    key = it[0];
                    value = it[1];
                }
                else
                    throw new TypeError(`Expected [key, value] tuple: ${it}`);
            }
            else if (it && it instanceof Object) {
                const keys = Object.keys(it);
                if (keys.length === 1) {
                    key = keys[0];
                    value = it[key];
                }
                else {
                    throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
                }
            }
            else {
                key = it;
            }
            pairs.items.push(createPair(key, value, ctx));
        }
    return pairs;
}
const pairs = {
    collection: 'seq',
    default: false,
    tag: 'tag:yaml.org,2002:pairs',
    resolve: resolvePairs,
    createNode: createPairs
};

class YAMLOMap extends YAMLSeq {
    constructor() {
        super();
        this.add = YAMLMap.prototype.add.bind(this);
        this.delete = YAMLMap.prototype.delete.bind(this);
        this.get = YAMLMap.prototype.get.bind(this);
        this.has = YAMLMap.prototype.has.bind(this);
        this.set = YAMLMap.prototype.set.bind(this);
        this.tag = YAMLOMap.tag;
    }
    /**
     * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
     * but TypeScript won't allow widening the signature of a child method.
     */
    toJSON(_, ctx) {
        if (!ctx)
            return super.toJSON(_);
        const map = new Map();
        if (ctx?.onCreate)
            ctx.onCreate(map);
        for (const pair of this.items) {
            let key, value;
            if (isPair(pair)) {
                key = toJS(pair.key, '', ctx);
                value = toJS(pair.value, key, ctx);
            }
            else {
                key = toJS(pair, '', ctx);
            }
            if (map.has(key))
                throw new Error('Ordered maps must not include duplicate keys');
            map.set(key, value);
        }
        return map;
    }
    static from(schema, iterable, ctx) {
        const pairs = createPairs(schema, iterable, ctx);
        const omap = new this();
        omap.items = pairs.items;
        return omap;
    }
}
YAMLOMap.tag = 'tag:yaml.org,2002:omap';
const omap = {
    collection: 'seq',
    identify: value => value instanceof Map,
    nodeClass: YAMLOMap,
    default: false,
    tag: 'tag:yaml.org,2002:omap',
    resolve(seq, onError) {
        const pairs = resolvePairs(seq, onError);
        const seenKeys = [];
        for (const { key } of pairs.items) {
            if (isScalar(key)) {
                if (seenKeys.includes(key.value)) {
                    onError(`Ordered maps must not include duplicate keys: ${key.value}`);
                }
                else {
                    seenKeys.push(key.value);
                }
            }
        }
        return Object.assign(new YAMLOMap(), pairs);
    },
    createNode: (schema, iterable, ctx) => YAMLOMap.from(schema, iterable, ctx)
};

function boolStringify({ value, source }, ctx) {
    const boolObj = value ? trueTag : falseTag;
    if (source && boolObj.test.test(source))
        return source;
    return value ? ctx.options.trueStr : ctx.options.falseStr;
}
const trueTag = {
    identify: value => value === true,
    default: true,
    tag: 'tag:yaml.org,2002:bool',
    test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
    resolve: () => new Scalar(true),
    stringify: boolStringify
};
const falseTag = {
    identify: value => value === false,
    default: true,
    tag: 'tag:yaml.org,2002:bool',
    test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
    resolve: () => new Scalar(false),
    stringify: boolStringify
};

const floatNaN = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    test: /^[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN)$/,
    resolve: (str) => str.slice(-3).toLowerCase() === 'nan'
        ? NaN
        : str[0] === '-'
            ? Number.NEGATIVE_INFINITY
            : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber
};
const floatExp = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    format: 'EXP',
    test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
    resolve: (str) => parseFloat(str.replace(/_/g, '')),
    stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber(node);
    }
};
const float = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
    resolve(str) {
        const node = new Scalar(parseFloat(str.replace(/_/g, '')));
        const dot = str.indexOf('.');
        if (dot !== -1) {
            const f = str.substring(dot + 1).replace(/_/g, '');
            if (f[f.length - 1] === '0')
                node.minFractionDigits = f.length;
        }
        return node;
    },
    stringify: stringifyNumber
};

const intIdentify = (value) => typeof value === 'bigint' || Number.isInteger(value);
function intResolve(str, offset, radix, { intAsBigInt }) {
    const sign = str[0];
    if (sign === '-' || sign === '+')
        offset += 1;
    str = str.substring(offset).replace(/_/g, '');
    if (intAsBigInt) {
        switch (radix) {
            case 2:
                str = `0b${str}`;
                break;
            case 8:
                str = `0o${str}`;
                break;
            case 16:
                str = `0x${str}`;
                break;
        }
        const n = BigInt(str);
        return sign === '-' ? BigInt(-1) * n : n;
    }
    const n = parseInt(str, radix);
    return sign === '-' ? -1 * n : n;
}
function intStringify(node, radix, prefix) {
    const { value } = node;
    if (intIdentify(value)) {
        const str = value.toString(radix);
        return value < 0 ? '-' + prefix + str.substr(1) : prefix + str;
    }
    return stringifyNumber(node);
}
const intBin = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'BIN',
    test: /^[-+]?0b[0-1_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
    stringify: node => intStringify(node, 2, '0b')
};
const intOct = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'OCT',
    test: /^[-+]?0[0-7_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
    stringify: node => intStringify(node, 8, '0')
};
const int = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    test: /^[-+]?[0-9][0-9_]*$/,
    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
    stringify: stringifyNumber
};
const intHex = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'HEX',
    test: /^[-+]?0x[0-9a-fA-F_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
    stringify: node => intStringify(node, 16, '0x')
};

class YAMLSet extends YAMLMap {
    constructor(schema) {
        super(schema);
        this.tag = YAMLSet.tag;
    }
    add(key) {
        let pair;
        if (isPair(key))
            pair = key;
        else if (key &&
            typeof key === 'object' &&
            'key' in key &&
            'value' in key &&
            key.value === null)
            pair = new Pair(key.key, null);
        else
            pair = new Pair(key, null);
        const prev = findPair(this.items, pair.key);
        if (!prev)
            this.items.push(pair);
    }
    /**
     * If `keepPair` is `true`, returns the Pair matching `key`.
     * Otherwise, returns the value of that Pair's key.
     */
    get(key, keepPair) {
        const pair = findPair(this.items, key);
        return !keepPair && isPair(pair)
            ? isScalar(pair.key)
                ? pair.key.value
                : pair.key
            : pair;
    }
    set(key, value) {
        if (typeof value !== 'boolean')
            throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
        const prev = findPair(this.items, key);
        if (prev && !value) {
            this.items.splice(this.items.indexOf(prev), 1);
        }
        else if (!prev && value) {
            this.items.push(new Pair(key));
        }
    }
    toJSON(_, ctx) {
        return super.toJSON(_, ctx, Set);
    }
    toString(ctx, onComment, onChompKeep) {
        if (!ctx)
            return JSON.stringify(this);
        if (this.hasAllNullValues(true))
            return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
        else
            throw new Error('Set items must all have null values');
    }
    static from(schema, iterable, ctx) {
        const { replacer } = ctx;
        const set = new this(schema);
        if (iterable && Symbol.iterator in Object(iterable))
            for (let value of iterable) {
                if (typeof replacer === 'function')
                    value = replacer.call(iterable, value, value);
                set.items.push(createPair(value, null, ctx));
            }
        return set;
    }
}
YAMLSet.tag = 'tag:yaml.org,2002:set';
const set = {
    collection: 'map',
    identify: value => value instanceof Set,
    nodeClass: YAMLSet,
    default: false,
    tag: 'tag:yaml.org,2002:set',
    createNode: (schema, iterable, ctx) => YAMLSet.from(schema, iterable, ctx),
    resolve(map, onError) {
        if (isMap(map)) {
            if (map.hasAllNullValues(true))
                return Object.assign(new YAMLSet(), map);
            else
                onError('Set items must all have null values');
        }
        else
            onError('Expected a mapping for this tag');
        return map;
    }
};

/** Internal types handle bigint as number, because TS can't figure it out. */
function parseSexagesimal(str, asBigInt) {
    const sign = str[0];
    const parts = sign === '-' || sign === '+' ? str.substring(1) : str;
    const num = (n) => asBigInt ? BigInt(n) : Number(n);
    const res = parts
        .replace(/_/g, '')
        .split(':')
        .reduce((res, p) => res * num(60) + num(p), num(0));
    return (sign === '-' ? num(-1) * res : res);
}
/**
 * hhhh:mm:ss.sss
 *
 * Internal types handle bigint as number, because TS can't figure it out.
 */
function stringifySexagesimal(node) {
    let { value } = node;
    let num = (n) => n;
    if (typeof value === 'bigint')
        num = n => BigInt(n);
    else if (isNaN(value) || !isFinite(value))
        return stringifyNumber(node);
    let sign = '';
    if (value < 0) {
        sign = '-';
        value *= num(-1);
    }
    const _60 = num(60);
    const parts = [value % _60]; // seconds, including ms
    if (value < 60) {
        parts.unshift(0); // at least one : is required
    }
    else {
        value = (value - parts[0]) / _60;
        parts.unshift(value % _60); // minutes
        if (value >= 60) {
            value = (value - parts[0]) / _60;
            parts.unshift(value); // hours
        }
    }
    return (sign +
        parts
            .map(n => String(n).padStart(2, '0'))
            .join(':')
            .replace(/000000\d*$/, '') // % 60 may introduce error
    );
}
const intTime = {
    identify: value => typeof value === 'bigint' || Number.isInteger(value),
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'TIME',
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
    resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
    stringify: stringifySexagesimal
};
const floatTime = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    format: 'TIME',
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
    resolve: str => parseSexagesimal(str, false),
    stringify: stringifySexagesimal
};
const timestamp = {
    identify: value => value instanceof Date,
    default: true,
    tag: 'tag:yaml.org,2002:timestamp',
    // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
    // may be omitted altogether, resulting in a date format. In such a case, the time part is
    // assumed to be 00:00:00Z (start of day, UTC).
    test: RegExp('^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})' + // YYYY-Mm-Dd
        '(?:' + // time is optional
        '(?:t|T|[ \\t]+)' + // t | T | whitespace
        '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)' + // Hh:Mm:Ss(.ss)?
        '(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?' + // Z | +5 | -03:30
        ')?$'),
    resolve(str) {
        const match = str.match(timestamp.test);
        if (!match)
            throw new Error('!!timestamp expects a date, starting with yyyy-mm-dd');
        const [, year, month, day, hour, minute, second] = match.map(Number);
        const millisec = match[7] ? Number((match[7] + '00').substr(1, 3)) : 0;
        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
        const tz = match[8];
        if (tz && tz !== 'Z') {
            let d = parseSexagesimal(tz, false);
            if (Math.abs(d) < 30)
                d *= 60;
            date -= 60000 * d;
        }
        return new Date(date);
    },
    stringify: ({ value }) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, '')
};

const schema = [
    map,
    seq,
    string$2,
    nullTag,
    trueTag,
    falseTag,
    intBin,
    intOct,
    int,
    intHex,
    floatNaN,
    floatExp,
    float,
    binary,
    omap,
    pairs,
    set,
    intTime,
    floatTime,
    timestamp
];

const schemas = new Map([
    ['core', schema$2],
    ['failsafe', [map, seq, string$2]],
    ['json', schema$1],
    ['yaml11', schema],
    ['yaml-1.1', schema]
]);
const tagsByName = {
    binary,
    bool: boolTag,
    float: float$1,
    floatExp: floatExp$1,
    floatNaN: floatNaN$1,
    floatTime,
    int: int$1,
    intHex: intHex$1,
    intOct: intOct$1,
    intTime,
    map,
    null: nullTag,
    omap,
    pairs,
    seq,
    set,
    timestamp
};
const coreKnownTags = {
    'tag:yaml.org,2002:binary': binary,
    'tag:yaml.org,2002:omap': omap,
    'tag:yaml.org,2002:pairs': pairs,
    'tag:yaml.org,2002:set': set,
    'tag:yaml.org,2002:timestamp': timestamp
};
function getTags$1(customTags, schemaName) {
    let tags = schemas.get(schemaName);
    if (!tags) {
        if (Array.isArray(customTags))
            tags = [];
        else {
            const keys = Array.from(schemas.keys())
                .filter(key => key !== 'yaml11')
                .map(key => JSON.stringify(key))
                .join(', ');
            throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
        }
    }
    if (Array.isArray(customTags)) {
        for (const tag of customTags)
            tags = tags.concat(tag);
    }
    else if (typeof customTags === 'function') {
        tags = customTags(tags.slice());
    }
    return tags.map(tag => {
        if (typeof tag !== 'string')
            return tag;
        const tagObj = tagsByName[tag];
        if (tagObj)
            return tagObj;
        const keys = Object.keys(tagsByName)
            .map(key => JSON.stringify(key))
            .join(', ');
        throw new Error(`Unknown custom tag "${tag}"; use one of ${keys}`);
    });
}

const sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
class Schema {
    constructor({ compat, customTags, merge, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {
        this.compat = Array.isArray(compat)
            ? getTags$1(compat, 'compat')
            : compat
                ? getTags$1(null, compat)
                : null;
        this.merge = !!merge;
        this.name = (typeof schema === 'string' && schema) || 'core';
        this.knownTags = resolveKnownTags ? coreKnownTags : {};
        this.tags = getTags$1(customTags, this.name);
        this.toStringOptions = toStringDefaults ?? null;
        Object.defineProperty(this, MAP, { value: map });
        Object.defineProperty(this, SCALAR$1, { value: string$2 });
        Object.defineProperty(this, SEQ, { value: seq });
        // Used by createMap()
        this.sortMapEntries =
            typeof sortMapEntries === 'function'
                ? sortMapEntries
                : sortMapEntries === true
                    ? sortMapEntriesByKey
                    : null;
    }
    clone() {
        const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
        copy.tags = this.tags.slice();
        return copy;
    }
}

function stringifyDocument(doc, options) {
    const lines = [];
    let hasDirectives = options.directives === true;
    if (options.directives !== false && doc.directives) {
        const dir = doc.directives.toString(doc);
        if (dir) {
            lines.push(dir);
            hasDirectives = true;
        }
        else if (doc.directives.docStart)
            hasDirectives = true;
    }
    if (hasDirectives)
        lines.push('---');
    const ctx = createStringifyContext(doc, options);
    const { commentString } = ctx.options;
    if (doc.commentBefore) {
        if (lines.length !== 1)
            lines.unshift('');
        const cs = commentString(doc.commentBefore);
        lines.unshift(indentComment(cs, ''));
    }
    let chompKeep = false;
    let contentComment = null;
    if (doc.contents) {
        if (isNode(doc.contents)) {
            if (doc.contents.spaceBefore && hasDirectives)
                lines.push('');
            if (doc.contents.commentBefore) {
                const cs = commentString(doc.contents.commentBefore);
                lines.push(indentComment(cs, ''));
            }
            // top-level block scalars need to be indented if followed by a comment
            ctx.forceBlockIndent = !!doc.comment;
            contentComment = doc.contents.comment;
        }
        const onChompKeep = contentComment ? undefined : () => (chompKeep = true);
        let body = stringify(doc.contents, ctx, () => (contentComment = null), onChompKeep);
        if (contentComment)
            body += lineComment(body, '', commentString(contentComment));
        if ((body[0] === '|' || body[0] === '>') &&
            lines[lines.length - 1] === '---') {
            // Top-level block scalars with a preceding doc marker ought to use the
            // same line for their header.
            lines[lines.length - 1] = `--- ${body}`;
        }
        else
            lines.push(body);
    }
    else {
        lines.push(stringify(doc.contents, ctx));
    }
    if (doc.directives?.docEnd) {
        if (doc.comment) {
            const cs = commentString(doc.comment);
            if (cs.includes('\n')) {
                lines.push('...');
                lines.push(indentComment(cs, ''));
            }
            else {
                lines.push(`... ${cs}`);
            }
        }
        else {
            lines.push('...');
        }
    }
    else {
        let dc = doc.comment;
        if (dc && chompKeep)
            dc = dc.replace(/^\n+/, '');
        if (dc) {
            if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '')
                lines.push('');
            lines.push(indentComment(commentString(dc), ''));
        }
    }
    return lines.join('\n') + '\n';
}

class Document {
    constructor(value, replacer, options) {
        /** A comment before this Document */
        this.commentBefore = null;
        /** A comment immediately after this Document */
        this.comment = null;
        /** Errors encountered during parsing. */
        this.errors = [];
        /** Warnings encountered during parsing. */
        this.warnings = [];
        Object.defineProperty(this, NODE_TYPE, { value: DOC });
        let _replacer = null;
        if (typeof replacer === 'function' || Array.isArray(replacer)) {
            _replacer = replacer;
        }
        else if (options === undefined && replacer) {
            options = replacer;
            replacer = undefined;
        }
        const opt = Object.assign({
            intAsBigInt: false,
            keepSourceTokens: false,
            logLevel: 'warn',
            prettyErrors: true,
            strict: true,
            uniqueKeys: true,
            version: '1.2'
        }, options);
        this.options = opt;
        let { version } = opt;
        if (options?._directives) {
            this.directives = options._directives.atDocument();
            if (this.directives.yaml.explicit)
                version = this.directives.yaml.version;
        }
        else
            this.directives = new Directives({ version });
        this.setSchema(version, options);
        // @ts-expect-error We can't really know that this matches Contents.
        this.contents =
            value === undefined ? null : this.createNode(value, _replacer, options);
    }
    /**
     * Create a deep copy of this Document and its contents.
     *
     * Custom Node values that inherit from `Object` still refer to their original instances.
     */
    clone() {
        const copy = Object.create(Document.prototype, {
            [NODE_TYPE]: { value: DOC }
        });
        copy.commentBefore = this.commentBefore;
        copy.comment = this.comment;
        copy.errors = this.errors.slice();
        copy.warnings = this.warnings.slice();
        copy.options = Object.assign({}, this.options);
        if (this.directives)
            copy.directives = this.directives.clone();
        copy.schema = this.schema.clone();
        // @ts-expect-error We can't really know that this matches Contents.
        copy.contents = isNode(this.contents)
            ? this.contents.clone(copy.schema)
            : this.contents;
        if (this.range)
            copy.range = this.range.slice();
        return copy;
    }
    /** Adds a value to the document. */
    add(value) {
        if (assertCollection(this.contents))
            this.contents.add(value);
    }
    /** Adds a value to the document. */
    addIn(path, value) {
        if (assertCollection(this.contents))
            this.contents.addIn(path, value);
    }
    /**
     * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
     *
     * If `node` already has an anchor, `name` is ignored.
     * Otherwise, the `node.anchor` value will be set to `name`,
     * or if an anchor with that name is already present in the document,
     * `name` will be used as a prefix for a new unique anchor.
     * If `name` is undefined, the generated anchor will use 'a' as a prefix.
     */
    createAlias(node, name) {
        if (!node.anchor) {
            const prev = anchorNames(this);
            node.anchor =
                // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
                !name || prev.has(name) ? findNewAnchor(name || 'a', prev) : name;
        }
        return new Alias(node.anchor);
    }
    createNode(value, replacer, options) {
        let _replacer = undefined;
        if (typeof replacer === 'function') {
            value = replacer.call({ '': value }, '', value);
            _replacer = replacer;
        }
        else if (Array.isArray(replacer)) {
            const keyToStr = (v) => typeof v === 'number' || v instanceof String || v instanceof Number;
            const asStr = replacer.filter(keyToStr).map(String);
            if (asStr.length > 0)
                replacer = replacer.concat(asStr);
            _replacer = replacer;
        }
        else if (options === undefined && replacer) {
            options = replacer;
            replacer = undefined;
        }
        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};
        const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(this, 
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        anchorPrefix || 'a');
        const ctx = {
            aliasDuplicateObjects: aliasDuplicateObjects ?? true,
            keepUndefined: keepUndefined ?? false,
            onAnchor,
            onTagObj,
            replacer: _replacer,
            schema: this.schema,
            sourceObjects
        };
        const node = createNode(value, tag, ctx);
        if (flow && isCollection(node))
            node.flow = true;
        setAnchors();
        return node;
    }
    /**
     * Convert a key and a value into a `Pair` using the current schema,
     * recursively wrapping all values as `Scalar` or `Collection` nodes.
     */
    createPair(key, value, options = {}) {
        const k = this.createNode(key, null, options);
        const v = this.createNode(value, null, options);
        return new Pair(k, v);
    }
    /**
     * Removes a value from the document.
     * @returns `true` if the item was found and removed.
     */
    delete(key) {
        return assertCollection(this.contents) ? this.contents.delete(key) : false;
    }
    /**
     * Removes a value from the document.
     * @returns `true` if the item was found and removed.
     */
    deleteIn(path) {
        if (isEmptyPath(path)) {
            if (this.contents == null)
                return false;
            // @ts-expect-error Presumed impossible if Strict extends false
            this.contents = null;
            return true;
        }
        return assertCollection(this.contents)
            ? this.contents.deleteIn(path)
            : false;
    }
    /**
     * Returns item at `key`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */
    get(key, keepScalar) {
        return isCollection(this.contents)
            ? this.contents.get(key, keepScalar)
            : undefined;
    }
    /**
     * Returns item at `path`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */
    getIn(path, keepScalar) {
        if (isEmptyPath(path))
            return !keepScalar && isScalar(this.contents)
                ? this.contents.value
                : this.contents;
        return isCollection(this.contents)
            ? this.contents.getIn(path, keepScalar)
            : undefined;
    }
    /**
     * Checks if the document includes a value with the key `key`.
     */
    has(key) {
        return isCollection(this.contents) ? this.contents.has(key) : false;
    }
    /**
     * Checks if the document includes a value at `path`.
     */
    hasIn(path) {
        if (isEmptyPath(path))
            return this.contents !== undefined;
        return isCollection(this.contents) ? this.contents.hasIn(path) : false;
    }
    /**
     * Sets a value in this document. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */
    set(key, value) {
        if (this.contents == null) {
            // @ts-expect-error We can't really know that this matches Contents.
            this.contents = collectionFromPath(this.schema, [key], value);
        }
        else if (assertCollection(this.contents)) {
            this.contents.set(key, value);
        }
    }
    /**
     * Sets a value in this document. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */
    setIn(path, value) {
        if (isEmptyPath(path)) {
            // @ts-expect-error We can't really know that this matches Contents.
            this.contents = value;
        }
        else if (this.contents == null) {
            // @ts-expect-error We can't really know that this matches Contents.
            this.contents = collectionFromPath(this.schema, Array.from(path), value);
        }
        else if (assertCollection(this.contents)) {
            this.contents.setIn(path, value);
        }
    }
    /**
     * Change the YAML version and schema used by the document.
     * A `null` version disables support for directives, explicit tags, anchors, and aliases.
     * It also requires the `schema` option to be given as a `Schema` instance value.
     *
     * Overrides all previously set schema options.
     */
    setSchema(version, options = {}) {
        if (typeof version === 'number')
            version = String(version);
        let opt;
        switch (version) {
            case '1.1':
                if (this.directives)
                    this.directives.yaml.version = '1.1';
                else
                    this.directives = new Directives({ version: '1.1' });
                opt = { merge: true, resolveKnownTags: false, schema: 'yaml-1.1' };
                break;
            case '1.2':
            case 'next':
                if (this.directives)
                    this.directives.yaml.version = version;
                else
                    this.directives = new Directives({ version });
                opt = { merge: false, resolveKnownTags: true, schema: 'core' };
                break;
            case null:
                if (this.directives)
                    delete this.directives;
                opt = null;
                break;
            default: {
                const sv = JSON.stringify(version);
                throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
            }
        }
        // Not using `instanceof Schema` to allow for duck typing
        if (options.schema instanceof Object)
            this.schema = options.schema;
        else if (opt)
            this.schema = new Schema(Object.assign(opt, options));
        else
            throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
    }
    // json & jsonArg are only used from toJSON()
    toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        const ctx = {
            anchors: new Map(),
            doc: this,
            keep: !json,
            mapAsMap: mapAsMap === true,
            mapKeyWarned: false,
            maxAliasCount: typeof maxAliasCount === 'number' ? maxAliasCount : 100
        };
        const res = toJS(this.contents, jsonArg ?? '', ctx);
        if (typeof onAnchor === 'function')
            for (const { count, res } of ctx.anchors.values())
                onAnchor(res, count);
        return typeof reviver === 'function'
            ? applyReviver(reviver, { '': res }, '', res)
            : res;
    }
    /**
     * A JSON representation of the document `contents`.
     *
     * @param jsonArg Used by `JSON.stringify` to indicate the array index or
     *   property name.
     */
    toJSON(jsonArg, onAnchor) {
        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
    }
    /** A YAML representation of the document. */
    toString(options = {}) {
        if (this.errors.length > 0)
            throw new Error('Document with errors cannot be stringified');
        if ('indent' in options &&
            (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
            const s = JSON.stringify(options.indent);
            throw new Error(`"indent" option must be a positive integer, not ${s}`);
        }
        return stringifyDocument(this, options);
    }
}
function assertCollection(contents) {
    if (isCollection(contents))
        return true;
    throw new Error('Expected a YAML collection as document contents');
}

class YAMLError extends Error {
    constructor(name, pos, code, message) {
        super();
        this.name = name;
        this.code = code;
        this.message = message;
        this.pos = pos;
    }
}
class YAMLParseError extends YAMLError {
    constructor(pos, code, message) {
        super('YAMLParseError', pos, code, message);
    }
}
class YAMLWarning extends YAMLError {
    constructor(pos, code, message) {
        super('YAMLWarning', pos, code, message);
    }
}
const prettifyError = (src, lc) => (error) => {
    if (error.pos[0] === -1)
        return;
    error.linePos = error.pos.map(pos => lc.linePos(pos));
    const { line, col } = error.linePos[0];
    error.message += ` at line ${line}, column ${col}`;
    let ci = col - 1;
    let lineStr = src
        .substring(lc.lineStarts[line - 1], lc.lineStarts[line])
        .replace(/[\n\r]+$/, '');
    // Trim to max 80 chars, keeping col position near the middle
    if (ci >= 60 && lineStr.length > 80) {
        const trimStart = Math.min(ci - 39, lineStr.length - 79);
        lineStr = '' + lineStr.substring(trimStart);
        ci -= trimStart - 1;
    }
    if (lineStr.length > 80)
        lineStr = lineStr.substring(0, 79) + '';
    // Include previous line in context if pointing at line start
    if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
        // Regexp won't match if start is trimmed
        let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
        if (prev.length > 80)
            prev = prev.substring(0, 79) + '\n';
        lineStr = prev + lineStr;
    }
    if (/[^ ]/.test(lineStr)) {
        let count = 1;
        const end = error.linePos[1];
        if (end && end.line === line && end.col > col) {
            count = Math.max(1, Math.min(end.col - col, 80 - ci));
        }
        const pointer = ' '.repeat(ci) + '^'.repeat(count);
        error.message += `:\n\n${lineStr}\n${pointer}\n`;
    }
};

function resolveProps(tokens, { flow, indicator, next, offset, onError, startOnNewline }) {
    let spaceBefore = false;
    let atNewline = startOnNewline;
    let hasSpace = startOnNewline;
    let comment = '';
    let commentSep = '';
    let hasNewline = false;
    let hasNewlineAfterProp = false;
    let reqSpace = false;
    let anchor = null;
    let tag = null;
    let comma = null;
    let found = null;
    let start = null;
    for (const token of tokens) {
        if (reqSpace) {
            if (token.type !== 'space' &&
                token.type !== 'newline' &&
                token.type !== 'comma')
                onError(token.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');
            reqSpace = false;
        }
        switch (token.type) {
            case 'space':
                // At the doc level, tabs at line start may be parsed
                // as leading white space rather than indentation.
                // In a flow collection, only the parser handles indent.
                if (!flow &&
                    atNewline &&
                    indicator !== 'doc-start' &&
                    token.source[0] === '\t')
                    onError(token, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');
                hasSpace = true;
                break;
            case 'comment': {
                if (!hasSpace)
                    onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');
                const cb = token.source.substring(1) || ' ';
                if (!comment)
                    comment = cb;
                else
                    comment += commentSep + cb;
                commentSep = '';
                atNewline = false;
                break;
            }
            case 'newline':
                if (atNewline) {
                    if (comment)
                        comment += token.source;
                    else
                        spaceBefore = true;
                }
                else
                    commentSep += token.source;
                atNewline = true;
                hasNewline = true;
                if (anchor || tag)
                    hasNewlineAfterProp = true;
                hasSpace = true;
                break;
            case 'anchor':
                if (anchor)
                    onError(token, 'MULTIPLE_ANCHORS', 'A node can have at most one anchor');
                if (token.source.endsWith(':'))
                    onError(token.offset + token.source.length - 1, 'BAD_ALIAS', 'Anchor ending in : is ambiguous', true);
                anchor = token;
                if (start === null)
                    start = token.offset;
                atNewline = false;
                hasSpace = false;
                reqSpace = true;
                break;
            case 'tag': {
                if (tag)
                    onError(token, 'MULTIPLE_TAGS', 'A node can have at most one tag');
                tag = token;
                if (start === null)
                    start = token.offset;
                atNewline = false;
                hasSpace = false;
                reqSpace = true;
                break;
            }
            case indicator:
                // Could here handle preceding comments differently
                if (anchor || tag)
                    onError(token, 'BAD_PROP_ORDER', `Anchors and tags must be after the ${token.source} indicator`);
                if (found)
                    onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.source} in ${flow ?? 'collection'}`);
                found = token;
                atNewline = false;
                hasSpace = false;
                break;
            case 'comma':
                if (flow) {
                    if (comma)
                        onError(token, 'UNEXPECTED_TOKEN', `Unexpected , in ${flow}`);
                    comma = token;
                    atNewline = false;
                    hasSpace = false;
                    break;
                }
            // else fallthrough
            default:
                onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.type} token`);
                atNewline = false;
                hasSpace = false;
        }
    }
    const last = tokens[tokens.length - 1];
    const end = last ? last.offset + last.source.length : offset;
    if (reqSpace &&
        next &&
        next.type !== 'space' &&
        next.type !== 'newline' &&
        next.type !== 'comma' &&
        (next.type !== 'scalar' || next.source !== ''))
        onError(next.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');
    return {
        comma,
        found,
        spaceBefore,
        comment,
        hasNewline,
        hasNewlineAfterProp,
        anchor,
        tag,
        end,
        start: start ?? end
    };
}

function containsNewline(key) {
    if (!key)
        return null;
    switch (key.type) {
        case 'alias':
        case 'scalar':
        case 'double-quoted-scalar':
        case 'single-quoted-scalar':
            if (key.source.includes('\n'))
                return true;
            if (key.end)
                for (const st of key.end)
                    if (st.type === 'newline')
                        return true;
            return false;
        case 'flow-collection':
            for (const it of key.items) {
                for (const st of it.start)
                    if (st.type === 'newline')
                        return true;
                if (it.sep)
                    for (const st of it.sep)
                        if (st.type === 'newline')
                            return true;
                if (containsNewline(it.key) || containsNewline(it.value))
                    return true;
            }
            return false;
        default:
            return true;
    }
}

function flowIndentCheck(indent, fc, onError) {
    if (fc?.type === 'flow-collection') {
        const end = fc.end[0];
        if (end.indent === indent &&
            (end.source === ']' || end.source === '}') &&
            containsNewline(fc)) {
            const msg = 'Flow end indicator should be more indented than parent';
            onError(end, 'BAD_INDENT', msg, true);
        }
    }
}

function mapIncludes(ctx, items, search) {
    const { uniqueKeys } = ctx.options;
    if (uniqueKeys === false)
        return false;
    const isEqual = typeof uniqueKeys === 'function'
        ? uniqueKeys
        : (a, b) => a === b ||
            (isScalar(a) &&
                isScalar(b) &&
                a.value === b.value &&
                !(a.value === '<<' && ctx.schema.merge));
    return items.some(pair => isEqual(pair.key, search));
}

const startColMsg = 'All mapping items must start at the same column';
function resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError, tag) {
    const NodeClass = tag?.nodeClass ?? YAMLMap;
    const map = new NodeClass(ctx.schema);
    if (ctx.atRoot)
        ctx.atRoot = false;
    let offset = bm.offset;
    let commentEnd = null;
    for (const collItem of bm.items) {
        const { start, key, sep, value } = collItem;
        // key properties
        const keyProps = resolveProps(start, {
            indicator: 'explicit-key-ind',
            next: key ?? sep?.[0],
            offset,
            onError,
            startOnNewline: true
        });
        const implicitKey = !keyProps.found;
        if (implicitKey) {
            if (key) {
                if (key.type === 'block-seq')
                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'A block sequence may not be used as an implicit map key');
                else if ('indent' in key && key.indent !== bm.indent)
                    onError(offset, 'BAD_INDENT', startColMsg);
            }
            if (!keyProps.anchor && !keyProps.tag && !sep) {
                commentEnd = keyProps.end;
                if (keyProps.comment) {
                    if (map.comment)
                        map.comment += '\n' + keyProps.comment;
                    else
                        map.comment = keyProps.comment;
                }
                continue;
            }
            if (keyProps.hasNewlineAfterProp || containsNewline(key)) {
                onError(key ?? start[start.length - 1], 'MULTILINE_IMPLICIT_KEY', 'Implicit keys need to be on a single line');
            }
        }
        else if (keyProps.found?.indent !== bm.indent) {
            onError(offset, 'BAD_INDENT', startColMsg);
        }
        // key value
        const keyStart = keyProps.end;
        const keyNode = key
            ? composeNode(ctx, key, keyProps, onError)
            : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
        if (ctx.schema.compat)
            flowIndentCheck(bm.indent, key, onError);
        if (mapIncludes(ctx, map.items, keyNode))
            onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');
        // value properties
        const valueProps = resolveProps(sep ?? [], {
            indicator: 'map-value-ind',
            next: value,
            offset: keyNode.range[2],
            onError,
            startOnNewline: !key || key.type === 'block-scalar'
        });
        offset = valueProps.end;
        if (valueProps.found) {
            if (implicitKey) {
                if (value?.type === 'block-map' && !valueProps.hasNewline)
                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'Nested mappings are not allowed in compact mappings');
                if (ctx.options.strict &&
                    keyProps.start < valueProps.found.offset - 1024)
                    onError(keyNode.range, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit block mapping key');
            }
            // value value
            const valueNode = value
                ? composeNode(ctx, value, valueProps, onError)
                : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);
            if (ctx.schema.compat)
                flowIndentCheck(bm.indent, value, onError);
            offset = valueNode.range[2];
            const pair = new Pair(keyNode, valueNode);
            if (ctx.options.keepSourceTokens)
                pair.srcToken = collItem;
            map.items.push(pair);
        }
        else {
            // key with no value
            if (implicitKey)
                onError(keyNode.range, 'MISSING_CHAR', 'Implicit map keys need to be followed by map values');
            if (valueProps.comment) {
                if (keyNode.comment)
                    keyNode.comment += '\n' + valueProps.comment;
                else
                    keyNode.comment = valueProps.comment;
            }
            const pair = new Pair(keyNode);
            if (ctx.options.keepSourceTokens)
                pair.srcToken = collItem;
            map.items.push(pair);
        }
    }
    if (commentEnd && commentEnd < offset)
        onError(commentEnd, 'IMPOSSIBLE', 'Map comment with trailing content');
    map.range = [bm.offset, offset, commentEnd ?? offset];
    return map;
}

function resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError, tag) {
    const NodeClass = tag?.nodeClass ?? YAMLSeq;
    const seq = new NodeClass(ctx.schema);
    if (ctx.atRoot)
        ctx.atRoot = false;
    let offset = bs.offset;
    let commentEnd = null;
    for (const { start, value } of bs.items) {
        const props = resolveProps(start, {
            indicator: 'seq-item-ind',
            next: value,
            offset,
            onError,
            startOnNewline: true
        });
        if (!props.found) {
            if (props.anchor || props.tag || value) {
                if (value && value.type === 'block-seq')
                    onError(props.end, 'BAD_INDENT', 'All sequence items must start at the same column');
                else
                    onError(offset, 'MISSING_CHAR', 'Sequence item without - indicator');
            }
            else {
                commentEnd = props.end;
                if (props.comment)
                    seq.comment = props.comment;
                continue;
            }
        }
        const node = value
            ? composeNode(ctx, value, props, onError)
            : composeEmptyNode(ctx, props.end, start, null, props, onError);
        if (ctx.schema.compat)
            flowIndentCheck(bs.indent, value, onError);
        offset = node.range[2];
        seq.items.push(node);
    }
    seq.range = [bs.offset, offset, commentEnd ?? offset];
    return seq;
}

function resolveEnd(end, offset, reqSpace, onError) {
    let comment = '';
    if (end) {
        let hasSpace = false;
        let sep = '';
        for (const token of end) {
            const { source, type } = token;
            switch (type) {
                case 'space':
                    hasSpace = true;
                    break;
                case 'comment': {
                    if (reqSpace && !hasSpace)
                        onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');
                    const cb = source.substring(1) || ' ';
                    if (!comment)
                        comment = cb;
                    else
                        comment += sep + cb;
                    sep = '';
                    break;
                }
                case 'newline':
                    if (comment)
                        sep += source;
                    hasSpace = true;
                    break;
                default:
                    onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${type} at node end`);
            }
            offset += source.length;
        }
    }
    return { comment, offset };
}

const blockMsg = 'Block collections are not allowed within flow collections';
const isBlock = (token) => token && (token.type === 'block-map' || token.type === 'block-seq');
function resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError, tag) {
    const isMap = fc.start.source === '{';
    const fcName = isMap ? 'flow map' : 'flow sequence';
    const NodeClass = (tag?.nodeClass ?? (isMap ? YAMLMap : YAMLSeq));
    const coll = new NodeClass(ctx.schema);
    coll.flow = true;
    const atRoot = ctx.atRoot;
    if (atRoot)
        ctx.atRoot = false;
    let offset = fc.offset + fc.start.source.length;
    for (let i = 0; i < fc.items.length; ++i) {
        const collItem = fc.items[i];
        const { start, key, sep, value } = collItem;
        const props = resolveProps(start, {
            flow: fcName,
            indicator: 'explicit-key-ind',
            next: key ?? sep?.[0],
            offset,
            onError,
            startOnNewline: false
        });
        if (!props.found) {
            if (!props.anchor && !props.tag && !sep && !value) {
                if (i === 0 && props.comma)
                    onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);
                else if (i < fc.items.length - 1)
                    onError(props.start, 'UNEXPECTED_TOKEN', `Unexpected empty item in ${fcName}`);
                if (props.comment) {
                    if (coll.comment)
                        coll.comment += '\n' + props.comment;
                    else
                        coll.comment = props.comment;
                }
                offset = props.end;
                continue;
            }
            if (!isMap && ctx.options.strict && containsNewline(key))
                onError(key, // checked by containsNewline()
                'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');
        }
        if (i === 0) {
            if (props.comma)
                onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);
        }
        else {
            if (!props.comma)
                onError(props.start, 'MISSING_CHAR', `Missing , between ${fcName} items`);
            if (props.comment) {
                let prevItemComment = '';
                loop: for (const st of start) {
                    switch (st.type) {
                        case 'comma':
                        case 'space':
                            break;
                        case 'comment':
                            prevItemComment = st.source.substring(1);
                            break loop;
                        default:
                            break loop;
                    }
                }
                if (prevItemComment) {
                    let prev = coll.items[coll.items.length - 1];
                    if (isPair(prev))
                        prev = prev.value ?? prev.key;
                    if (prev.comment)
                        prev.comment += '\n' + prevItemComment;
                    else
                        prev.comment = prevItemComment;
                    props.comment = props.comment.substring(prevItemComment.length + 1);
                }
            }
        }
        if (!isMap && !sep && !props.found) {
            // item is a value in a seq
            //  key & sep are empty, start does not include ? or :
            const valueNode = value
                ? composeNode(ctx, value, props, onError)
                : composeEmptyNode(ctx, props.end, sep, null, props, onError);
            coll.items.push(valueNode);
            offset = valueNode.range[2];
            if (isBlock(value))
                onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);
        }
        else {
            // item is a key+value pair
            // key value
            const keyStart = props.end;
            const keyNode = key
                ? composeNode(ctx, key, props, onError)
                : composeEmptyNode(ctx, keyStart, start, null, props, onError);
            if (isBlock(key))
                onError(keyNode.range, 'BLOCK_IN_FLOW', blockMsg);
            // value properties
            const valueProps = resolveProps(sep ?? [], {
                flow: fcName,
                indicator: 'map-value-ind',
                next: value,
                offset: keyNode.range[2],
                onError,
                startOnNewline: false
            });
            if (valueProps.found) {
                if (!isMap && !props.found && ctx.options.strict) {
                    if (sep)
                        for (const st of sep) {
                            if (st === valueProps.found)
                                break;
                            if (st.type === 'newline') {
                                onError(st, 'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');
                                break;
                            }
                        }
                    if (props.start < valueProps.found.offset - 1024)
                        onError(valueProps.found, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit flow sequence key');
                }
            }
            else if (value) {
                if ('source' in value && value.source && value.source[0] === ':')
                    onError(value, 'MISSING_CHAR', `Missing space after : in ${fcName}`);
                else
                    onError(valueProps.start, 'MISSING_CHAR', `Missing , or : between ${fcName} items`);
            }
            // value value
            const valueNode = value
                ? composeNode(ctx, value, valueProps, onError)
                : valueProps.found
                    ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError)
                    : null;
            if (valueNode) {
                if (isBlock(value))
                    onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);
            }
            else if (valueProps.comment) {
                if (keyNode.comment)
                    keyNode.comment += '\n' + valueProps.comment;
                else
                    keyNode.comment = valueProps.comment;
            }
            const pair = new Pair(keyNode, valueNode);
            if (ctx.options.keepSourceTokens)
                pair.srcToken = collItem;
            if (isMap) {
                const map = coll;
                if (mapIncludes(ctx, map.items, keyNode))
                    onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');
                map.items.push(pair);
            }
            else {
                const map = new YAMLMap(ctx.schema);
                map.flow = true;
                map.items.push(pair);
                coll.items.push(map);
            }
            offset = valueNode ? valueNode.range[2] : valueProps.end;
        }
    }
    const expectedEnd = isMap ? '}' : ']';
    const [ce, ...ee] = fc.end;
    let cePos = offset;
    if (ce && ce.source === expectedEnd)
        cePos = ce.offset + ce.source.length;
    else {
        const name = fcName[0].toUpperCase() + fcName.substring(1);
        const msg = atRoot
            ? `${name} must end with a ${expectedEnd}`
            : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
        onError(offset, atRoot ? 'MISSING_CHAR' : 'BAD_INDENT', msg);
        if (ce && ce.source.length !== 1)
            ee.unshift(ce);
    }
    if (ee.length > 0) {
        const end = resolveEnd(ee, cePos, ctx.options.strict, onError);
        if (end.comment) {
            if (coll.comment)
                coll.comment += '\n' + end.comment;
            else
                coll.comment = end.comment;
        }
        coll.range = [fc.offset, cePos, end.offset];
    }
    else {
        coll.range = [fc.offset, cePos, cePos];
    }
    return coll;
}

function resolveCollection(CN, ctx, token, onError, tagName, tag) {
    const coll = token.type === 'block-map'
        ? resolveBlockMap(CN, ctx, token, onError, tag)
        : token.type === 'block-seq'
            ? resolveBlockSeq(CN, ctx, token, onError, tag)
            : resolveFlowCollection(CN, ctx, token, onError, tag);
    const Coll = coll.constructor;
    // If we got a tagName matching the class, or the tag name is '!',
    // then use the tagName from the node class used to create it.
    if (tagName === '!' || tagName === Coll.tagName) {
        coll.tag = Coll.tagName;
        return coll;
    }
    if (tagName)
        coll.tag = tagName;
    return coll;
}
function composeCollection(CN, ctx, token, tagToken, onError) {
    const tagName = !tagToken
        ? null
        : ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg));
    const expType = token.type === 'block-map'
        ? 'map'
        : token.type === 'block-seq'
            ? 'seq'
            : token.start.source === '{'
                ? 'map'
                : 'seq';
    // shortcut: check if it's a generic YAMLMap or YAMLSeq
    // before jumping into the custom tag logic.
    if (!tagToken ||
        !tagName ||
        tagName === '!' ||
        (tagName === YAMLMap.tagName && expType === 'map') ||
        (tagName === YAMLSeq.tagName && expType === 'seq') ||
        !expType) {
        return resolveCollection(CN, ctx, token, onError, tagName);
    }
    let tag = ctx.schema.tags.find(t => t.tag === tagName && t.collection === expType);
    if (!tag) {
        const kt = ctx.schema.knownTags[tagName];
        if (kt && kt.collection === expType) {
            ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
            tag = kt;
        }
        else {
            if (kt?.collection) {
                onError(tagToken, 'BAD_COLLECTION_TYPE', `${kt.tag} used for ${expType} collection, but expects ${kt.collection}`, true);
            }
            else {
                onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, true);
            }
            return resolveCollection(CN, ctx, token, onError, tagName);
        }
    }
    const coll = resolveCollection(CN, ctx, token, onError, tagName, tag);
    const res = tag.resolve?.(coll, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg), ctx.options) ?? coll;
    const node = isNode(res)
        ? res
        : new Scalar(res);
    node.range = coll.range;
    node.tag = tagName;
    if (tag?.format)
        node.format = tag.format;
    return node;
}

function resolveBlockScalar(scalar, strict, onError) {
    const start = scalar.offset;
    const header = parseBlockScalarHeader(scalar, strict, onError);
    if (!header)
        return { value: '', type: null, comment: '', range: [start, start, start] };
    const type = header.mode === '>' ? Scalar.BLOCK_FOLDED : Scalar.BLOCK_LITERAL;
    const lines = scalar.source ? splitLines(scalar.source) : [];
    // determine the end of content & start of chomping
    let chompStart = lines.length;
    for (let i = lines.length - 1; i >= 0; --i) {
        const content = lines[i][1];
        if (content === '' || content === '\r')
            chompStart = i;
        else
            break;
    }
    // shortcut for empty contents
    if (chompStart === 0) {
        const value = header.chomp === '+' && lines.length > 0
            ? '\n'.repeat(Math.max(1, lines.length - 1))
            : '';
        let end = start + header.length;
        if (scalar.source)
            end += scalar.source.length;
        return { value, type, comment: header.comment, range: [start, end, end] };
    }
    // find the indentation level to trim from start
    let trimIndent = scalar.indent + header.indent;
    let offset = scalar.offset + header.length;
    let contentStart = 0;
    for (let i = 0; i < chompStart; ++i) {
        const [indent, content] = lines[i];
        if (content === '' || content === '\r') {
            if (header.indent === 0 && indent.length > trimIndent)
                trimIndent = indent.length;
        }
        else {
            if (indent.length < trimIndent) {
                const message = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';
                onError(offset + indent.length, 'MISSING_CHAR', message);
            }
            if (header.indent === 0)
                trimIndent = indent.length;
            contentStart = i;
            break;
        }
        offset += indent.length + content.length + 1;
    }
    // include trailing more-indented empty lines in content
    for (let i = lines.length - 1; i >= chompStart; --i) {
        if (lines[i][0].length > trimIndent)
            chompStart = i + 1;
    }
    let value = '';
    let sep = '';
    let prevMoreIndented = false;
    // leading whitespace is kept intact
    for (let i = 0; i < contentStart; ++i)
        value += lines[i][0].slice(trimIndent) + '\n';
    for (let i = contentStart; i < chompStart; ++i) {
        let [indent, content] = lines[i];
        offset += indent.length + content.length + 1;
        const crlf = content[content.length - 1] === '\r';
        if (crlf)
            content = content.slice(0, -1);
        /* istanbul ignore if already caught in lexer */
        if (content && indent.length < trimIndent) {
            const src = header.indent
                ? 'explicit indentation indicator'
                : 'first line';
            const message = `Block scalar lines must not be less indented than their ${src}`;
            onError(offset - content.length - (crlf ? 2 : 1), 'BAD_INDENT', message);
            indent = '';
        }
        if (type === Scalar.BLOCK_LITERAL) {
            value += sep + indent.slice(trimIndent) + content;
            sep = '\n';
        }
        else if (indent.length > trimIndent || content[0] === '\t') {
            // more-indented content within a folded block
            if (sep === ' ')
                sep = '\n';
            else if (!prevMoreIndented && sep === '\n')
                sep = '\n\n';
            value += sep + indent.slice(trimIndent) + content;
            sep = '\n';
            prevMoreIndented = true;
        }
        else if (content === '') {
            // empty line
            if (sep === '\n')
                value += '\n';
            else
                sep = '\n';
        }
        else {
            value += sep + content;
            sep = ' ';
            prevMoreIndented = false;
        }
    }
    switch (header.chomp) {
        case '-':
            break;
        case '+':
            for (let i = chompStart; i < lines.length; ++i)
                value += '\n' + lines[i][0].slice(trimIndent);
            if (value[value.length - 1] !== '\n')
                value += '\n';
            break;
        default:
            value += '\n';
    }
    const end = start + header.length + scalar.source.length;
    return { value, type, comment: header.comment, range: [start, end, end] };
}
function parseBlockScalarHeader({ offset, props }, strict, onError) {
    /* istanbul ignore if should not happen */
    if (props[0].type !== 'block-scalar-header') {
        onError(props[0], 'IMPOSSIBLE', 'Block scalar header not found');
        return null;
    }
    const { source } = props[0];
    const mode = source[0];
    let indent = 0;
    let chomp = '';
    let error = -1;
    for (let i = 1; i < source.length; ++i) {
        const ch = source[i];
        if (!chomp && (ch === '-' || ch === '+'))
            chomp = ch;
        else {
            const n = Number(ch);
            if (!indent && n)
                indent = n;
            else if (error === -1)
                error = offset + i;
        }
    }
    if (error !== -1)
        onError(error, 'UNEXPECTED_TOKEN', `Block scalar header includes extra characters: ${source}`);
    let hasSpace = false;
    let comment = '';
    let length = source.length;
    for (let i = 1; i < props.length; ++i) {
        const token = props[i];
        switch (token.type) {
            case 'space':
                hasSpace = true;
            // fallthrough
            case 'newline':
                length += token.source.length;
                break;
            case 'comment':
                if (strict && !hasSpace) {
                    const message = 'Comments must be separated from other tokens by white space characters';
                    onError(token, 'MISSING_CHAR', message);
                }
                length += token.source.length;
                comment = token.source.substring(1);
                break;
            case 'error':
                onError(token, 'UNEXPECTED_TOKEN', token.message);
                length += token.source.length;
                break;
            /* istanbul ignore next should not happen */
            default: {
                const message = `Unexpected token in block scalar header: ${token.type}`;
                onError(token, 'UNEXPECTED_TOKEN', message);
                const ts = token.source;
                if (ts && typeof ts === 'string')
                    length += ts.length;
            }
        }
    }
    return { mode, indent, chomp, comment, length };
}
/** @returns Array of lines split up as `[indent, content]` */
function splitLines(source) {
    const split = source.split(/\n( *)/);
    const first = split[0];
    const m = first.match(/^( *)/);
    const line0 = m?.[1]
        ? [m[1], first.slice(m[1].length)]
        : ['', first];
    const lines = [line0];
    for (let i = 1; i < split.length; i += 2)
        lines.push([split[i], split[i + 1]]);
    return lines;
}

function resolveFlowScalar(scalar, strict, onError) {
    const { offset, type, source, end } = scalar;
    let _type;
    let value;
    const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
    switch (type) {
        case 'scalar':
            _type = Scalar.PLAIN;
            value = plainValue(source, _onError);
            break;
        case 'single-quoted-scalar':
            _type = Scalar.QUOTE_SINGLE;
            value = singleQuotedValue(source, _onError);
            break;
        case 'double-quoted-scalar':
            _type = Scalar.QUOTE_DOUBLE;
            value = doubleQuotedValue(source, _onError);
            break;
        /* istanbul ignore next should not happen */
        default:
            onError(scalar, 'UNEXPECTED_TOKEN', `Expected a flow scalar value, but found: ${type}`);
            return {
                value: '',
                type: null,
                comment: '',
                range: [offset, offset + source.length, offset + source.length]
            };
    }
    const valueEnd = offset + source.length;
    const re = resolveEnd(end, valueEnd, strict, onError);
    return {
        value,
        type: _type,
        comment: re.comment,
        range: [offset, valueEnd, re.offset]
    };
}
function plainValue(source, onError) {
    let badChar = '';
    switch (source[0]) {
        /* istanbul ignore next should not happen */
        case '\t':
            badChar = 'a tab character';
            break;
        case ',':
            badChar = 'flow indicator character ,';
            break;
        case '%':
            badChar = 'directive indicator character %';
            break;
        case '|':
        case '>': {
            badChar = `block scalar indicator ${source[0]}`;
            break;
        }
        case '@':
        case '`': {
            badChar = `reserved character ${source[0]}`;
            break;
        }
    }
    if (badChar)
        onError(0, 'BAD_SCALAR_START', `Plain value cannot start with ${badChar}`);
    return foldLines(source);
}
function singleQuotedValue(source, onError) {
    if (source[source.length - 1] !== "'" || source.length === 1)
        onError(source.length, 'MISSING_CHAR', "Missing closing 'quote");
    return foldLines(source.slice(1, -1)).replace(/''/g, "'");
}
function foldLines(source) {
    /**
     * The negative lookbehind here and in the `re` RegExp is to
     * prevent causing a polynomial search time in certain cases.
     *
     * The try-catch is for Safari, which doesn't support this yet:
     * https://caniuse.com/js-regexp-lookbehind
     */
    let first, line;
    try {
        first = new RegExp('(.*?)(?<![ \t])[ \t]*\r?\n', 'sy');
        line = new RegExp('[ \t]*(.*?)(?:(?<![ \t])[ \t]*)?\r?\n', 'sy');
    }
    catch (_) {
        first = /(.*?)[ \t]*\r?\n/sy;
        line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
    }
    let match = first.exec(source);
    if (!match)
        return source;
    let res = match[1];
    let sep = ' ';
    let pos = first.lastIndex;
    line.lastIndex = pos;
    while ((match = line.exec(source))) {
        if (match[1] === '') {
            if (sep === '\n')
                res += sep;
            else
                sep = '\n';
        }
        else {
            res += sep + match[1];
            sep = ' ';
        }
        pos = line.lastIndex;
    }
    const last = /[ \t]*(.*)/sy;
    last.lastIndex = pos;
    match = last.exec(source);
    return res + sep + (match?.[1] ?? '');
}
function doubleQuotedValue(source, onError) {
    let res = '';
    for (let i = 1; i < source.length - 1; ++i) {
        const ch = source[i];
        if (ch === '\r' && source[i + 1] === '\n')
            continue;
        if (ch === '\n') {
            const { fold, offset } = foldNewline(source, i);
            res += fold;
            i = offset;
        }
        else if (ch === '\\') {
            let next = source[++i];
            const cc = escapeCodes[next];
            if (cc)
                res += cc;
            else if (next === '\n') {
                // skip escaped newlines, but still trim the following line
                next = source[i + 1];
                while (next === ' ' || next === '\t')
                    next = source[++i + 1];
            }
            else if (next === '\r' && source[i + 1] === '\n') {
                // skip escaped CRLF newlines, but still trim the following line
                next = source[++i + 1];
                while (next === ' ' || next === '\t')
                    next = source[++i + 1];
            }
            else if (next === 'x' || next === 'u' || next === 'U') {
                const length = { x: 2, u: 4, U: 8 }[next];
                res += parseCharCode(source, i + 1, length, onError);
                i += length;
            }
            else {
                const raw = source.substr(i - 1, 2);
                onError(i - 1, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);
                res += raw;
            }
        }
        else if (ch === ' ' || ch === '\t') {
            // trim trailing whitespace
            const wsStart = i;
            let next = source[i + 1];
            while (next === ' ' || next === '\t')
                next = source[++i + 1];
            if (next !== '\n' && !(next === '\r' && source[i + 2] === '\n'))
                res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
        }
        else {
            res += ch;
        }
    }
    if (source[source.length - 1] !== '"' || source.length === 1)
        onError(source.length, 'MISSING_CHAR', 'Missing closing "quote');
    return res;
}
/**
 * Fold a single newline into a space, multiple newlines to N - 1 newlines.
 * Presumes `source[offset] === '\n'`
 */
function foldNewline(source, offset) {
    let fold = '';
    let ch = source[offset + 1];
    while (ch === ' ' || ch === '\t' || ch === '\n' || ch === '\r') {
        if (ch === '\r' && source[offset + 2] !== '\n')
            break;
        if (ch === '\n')
            fold += '\n';
        offset += 1;
        ch = source[offset + 1];
    }
    if (!fold)
        fold = ' ';
    return { fold, offset };
}
const escapeCodes = {
    '0': '\0',
    a: '\x07',
    b: '\b',
    e: '\x1b',
    f: '\f',
    n: '\n',
    r: '\r',
    t: '\t',
    v: '\v',
    N: '\u0085',
    _: '\u00a0',
    L: '\u2028',
    P: '\u2029',
    ' ': ' ',
    '"': '"',
    '/': '/',
    '\\': '\\',
    '\t': '\t'
};
function parseCharCode(source, offset, length, onError) {
    const cc = source.substr(offset, length);
    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
    const code = ok ? parseInt(cc, 16) : NaN;
    if (isNaN(code)) {
        const raw = source.substr(offset - 2, length + 2);
        onError(offset - 2, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);
        return raw;
    }
    return String.fromCodePoint(code);
}

function composeScalar(ctx, token, tagToken, onError) {
    const { value, type, comment, range } = token.type === 'block-scalar'
        ? resolveBlockScalar(token, ctx.options.strict, onError)
        : resolveFlowScalar(token, ctx.options.strict, onError);
    const tagName = tagToken
        ? ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg))
        : null;
    const tag = tagToken && tagName
        ? findScalarTagByName(ctx.schema, value, tagName, tagToken, onError)
        : token.type === 'scalar'
            ? findScalarTagByTest(ctx, value, token, onError)
            : ctx.schema[SCALAR$1];
    let scalar;
    try {
        const res = tag.resolve(value, msg => onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg), ctx.options);
        scalar = isScalar(res) ? res : new Scalar(res);
    }
    catch (error) {
        const msg = error instanceof Error ? error.message : String(error);
        onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg);
        scalar = new Scalar(value);
    }
    scalar.range = range;
    scalar.source = value;
    if (type)
        scalar.type = type;
    if (tagName)
        scalar.tag = tagName;
    if (tag.format)
        scalar.format = tag.format;
    if (comment)
        scalar.comment = comment;
    return scalar;
}
function findScalarTagByName(schema, value, tagName, tagToken, onError) {
    if (tagName === '!')
        return schema[SCALAR$1]; // non-specific tag
    const matchWithTest = [];
    for (const tag of schema.tags) {
        if (!tag.collection && tag.tag === tagName) {
            if (tag.default && tag.test)
                matchWithTest.push(tag);
            else
                return tag;
        }
    }
    for (const tag of matchWithTest)
        if (tag.test?.test(value))
            return tag;
    const kt = schema.knownTags[tagName];
    if (kt && !kt.collection) {
        // Ensure that the known tag is available for stringifying,
        // but does not get used by default.
        schema.tags.push(Object.assign({}, kt, { default: false, test: undefined }));
        return kt;
    }
    onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, tagName !== 'tag:yaml.org,2002:str');
    return schema[SCALAR$1];
}
function findScalarTagByTest({ directives, schema }, value, token, onError) {
    const tag = schema.tags.find(tag => tag.default && tag.test?.test(value)) || schema[SCALAR$1];
    if (schema.compat) {
        const compat = schema.compat.find(tag => tag.default && tag.test?.test(value)) ??
            schema[SCALAR$1];
        if (tag.tag !== compat.tag) {
            const ts = directives.tagString(tag.tag);
            const cs = directives.tagString(compat.tag);
            const msg = `Value may be parsed as either ${ts} or ${cs}`;
            onError(token, 'TAG_RESOLVE_FAILED', msg, true);
        }
    }
    return tag;
}

function emptyScalarPosition(offset, before, pos) {
    if (before) {
        if (pos === null)
            pos = before.length;
        for (let i = pos - 1; i >= 0; --i) {
            let st = before[i];
            switch (st.type) {
                case 'space':
                case 'comment':
                case 'newline':
                    offset -= st.source.length;
                    continue;
            }
            // Technically, an empty scalar is immediately after the last non-empty
            // node, but it's more useful to place it after any whitespace.
            st = before[++i];
            while (st?.type === 'space') {
                offset += st.source.length;
                st = before[++i];
            }
            break;
        }
    }
    return offset;
}

const CN = { composeNode, composeEmptyNode };
function composeNode(ctx, token, props, onError) {
    const { spaceBefore, comment, anchor, tag } = props;
    let node;
    let isSrcToken = true;
    switch (token.type) {
        case 'alias':
            node = composeAlias(ctx, token, onError);
            if (anchor || tag)
                onError(token, 'ALIAS_PROPS', 'An alias node must not specify any properties');
            break;
        case 'scalar':
        case 'single-quoted-scalar':
        case 'double-quoted-scalar':
        case 'block-scalar':
            node = composeScalar(ctx, token, tag, onError);
            if (anchor)
                node.anchor = anchor.source.substring(1);
            break;
        case 'block-map':
        case 'block-seq':
        case 'flow-collection':
            node = composeCollection(CN, ctx, token, tag, onError);
            if (anchor)
                node.anchor = anchor.source.substring(1);
            break;
        default: {
            const message = token.type === 'error'
                ? token.message
                : `Unsupported token (type: ${token.type})`;
            onError(token, 'UNEXPECTED_TOKEN', message);
            node = composeEmptyNode(ctx, token.offset, undefined, null, props, onError);
            isSrcToken = false;
        }
    }
    if (anchor && node.anchor === '')
        onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');
    if (spaceBefore)
        node.spaceBefore = true;
    if (comment) {
        if (token.type === 'scalar' && token.source === '')
            node.comment = comment;
        else
            node.commentBefore = comment;
    }
    // @ts-expect-error Type checking misses meaning of isSrcToken
    if (ctx.options.keepSourceTokens && isSrcToken)
        node.srcToken = token;
    return node;
}
function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {
    const token = {
        type: 'scalar',
        offset: emptyScalarPosition(offset, before, pos),
        indent: -1,
        source: ''
    };
    const node = composeScalar(ctx, token, tag, onError);
    if (anchor) {
        node.anchor = anchor.source.substring(1);
        if (node.anchor === '')
            onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');
    }
    if (spaceBefore)
        node.spaceBefore = true;
    if (comment) {
        node.comment = comment;
        node.range[2] = end;
    }
    return node;
}
function composeAlias({ options }, { offset, source, end }, onError) {
    const alias = new Alias(source.substring(1));
    if (alias.source === '')
        onError(offset, 'BAD_ALIAS', 'Alias cannot be an empty string');
    if (alias.source.endsWith(':'))
        onError(offset + source.length - 1, 'BAD_ALIAS', 'Alias ending in : is ambiguous', true);
    const valueEnd = offset + source.length;
    const re = resolveEnd(end, valueEnd, options.strict, onError);
    alias.range = [offset, valueEnd, re.offset];
    if (re.comment)
        alias.comment = re.comment;
    return alias;
}

function composeDoc(options, directives, { offset, start, value, end }, onError) {
    const opts = Object.assign({ _directives: directives }, options);
    const doc = new Document(undefined, opts);
    const ctx = {
        atRoot: true,
        directives: doc.directives,
        options: doc.options,
        schema: doc.schema
    };
    const props = resolveProps(start, {
        indicator: 'doc-start',
        next: value ?? end?.[0],
        offset,
        onError,
        startOnNewline: true
    });
    if (props.found) {
        doc.directives.docStart = true;
        if (value &&
            (value.type === 'block-map' || value.type === 'block-seq') &&
            !props.hasNewline)
            onError(props.end, 'MISSING_CHAR', 'Block collection cannot start on same line with directives-end marker');
    }
    // @ts-expect-error If Contents is set, let's trust the user
    doc.contents = value
        ? composeNode(ctx, value, props, onError)
        : composeEmptyNode(ctx, props.end, start, null, props, onError);
    const contentEnd = doc.contents.range[2];
    const re = resolveEnd(end, contentEnd, false, onError);
    if (re.comment)
        doc.comment = re.comment;
    doc.range = [offset, contentEnd, re.offset];
    return doc;
}

function getErrorPos(src) {
    if (typeof src === 'number')
        return [src, src + 1];
    if (Array.isArray(src))
        return src.length === 2 ? src : [src[0], src[1]];
    const { offset, source } = src;
    return [offset, offset + (typeof source === 'string' ? source.length : 1)];
}
function parsePrelude(prelude) {
    let comment = '';
    let atComment = false;
    let afterEmptyLine = false;
    for (let i = 0; i < prelude.length; ++i) {
        const source = prelude[i];
        switch (source[0]) {
            case '#':
                comment +=
                    (comment === '' ? '' : afterEmptyLine ? '\n\n' : '\n') +
                        (source.substring(1) || ' ');
                atComment = true;
                afterEmptyLine = false;
                break;
            case '%':
                if (prelude[i + 1]?.[0] !== '#')
                    i += 1;
                atComment = false;
                break;
            default:
                // This may be wrong after doc-end, but in that case it doesn't matter
                if (!atComment)
                    afterEmptyLine = true;
                atComment = false;
        }
    }
    return { comment, afterEmptyLine };
}
/**
 * Compose a stream of CST nodes into a stream of YAML Documents.
 *
 * ```ts
 * import { Composer, Parser } from 'yaml'
 *
 * const src: string = ...
 * const tokens = new Parser().parse(src)
 * const docs = new Composer().compose(tokens)
 * ```
 */
class Composer {
    constructor(options = {}) {
        this.doc = null;
        this.atDirectives = false;
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
        this.onError = (source, code, message, warning) => {
            const pos = getErrorPos(source);
            if (warning)
                this.warnings.push(new YAMLWarning(pos, code, message));
            else
                this.errors.push(new YAMLParseError(pos, code, message));
        };
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        this.directives = new Directives({ version: options.version || '1.2' });
        this.options = options;
    }
    decorate(doc, afterDoc) {
        const { comment, afterEmptyLine } = parsePrelude(this.prelude);
        //console.log({ dc: doc.comment, prelude, comment })
        if (comment) {
            const dc = doc.contents;
            if (afterDoc) {
                doc.comment = doc.comment ? `${doc.comment}\n${comment}` : comment;
            }
            else if (afterEmptyLine || doc.directives.docStart || !dc) {
                doc.commentBefore = comment;
            }
            else if (isCollection(dc) && !dc.flow && dc.items.length > 0) {
                let it = dc.items[0];
                if (isPair(it))
                    it = it.key;
                const cb = it.commentBefore;
                it.commentBefore = cb ? `${comment}\n${cb}` : comment;
            }
            else {
                const cb = dc.commentBefore;
                dc.commentBefore = cb ? `${comment}\n${cb}` : comment;
            }
        }
        if (afterDoc) {
            Array.prototype.push.apply(doc.errors, this.errors);
            Array.prototype.push.apply(doc.warnings, this.warnings);
        }
        else {
            doc.errors = this.errors;
            doc.warnings = this.warnings;
        }
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
    }
    /**
     * Current stream status information.
     *
     * Mostly useful at the end of input for an empty stream.
     */
    streamInfo() {
        return {
            comment: parsePrelude(this.prelude).comment,
            directives: this.directives,
            errors: this.errors,
            warnings: this.warnings
        };
    }
    /**
     * Compose tokens into documents.
     *
     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
     */
    *compose(tokens, forceDoc = false, endOffset = -1) {
        for (const token of tokens)
            yield* this.next(token);
        yield* this.end(forceDoc, endOffset);
    }
    /** Advance the composer by one CST token. */
    *next(token) {
        switch (token.type) {
            case 'directive':
                this.directives.add(token.source, (offset, message, warning) => {
                    const pos = getErrorPos(token);
                    pos[0] += offset;
                    this.onError(pos, 'BAD_DIRECTIVE', message, warning);
                });
                this.prelude.push(token.source);
                this.atDirectives = true;
                break;
            case 'document': {
                const doc = composeDoc(this.options, this.directives, token, this.onError);
                if (this.atDirectives && !doc.directives.docStart)
                    this.onError(token, 'MISSING_CHAR', 'Missing directives-end/doc-start indicator line');
                this.decorate(doc, false);
                if (this.doc)
                    yield this.doc;
                this.doc = doc;
                this.atDirectives = false;
                break;
            }
            case 'byte-order-mark':
            case 'space':
                break;
            case 'comment':
            case 'newline':
                this.prelude.push(token.source);
                break;
            case 'error': {
                const msg = token.source
                    ? `${token.message}: ${JSON.stringify(token.source)}`
                    : token.message;
                const error = new YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg);
                if (this.atDirectives || !this.doc)
                    this.errors.push(error);
                else
                    this.doc.errors.push(error);
                break;
            }
            case 'doc-end': {
                if (!this.doc) {
                    const msg = 'Unexpected doc-end without preceding document';
                    this.errors.push(new YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg));
                    break;
                }
                this.doc.directives.docEnd = true;
                const end = resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
                this.decorate(this.doc, true);
                if (end.comment) {
                    const dc = this.doc.comment;
                    this.doc.comment = dc ? `${dc}\n${end.comment}` : end.comment;
                }
                this.doc.range[2] = end.offset;
                break;
            }
            default:
                this.errors.push(new YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', `Unsupported token ${token.type}`));
        }
    }
    /**
     * Call at end of input to yield any remaining document.
     *
     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
     */
    *end(forceDoc = false, endOffset = -1) {
        if (this.doc) {
            this.decorate(this.doc, true);
            yield this.doc;
            this.doc = null;
        }
        else if (forceDoc) {
            const opts = Object.assign({ _directives: this.directives }, this.options);
            const doc = new Document(undefined, opts);
            if (this.atDirectives)
                this.onError(endOffset, 'MISSING_CHAR', 'Missing directives-end indicator line');
            doc.range = [0, endOffset, endOffset];
            this.decorate(doc, false);
            yield doc;
        }
    }
}

/** The byte order mark */
const BOM = '\u{FEFF}';
/** Start of doc-mode */
const DOCUMENT = '\x02'; // C0: Start of Text
/** Unexpected end of flow-mode */
const FLOW_END = '\x18'; // C0: Cancel
/** Next token is a scalar value */
const SCALAR = '\x1f'; // C0: Unit Separator
/** Identify the type of a lexer token. May return `null` for unknown tokens. */
function tokenType(source) {
    switch (source) {
        case BOM:
            return 'byte-order-mark';
        case DOCUMENT:
            return 'doc-mode';
        case FLOW_END:
            return 'flow-error-end';
        case SCALAR:
            return 'scalar';
        case '---':
            return 'doc-start';
        case '...':
            return 'doc-end';
        case '':
        case '\n':
        case '\r\n':
            return 'newline';
        case '-':
            return 'seq-item-ind';
        case '?':
            return 'explicit-key-ind';
        case ':':
            return 'map-value-ind';
        case '{':
            return 'flow-map-start';
        case '}':
            return 'flow-map-end';
        case '[':
            return 'flow-seq-start';
        case ']':
            return 'flow-seq-end';
        case ',':
            return 'comma';
    }
    switch (source[0]) {
        case ' ':
        case '\t':
            return 'space';
        case '#':
            return 'comment';
        case '%':
            return 'directive-line';
        case '*':
            return 'alias';
        case '&':
            return 'anchor';
        case '!':
            return 'tag';
        case "'":
            return 'single-quoted-scalar';
        case '"':
            return 'double-quoted-scalar';
        case '|':
        case '>':
            return 'block-scalar-header';
    }
    return null;
}

/*
START -> stream

stream
  directive -> line-end -> stream
  indent + line-end -> stream
  [else] -> line-start

line-end
  comment -> line-end
  newline -> .
  input-end -> END

line-start
  doc-start -> doc
  doc-end -> stream
  [else] -> indent -> block-start

block-start
  seq-item-start -> block-start
  explicit-key-start -> block-start
  map-value-start -> block-start
  [else] -> doc

doc
  line-end -> line-start
  spaces -> doc
  anchor -> doc
  tag -> doc
  flow-start -> flow -> doc
  flow-end -> error -> doc
  seq-item-start -> error -> doc
  explicit-key-start -> error -> doc
  map-value-start -> doc
  alias -> doc
  quote-start -> quoted-scalar -> doc
  block-scalar-header -> line-end -> block-scalar(min) -> line-start
  [else] -> plain-scalar(false, min) -> doc

flow
  line-end -> flow
  spaces -> flow
  anchor -> flow
  tag -> flow
  flow-start -> flow -> flow
  flow-end -> .
  seq-item-start -> error -> flow
  explicit-key-start -> flow
  map-value-start -> flow
  alias -> flow
  quote-start -> quoted-scalar -> flow
  comma -> flow
  [else] -> plain-scalar(true, 0) -> flow

quoted-scalar
  quote-end -> .
  [else] -> quoted-scalar

block-scalar(min)
  newline + peek(indent < min) -> .
  [else] -> block-scalar(min)

plain-scalar(is-flow, min)
  scalar-end(is-flow) -> .
  peek(newline + (indent < min)) -> .
  [else] -> plain-scalar(min)
*/
function isEmpty(ch) {
    switch (ch) {
        case undefined:
        case ' ':
        case '\n':
        case '\r':
        case '\t':
            return true;
        default:
            return false;
    }
}
const hexDigits = '0123456789ABCDEFabcdef'.split('');
const tagChars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()".split('');
const invalidFlowScalarChars = ',[]{}'.split('');
const invalidAnchorChars = ' ,[]{}\n\r\t'.split('');
const isNotAnchorChar = (ch) => !ch || invalidAnchorChars.includes(ch);
/**
 * Splits an input string into lexical tokens, i.e. smaller strings that are
 * easily identifiable by `tokens.tokenType()`.
 *
 * Lexing starts always in a "stream" context. Incomplete input may be buffered
 * until a complete token can be emitted.
 *
 * In addition to slices of the original input, the following control characters
 * may also be emitted:
 *
 * - `\x02` (Start of Text): A document starts with the next token
 * - `\x18` (Cancel): Unexpected end of flow-mode (indicates an error)
 * - `\x1f` (Unit Separator): Next token is a scalar value
 * - `\u{FEFF}` (Byte order mark): Emitted separately outside documents
 */
class Lexer {
    constructor() {
        /**
         * Flag indicating whether the end of the current buffer marks the end of
         * all input
         */
        this.atEnd = false;
        /**
         * Explicit indent set in block scalar header, as an offset from the current
         * minimum indent, so e.g. set to 1 from a header `|2+`. Set to -1 if not
         * explicitly set.
         */
        this.blockScalarIndent = -1;
        /**
         * Block scalars that include a + (keep) chomping indicator in their header
         * include trailing empty lines, which are otherwise excluded from the
         * scalar's contents.
         */
        this.blockScalarKeep = false;
        /** Current input */
        this.buffer = '';
        /**
         * Flag noting whether the map value indicator : can immediately follow this
         * node within a flow context.
         */
        this.flowKey = false;
        /** Count of surrounding flow collection levels. */
        this.flowLevel = 0;
        /**
         * Minimum level of indentation required for next lines to be parsed as a
         * part of the current scalar value.
         */
        this.indentNext = 0;
        /** Indentation level of the current line. */
        this.indentValue = 0;
        /** Position of the next \n character. */
        this.lineEndPos = null;
        /** Stores the state of the lexer if reaching the end of incpomplete input */
        this.next = null;
        /** A pointer to `buffer`; the current position of the lexer. */
        this.pos = 0;
    }
    /**
     * Generate YAML tokens from the `source` string. If `incomplete`,
     * a part of the last line may be left as a buffer for the next call.
     *
     * @returns A generator of lexical tokens
     */
    *lex(source, incomplete = false) {
        if (source) {
            this.buffer = this.buffer ? this.buffer + source : source;
            this.lineEndPos = null;
        }
        this.atEnd = !incomplete;
        let next = this.next ?? 'stream';
        while (next && (incomplete || this.hasChars(1)))
            next = yield* this.parseNext(next);
    }
    atLineEnd() {
        let i = this.pos;
        let ch = this.buffer[i];
        while (ch === ' ' || ch === '\t')
            ch = this.buffer[++i];
        if (!ch || ch === '#' || ch === '\n')
            return true;
        if (ch === '\r')
            return this.buffer[i + 1] === '\n';
        return false;
    }
    charAt(n) {
        return this.buffer[this.pos + n];
    }
    continueScalar(offset) {
        let ch = this.buffer[offset];
        if (this.indentNext > 0) {
            let indent = 0;
            while (ch === ' ')
                ch = this.buffer[++indent + offset];
            if (ch === '\r') {
                const next = this.buffer[indent + offset + 1];
                if (next === '\n' || (!next && !this.atEnd))
                    return offset + indent + 1;
            }
            return ch === '\n' || indent >= this.indentNext || (!ch && !this.atEnd)
                ? offset + indent
                : -1;
        }
        if (ch === '-' || ch === '.') {
            const dt = this.buffer.substr(offset, 3);
            if ((dt === '---' || dt === '...') && isEmpty(this.buffer[offset + 3]))
                return -1;
        }
        return offset;
    }
    getLine() {
        let end = this.lineEndPos;
        if (typeof end !== 'number' || (end !== -1 && end < this.pos)) {
            end = this.buffer.indexOf('\n', this.pos);
            this.lineEndPos = end;
        }
        if (end === -1)
            return this.atEnd ? this.buffer.substring(this.pos) : null;
        if (this.buffer[end - 1] === '\r')
            end -= 1;
        return this.buffer.substring(this.pos, end);
    }
    hasChars(n) {
        return this.pos + n <= this.buffer.length;
    }
    setNext(state) {
        this.buffer = this.buffer.substring(this.pos);
        this.pos = 0;
        this.lineEndPos = null;
        this.next = state;
        return null;
    }
    peek(n) {
        return this.buffer.substr(this.pos, n);
    }
    *parseNext(next) {
        switch (next) {
            case 'stream':
                return yield* this.parseStream();
            case 'line-start':
                return yield* this.parseLineStart();
            case 'block-start':
                return yield* this.parseBlockStart();
            case 'doc':
                return yield* this.parseDocument();
            case 'flow':
                return yield* this.parseFlowCollection();
            case 'quoted-scalar':
                return yield* this.parseQuotedScalar();
            case 'block-scalar':
                return yield* this.parseBlockScalar();
            case 'plain-scalar':
                return yield* this.parsePlainScalar();
        }
    }
    *parseStream() {
        let line = this.getLine();
        if (line === null)
            return this.setNext('stream');
        if (line[0] === BOM) {
            yield* this.pushCount(1);
            line = line.substring(1);
        }
        if (line[0] === '%') {
            let dirEnd = line.length;
            const cs = line.indexOf('#');
            if (cs !== -1) {
                const ch = line[cs - 1];
                if (ch === ' ' || ch === '\t')
                    dirEnd = cs - 1;
            }
            while (true) {
                const ch = line[dirEnd - 1];
                if (ch === ' ' || ch === '\t')
                    dirEnd -= 1;
                else
                    break;
            }
            const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
            yield* this.pushCount(line.length - n); // possible comment
            this.pushNewline();
            return 'stream';
        }
        if (this.atLineEnd()) {
            const sp = yield* this.pushSpaces(true);
            yield* this.pushCount(line.length - sp);
            yield* this.pushNewline();
            return 'stream';
        }
        yield DOCUMENT;
        return yield* this.parseLineStart();
    }
    *parseLineStart() {
        const ch = this.charAt(0);
        if (!ch && !this.atEnd)
            return this.setNext('line-start');
        if (ch === '-' || ch === '.') {
            if (!this.atEnd && !this.hasChars(4))
                return this.setNext('line-start');
            const s = this.peek(3);
            if (s === '---' && isEmpty(this.charAt(3))) {
                yield* this.pushCount(3);
                this.indentValue = 0;
                this.indentNext = 0;
                return 'doc';
            }
            else if (s === '...' && isEmpty(this.charAt(3))) {
                yield* this.pushCount(3);
                return 'stream';
            }
        }
        this.indentValue = yield* this.pushSpaces(false);
        if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
            this.indentNext = this.indentValue;
        return yield* this.parseBlockStart();
    }
    *parseBlockStart() {
        const [ch0, ch1] = this.peek(2);
        if (!ch1 && !this.atEnd)
            return this.setNext('block-start');
        if ((ch0 === '-' || ch0 === '?' || ch0 === ':') && isEmpty(ch1)) {
            const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
            this.indentNext = this.indentValue + 1;
            this.indentValue += n;
            return yield* this.parseBlockStart();
        }
        return 'doc';
    }
    *parseDocument() {
        yield* this.pushSpaces(true);
        const line = this.getLine();
        if (line === null)
            return this.setNext('doc');
        let n = yield* this.pushIndicators();
        switch (line[n]) {
            case '#':
                yield* this.pushCount(line.length - n);
            // fallthrough
            case undefined:
                yield* this.pushNewline();
                return yield* this.parseLineStart();
            case '{':
            case '[':
                yield* this.pushCount(1);
                this.flowKey = false;
                this.flowLevel = 1;
                return 'flow';
            case '}':
            case ']':
                // this is an error
                yield* this.pushCount(1);
                return 'doc';
            case '*':
                yield* this.pushUntil(isNotAnchorChar);
                return 'doc';
            case '"':
            case "'":
                return yield* this.parseQuotedScalar();
            case '|':
            case '>':
                n += yield* this.parseBlockScalarHeader();
                n += yield* this.pushSpaces(true);
                yield* this.pushCount(line.length - n);
                yield* this.pushNewline();
                return yield* this.parseBlockScalar();
            default:
                return yield* this.parsePlainScalar();
        }
    }
    *parseFlowCollection() {
        let nl, sp;
        let indent = -1;
        do {
            nl = yield* this.pushNewline();
            if (nl > 0) {
                sp = yield* this.pushSpaces(false);
                this.indentValue = indent = sp;
            }
            else {
                sp = 0;
            }
            sp += yield* this.pushSpaces(true);
        } while (nl + sp > 0);
        const line = this.getLine();
        if (line === null)
            return this.setNext('flow');
        if ((indent !== -1 && indent < this.indentNext && line[0] !== '#') ||
            (indent === 0 &&
                (line.startsWith('---') || line.startsWith('...')) &&
                isEmpty(line[3]))) {
            // Allowing for the terminal ] or } at the same (rather than greater)
            // indent level as the initial [ or { is technically invalid, but
            // failing here would be surprising to users.
            const atFlowEndMarker = indent === this.indentNext - 1 &&
                this.flowLevel === 1 &&
                (line[0] === ']' || line[0] === '}');
            if (!atFlowEndMarker) {
                // this is an error
                this.flowLevel = 0;
                yield FLOW_END;
                return yield* this.parseLineStart();
            }
        }
        let n = 0;
        while (line[n] === ',') {
            n += yield* this.pushCount(1);
            n += yield* this.pushSpaces(true);
            this.flowKey = false;
        }
        n += yield* this.pushIndicators();
        switch (line[n]) {
            case undefined:
                return 'flow';
            case '#':
                yield* this.pushCount(line.length - n);
                return 'flow';
            case '{':
            case '[':
                yield* this.pushCount(1);
                this.flowKey = false;
                this.flowLevel += 1;
                return 'flow';
            case '}':
            case ']':
                yield* this.pushCount(1);
                this.flowKey = true;
                this.flowLevel -= 1;
                return this.flowLevel ? 'flow' : 'doc';
            case '*':
                yield* this.pushUntil(isNotAnchorChar);
                return 'flow';
            case '"':
            case "'":
                this.flowKey = true;
                return yield* this.parseQuotedScalar();
            case ':': {
                const next = this.charAt(1);
                if (this.flowKey || isEmpty(next) || next === ',') {
                    this.flowKey = false;
                    yield* this.pushCount(1);
                    yield* this.pushSpaces(true);
                    return 'flow';
                }
            }
            // fallthrough
            default:
                this.flowKey = false;
                return yield* this.parsePlainScalar();
        }
    }
    *parseQuotedScalar() {
        const quote = this.charAt(0);
        let end = this.buffer.indexOf(quote, this.pos + 1);
        if (quote === "'") {
            while (end !== -1 && this.buffer[end + 1] === "'")
                end = this.buffer.indexOf("'", end + 2);
        }
        else {
            // double-quote
            while (end !== -1) {
                let n = 0;
                while (this.buffer[end - 1 - n] === '\\')
                    n += 1;
                if (n % 2 === 0)
                    break;
                end = this.buffer.indexOf('"', end + 1);
            }
        }
        // Only looking for newlines within the quotes
        const qb = this.buffer.substring(0, end);
        let nl = qb.indexOf('\n', this.pos);
        if (nl !== -1) {
            while (nl !== -1) {
                const cs = this.continueScalar(nl + 1);
                if (cs === -1)
                    break;
                nl = qb.indexOf('\n', cs);
            }
            if (nl !== -1) {
                // this is an error caused by an unexpected unindent
                end = nl - (qb[nl - 1] === '\r' ? 2 : 1);
            }
        }
        if (end === -1) {
            if (!this.atEnd)
                return this.setNext('quoted-scalar');
            end = this.buffer.length;
        }
        yield* this.pushToIndex(end + 1, false);
        return this.flowLevel ? 'flow' : 'doc';
    }
    *parseBlockScalarHeader() {
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        let i = this.pos;
        while (true) {
            const ch = this.buffer[++i];
            if (ch === '+')
                this.blockScalarKeep = true;
            else if (ch > '0' && ch <= '9')
                this.blockScalarIndent = Number(ch) - 1;
            else if (ch !== '-')
                break;
        }
        return yield* this.pushUntil(ch => isEmpty(ch) || ch === '#');
    }
    *parseBlockScalar() {
        let nl = this.pos - 1; // may be -1 if this.pos === 0
        let indent = 0;
        let ch;
        loop: for (let i = this.pos; (ch = this.buffer[i]); ++i) {
            switch (ch) {
                case ' ':
                    indent += 1;
                    break;
                case '\n':
                    nl = i;
                    indent = 0;
                    break;
                case '\r': {
                    const next = this.buffer[i + 1];
                    if (!next && !this.atEnd)
                        return this.setNext('block-scalar');
                    if (next === '\n')
                        break;
                } // fallthrough
                default:
                    break loop;
            }
        }
        if (!ch && !this.atEnd)
            return this.setNext('block-scalar');
        if (indent >= this.indentNext) {
            if (this.blockScalarIndent === -1)
                this.indentNext = indent;
            else
                this.indentNext += this.blockScalarIndent;
            do {
                const cs = this.continueScalar(nl + 1);
                if (cs === -1)
                    break;
                nl = this.buffer.indexOf('\n', cs);
            } while (nl !== -1);
            if (nl === -1) {
                if (!this.atEnd)
                    return this.setNext('block-scalar');
                nl = this.buffer.length;
            }
        }
        if (!this.blockScalarKeep) {
            do {
                let i = nl - 1;
                let ch = this.buffer[i];
                if (ch === '\r')
                    ch = this.buffer[--i];
                const lastChar = i; // Drop the line if last char not more indented
                while (ch === ' ' || ch === '\t')
                    ch = this.buffer[--i];
                if (ch === '\n' && i >= this.pos && i + 1 + indent > lastChar)
                    nl = i;
                else
                    break;
            } while (true);
        }
        yield SCALAR;
        yield* this.pushToIndex(nl + 1, true);
        return yield* this.parseLineStart();
    }
    *parsePlainScalar() {
        const inFlow = this.flowLevel > 0;
        let end = this.pos - 1;
        let i = this.pos - 1;
        let ch;
        while ((ch = this.buffer[++i])) {
            if (ch === ':') {
                const next = this.buffer[i + 1];
                if (isEmpty(next) || (inFlow && next === ','))
                    break;
                end = i;
            }
            else if (isEmpty(ch)) {
                let next = this.buffer[i + 1];
                if (ch === '\r') {
                    if (next === '\n') {
                        i += 1;
                        ch = '\n';
                        next = this.buffer[i + 1];
                    }
                    else
                        end = i;
                }
                if (next === '#' || (inFlow && invalidFlowScalarChars.includes(next)))
                    break;
                if (ch === '\n') {
                    const cs = this.continueScalar(i + 1);
                    if (cs === -1)
                        break;
                    i = Math.max(i, cs - 2); // to advance, but still account for ' #'
                }
            }
            else {
                if (inFlow && invalidFlowScalarChars.includes(ch))
                    break;
                end = i;
            }
        }
        if (!ch && !this.atEnd)
            return this.setNext('plain-scalar');
        yield SCALAR;
        yield* this.pushToIndex(end + 1, true);
        return inFlow ? 'flow' : 'doc';
    }
    *pushCount(n) {
        if (n > 0) {
            yield this.buffer.substr(this.pos, n);
            this.pos += n;
            return n;
        }
        return 0;
    }
    *pushToIndex(i, allowEmpty) {
        const s = this.buffer.slice(this.pos, i);
        if (s) {
            yield s;
            this.pos += s.length;
            return s.length;
        }
        else if (allowEmpty)
            yield '';
        return 0;
    }
    *pushIndicators() {
        switch (this.charAt(0)) {
            case '!':
                return ((yield* this.pushTag()) +
                    (yield* this.pushSpaces(true)) +
                    (yield* this.pushIndicators()));
            case '&':
                return ((yield* this.pushUntil(isNotAnchorChar)) +
                    (yield* this.pushSpaces(true)) +
                    (yield* this.pushIndicators()));
            case '-': // this is an error
            case '?': // this is an error outside flow collections
            case ':': {
                const inFlow = this.flowLevel > 0;
                const ch1 = this.charAt(1);
                if (isEmpty(ch1) || (inFlow && invalidFlowScalarChars.includes(ch1))) {
                    if (!inFlow)
                        this.indentNext = this.indentValue + 1;
                    else if (this.flowKey)
                        this.flowKey = false;
                    return ((yield* this.pushCount(1)) +
                        (yield* this.pushSpaces(true)) +
                        (yield* this.pushIndicators()));
                }
            }
        }
        return 0;
    }
    *pushTag() {
        if (this.charAt(1) === '<') {
            let i = this.pos + 2;
            let ch = this.buffer[i];
            while (!isEmpty(ch) && ch !== '>')
                ch = this.buffer[++i];
            return yield* this.pushToIndex(ch === '>' ? i + 1 : i, false);
        }
        else {
            let i = this.pos + 1;
            let ch = this.buffer[i];
            while (ch) {
                if (tagChars.includes(ch))
                    ch = this.buffer[++i];
                else if (ch === '%' &&
                    hexDigits.includes(this.buffer[i + 1]) &&
                    hexDigits.includes(this.buffer[i + 2])) {
                    ch = this.buffer[(i += 3)];
                }
                else
                    break;
            }
            return yield* this.pushToIndex(i, false);
        }
    }
    *pushNewline() {
        const ch = this.buffer[this.pos];
        if (ch === '\n')
            return yield* this.pushCount(1);
        else if (ch === '\r' && this.charAt(1) === '\n')
            return yield* this.pushCount(2);
        else
            return 0;
    }
    *pushSpaces(allowTabs) {
        let i = this.pos - 1;
        let ch;
        do {
            ch = this.buffer[++i];
        } while (ch === ' ' || (allowTabs && ch === '\t'));
        const n = i - this.pos;
        if (n > 0) {
            yield this.buffer.substr(this.pos, n);
            this.pos = i;
        }
        return n;
    }
    *pushUntil(test) {
        let i = this.pos;
        let ch = this.buffer[i];
        while (!test(ch))
            ch = this.buffer[++i];
        return yield* this.pushToIndex(i, false);
    }
}

/**
 * Tracks newlines during parsing in order to provide an efficient API for
 * determining the one-indexed `{ line, col }` position for any offset
 * within the input.
 */
class LineCounter {
    constructor() {
        this.lineStarts = [];
        /**
         * Should be called in ascending order. Otherwise, call
         * `lineCounter.lineStarts.sort()` before calling `linePos()`.
         */
        this.addNewLine = (offset) => this.lineStarts.push(offset);
        /**
         * Performs a binary search and returns the 1-indexed { line, col }
         * position of `offset`. If `line === 0`, `addNewLine` has never been
         * called or `offset` is before the first known newline.
         */
        this.linePos = (offset) => {
            let low = 0;
            let high = this.lineStarts.length;
            while (low < high) {
                const mid = (low + high) >> 1; // Math.floor((low + high) / 2)
                if (this.lineStarts[mid] < offset)
                    low = mid + 1;
                else
                    high = mid;
            }
            if (this.lineStarts[low] === offset)
                return { line: low + 1, col: 1 };
            if (low === 0)
                return { line: 0, col: offset };
            const start = this.lineStarts[low - 1];
            return { line: low, col: offset - start + 1 };
        };
    }
}

function includesToken(list, type) {
    for (let i = 0; i < list.length; ++i)
        if (list[i].type === type)
            return true;
    return false;
}
function findNonEmptyIndex(list) {
    for (let i = 0; i < list.length; ++i) {
        switch (list[i].type) {
            case 'space':
            case 'comment':
            case 'newline':
                break;
            default:
                return i;
        }
    }
    return -1;
}
function isFlowToken(token) {
    switch (token?.type) {
        case 'alias':
        case 'scalar':
        case 'single-quoted-scalar':
        case 'double-quoted-scalar':
        case 'flow-collection':
            return true;
        default:
            return false;
    }
}
function getPrevProps(parent) {
    switch (parent.type) {
        case 'document':
            return parent.start;
        case 'block-map': {
            const it = parent.items[parent.items.length - 1];
            return it.sep ?? it.start;
        }
        case 'block-seq':
            return parent.items[parent.items.length - 1].start;
        /* istanbul ignore next should not happen */
        default:
            return [];
    }
}
/** Note: May modify input array */
function getFirstKeyStartProps(prev) {
    if (prev.length === 0)
        return [];
    let i = prev.length;
    loop: while (--i >= 0) {
        switch (prev[i].type) {
            case 'doc-start':
            case 'explicit-key-ind':
            case 'map-value-ind':
            case 'seq-item-ind':
            case 'newline':
                break loop;
        }
    }
    while (prev[++i]?.type === 'space') {
        /* loop */
    }
    return prev.splice(i, prev.length);
}
function fixFlowSeqItems(fc) {
    if (fc.start.type === 'flow-seq-start') {
        for (const it of fc.items) {
            if (it.sep &&
                !it.value &&
                !includesToken(it.start, 'explicit-key-ind') &&
                !includesToken(it.sep, 'map-value-ind')) {
                if (it.key)
                    it.value = it.key;
                delete it.key;
                if (isFlowToken(it.value)) {
                    if (it.value.end)
                        Array.prototype.push.apply(it.value.end, it.sep);
                    else
                        it.value.end = it.sep;
                }
                else
                    Array.prototype.push.apply(it.start, it.sep);
                delete it.sep;
            }
        }
    }
}
/**
 * A YAML concrete syntax tree (CST) parser
 *
 * ```ts
 * const src: string = ...
 * for (const token of new Parser().parse(src)) {
 *   // token: Token
 * }
 * ```
 *
 * To use the parser with a user-provided lexer:
 *
 * ```ts
 * function* parse(source: string, lexer: Lexer) {
 *   const parser = new Parser()
 *   for (const lexeme of lexer.lex(source))
 *     yield* parser.next(lexeme)
 *   yield* parser.end()
 * }
 *
 * const src: string = ...
 * const lexer = new Lexer()
 * for (const token of parse(src, lexer)) {
 *   // token: Token
 * }
 * ```
 */
class Parser {
    /**
     * @param onNewLine - If defined, called separately with the start position of
     *   each new line (in `parse()`, including the start of input).
     */
    constructor(onNewLine) {
        /** If true, space and sequence indicators count as indentation */
        this.atNewLine = true;
        /** If true, next token is a scalar value */
        this.atScalar = false;
        /** Current indentation level */
        this.indent = 0;
        /** Current offset since the start of parsing */
        this.offset = 0;
        /** On the same line with a block map key */
        this.onKeyLine = false;
        /** Top indicates the node that's currently being built */
        this.stack = [];
        /** The source of the current token, set in parse() */
        this.source = '';
        /** The type of the current token, set in parse() */
        this.type = '';
        // Must be defined after `next()`
        this.lexer = new Lexer();
        this.onNewLine = onNewLine;
    }
    /**
     * Parse `source` as a YAML stream.
     * If `incomplete`, a part of the last line may be left as a buffer for the next call.
     *
     * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
     *
     * @returns A generator of tokens representing each directive, document, and other structure.
     */
    *parse(source, incomplete = false) {
        if (this.onNewLine && this.offset === 0)
            this.onNewLine(0);
        for (const lexeme of this.lexer.lex(source, incomplete))
            yield* this.next(lexeme);
        if (!incomplete)
            yield* this.end();
    }
    /**
     * Advance the parser by the `source` of one lexical token.
     */
    *next(source) {
        this.source = source;
        if (this.atScalar) {
            this.atScalar = false;
            yield* this.step();
            this.offset += source.length;
            return;
        }
        const type = tokenType(source);
        if (!type) {
            const message = `Not a YAML token: ${source}`;
            yield* this.pop({ type: 'error', offset: this.offset, message, source });
            this.offset += source.length;
        }
        else if (type === 'scalar') {
            this.atNewLine = false;
            this.atScalar = true;
            this.type = 'scalar';
        }
        else {
            this.type = type;
            yield* this.step();
            switch (type) {
                case 'newline':
                    this.atNewLine = true;
                    this.indent = 0;
                    if (this.onNewLine)
                        this.onNewLine(this.offset + source.length);
                    break;
                case 'space':
                    if (this.atNewLine && source[0] === ' ')
                        this.indent += source.length;
                    break;
                case 'explicit-key-ind':
                case 'map-value-ind':
                case 'seq-item-ind':
                    if (this.atNewLine)
                        this.indent += source.length;
                    break;
                case 'doc-mode':
                case 'flow-error-end':
                    return;
                default:
                    this.atNewLine = false;
            }
            this.offset += source.length;
        }
    }
    /** Call at end of input to push out any remaining constructions */
    *end() {
        while (this.stack.length > 0)
            yield* this.pop();
    }
    get sourceToken() {
        const st = {
            type: this.type,
            offset: this.offset,
            indent: this.indent,
            source: this.source
        };
        return st;
    }
    *step() {
        const top = this.peek(1);
        if (this.type === 'doc-end' && (!top || top.type !== 'doc-end')) {
            while (this.stack.length > 0)
                yield* this.pop();
            this.stack.push({
                type: 'doc-end',
                offset: this.offset,
                source: this.source
            });
            return;
        }
        if (!top)
            return yield* this.stream();
        switch (top.type) {
            case 'document':
                return yield* this.document(top);
            case 'alias':
            case 'scalar':
            case 'single-quoted-scalar':
            case 'double-quoted-scalar':
                return yield* this.scalar(top);
            case 'block-scalar':
                return yield* this.blockScalar(top);
            case 'block-map':
                return yield* this.blockMap(top);
            case 'block-seq':
                return yield* this.blockSequence(top);
            case 'flow-collection':
                return yield* this.flowCollection(top);
            case 'doc-end':
                return yield* this.documentEnd(top);
        }
        /* istanbul ignore next should not happen */
        yield* this.pop();
    }
    peek(n) {
        return this.stack[this.stack.length - n];
    }
    *pop(error) {
        const token = error ?? this.stack.pop();
        /* istanbul ignore if should not happen */
        if (!token) {
            const message = 'Tried to pop an empty stack';
            yield { type: 'error', offset: this.offset, source: '', message };
        }
        else if (this.stack.length === 0) {
            yield token;
        }
        else {
            const top = this.peek(1);
            if (token.type === 'block-scalar') {
                // Block scalars use their parent rather than header indent
                token.indent = 'indent' in top ? top.indent : 0;
            }
            else if (token.type === 'flow-collection' && top.type === 'document') {
                // Ignore all indent for top-level flow collections
                token.indent = 0;
            }
            if (token.type === 'flow-collection')
                fixFlowSeqItems(token);
            switch (top.type) {
                case 'document':
                    top.value = token;
                    break;
                case 'block-scalar':
                    top.props.push(token); // error
                    break;
                case 'block-map': {
                    const it = top.items[top.items.length - 1];
                    if (it.value) {
                        top.items.push({ start: [], key: token, sep: [] });
                        this.onKeyLine = true;
                        return;
                    }
                    else if (it.sep) {
                        it.value = token;
                    }
                    else {
                        Object.assign(it, { key: token, sep: [] });
                        this.onKeyLine = !includesToken(it.start, 'explicit-key-ind');
                        return;
                    }
                    break;
                }
                case 'block-seq': {
                    const it = top.items[top.items.length - 1];
                    if (it.value)
                        top.items.push({ start: [], value: token });
                    else
                        it.value = token;
                    break;
                }
                case 'flow-collection': {
                    const it = top.items[top.items.length - 1];
                    if (!it || it.value)
                        top.items.push({ start: [], key: token, sep: [] });
                    else if (it.sep)
                        it.value = token;
                    else
                        Object.assign(it, { key: token, sep: [] });
                    return;
                }
                /* istanbul ignore next should not happen */
                default:
                    yield* this.pop();
                    yield* this.pop(token);
            }
            if ((top.type === 'document' ||
                top.type === 'block-map' ||
                top.type === 'block-seq') &&
                (token.type === 'block-map' || token.type === 'block-seq')) {
                const last = token.items[token.items.length - 1];
                if (last &&
                    !last.sep &&
                    !last.value &&
                    last.start.length > 0 &&
                    findNonEmptyIndex(last.start) === -1 &&
                    (token.indent === 0 ||
                        last.start.every(st => st.type !== 'comment' || st.indent < token.indent))) {
                    if (top.type === 'document')
                        top.end = last.start;
                    else
                        top.items.push({ start: last.start });
                    token.items.splice(-1, 1);
                }
            }
        }
    }
    *stream() {
        switch (this.type) {
            case 'directive-line':
                yield { type: 'directive', offset: this.offset, source: this.source };
                return;
            case 'byte-order-mark':
            case 'space':
            case 'comment':
            case 'newline':
                yield this.sourceToken;
                return;
            case 'doc-mode':
            case 'doc-start': {
                const doc = {
                    type: 'document',
                    offset: this.offset,
                    start: []
                };
                if (this.type === 'doc-start')
                    doc.start.push(this.sourceToken);
                this.stack.push(doc);
                return;
            }
        }
        yield {
            type: 'error',
            offset: this.offset,
            message: `Unexpected ${this.type} token in YAML stream`,
            source: this.source
        };
    }
    *document(doc) {
        if (doc.value)
            return yield* this.lineEnd(doc);
        switch (this.type) {
            case 'doc-start': {
                if (findNonEmptyIndex(doc.start) !== -1) {
                    yield* this.pop();
                    yield* this.step();
                }
                else
                    doc.start.push(this.sourceToken);
                return;
            }
            case 'anchor':
            case 'tag':
            case 'space':
            case 'comment':
            case 'newline':
                doc.start.push(this.sourceToken);
                return;
        }
        const bv = this.startBlockValue(doc);
        if (bv)
            this.stack.push(bv);
        else {
            yield {
                type: 'error',
                offset: this.offset,
                message: `Unexpected ${this.type} token in YAML document`,
                source: this.source
            };
        }
    }
    *scalar(scalar) {
        if (this.type === 'map-value-ind') {
            const prev = getPrevProps(this.peek(2));
            const start = getFirstKeyStartProps(prev);
            let sep;
            if (scalar.end) {
                sep = scalar.end;
                sep.push(this.sourceToken);
                delete scalar.end;
            }
            else
                sep = [this.sourceToken];
            const map = {
                type: 'block-map',
                offset: scalar.offset,
                indent: scalar.indent,
                items: [{ start, key: scalar, sep }]
            };
            this.onKeyLine = true;
            this.stack[this.stack.length - 1] = map;
        }
        else
            yield* this.lineEnd(scalar);
    }
    *blockScalar(scalar) {
        switch (this.type) {
            case 'space':
            case 'comment':
            case 'newline':
                scalar.props.push(this.sourceToken);
                return;
            case 'scalar':
                scalar.source = this.source;
                // block-scalar source includes trailing newline
                this.atNewLine = true;
                this.indent = 0;
                if (this.onNewLine) {
                    let nl = this.source.indexOf('\n') + 1;
                    while (nl !== 0) {
                        this.onNewLine(this.offset + nl);
                        nl = this.source.indexOf('\n', nl) + 1;
                    }
                }
                yield* this.pop();
                break;
            /* istanbul ignore next should not happen */
            default:
                yield* this.pop();
                yield* this.step();
        }
    }
    *blockMap(map) {
        const it = map.items[map.items.length - 1];
        // it.sep is true-ish if pair already has key or : separator
        switch (this.type) {
            case 'newline':
                this.onKeyLine = false;
                if (it.value) {
                    const end = 'end' in it.value ? it.value.end : undefined;
                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;
                    if (last?.type === 'comment')
                        end?.push(this.sourceToken);
                    else
                        map.items.push({ start: [this.sourceToken] });
                }
                else if (it.sep) {
                    it.sep.push(this.sourceToken);
                }
                else {
                    it.start.push(this.sourceToken);
                }
                return;
            case 'space':
            case 'comment':
                if (it.value) {
                    map.items.push({ start: [this.sourceToken] });
                }
                else if (it.sep) {
                    it.sep.push(this.sourceToken);
                }
                else {
                    if (this.atIndentedComment(it.start, map.indent)) {
                        const prev = map.items[map.items.length - 2];
                        const end = prev?.value?.end;
                        if (Array.isArray(end)) {
                            Array.prototype.push.apply(end, it.start);
                            end.push(this.sourceToken);
                            map.items.pop();
                            return;
                        }
                    }
                    it.start.push(this.sourceToken);
                }
                return;
        }
        if (this.indent >= map.indent) {
            const atNextItem = !this.onKeyLine && this.indent === map.indent && it.sep;
            // For empty nodes, assign newline-separated not indented empty tokens to following node
            let start = [];
            if (atNextItem && it.sep && !it.value) {
                const nl = [];
                for (let i = 0; i < it.sep.length; ++i) {
                    const st = it.sep[i];
                    switch (st.type) {
                        case 'newline':
                            nl.push(i);
                            break;
                        case 'space':
                            break;
                        case 'comment':
                            if (st.indent > map.indent)
                                nl.length = 0;
                            break;
                        default:
                            nl.length = 0;
                    }
                }
                if (nl.length >= 2)
                    start = it.sep.splice(nl[1]);
            }
            switch (this.type) {
                case 'anchor':
                case 'tag':
                    if (atNextItem || it.value) {
                        start.push(this.sourceToken);
                        map.items.push({ start });
                        this.onKeyLine = true;
                    }
                    else if (it.sep) {
                        it.sep.push(this.sourceToken);
                    }
                    else {
                        it.start.push(this.sourceToken);
                    }
                    return;
                case 'explicit-key-ind':
                    if (!it.sep && !includesToken(it.start, 'explicit-key-ind')) {
                        it.start.push(this.sourceToken);
                    }
                    else if (atNextItem || it.value) {
                        start.push(this.sourceToken);
                        map.items.push({ start });
                    }
                    else {
                        this.stack.push({
                            type: 'block-map',
                            offset: this.offset,
                            indent: this.indent,
                            items: [{ start: [this.sourceToken] }]
                        });
                    }
                    this.onKeyLine = true;
                    return;
                case 'map-value-ind':
                    if (includesToken(it.start, 'explicit-key-ind')) {
                        if (!it.sep) {
                            if (includesToken(it.start, 'newline')) {
                                Object.assign(it, { key: null, sep: [this.sourceToken] });
                            }
                            else {
                                const start = getFirstKeyStartProps(it.start);
                                this.stack.push({
                                    type: 'block-map',
                                    offset: this.offset,
                                    indent: this.indent,
                                    items: [{ start, key: null, sep: [this.sourceToken] }]
                                });
                            }
                        }
                        else if (it.value) {
                            map.items.push({ start: [], key: null, sep: [this.sourceToken] });
                        }
                        else if (includesToken(it.sep, 'map-value-ind')) {
                            this.stack.push({
                                type: 'block-map',
                                offset: this.offset,
                                indent: this.indent,
                                items: [{ start, key: null, sep: [this.sourceToken] }]
                            });
                        }
                        else if (isFlowToken(it.key) &&
                            !includesToken(it.sep, 'newline')) {
                            const start = getFirstKeyStartProps(it.start);
                            const key = it.key;
                            const sep = it.sep;
                            sep.push(this.sourceToken);
                            // @ts-expect-error type guard is wrong here
                            delete it.key, delete it.sep;
                            this.stack.push({
                                type: 'block-map',
                                offset: this.offset,
                                indent: this.indent,
                                items: [{ start, key, sep }]
                            });
                        }
                        else if (start.length > 0) {
                            // Not actually at next item
                            it.sep = it.sep.concat(start, this.sourceToken);
                        }
                        else {
                            it.sep.push(this.sourceToken);
                        }
                    }
                    else {
                        if (!it.sep) {
                            Object.assign(it, { key: null, sep: [this.sourceToken] });
                        }
                        else if (it.value || atNextItem) {
                            map.items.push({ start, key: null, sep: [this.sourceToken] });
                        }
                        else if (includesToken(it.sep, 'map-value-ind')) {
                            this.stack.push({
                                type: 'block-map',
                                offset: this.offset,
                                indent: this.indent,
                                items: [{ start: [], key: null, sep: [this.sourceToken] }]
                            });
                        }
                        else {
                            it.sep.push(this.sourceToken);
                        }
                    }
                    this.onKeyLine = true;
                    return;
                case 'alias':
                case 'scalar':
                case 'single-quoted-scalar':
                case 'double-quoted-scalar': {
                    const fs = this.flowScalar(this.type);
                    if (atNextItem || it.value) {
                        map.items.push({ start, key: fs, sep: [] });
                        this.onKeyLine = true;
                    }
                    else if (it.sep) {
                        this.stack.push(fs);
                    }
                    else {
                        Object.assign(it, { key: fs, sep: [] });
                        this.onKeyLine = true;
                    }
                    return;
                }
                default: {
                    const bv = this.startBlockValue(map);
                    if (bv) {
                        if (atNextItem &&
                            bv.type !== 'block-seq' &&
                            includesToken(it.start, 'explicit-key-ind')) {
                            map.items.push({ start });
                        }
                        this.stack.push(bv);
                        return;
                    }
                }
            }
        }
        yield* this.pop();
        yield* this.step();
    }
    *blockSequence(seq) {
        const it = seq.items[seq.items.length - 1];
        switch (this.type) {
            case 'newline':
                if (it.value) {
                    const end = 'end' in it.value ? it.value.end : undefined;
                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;
                    if (last?.type === 'comment')
                        end?.push(this.sourceToken);
                    else
                        seq.items.push({ start: [this.sourceToken] });
                }
                else
                    it.start.push(this.sourceToken);
                return;
            case 'space':
            case 'comment':
                if (it.value)
                    seq.items.push({ start: [this.sourceToken] });
                else {
                    if (this.atIndentedComment(it.start, seq.indent)) {
                        const prev = seq.items[seq.items.length - 2];
                        const end = prev?.value?.end;
                        if (Array.isArray(end)) {
                            Array.prototype.push.apply(end, it.start);
                            end.push(this.sourceToken);
                            seq.items.pop();
                            return;
                        }
                    }
                    it.start.push(this.sourceToken);
                }
                return;
            case 'anchor':
            case 'tag':
                if (it.value || this.indent <= seq.indent)
                    break;
                it.start.push(this.sourceToken);
                return;
            case 'seq-item-ind':
                if (this.indent !== seq.indent)
                    break;
                if (it.value || includesToken(it.start, 'seq-item-ind'))
                    seq.items.push({ start: [this.sourceToken] });
                else
                    it.start.push(this.sourceToken);
                return;
        }
        if (this.indent > seq.indent) {
            const bv = this.startBlockValue(seq);
            if (bv) {
                this.stack.push(bv);
                return;
            }
        }
        yield* this.pop();
        yield* this.step();
    }
    *flowCollection(fc) {
        const it = fc.items[fc.items.length - 1];
        if (this.type === 'flow-error-end') {
            let top;
            do {
                yield* this.pop();
                top = this.peek(1);
            } while (top && top.type === 'flow-collection');
        }
        else if (fc.end.length === 0) {
            switch (this.type) {
                case 'comma':
                case 'explicit-key-ind':
                    if (!it || it.sep)
                        fc.items.push({ start: [this.sourceToken] });
                    else
                        it.start.push(this.sourceToken);
                    return;
                case 'map-value-ind':
                    if (!it || it.value)
                        fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
                    else if (it.sep)
                        it.sep.push(this.sourceToken);
                    else
                        Object.assign(it, { key: null, sep: [this.sourceToken] });
                    return;
                case 'space':
                case 'comment':
                case 'newline':
                case 'anchor':
                case 'tag':
                    if (!it || it.value)
                        fc.items.push({ start: [this.sourceToken] });
                    else if (it.sep)
                        it.sep.push(this.sourceToken);
                    else
                        it.start.push(this.sourceToken);
                    return;
                case 'alias':
                case 'scalar':
                case 'single-quoted-scalar':
                case 'double-quoted-scalar': {
                    const fs = this.flowScalar(this.type);
                    if (!it || it.value)
                        fc.items.push({ start: [], key: fs, sep: [] });
                    else if (it.sep)
                        this.stack.push(fs);
                    else
                        Object.assign(it, { key: fs, sep: [] });
                    return;
                }
                case 'flow-map-end':
                case 'flow-seq-end':
                    fc.end.push(this.sourceToken);
                    return;
            }
            const bv = this.startBlockValue(fc);
            /* istanbul ignore else should not happen */
            if (bv)
                this.stack.push(bv);
            else {
                yield* this.pop();
                yield* this.step();
            }
        }
        else {
            const parent = this.peek(2);
            if (parent.type === 'block-map' &&
                ((this.type === 'map-value-ind' && parent.indent === fc.indent) ||
                    (this.type === 'newline' &&
                        !parent.items[parent.items.length - 1].sep))) {
                yield* this.pop();
                yield* this.step();
            }
            else if (this.type === 'map-value-ind' &&
                parent.type !== 'flow-collection') {
                const prev = getPrevProps(parent);
                const start = getFirstKeyStartProps(prev);
                fixFlowSeqItems(fc);
                const sep = fc.end.splice(1, fc.end.length);
                sep.push(this.sourceToken);
                const map = {
                    type: 'block-map',
                    offset: fc.offset,
                    indent: fc.indent,
                    items: [{ start, key: fc, sep }]
                };
                this.onKeyLine = true;
                this.stack[this.stack.length - 1] = map;
            }
            else {
                yield* this.lineEnd(fc);
            }
        }
    }
    flowScalar(type) {
        if (this.onNewLine) {
            let nl = this.source.indexOf('\n') + 1;
            while (nl !== 0) {
                this.onNewLine(this.offset + nl);
                nl = this.source.indexOf('\n', nl) + 1;
            }
        }
        return {
            type,
            offset: this.offset,
            indent: this.indent,
            source: this.source
        };
    }
    startBlockValue(parent) {
        switch (this.type) {
            case 'alias':
            case 'scalar':
            case 'single-quoted-scalar':
            case 'double-quoted-scalar':
                return this.flowScalar(this.type);
            case 'block-scalar-header':
                return {
                    type: 'block-scalar',
                    offset: this.offset,
                    indent: this.indent,
                    props: [this.sourceToken],
                    source: ''
                };
            case 'flow-map-start':
            case 'flow-seq-start':
                return {
                    type: 'flow-collection',
                    offset: this.offset,
                    indent: this.indent,
                    start: this.sourceToken,
                    items: [],
                    end: []
                };
            case 'seq-item-ind':
                return {
                    type: 'block-seq',
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: [this.sourceToken] }]
                };
            case 'explicit-key-ind': {
                this.onKeyLine = true;
                const prev = getPrevProps(parent);
                const start = getFirstKeyStartProps(prev);
                start.push(this.sourceToken);
                return {
                    type: 'block-map',
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start }]
                };
            }
            case 'map-value-ind': {
                this.onKeyLine = true;
                const prev = getPrevProps(parent);
                const start = getFirstKeyStartProps(prev);
                return {
                    type: 'block-map',
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start, key: null, sep: [this.sourceToken] }]
                };
            }
        }
        return null;
    }
    atIndentedComment(start, indent) {
        if (this.type !== 'comment')
            return false;
        if (this.indent <= indent)
            return false;
        return start.every(st => st.type === 'newline' || st.type === 'space');
    }
    *documentEnd(docEnd) {
        if (this.type !== 'doc-mode') {
            if (docEnd.end)
                docEnd.end.push(this.sourceToken);
            else
                docEnd.end = [this.sourceToken];
            if (this.type === 'newline')
                yield* this.pop();
        }
    }
    *lineEnd(token) {
        switch (this.type) {
            case 'comma':
            case 'doc-start':
            case 'doc-end':
            case 'flow-seq-end':
            case 'flow-map-end':
            case 'map-value-ind':
                yield* this.pop();
                yield* this.step();
                break;
            case 'newline':
                this.onKeyLine = false;
            // fallthrough
            case 'space':
            case 'comment':
            default:
                // all other values are errors
                if (token.end)
                    token.end.push(this.sourceToken);
                else
                    token.end = [this.sourceToken];
                if (this.type === 'newline')
                    yield* this.pop();
        }
    }
}

function parseOptions(options) {
    const prettyErrors = options.prettyErrors !== false;
    const lineCounter = options.lineCounter || (prettyErrors && new LineCounter()) || null;
    return { lineCounter, prettyErrors };
}
/** Parse an input string into a single YAML.Document */
function parseDocument(source, options = {}) {
    const { lineCounter, prettyErrors } = parseOptions(options);
    const parser = new Parser(lineCounter?.addNewLine);
    const composer = new Composer(options);
    // `doc` is always set by compose.end(true) at the very latest
    let doc = null;
    for (const _doc of composer.compose(parser.parse(source), true, source.length)) {
        if (!doc)
            doc = _doc;
        else if (doc.options.logLevel !== 'silent') {
            doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), 'MULTIPLE_DOCS', 'Source contains multiple documents; please use YAML.parseAllDocuments()'));
            break;
        }
    }
    if (prettyErrors && lineCounter) {
        doc.errors.forEach(prettifyError(source, lineCounter));
        doc.warnings.forEach(prettifyError(source, lineCounter));
    }
    return doc;
}

function getLocationInYamlScript(file, path, kind = "value") {
    var _a, _b, _c, _d;
    const node = findYamlNode(file, path, kind);
    return {
        file: file.file,
        pos: (_b = (_a = node === null || node === void 0 ? void 0 : node.range) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : 0,
        end: (_d = (_c = node === null || node === void 0 ? void 0 : node.range) === null || _c === void 0 ? void 0 : _c[1]) !== null && _d !== void 0 ? _d : 0,
    };
}
function findYamlNode(file, path, kind = "value") {
    let current = file.doc.contents;
    for (let i = 0; i < path.length; i++) {
        const key = path[i];
        const isLast = i === path.length - 1;
        if (isScalar(current)) {
            return current;
        }
        else if (isCollection(current)) {
            if (isLast) {
                if (kind === "value" || !isMap(current)) {
                    return current.get(key, true);
                }
                else {
                    const pair = findPair(current.items, key);
                    if (kind === "key") {
                        return pair === null || pair === void 0 ? void 0 : pair.key;
                    }
                    else {
                        return pair;
                    }
                }
            }
            else {
                current = current.get(key, true);
            }
        }
        else {
            continue;
        }
    }
    return current !== null && current !== void 0 ? current : undefined;
}

function createJSONSchemaValidator(schema, options = { strict: true }) {
    const ajv = new Ajv({
        strict: options.strict,
        coerceTypes: options.coerceTypes,
        allErrors: true,
    });
    ajv.addFormat("absolute-path", {
        type: "string",
        validate: (path) => {
            return !path.startsWith(".") && isPathAbsolute(path);
        },
    });
    return { validate };
    function validate(config, target) {
        var _a;
        const validate = ajv.compile(schema);
        const valid = validate(config);
        compilerAssert(!valid || !validate.errors, "There should be errors reported if the schema is not valid.");
        const diagnostics = [];
        for (const error of (_a = validate.errors) !== null && _a !== void 0 ? _a : []) {
            const diagnostic = ajvErrorToDiagnostic(config, error, target);
            diagnostics.push(diagnostic);
        }
        return diagnostics;
    }
}
const IGNORED_AJV_PARAMS = new Set(["type", "errors"]);
function ajvErrorToDiagnostic(obj, error, target) {
    const tspTarget = resolveTarget(error, target);
    if (error.params.format === "absolute-path") {
        return createDiagnostic({
            code: "config-path-absolute",
            format: { path: getErrorValue(obj, error) },
            target: tspTarget,
        });
    }
    const messageLines = [`Schema violation: ${error.message} (${error.instancePath || "/"})`];
    for (const [name, value] of Object.entries(error.params).filter(([name]) => !IGNORED_AJV_PARAMS.has(name))) {
        const formattedValue = Array.isArray(value) ? [...new Set(value)].join(", ") : value;
        messageLines.push(`  ${name}: ${formattedValue}`);
    }
    const message = messageLines.join("\n");
    return {
        code: "invalid-schema",
        message,
        severity: "error",
        target: tspTarget,
    };
}
function resolveTarget(error, target) {
    if (target === NoTarget) {
        return NoTarget;
    }
    if (!("kind" in target)) {
        return { file: target, pos: 0, end: 0 };
    }
    switch (target.kind) {
        case "yaml-script":
            return getLocationInYamlScript(target, getErrorPath(error), "key");
        case "path-target":
            return getLocationInYamlScript(target.script, [...target.path, ...getErrorPath(error)], "key");
    }
}
function getErrorPath(error) {
    const instancePath = parseJsonPointer(error.instancePath);
    switch (error.keyword) {
        case "additionalProperties":
            return [...instancePath, error.params.additionalProperty];
        default:
            return instancePath;
    }
}
function getErrorValue(obj, error) {
    const path = getErrorPath(error);
    let current = obj;
    for (const segment of path) {
        current = current[segment];
    }
    return current;
}
/**
 * Converts a json pointer into a array of reference tokens
 */
function parseJsonPointer(pointer) {
    if (pointer === "") {
        return [];
    }
    if (pointer.charAt(0) !== "/") {
        compilerAssert(false, `Invalid JSON pointer: "${pointer}"`);
    }
    return pointer.substring(1).split(/\//).map(unescape);
}
/**
 * Unescape a reference token
 *
 * @param str
 * @returns {string}
 */
function unescape(str) {
    return str.replace(/~1/g, "/").replace(/~0/g, "~");
}

const globalLibraryUrlsLoadedSym = Symbol.for("TYPESPEC_LIBRARY_URLS_LOADED");
if (globalThis[globalLibraryUrlsLoadedSym] === undefined) {
    globalThis[globalLibraryUrlsLoadedSym] = new Set();
}
const loadedUrls = globalThis[globalLibraryUrlsLoadedSym];
/**
 * @internal List of urls that used `createTypeSpecLibrary`. Used to keep track of the loaded version of library and make sure they are compatible.
 */
function getLibraryUrlsLoaded() {
    return loadedUrls;
}
/** @deprecated use createTypeSpecLibrary */
const createCadlLibrary = createTypeSpecLibrary;
/**
 * Create a new TypeSpec library definition.
 * @param lib Library definition.
 * @returns Library with utility functions.
 *
 *
 * @tutorial Create the lib object with `as const` to get the full typing.
 *
 * @example
 * const libDef = {
 *   name: "myLib",
 *   diagnostics: {
 *    "my-code": {serverity: "error", messages: {default: "Foo bar"}}
 *   },
 * } as const;
 *
 * const lib = createTypeSpecLibrary(libDef);
 */
function createTypeSpecLibrary(lib) {
    let emitterOptionValidator;
    const { reportDiagnostic, createDiagnostic } = createDiagnosticCreator(lib.diagnostics, lib.name);
    function createStateSymbol(name) {
        return Symbol.for(`${lib.name}.${name}`);
    }
    const caller = getCaller();
    if (caller) {
        loadedUrls.add(caller);
    }
    return {
        ...lib,
        reportDiagnostic,
        createDiagnostic,
        createStateSymbol,
        get emitterOptionValidator() {
            var _a;
            if (!emitterOptionValidator && ((_a = lib.emitter) === null || _a === void 0 ? void 0 : _a.options)) {
                emitterOptionValidator = createJSONSchemaValidator(lib.emitter.options, {
                    coerceTypes: true,
                });
            }
            return emitterOptionValidator;
        },
        getTracer,
    };
    function getTracer(program) {
        return program.tracer.sub(lib.name);
    }
}
function paramMessage(strings, ...keys) {
    const template = (dict) => {
        const result = [strings[0]];
        keys.forEach((key, i) => {
            const value = dict[key];
            if (value !== undefined) {
                result.push(value);
            }
            result.push(strings[i + 1]);
        });
        return result.join("");
    };
    template.keys = keys;
    return template;
}
/** Create a new linter rule. */
function createLinterRule(definition) {
    compilerAssert(!definition.name.includes("/"), "Rule name cannot contain a '/'.");
    return definition;
}
/** @deprecated use setTypeSpecNamespace */
const setCadlNamespace = setTypeSpecNamespace;
/**
 * Set the TypeSpec namespace for that function.
 * @param namespace Namespace string (e.g. "Foo.Bar")
 * @param functions Functions
 */
function setTypeSpecNamespace(namespace, ...functions) {
    functions.forEach((c) => (c.namespace = namespace));
}
function getCaller() {
    const caller = getCallStack()[2];
    return typeof caller === "object" && "getFileName" in caller ? caller.getFileName() : undefined;
}
function getCallStack() {
    const _prepareStackTrace = Error.prepareStackTrace;
    Error.prepareStackTrace = (_, stack) => stack;
    const stack = new Error().stack.slice(1); // eslint-disable-line unicorn/error-message
    Error.prepareStackTrace = _prepareStackTrace;
    return stack;
}

// Static assert: this won't compile if one of the entries above is invalid.
const diagnostics = {
    /**
     * Scanner errors.
     */
    "digit-expected": {
        severity: "error",
        messages: {
            default: "Digit expected.",
        },
    },
    "hex-digit-expected": {
        severity: "error",
        messages: {
            default: "Hexadecimal digit expected.",
        },
    },
    "binary-digit-expected": {
        severity: "error",
        messages: {
            default: "Binary digit expected.",
        },
    },
    unterminated: {
        severity: "error",
        messages: {
            default: paramMessage `Unterminated ${"token"}.`,
        },
    },
    "creating-file": {
        severity: "error",
        messages: {
            default: paramMessage `Error creating single file: ${"filename"},  ${"error"}`,
        },
    },
    "invalid-escape-sequence": {
        severity: "error",
        messages: {
            default: "Invalid escape sequence.",
        },
    },
    "no-new-line-start-triple-quote": {
        severity: "error",
        messages: {
            default: "String content in triple quotes must begin on a new line.",
        },
    },
    "no-new-line-end-triple-quote": {
        severity: "error",
        messages: {
            default: "Closing triple quotes must begin on a new line.",
        },
    },
    "triple-quote-indent": {
        severity: "error",
        messages: {
            default: "All lines in triple-quoted string lines must have the same indentation as closing triple quotes.",
        },
    },
    "invalid-character": {
        severity: "error",
        messages: {
            default: "Invalid character.",
        },
    },
    /**
     * Utils
     */
    "file-not-found": {
        severity: "error",
        messages: {
            default: paramMessage `File ${"path"} not found.`,
        },
    },
    "file-load": {
        severity: "error",
        messages: {
            default: paramMessage `${"message"}`,
        },
    },
    /**
     * Init templates
     */
    "init-template-invalid-json": {
        severity: "error",
        messages: {
            default: paramMessage `Unable to parse ${"url"}: ${"message"}. Check that the template URL is correct.`,
        },
    },
    "init-template-download-failed": {
        severity: "error",
        messages: {
            default: paramMessage `Failed to download template from ${"url"}: ${"message"}. Check that the template URL is correct.`,
        },
    },
    /**
     * Parser errors.
     */
    "multiple-blockless-namespace": {
        severity: "error",
        messages: {
            default: "Cannot use multiple blockless namespaces.",
        },
    },
    "blockless-namespace-first": {
        severity: "error",
        messages: {
            default: "Blockless namespaces can't follow other declarations.",
            topLevel: "Blockless namespace can only be top-level.",
        },
    },
    "import-first": {
        severity: "error",
        messages: {
            default: "Imports must come prior to namespaces or other declarations.",
            topLevel: "Imports must be top-level and come prior to namespaces or other declarations.",
        },
    },
    "token-expected": {
        severity: "error",
        messages: {
            default: paramMessage `${"token"} expected.`,
            unexpected: paramMessage `Unexpected token ${"token"}`,
            numericOrStringLiteral: "Expected numeric or string literal.",
            identifier: "Identifier expected.",
            projectionDirection: "from or to expected.",
            expression: "Expression expected.",
            statement: "Statement expected.",
            property: "Property expected.",
            enumMember: "Enum member expected.",
        },
    },
    "trailing-token": {
        severity: "error",
        messages: {
            default: paramMessage `Trailing ${"token"}`,
        },
    },
    "unknown-directive": {
        severity: "error",
        messages: {
            default: paramMessage `Unknown directive '#${"id"}'`,
        },
    },
    "augment-decorator-target": {
        severity: "error",
        messages: {
            default: `Augment decorator first argument must be a type reference.`,
            noInstance: `Cannot reference template instances`,
        },
    },
    "duplicate-decorator": {
        severity: "warning",
        messages: {
            default: paramMessage `Decorator ${"decoratorName"} cannot be used twice on the same declaration.`,
        },
    },
    "decorator-conflict": {
        severity: "warning",
        messages: {
            default: paramMessage `Decorator ${"decoratorName"} cannot be used with decorator ${"otherDecoratorName"} on the same declaration.`,
        },
    },
    "reserved-identifier": {
        severity: "error",
        messages: {
            default: "Keyword cannot be used as identifier.",
        },
    },
    "invalid-directive-location": {
        severity: "error",
        messages: {
            default: paramMessage `Cannot place directive on ${"nodeName"}.`,
        },
    },
    "invalid-decorator-location": {
        severity: "error",
        messages: {
            default: paramMessage `Cannot decorate ${"nodeName"}.`,
        },
    },
    "invalid-projection": {
        severity: "error",
        messages: {
            default: "Invalid projection",
            wrongType: "Non-projection can't be used to project",
            noTo: "Projection missing to projection",
            projectionError: paramMessage `An error occurred when projecting this type: ${"message"}`,
        },
    },
    "default-required": {
        severity: "error",
        messages: {
            default: "Required template parameters must not follow optional template parameters",
        },
    },
    "invalid-template-default": {
        severity: "error",
        messages: {
            default: "Template parameter defaults can only reference previously declared type parameters.",
        },
    },
    "required-parameter-first": {
        severity: "error",
        messages: {
            default: "A required parameter cannot follow an optional parameter.",
        },
    },
    "rest-parameter-last": {
        severity: "error",
        messages: {
            default: "A rest parameter must be last in a parameter list.",
        },
    },
    "rest-parameter-required": {
        severity: "error",
        messages: {
            default: "A rest parameter cannot be optional.",
        },
    },
    /**
     * Parser doc comment warnings.
     * Design goal: Malformed doc comments should only produce warnings, not errors.
     */
    "doc-invalid-identifier": {
        severity: "warning",
        messages: {
            default: "Invalid identifier.",
            tag: "Invalid tag name. Use backticks around code if this was not meant to be a tag.",
            param: "Invalid parameter name.",
            templateParam: "Invalid template parameter name.",
        },
    },
    /**
     * Checker
     */
    "using-invalid-ref": {
        severity: "error",
        messages: {
            default: "Using must refer to a namespace",
        },
    },
    "invalid-type-ref": {
        severity: "error",
        messages: {
            default: "Invalid type reference",
            decorator: "Can't put a decorator in a type",
            function: "Can't use a function as a type",
        },
    },
    "invalid-template-args": {
        severity: "error",
        messages: {
            default: "Invalid template arguments.",
            notTemplate: "Can't pass template arguments to non-templated type",
            tooFew: "Too few template arguments provided.",
            tooMany: "Too many template arguments provided.",
        },
    },
    "intersect-non-model": {
        severity: "error",
        messages: {
            default: "Cannot intersect non-model types (including union types).",
        },
    },
    "intersect-invalid-index": {
        severity: "error",
        messages: {
            default: "Cannot intersect incompatible models.",
            never: "Cannot intersect a model that cannot hold properties.",
            array: "Cannot intersect an array model.",
        },
    },
    "intersect-duplicate-property": {
        severity: "error",
        messages: {
            default: paramMessage `Intersection contains duplicate property definitions for ${"propName"}`,
        },
    },
    "unknown-identifier": {
        severity: "error",
        messages: {
            default: paramMessage `Unknown identifier ${"id"}`,
        },
    },
    "unknown-decorator": {
        severity: "error",
        messages: {
            default: "Unknown decorator",
        },
    },
    "invalid-decorator": {
        severity: "error",
        messages: {
            default: paramMessage `${"id"} is not a decorator`,
        },
    },
    "invalid-ref": {
        severity: "error",
        messages: {
            default: paramMessage `Cannot resolve ${"id"}`,
            inDecorator: paramMessage `Cannot resolve ${"id"} in decorator`,
            underNamespace: paramMessage `Namespace ${"namespace"} doesn't have member ${"id"}`,
            underContainer: paramMessage `${"kind"} doesn't have member ${"id"}`,
            metaProperty: paramMessage `${"kind"} doesn't have meta property ${"id"}`,
            node: paramMessage `Cannot resolve '${"id"}' in node ${"nodeName"} since it has no members. Did you mean to use "::" instead of "."?`,
        },
    },
    "duplicate-property": {
        severity: "error",
        messages: {
            default: paramMessage `Model already has a property named ${"propName"}`,
        },
    },
    "override-property-mismatch": {
        severity: "error",
        messages: {
            default: paramMessage `Model has an inherited property named ${"propName"} of type ${"propType"} which cannot override type ${"parentType"}`,
        },
    },
    "extend-scalar": {
        severity: "error",
        messages: {
            default: "Scalar must extend other scalars.",
        },
    },
    "extend-model": {
        severity: "error",
        messages: {
            default: "Models must extend other models.",
            modelExpression: "Models cannot extend model expressions.",
        },
    },
    "is-model": {
        severity: "error",
        messages: {
            default: "Model `is` must specify another model.",
            modelExpression: "Model `is` cannot specify a model expression.",
        },
    },
    "is-operation": {
        severity: "error",
        messages: {
            default: "Operation can only reuse the signature of another operation.",
        },
    },
    "spread-model": {
        severity: "error",
        messages: {
            default: "Cannot spread properties of non-model type.",
            neverIndex: "Cannot spread type because it cannot hold properties.",
            selfSpread: "Cannot spread type within its own declaration.",
        },
    },
    "unsupported-default": {
        severity: "error",
        messages: {
            default: paramMessage `Default must be have a value type but has type '${"type"}'.`,
        },
    },
    unassignable: {
        severity: "error",
        messages: {
            default: paramMessage `Type '${"value"}' is not assignable to type '${"targetType"}'`,
            withDetails: paramMessage `Type '${"sourceType"}' is not assignable to type '${"targetType"}'\n  ${"details"}`,
        },
    },
    "no-prop": {
        severity: "error",
        messages: {
            default: paramMessage `Property '${"propName"}' cannot be defined because model cannot hold properties.`,
        },
    },
    "missing-index": {
        severity: "error",
        messages: {
            default: paramMessage `Index signature for type '${"indexType"}' is missing in type '${"sourceType"}'.`,
        },
    },
    "missing-property": {
        severity: "error",
        messages: {
            default: paramMessage `Property '${"propertyName"}' is missing on type '${"sourceType"}' but required in '${"targetType"}'`,
        },
    },
    "extends-interface": {
        severity: "error",
        messages: {
            default: "Interfaces can only extend other interfaces",
        },
    },
    "extends-interface-duplicate": {
        severity: "error",
        messages: {
            default: paramMessage `Interface extends cannot have duplicate members. The duplicate member is named ${"name"}`,
        },
    },
    "interface-duplicate": {
        severity: "error",
        messages: {
            default: paramMessage `Interface already has a member named ${"name"}`,
        },
    },
    "union-duplicate": {
        severity: "error",
        messages: {
            default: paramMessage `Union already has a variant named ${"name"}`,
        },
    },
    "enum-member-duplicate": {
        severity: "error",
        messages: {
            default: paramMessage `Enum already has a member named ${"name"}`,
        },
    },
    "spread-enum": {
        severity: "error",
        messages: {
            default: "Cannot spread members of non-enum type.",
        },
    },
    "decorator-fail": {
        severity: "error",
        messages: {
            default: paramMessage `Decorator ${"decoratorName"} failed!\n\n${"error"}`,
        },
    },
    "rest-parameter-array": {
        severity: "error",
        messages: {
            default: "A rest parameter must be of an array type.",
        },
    },
    "decorator-extern": {
        severity: "error",
        messages: {
            default: "A decorator declaration must be prefixed with the 'extern' modifier.",
        },
    },
    "function-extern": {
        severity: "error",
        messages: {
            default: "A function declaration must be prefixed with the 'extern' modifier.",
        },
    },
    "missing-implementation": {
        severity: "error",
        messages: {
            default: "Extern declaration must have an implementation in JS file.",
        },
    },
    "overload-same-parent": {
        severity: "error",
        messages: {
            default: `Overload must be in the same interface or namespace.`,
        },
    },
    shadow: {
        severity: "warning",
        messages: {
            default: paramMessage `Shadowing parent template parmaeter with the same name "${"name"}"`,
        },
    },
    "invalid-deprecation-argument": {
        severity: "error",
        messages: {
            default: paramMessage `#deprecation directive is expecting a string literal as the message but got a "${"kind"}"`,
            missing: "#deprecation directive is expecting a message argument but none was provided.",
        },
    },
    "duplicate-deprecation": {
        severity: "warning",
        messages: {
            default: "The #deprecated directive cannot be used more than once on the same declaration.",
        },
    },
    /**
     * Configuration
     */
    "config-invalid-argument": {
        severity: "error",
        messages: {
            default: paramMessage `Argument "${"name"}" is not defined as a parameter in the config.`,
        },
    },
    "config-circular-variable": {
        severity: "error",
        messages: {
            default: paramMessage `There is a circular reference to variable "${"name"}" in the cli configuration or arguments.`,
        },
    },
    "config-path-absolute": {
        severity: "error",
        messages: {
            default: paramMessage `Path "${"path"}" cannot be relative. Use {cwd} or {project-root} to specify what the path should be relative to.`,
        },
    },
    "config-path-not-found": {
        severity: "error",
        messages: {
            default: paramMessage `No configuration file found at config path "${"path"}".`,
        },
    },
    /**
     * Program
     */
    "dynamic-import": {
        severity: "error",
        messages: {
            default: "Dynamically generated TypeSpec cannot have imports",
        },
    },
    "invalid-import": {
        severity: "error",
        messages: {
            default: "Import paths must reference either a directory, a .tsp file, or .js file",
        },
    },
    "invalid-main": {
        severity: "error",
        messages: {
            default: "Main file must either be a .tsp file or a .js file.",
        },
    },
    "import-not-found": {
        severity: "error",
        messages: {
            default: paramMessage `Couldn't resolve import "${"path"}"`,
        },
    },
    "library-invalid": {
        severity: "error",
        messages: {
            tspMain: paramMessage `Library "${"path"}" has an invalid tspMain file.`,
            default: paramMessage `Library "${"path"}" has an invalid main file.`,
        },
    },
    "incompatible-library": {
        severity: "warning",
        messages: {
            default: paramMessage `Multiple versions of "${"name"}" library were loaded:\n${"versionMap"}`,
        },
    },
    "compiler-version-mismatch": {
        severity: "warning",
        messages: {
            default: paramMessage `Current TypeSpec compiler conflicts with local version of @typespec/compiler referenced in ${"basedir"}. \nIf this warning occurs on the command line, try running \`typespec\` with a working directory of ${"basedir"}. \nIf this warning occurs in the IDE, try configuring the \`tsp-server\` path to ${"betterTypeSpecServerPath"}.\n  Expected: ${"expected"}\n  Resolved: ${"actual"}`,
        },
    },
    "duplicate-symbol": {
        severity: "error",
        messages: {
            default: paramMessage `Duplicate name: "${"name"}"`,
        },
    },
    "decorator-decl-target": {
        severity: "error",
        messages: {
            default: "dec must have at least one parameter.",
            required: "dec first parameter must be required.",
        },
    },
    "projections-are-experimental": {
        severity: "warning",
        messages: {
            default: "Projections are experimental - your code will need to change as this feature evolves.",
        },
    },
    "non-literal-string-template": {
        severity: "error",
        messages: {
            default: "Value interpolated in this string template cannot be converted to a string. Only literal types can be automatically interpolated.",
        },
    },
    /**
     * Binder
     */
    "ambiguous-symbol": {
        severity: "error",
        messages: {
            default: paramMessage `"${"name"}" is an ambiguous name between ${"duplicateNames"}. Try using fully qualified name instead: ${"duplicateNames"}`,
        },
    },
    "duplicate-using": {
        severity: "error",
        messages: {
            default: paramMessage `duplicate using of "${"usingName"}" namespace`,
        },
    },
    /**
     * Library
     */
    "on-validate-fail": {
        severity: "error",
        messages: {
            default: paramMessage `onValidate failed with errors. ${"error"}`,
        },
    },
    "invalid-emitter": {
        severity: "error",
        messages: {
            default: paramMessage `Requested emitter package ${"emitterPackage"} does not provide an "onEmit" function.`,
        },
    },
    "missing-import": {
        severity: "error",
        messages: {
            default: paramMessage `Emitter '${"emitterName"}' requires '${"requiredImport"}' to be imported. Add 'import "${"requiredImport"}".`,
        },
    },
    /**
     * Linter
     */
    "invalid-rule-ref": {
        severity: "error",
        messages: {
            default: paramMessage `Reference "${"ref"}" is not a valid reference to a rule or ruleset. It must be in the following format: "<library-name>:<rule-name>"`,
        },
    },
    "unknown-rule": {
        severity: "error",
        messages: {
            default: paramMessage `Rule "${"ruleName"}" is not found in library "${"libraryName"}"`,
        },
    },
    "unknown-rule-set": {
        severity: "error",
        messages: {
            default: paramMessage `Rule set "${"ruleSetName"}" is not found in library "${"libraryName"}"`,
        },
    },
    "rule-enabled-disabled": {
        severity: "error",
        messages: {
            default: paramMessage `Rule "${"ruleName"}" has been enabled and disabled in the same ruleset.`,
        },
    },
    /**
     * Formatter
     */
    "format-failed": {
        severity: "error",
        messages: {
            default: paramMessage `File '${"file"}' failed to format. ${"details"}`,
        },
    },
    /**
     * Decorator
     */
    "decorator-wrong-target": {
        severity: "error",
        messages: {
            default: paramMessage `Cannot apply ${"decorator"} decorator to ${"to"}`,
            withExpected: paramMessage `Cannot apply ${"decorator"} decorator to ${"to"} since it is not assignable to ${"expected"}`,
        },
    },
    "invalid-argument": {
        severity: "error",
        messages: {
            default: paramMessage `Argument '${"value"}' is not assignable to parameter of type '${"expected"}'`,
        },
    },
    "invalid-argument-count": {
        severity: "error",
        messages: {
            default: paramMessage `Expected ${"expected"} arguments, but got ${"actual"}.`,
            atLeast: paramMessage `Expected at least ${"expected"} arguments, but got ${"actual"}.`,
        },
    },
    "known-values-invalid-enum": {
        severity: "error",
        messages: {
            default: paramMessage `Enum cannot be used on this type. Member ${"member"} is not assignable to type ${"type"}.`,
        },
    },
    "invalid-value": {
        severity: "error",
        messages: {
            default: paramMessage `Type '${"kind"}' is not a value type.`,
            atPath: paramMessage `Type '${"kind"}' of '${"path"}' is not a value type.`,
        },
    },
    deprecated: {
        severity: "warning",
        messages: {
            default: paramMessage `Deprecated: ${"message"}`,
        },
    },
    "no-optional-key": {
        severity: "error",
        messages: {
            default: paramMessage `Property '${"propertyName"}' marked as key cannot be optional.`,
        },
    },
    "invalid-discriminated-union": {
        severity: "error",
        messages: {
            default: "",
            noAnonVariants: "Unions with anonymous variants cannot be discriminated",
        },
    },
    "invalid-discriminated-union-variant": {
        severity: "error",
        messages: {
            default: paramMessage `Union variant "${"name"}" must be a model type.`,
            noDiscriminant: paramMessage `Variant "${"name"}" type is missing the discriminant property "${"discriminant"}".`,
            wrongDiscriminantType: paramMessage `Variant "${"name"}" type's discriminant property "${"discriminant"}" must be a string literal or string enum member.`,
        },
    },
    "missing-discriminator-property": {
        severity: "error",
        messages: {
            default: paramMessage `Each derived model of a discriminated model type should have set the discriminator property("${"discriminator"}") or have a derived model which has. Add \`${"discriminator"}: "<discriminator-value>"\``,
        },
    },
    "invalid-discriminator-value": {
        severity: "error",
        messages: {
            default: paramMessage `Discriminator value should be a string, union of string or string enum but was ${"kind"}.`,
            required: "The discriminator property must be a required property.",
            duplicate: paramMessage `Discriminator value "${"discriminator"}" is already used in another variant.`,
        },
    },
    "invalid-encode": {
        severity: "error",
        messages: {
            default: "Invalid encoding",
            wrongType: paramMessage `Encoding '${"encoding"}' cannot be used on type '${"type"}'. Expected: ${"expected"}.`,
            wrongEncodingType: paramMessage `Encoding '${"encoding"}' on type '${"type"}' is expected to be serialized as '${"expected"}' but got '${"actual"}'.`,
            wrongNumericEncodingType: paramMessage `Encoding '${"encoding"}' on type '${"type"}' is expected to be serialized as '${"expected"}' but got '${"actual"}'. Set '@encode' 2nd parameter to be of type ${"expected"}. e.g. '@encode("${"encoding"}", int32)'`,
        },
    },
    /**
     * Service
     */
    "service-decorator-duplicate": {
        severity: "error",
        messages: {
            default: `@service can only be set once per TypeSpec document.`,
        },
    },
    "list-type-not-model": {
        severity: "error",
        messages: {
            default: "@list decorator's parameter must be a model type.",
        },
    },
    "invalid-range": {
        severity: "error",
        messages: {
            default: paramMessage `Range "${"start"}..${"end"}" is invalid.`,
        },
    },
    /**
     * Mutator
     */
    "add-response": {
        severity: "error",
        messages: {
            default: "Cannot add a response to anything except an operation statement.",
        },
    },
    "add-parameter": {
        severity: "error",
        messages: {
            default: "Cannot add a parameter to anything except an operation statement.",
        },
    },
    "add-model-property": {
        severity: "error",
        messages: {
            default: "Cannot add a model property to anything except a model statement.",
        },
    },
    "add-model-property-fail": {
        severity: "error",
        messages: {
            default: paramMessage `Could not add property/parameter "${"propertyName"}" of type "${"propertyTypeName"}"`,
        },
    },
    "add-response-type": {
        severity: "error",
        messages: {
            default: paramMessage `Could not add response type "${"responseTypeName"}" to operation ${"operationName"}"`,
        },
    },
    "circular-base-type": {
        severity: "error",
        messages: {
            default: paramMessage `Type '${"typeName"}' recursively references itself as a base type.`,
        },
    },
    "circular-op-signature": {
        severity: "error",
        messages: {
            default: paramMessage `Operation '${"typeName"}' recursively references itself.`,
        },
    },
    "circular-alias-type": {
        severity: "error",
        messages: {
            default: paramMessage `Alias type '${"typeName"}' recursively references itself.`,
        },
    },
    "circular-prop": {
        severity: "error",
        messages: {
            default: paramMessage `Property '${"propName"}' recursively references itself.`,
        },
    },
    "conflict-marker": {
        severity: "error",
        messages: {
            default: "Conflict marker encountered.",
        },
    },
    // #region CLI
    "no-compatible-vs-installed": {
        severity: "error",
        messages: {
            default: "No compatible version of Visual Studio found.",
        },
    },
    "vs-extension-windows-only": {
        severity: "error",
        messages: {
            default: "Visual Studio extension is not supported on non-Windows.",
        },
    },
    "vscode-in-path": {
        severity: "error",
        messages: {
            default: "Couldn't find VS Code 'code' command in PATH. Make sure you have the VS Code executable added to the system PATH.",
            osx: "Couldn't find VS Code 'code' command in PATH. Make sure you have the VS Code executable added to the system PATH.\nSee instruction for Mac OS here https://code.visualstudio.com/docs/setup/mac",
        },
    },
    // #endregion CLI
};
const { createDiagnostic, reportDiagnostic } = createDiagnosticCreator(diagnostics);

var manifest = {
  "version": "0.51.0",
  "commit": "e52a32c76af68f2113584bec070753ea19f791db"
};

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
const typespecVersion = manifest.version;
/** @deprecated Use typespecVersion */
const cadlVersion = typespecVersion;
const MANIFEST = manifest;

var __classPrivateFieldGet$4 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet$2 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _MultiKeyMap_currentId, _MultiKeyMap_idMap, _MultiKeyMap_items, _Queue_elements, _Queue_headIndex, _DuplicateTracker_entries, _RekeyableMapImpl_keys, _RekeyableMapImpl_values, _a$1;
/**
 * Recursively calls Object.freeze such that all objects and arrays
 * referenced are frozen.
 *
 * Does not support cycles. Intended to be used only on plain data that can
 * be directly represented in JSON.
 */
function deepFreeze(value) {
    if (Array.isArray(value)) {
        value.forEach(deepFreeze);
    }
    else if (typeof value === "object") {
        for (const prop in value) {
            deepFreeze(value[prop]);
        }
    }
    return Object.freeze(value);
}
/**
 * Deeply clones an object.
 *
 * Does not support cycles. Intended to be used only on plain data that can
 * be directly represented in JSON.
 */
function deepClone(value) {
    if (Array.isArray(value)) {
        return value.map(deepClone);
    }
    if (typeof value === "object") {
        const obj = {};
        for (const prop in value) {
            obj[prop] = deepClone(value[prop]);
        }
        return obj;
    }
    return value;
}
/**
 * Checks if two objects are deeply equal.
 *
 * Does not support cycles. Intended to be used only on plain data that can
 * be directly represented in JSON.
 */
function deepEquals(left, right) {
    if (left === right) {
        return true;
    }
    if (left === null || right === null || typeof left !== "object" || typeof right !== "object") {
        return false;
    }
    if (Array.isArray(left)) {
        return Array.isArray(right) ? arrayEquals(left, right, deepEquals) : false;
    }
    return mapEquals(new Map(Object.entries(left)), new Map(Object.entries(right)), deepEquals);
}
/**
 * Check if two arrays have the same elements.
 *
 * @param equals Optional callback for element equality comparison.
 *               Default is to compare by identity using `===`.
 */
function arrayEquals(left, right, equals = (x, y) => x === y) {
    if (left === right) {
        return true;
    }
    if (left.length !== right.length) {
        return false;
    }
    for (let i = 0; i < left.length; i++) {
        if (!equals(left[i], right[i])) {
            return false;
        }
    }
    return true;
}
/**
 * Check if two maps have the same entries.
 *
 * @param equals Optional callback for value equality comparison.
 *               Default is to compare by identity using `===`.
 */
function mapEquals(left, right, equals = (x, y) => x === y) {
    if (left === right) {
        return true;
    }
    if (left.size !== right.size) {
        return false;
    }
    for (const [key, value] of left) {
        if (!right.has(key) || !equals(value, right.get(key))) {
            return false;
        }
    }
    return true;
}
async function getNormalizedRealPath(host, path) {
    return normalizePath(await host.realpath(path));
}
async function doIO(action, path, reportDiagnostic, options) {
    var _b;
    let result;
    try {
        result = await action(path);
    }
    catch (e) {
        let diagnostic;
        let target = (_b = options === null || options === void 0 ? void 0 : options.diagnosticTarget) !== null && _b !== void 0 ? _b : NoTarget;
        // blame the JS file, not the TypeSpec import statement for JS syntax errors.
        if (e instanceof SyntaxError && (options === null || options === void 0 ? void 0 : options.jsDiagnosticTarget)) {
            target = options.jsDiagnosticTarget;
        }
        switch (e.code) {
            case "ENOENT":
                if (options === null || options === void 0 ? void 0 : options.allowFileNotFound) {
                    return undefined;
                }
                diagnostic = createDiagnostic({ code: "file-not-found", target, format: { path } });
                break;
            default:
                diagnostic = createDiagnostic({
                    code: "file-load",
                    target,
                    format: { message: e.message },
                });
                break;
        }
        reportDiagnostic(diagnostic);
        return undefined;
    }
    return result;
}
async function loadFile(host, path, load, reportDiagnostic, options) {
    const file = await doIO(host.readFile, path, reportDiagnostic, options);
    if (!file) {
        return [undefined, createSourceFile("", path)];
    }
    let data;
    try {
        data = load(file.text);
    }
    catch (e) {
        reportDiagnostic({
            code: "file-load",
            message: e.message,
            severity: "error",
            target: { file, pos: 1, end: 1 },
        });
        return [undefined, file];
    }
    return [data, file];
}
/**
 * A specially typed version of `Array.isArray` to work around [this issue](https://github.com/microsoft/TypeScript/issues/17002).
 */
function isArray(
// eslint-disable-next-line @typescript-eslint/ban-types
arg) {
    return Array.isArray(arg);
}
/**
 * Check if argument is not undefined.
 */
function isDefined(arg) {
    return arg !== undefined;
}
/**
 * Remove undefined properties from object.
 */
function omitUndefined(data) {
    return Object.fromEntries(Object.entries(data).filter(([k, v]) => v !== undefined));
}
/**
 * Look for the project root by looking up until a `package.json` is found.
 * @param path Path to start looking
 * @param lookIn
 */
async function findProjectRoot(host, path) {
    let current = path;
    while (true) {
        const pkgPath = joinPaths(current, "package.json");
        const stat = await doIO(() => host.stat(pkgPath), pkgPath, () => { });
        if (stat === null || stat === void 0 ? void 0 : stat.isFile()) {
            return current;
        }
        const parent = getDirectoryPath(current);
        if (parent === current) {
            return undefined;
        }
        current = parent;
    }
}
/**
 * Extract package.json's tspMain entry point in a given path. Note, it takes into
 * back compat for deprecated cadlMain
 * @param path Path that contains package.json
 * @param reportDiagnostic optional diagnostic handler.
 */
function resolveTspMain(packageJson) {
    if ((packageJson === null || packageJson === void 0 ? void 0 : packageJson.tspMain) !== undefined) {
        return packageJson.tspMain;
    }
    if ((packageJson === null || packageJson === void 0 ? void 0 : packageJson.cadlMain) !== undefined) {
        return packageJson.cadlMain;
    }
    return undefined;
}
/**
 * A map keyed by a set of objects.
 *
 * This is likely non-optimal.
 */
class MultiKeyMap {
    constructor() {
        _MultiKeyMap_currentId.set(this, 0);
        _MultiKeyMap_idMap.set(this, new WeakMap());
        _MultiKeyMap_items.set(this, new Map());
    }
    get(items) {
        return __classPrivateFieldGet$4(this, _MultiKeyMap_items, "f").get(this.compositeKeyFor(items));
    }
    set(items, value) {
        const key = this.compositeKeyFor(items);
        __classPrivateFieldGet$4(this, _MultiKeyMap_items, "f").set(key, value);
    }
    compositeKeyFor(items) {
        return items.map((i) => this.keyFor(i)).join(",");
    }
    keyFor(item) {
        var _b, _c;
        if (__classPrivateFieldGet$4(this, _MultiKeyMap_idMap, "f").has(item)) {
            return __classPrivateFieldGet$4(this, _MultiKeyMap_idMap, "f").get(item);
        }
        const id = (__classPrivateFieldSet$2(this, _MultiKeyMap_currentId, (_c = __classPrivateFieldGet$4(this, _MultiKeyMap_currentId, "f"), _b = _c++, _c), "f"), _b);
        __classPrivateFieldGet$4(this, _MultiKeyMap_idMap, "f").set(item, id);
        return id;
    }
}
_MultiKeyMap_currentId = new WeakMap(), _MultiKeyMap_idMap = new WeakMap(), _MultiKeyMap_items = new WeakMap();
/**
 * A map with exactly two keys per value.
 *
 * Functionally the same as `MultiKeyMap<[K1, K2], V>`, but more efficient.
 * @hidden bug in typedoc
 */
class TwoLevelMap extends Map {
    /**
     * Get an existing entry in the map or add a new one if not found.
     *
     * @param key1 The first key
     * @param key2 The second key
     * @param create A callback to create the new entry when not found.
     * @param sentinel An optional sentinel value to use to indicate that the
     *                 entry is being created.
     */
    getOrAdd(key1, key2, create, sentinel) {
        let map = this.get(key1);
        if (map === undefined) {
            map = new Map();
            this.set(key1, map);
        }
        let entry = map.get(key2);
        if (entry === undefined) {
            if (sentinel !== undefined) {
                map.set(key2, sentinel);
            }
            entry = create();
            map.set(key2, entry);
        }
        return entry;
    }
}
// Adapted from https://github.com/microsoft/TypeScript/blob/bc52ff6f4be9347981de415a35da90497eae84ac/src/compiler/core.ts#L1507
class Queue {
    constructor(elements) {
        var _b;
        _Queue_elements.set(this, void 0);
        _Queue_headIndex.set(this, 0);
        __classPrivateFieldSet$2(this, _Queue_elements, (_b = elements === null || elements === void 0 ? void 0 : elements.slice()) !== null && _b !== void 0 ? _b : [], "f");
    }
    isEmpty() {
        return __classPrivateFieldGet$4(this, _Queue_headIndex, "f") === __classPrivateFieldGet$4(this, _Queue_elements, "f").length;
    }
    enqueue(...items) {
        __classPrivateFieldGet$4(this, _Queue_elements, "f").push(...items);
    }
    dequeue() {
        var _b;
        if (this.isEmpty()) {
            throw new Error("Queue is empty.");
        }
        const result = __classPrivateFieldGet$4(this, _Queue_elements, "f")[__classPrivateFieldGet$4(this, _Queue_headIndex, "f")];
        __classPrivateFieldGet$4(this, _Queue_elements, "f")[__classPrivateFieldGet$4(this, _Queue_headIndex, "f")] = undefined; // Don't keep referencing dequeued item
        __classPrivateFieldSet$2(this, _Queue_headIndex, // Don't keep referencing dequeued item
        (_b = __classPrivateFieldGet$4(this, _Queue_headIndex, "f"), _b++, _b), "f");
        // If more than half of the queue is empty, copy the remaining elements to the
        // front and shrink the array (unless we'd be saving fewer than 100 slots)
        if (__classPrivateFieldGet$4(this, _Queue_headIndex, "f") > 100 && __classPrivateFieldGet$4(this, _Queue_headIndex, "f") > __classPrivateFieldGet$4(this, _Queue_elements, "f").length >> 1) {
            const newLength = __classPrivateFieldGet$4(this, _Queue_elements, "f").length - __classPrivateFieldGet$4(this, _Queue_headIndex, "f");
            __classPrivateFieldGet$4(this, _Queue_elements, "f").copyWithin(0, __classPrivateFieldGet$4(this, _Queue_headIndex, "f"));
            __classPrivateFieldGet$4(this, _Queue_elements, "f").length = newLength;
            __classPrivateFieldSet$2(this, _Queue_headIndex, 0, "f");
        }
        return result;
    }
}
_Queue_elements = new WeakMap(), _Queue_headIndex = new WeakMap();
/**
 * Casts away readonly typing.
 *
 * Use it like this when it is safe to override readonly typing:
 *   mutate(item).prop = value;
 */
function mutate(value) {
    return value;
}
function getSourceFileKindFromExt(path) {
    const ext = getAnyExtensionFromPath(path);
    if (ext === ".js" || ext === ".mjs") {
        return "js";
    }
    else if (ext === ".tsp" || ext === ".cadl") {
        return "typespec";
    }
    else {
        return undefined;
    }
}
/**
 * Helper class to track duplicate instance
 */
class DuplicateTracker {
    constructor() {
        _DuplicateTracker_entries.set(this, new Map());
    }
    /**
     * Track usage of K.
     * @param k key that is being checked for duplicate.
     * @param v value that map to the key
     */
    track(k, v) {
        const existing = __classPrivateFieldGet$4(this, _DuplicateTracker_entries, "f").get(k);
        if (existing === undefined) {
            __classPrivateFieldGet$4(this, _DuplicateTracker_entries, "f").set(k, [v]);
        }
        else {
            existing.push(v);
        }
    }
    /**
     * Return iterator of all the duplicate entries.
     */
    *entries() {
        for (const [k, v] of __classPrivateFieldGet$4(this, _DuplicateTracker_entries, "f").entries()) {
            if (v.length > 1) {
                yield [k, v];
            }
        }
    }
}
_DuplicateTracker_entries = new WeakMap();
function createRekeyableMap(entries) {
    return new RekeyableMapImpl(entries);
}
class RekeyableMapImpl {
    constructor(entries) {
        _RekeyableMapImpl_keys.set(this, new Map());
        _RekeyableMapImpl_values.set(this, new Map());
        this[_a$1] = "RekeyableMap";
        if (entries) {
            for (const [key, value] of entries) {
                this.set(key, value);
            }
        }
    }
    clear() {
        __classPrivateFieldGet$4(this, _RekeyableMapImpl_keys, "f").clear();
        __classPrivateFieldGet$4(this, _RekeyableMapImpl_values, "f").clear();
    }
    delete(key) {
        const keyItem = __classPrivateFieldGet$4(this, _RekeyableMapImpl_keys, "f").get(key);
        if (keyItem) {
            __classPrivateFieldGet$4(this, _RekeyableMapImpl_keys, "f").delete(key);
            return __classPrivateFieldGet$4(this, _RekeyableMapImpl_values, "f").delete(keyItem);
        }
        return false;
    }
    forEach(callbackfn, thisArg) {
        __classPrivateFieldGet$4(this, _RekeyableMapImpl_values, "f").forEach((value, keyItem) => {
            callbackfn(value, keyItem.key, this);
        }, thisArg);
    }
    get(key) {
        const keyItem = __classPrivateFieldGet$4(this, _RekeyableMapImpl_keys, "f").get(key);
        return keyItem ? __classPrivateFieldGet$4(this, _RekeyableMapImpl_values, "f").get(keyItem) : undefined;
    }
    has(key) {
        return __classPrivateFieldGet$4(this, _RekeyableMapImpl_keys, "f").has(key);
    }
    set(key, value) {
        let keyItem = __classPrivateFieldGet$4(this, _RekeyableMapImpl_keys, "f").get(key);
        if (!keyItem) {
            keyItem = { key };
            __classPrivateFieldGet$4(this, _RekeyableMapImpl_keys, "f").set(key, keyItem);
        }
        __classPrivateFieldGet$4(this, _RekeyableMapImpl_values, "f").set(keyItem, value);
        return this;
    }
    get size() {
        return __classPrivateFieldGet$4(this, _RekeyableMapImpl_values, "f").size;
    }
    *entries() {
        for (const [k, v] of __classPrivateFieldGet$4(this, _RekeyableMapImpl_values, "f")) {
            yield [k.key, v];
        }
    }
    *keys() {
        for (const k of __classPrivateFieldGet$4(this, _RekeyableMapImpl_values, "f").keys()) {
            yield k.key;
        }
    }
    values() {
        return __classPrivateFieldGet$4(this, _RekeyableMapImpl_values, "f").values();
    }
    [(_RekeyableMapImpl_keys = new WeakMap(), _RekeyableMapImpl_values = new WeakMap(), Symbol.iterator)]() {
        return this.entries();
    }
    rekey(existingKey, newKey) {
        const keyItem = __classPrivateFieldGet$4(this, _RekeyableMapImpl_keys, "f").get(existingKey);
        if (!keyItem) {
            return false;
        }
        __classPrivateFieldGet$4(this, _RekeyableMapImpl_keys, "f").delete(existingKey);
        const newKeyItem = __classPrivateFieldGet$4(this, _RekeyableMapImpl_keys, "f").get(newKey);
        if (newKeyItem) {
            __classPrivateFieldGet$4(this, _RekeyableMapImpl_values, "f").delete(newKeyItem);
        }
        keyItem.key = newKey;
        __classPrivateFieldGet$4(this, _RekeyableMapImpl_keys, "f").set(newKey, keyItem);
        return true;
    }
}
_a$1 = Symbol.toStringTag;

function parseYaml(source) {
    const diagnostics = createDiagnosticCollector();
    const file = typeof source === "string" ? createSourceFile(source, "<anonymous file>") : source;
    const doc = parseDocument(file.text, {
        prettyErrors: false, // We are handling the error display ourself to be consistent in the style.
    });
    for (const error of doc.errors) {
        diagnostics.add(convertYamlErrorToDiagnostic("error", error, file));
    }
    for (const warning of doc.warnings) {
        diagnostics.add(convertYamlErrorToDiagnostic("warning", warning, file));
    }
    return diagnostics.wrap({
        kind: "yaml-script",
        file,
        value: doc.toJSON(),
        doc,
    });
}
function convertYamlErrorToDiagnostic(severity, error, file) {
    return {
        code: `yaml-${error.code.toLowerCase().replace(/_/g, "-")}`,
        message: error.message,
        severity,
        target: { file, pos: error.pos[0], end: error.pos[1] },
    };
}

const emitterOptionsSchema = {
    type: "object",
    additionalProperties: true,
    required: [],
    properties: {
        "emitter-output-dir": { type: "string", nullable: true },
    },
};
const TypeSpecConfigJsonSchema = {
    type: "object",
    additionalProperties: false,
    properties: {
        extends: {
            type: "string",
            nullable: true,
        },
        "environment-variables": {
            type: "object",
            nullable: true,
            required: [],
            additionalProperties: {
                type: "object",
                properties: {
                    default: { type: "string" },
                },
                required: ["default"],
            },
        },
        parameters: {
            type: "object",
            nullable: true,
            required: [],
            additionalProperties: {
                type: "object",
                properties: {
                    default: { type: "string" },
                },
                required: ["default"],
            },
        },
        "output-dir": {
            type: "string",
            nullable: true,
        },
        "warn-as-error": {
            type: "boolean",
            nullable: true,
        },
        trace: {
            oneOf: [
                { type: "string" },
                {
                    type: "array",
                    items: { type: "string" },
                },
            ],
        },
        imports: {
            type: "array",
            nullable: true,
            items: { type: "string" },
        },
        emit: {
            type: "array",
            nullable: true,
            items: { type: "string" },
        },
        options: {
            type: "object",
            nullable: true,
            required: [],
            additionalProperties: emitterOptionsSchema,
        },
        emitters: {
            type: "object",
            nullable: true,
            required: [],
            additionalProperties: {
                oneOf: [{ type: "boolean" }, emitterOptionsSchema],
            },
        },
        linter: {
            type: "object",
            nullable: true,
            required: [],
            additionalProperties: false,
            properties: {
                extends: {
                    type: "array",
                    nullable: true,
                    items: { type: "string" },
                },
                enable: {
                    type: "object",
                    required: [],
                    nullable: true,
                    additionalProperties: { type: "boolean" },
                },
                disable: {
                    type: "object",
                    required: [],
                    nullable: true,
                    additionalProperties: { type: "string" },
                },
            },
        }, // ajv type system doesn't like the string templates
    },
};

const OldTypeSpecConfigFilename = "cadl-project.yaml";
const TypeSpecConfigFilename = "tspconfig.yaml";
const defaultConfig = deepFreeze({
    outputDir: "{cwd}/tsp-output",
    diagnostics: [],
});
/**
 * Look for the project root by looking up until a `tspconfig.yaml` is found.
 * @param path Path to the file or the folder to start looking
 */
async function findTypeSpecConfigPath(host, path, lookup = true) {
    // if the path is a file, return immediately
    const stats = await doIO(() => host.stat(path), path, () => { }, { allowFileNotFound: true });
    if (!stats) {
        return undefined;
    }
    else if (stats.isFile()) {
        return path;
    }
    let current = path;
    // only recurse if the path is a directory and the flag was set to true (only for default case)
    // otherwise, look in the specific directory for tspconfig.yaml ONLY (not cadl-project.yaml)
    if (!lookup) {
        current = `${path}/tspconfig.yaml`;
        const stats = await doIO(() => host.stat(current), current, () => { }, { allowFileNotFound: true });
        if (stats === null || stats === void 0 ? void 0 : stats.isFile()) {
            return current;
        }
        return undefined;
    }
    else {
        while (true) {
            let pkgPath = await searchConfigFile(host, current, TypeSpecConfigFilename);
            if (pkgPath === undefined) {
                pkgPath = await searchConfigFile(host, current, OldTypeSpecConfigFilename);
            }
            // if found either file in current folder, return it
            if (pkgPath !== undefined) {
                return pkgPath;
            }
            const parent = getDirectoryPath(current);
            if (parent === current) {
                return undefined;
            }
            current = parent;
        }
    }
}
/**
 * Load the typespec configuration for the provided path or directory
 * @param host
 * @param path
 */
async function loadTypeSpecConfigForPath(host, path, errorIfNotFound = false, lookup = true) {
    const typespecConfigPath = await findTypeSpecConfigPath(host, path, lookup);
    if (typespecConfigPath === undefined) {
        const projectRoot = getDirectoryPath(path);
        const tsConfig = { ...deepClone(defaultConfig), projectRoot: projectRoot };
        if (errorIfNotFound) {
            tsConfig.diagnostics.push(createDiagnostic({
                code: "config-path-not-found",
                format: {
                    path: path,
                },
                target: NoTarget,
            }));
        }
        return tsConfig;
    }
    const tsConfig = await loadTypeSpecConfigFile(host, typespecConfigPath);
    // Add diagnostics if still using cadl-project.yaml
    if (typespecConfigPath.endsWith(OldTypeSpecConfigFilename)) {
        tsConfig.diagnostics.push(createDiagnostic({
            code: "deprecated",
            format: {
                message: "`cadl-project.yaml` is deprecated. Please rename to `tspconfig.yaml`.",
            },
            target: NoTarget,
        }));
    }
    return tsConfig;
}
/**
 * Load given file as a TypeSpec configuration
 */
async function loadTypeSpecConfigFile(host, filePath) {
    const config = await loadConfigFile(host, filePath, parseYaml);
    if (config.diagnostics.length === 0 && config.extends) {
        const extendPath = resolvePath(getDirectoryPath(filePath), config.extends);
        const parent = await loadTypeSpecConfigFile(host, extendPath);
        // Add diagnostics if still using cadl-project.yaml
        if (filePath.endsWith(OldTypeSpecConfigFilename)) {
            parent.diagnostics.push(createDiagnostic({
                code: "deprecated",
                format: {
                    message: "`cadl-project.yaml` is deprecated. Please rename to `tspconfig.yaml`.",
                },
                target: NoTarget,
            }));
        }
        if (parent.diagnostics.length > 0) {
            return {
                ...config,
                diagnostics: parent.diagnostics,
            };
        }
        return {
            ...parent,
            ...config,
        };
    }
    return {
        ...deepClone(defaultConfig),
        ...config,
    };
}
const configValidator = createJSONSchemaValidator(TypeSpecConfigJsonSchema);
async function searchConfigFile(host, path, filename) {
    const pkgPath = joinPaths(path, filename);
    const stat = await doIO(() => host.stat(pkgPath), pkgPath, () => { });
    return (stat === null || stat === void 0 ? void 0 : stat.isFile()) === true ? pkgPath : undefined;
}
async function loadConfigFile(host, filename, loadData) {
    var _a, _b;
    let diagnostics = [];
    const reportDiagnostic = (d) => diagnostics.push(d);
    const file = (_a = (await doIO(host.readFile, filename, reportDiagnostic))) !== null && _a !== void 0 ? _a : createSourceFile("", filename);
    const [yamlScript, yamlDiagnostics] = loadData(file);
    yamlDiagnostics.forEach((d) => reportDiagnostic(d));
    let data = yamlScript.value;
    if (data) {
        diagnostics = diagnostics.concat(configValidator.validate(data, yamlScript));
    }
    if (!data || diagnostics.length > 0) {
        // NOTE: Don't trust the data if there are errors and use default
        // config. Otherwise, we may return an object that does not conform to
        // TypeSpecConfig's typing.
        data = deepClone(defaultConfig);
    }
    const emit = data.emit;
    const options = data.options;
    return omitUndefined({
        projectRoot: getDirectoryPath(filename),
        file: yamlScript,
        filename,
        diagnostics,
        extends: data.extends,
        environmentVariables: data["environment-variables"],
        parameters: data.parameters,
        outputDir: (_b = data["output-dir"]) !== null && _b !== void 0 ? _b : "{cwd}/tsp-output",
        warnAsError: data["warn-as-error"],
        imports: data.imports,
        trace: typeof data.trace === "string" ? [data.trace] : data.trace,
        emit,
        options,
        linter: data.linter,
    });
}
function validateConfigPathsAbsolute(config) {
    var _a;
    const diagnostics = [];
    function checkPath(value, path) {
        if (value === undefined) {
            return;
        }
        const diagnostic = validatePathAbsolute(value, config.file ? { file: config.file, path } : NoTarget);
        if (diagnostic) {
            diagnostics.push(diagnostic);
        }
    }
    checkPath(config.outputDir, ["output-dir"]);
    for (const [emitterName, emitterOptions] of Object.entries((_a = config.options) !== null && _a !== void 0 ? _a : {})) {
        checkPath(emitterOptions["emitter-output-dir"], ["options", emitterName, "emitter-output-dir"]);
    }
    return diagnostics;
}
function validatePathAbsolute(path, target) {
    if (path.startsWith(".") || !isPathAbsolute(path)) {
        return createDiagnostic({
            code: "config-path-absolute",
            format: { path },
            target: target === NoTarget ? target : getLocationInYamlScript(target.file, target.path),
        });
    }
    return undefined;
}

var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/document/public.js
var public_exports = {};
__export(public_exports, {
  builders: () => builders,
  printer: () => printer,
  utils: () => utils
});

// src/document/constants.js
var DOC_TYPE_STRING = "string";
var DOC_TYPE_ARRAY = "array";
var DOC_TYPE_CURSOR = "cursor";
var DOC_TYPE_INDENT = "indent";
var DOC_TYPE_ALIGN = "align";
var DOC_TYPE_TRIM = "trim";
var DOC_TYPE_GROUP = "group";
var DOC_TYPE_FILL = "fill";
var DOC_TYPE_IF_BREAK = "if-break";
var DOC_TYPE_INDENT_IF_BREAK = "indent-if-break";
var DOC_TYPE_LINE_SUFFIX = "line-suffix";
var DOC_TYPE_LINE_SUFFIX_BOUNDARY = "line-suffix-boundary";
var DOC_TYPE_LINE = "line";
var DOC_TYPE_LABEL = "label";
var DOC_TYPE_BREAK_PARENT = "break-parent";
var VALID_OBJECT_DOC_TYPES = /* @__PURE__ */ new Set([
  DOC_TYPE_CURSOR,
  DOC_TYPE_INDENT,
  DOC_TYPE_ALIGN,
  DOC_TYPE_TRIM,
  DOC_TYPE_GROUP,
  DOC_TYPE_FILL,
  DOC_TYPE_IF_BREAK,
  DOC_TYPE_INDENT_IF_BREAK,
  DOC_TYPE_LINE_SUFFIX,
  DOC_TYPE_LINE_SUFFIX_BOUNDARY,
  DOC_TYPE_LINE,
  DOC_TYPE_LABEL,
  DOC_TYPE_BREAK_PARENT
]);

// src/document/utils/get-doc-type.js
function getDocType(doc) {
  if (typeof doc === "string") {
    return DOC_TYPE_STRING;
  }
  if (Array.isArray(doc)) {
    return DOC_TYPE_ARRAY;
  }
  if (!doc) {
    return;
  }
  const { type } = doc;
  if (VALID_OBJECT_DOC_TYPES.has(type)) {
    return type;
  }
}
var get_doc_type_default = getDocType;

// src/document/invalid-doc-error.js
var disjunctionListFormat = (list) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(list);
function getDocErrorMessage(doc) {
  const type = doc === null ? "null" : typeof doc;
  if (type !== "string" && type !== "object") {
    return `Unexpected doc '${type}', 
Expected it to be 'string' or 'object'.`;
  }
  if (get_doc_type_default(doc)) {
    throw new Error("doc is valid.");
  }
  const objectType = Object.prototype.toString.call(doc);
  if (objectType !== "[object Object]") {
    return `Unexpected doc '${objectType}'.`;
  }
  const EXPECTED_TYPE_VALUES = disjunctionListFormat(
    [...VALID_OBJECT_DOC_TYPES].map((type2) => `'${type2}'`)
  );
  return `Unexpected doc.type '${doc.type}'.
Expected it to be ${EXPECTED_TYPE_VALUES}.`;
}
var InvalidDocError = class extends Error {
  name = "InvalidDocError";
  constructor(doc) {
    super(getDocErrorMessage(doc));
    this.doc = doc;
  }
};
var invalid_doc_error_default = InvalidDocError;

// src/document/utils/traverse-doc.js
var traverseDocOnExitStackMarker = {};
function traverseDoc(doc, onEnter, onExit, shouldTraverseConditionalGroups) {
  const docsStack = [doc];
  while (docsStack.length > 0) {
    const doc2 = docsStack.pop();
    if (doc2 === traverseDocOnExitStackMarker) {
      onExit(docsStack.pop());
      continue;
    }
    if (onExit) {
      docsStack.push(doc2, traverseDocOnExitStackMarker);
    }
    const docType = get_doc_type_default(doc2);
    if (!docType) {
      throw new invalid_doc_error_default(doc2);
    }
    if ((onEnter == null ? void 0 : onEnter(doc2)) === false) {
      continue;
    }
    switch (docType) {
      case DOC_TYPE_ARRAY:
      case DOC_TYPE_FILL: {
        const parts = docType === DOC_TYPE_ARRAY ? doc2 : doc2.parts;
        for (let ic = parts.length, i = ic - 1; i >= 0; --i) {
          docsStack.push(parts[i]);
        }
        break;
      }
      case DOC_TYPE_IF_BREAK:
        docsStack.push(doc2.flatContents, doc2.breakContents);
        break;
      case DOC_TYPE_GROUP:
        if (shouldTraverseConditionalGroups && doc2.expandedStates) {
          for (let ic = doc2.expandedStates.length, i = ic - 1; i >= 0; --i) {
            docsStack.push(doc2.expandedStates[i]);
          }
        } else {
          docsStack.push(doc2.contents);
        }
        break;
      case DOC_TYPE_ALIGN:
      case DOC_TYPE_INDENT:
      case DOC_TYPE_INDENT_IF_BREAK:
      case DOC_TYPE_LABEL:
      case DOC_TYPE_LINE_SUFFIX:
        docsStack.push(doc2.contents);
        break;
      case DOC_TYPE_STRING:
      case DOC_TYPE_CURSOR:
      case DOC_TYPE_TRIM:
      case DOC_TYPE_LINE_SUFFIX_BOUNDARY:
      case DOC_TYPE_LINE:
      case DOC_TYPE_BREAK_PARENT:
        break;
      default:
        throw new invalid_doc_error_default(doc2);
    }
  }
}
var traverse_doc_default = traverseDoc;

// src/document/utils/assert-doc.js
var noop = () => {
};
var assertDocArray = noop ;

// src/document/builders.js
function indent$1(contents) {
  return { type: DOC_TYPE_INDENT, contents };
}
function align$1(widthOrString, contents) {
  return { type: DOC_TYPE_ALIGN, contents, n: widthOrString };
}
function group$1(contents, opts = {}) {
  assertDocArray(
    opts.expandedStates);
  return {
    type: DOC_TYPE_GROUP,
    id: opts.id,
    contents,
    break: Boolean(opts.shouldBreak),
    expandedStates: opts.expandedStates
  };
}
function dedentToRoot(contents) {
  return align$1(Number.NEGATIVE_INFINITY, contents);
}
function markAsRoot(contents) {
  return align$1({ type: "root" }, contents);
}
function dedent(contents) {
  return align$1(-1, contents);
}
function conditionalGroup(states, opts) {
  return group$1(states[0], { ...opts, expandedStates: states });
}
function fill(parts) {
  return { type: DOC_TYPE_FILL, parts };
}
function ifBreak$1(breakContents, flatContents = "", opts = {}) {
  return {
    type: DOC_TYPE_IF_BREAK,
    breakContents,
    flatContents,
    groupId: opts.groupId
  };
}
function indentIfBreak(contents, opts) {
  return {
    type: DOC_TYPE_INDENT_IF_BREAK,
    contents,
    groupId: opts.groupId,
    negate: opts.negate
  };
}
function lineSuffix(contents) {
  return { type: DOC_TYPE_LINE_SUFFIX, contents };
}
var lineSuffixBoundary = { type: DOC_TYPE_LINE_SUFFIX_BOUNDARY };
var breakParent$1 = { type: DOC_TYPE_BREAK_PARENT };
var trim$1 = { type: DOC_TYPE_TRIM };
var hardlineWithoutBreakParent = { type: DOC_TYPE_LINE, hard: true };
var literallineWithoutBreakParent = {
  type: DOC_TYPE_LINE,
  hard: true,
  literal: true
};
var line$1 = { type: DOC_TYPE_LINE };
var softline$1 = { type: DOC_TYPE_LINE, soft: true };
var hardline$1 = [hardlineWithoutBreakParent, breakParent$1];
var literalline = [literallineWithoutBreakParent, breakParent$1];
var cursor = { type: DOC_TYPE_CURSOR };
function join$1(separator, docs) {
  const parts = [];
  for (let i = 0; i < docs.length; i++) {
    if (i !== 0) {
      parts.push(separator);
    }
    parts.push(docs[i]);
  }
  return parts;
}
function addAlignmentToDoc(doc, size, tabWidth) {
  let aligned = doc;
  if (size > 0) {
    for (let i = 0; i < Math.floor(size / tabWidth); ++i) {
      aligned = indent$1(aligned);
    }
    aligned = align$1(size % tabWidth, aligned);
    aligned = align$1(Number.NEGATIVE_INFINITY, aligned);
  }
  return aligned;
}
function label(label2, contents) {
  return label2 ? { type: DOC_TYPE_LABEL, label: label2, contents } : contents;
}

// scripts/build/shims/at.js
var at$1 = (isOptionalObject, object, index) => {
  if (isOptionalObject && (object === void 0 || object === null)) {
    return;
  }
  if (Array.isArray(object) || typeof object === "string") {
    return object[index < 0 ? object.length + index : index];
  }
  return object.at(index);
};
var at_default = at$1;

// scripts/build/shims/string-replace-all.js
var stringReplaceAll = (isOptionalObject, original, pattern, replacement) => {
  if (isOptionalObject && (original === void 0 || original === null)) {
    return;
  }
  if (original.replaceAll) {
    return original.replaceAll(pattern, replacement);
  }
  if (pattern.global) {
    return original.replace(pattern, replacement);
  }
  return original.split(pattern).join(replacement);
};
var string_replace_all_default = stringReplaceAll;

// src/common/end-of-line.js
function convertEndOfLineToChars(value) {
  switch (value) {
    case "cr":
      return "\r";
    case "crlf":
      return "\r\n";
    default:
      return "\n";
  }
}

// node_modules/emoji-regex/index.mjs
var emoji_regex_default = () => {
  return /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
};

// node_modules/get-east-asian-width/lookup.js
function isFullWidth(x) {
  return x === 12288 || x >= 65281 && x <= 65376 || x >= 65504 && x <= 65510;
}
function isWide(x) {
  return x >= 4352 && x <= 4447 || x === 8986 || x === 8987 || x === 9001 || x === 9002 || x >= 9193 && x <= 9196 || x === 9200 || x === 9203 || x === 9725 || x === 9726 || x === 9748 || x === 9749 || x >= 9800 && x <= 9811 || x === 9855 || x === 9875 || x === 9889 || x === 9898 || x === 9899 || x === 9917 || x === 9918 || x === 9924 || x === 9925 || x === 9934 || x === 9940 || x === 9962 || x === 9970 || x === 9971 || x === 9973 || x === 9978 || x === 9981 || x === 9989 || x === 9994 || x === 9995 || x === 10024 || x === 10060 || x === 10062 || x >= 10067 && x <= 10069 || x === 10071 || x >= 10133 && x <= 10135 || x === 10160 || x === 10175 || x === 11035 || x === 11036 || x === 11088 || x === 11093 || x >= 11904 && x <= 11929 || x >= 11931 && x <= 12019 || x >= 12032 && x <= 12245 || x >= 12272 && x <= 12287 || x >= 12289 && x <= 12350 || x >= 12353 && x <= 12438 || x >= 12441 && x <= 12543 || x >= 12549 && x <= 12591 || x >= 12593 && x <= 12686 || x >= 12688 && x <= 12771 || x >= 12783 && x <= 12830 || x >= 12832 && x <= 12871 || x >= 12880 && x <= 19903 || x >= 19968 && x <= 42124 || x >= 42128 && x <= 42182 || x >= 43360 && x <= 43388 || x >= 44032 && x <= 55203 || x >= 63744 && x <= 64255 || x >= 65040 && x <= 65049 || x >= 65072 && x <= 65106 || x >= 65108 && x <= 65126 || x >= 65128 && x <= 65131 || x >= 94176 && x <= 94180 || x === 94192 || x === 94193 || x >= 94208 && x <= 100343 || x >= 100352 && x <= 101589 || x >= 101632 && x <= 101640 || x >= 110576 && x <= 110579 || x >= 110581 && x <= 110587 || x === 110589 || x === 110590 || x >= 110592 && x <= 110882 || x === 110898 || x >= 110928 && x <= 110930 || x === 110933 || x >= 110948 && x <= 110951 || x >= 110960 && x <= 111355 || x === 126980 || x === 127183 || x === 127374 || x >= 127377 && x <= 127386 || x >= 127488 && x <= 127490 || x >= 127504 && x <= 127547 || x >= 127552 && x <= 127560 || x === 127568 || x === 127569 || x >= 127584 && x <= 127589 || x >= 127744 && x <= 127776 || x >= 127789 && x <= 127797 || x >= 127799 && x <= 127868 || x >= 127870 && x <= 127891 || x >= 127904 && x <= 127946 || x >= 127951 && x <= 127955 || x >= 127968 && x <= 127984 || x === 127988 || x >= 127992 && x <= 128062 || x === 128064 || x >= 128066 && x <= 128252 || x >= 128255 && x <= 128317 || x >= 128331 && x <= 128334 || x >= 128336 && x <= 128359 || x === 128378 || x === 128405 || x === 128406 || x === 128420 || x >= 128507 && x <= 128591 || x >= 128640 && x <= 128709 || x === 128716 || x >= 128720 && x <= 128722 || x >= 128725 && x <= 128727 || x >= 128732 && x <= 128735 || x === 128747 || x === 128748 || x >= 128756 && x <= 128764 || x >= 128992 && x <= 129003 || x === 129008 || x >= 129292 && x <= 129338 || x >= 129340 && x <= 129349 || x >= 129351 && x <= 129535 || x >= 129648 && x <= 129660 || x >= 129664 && x <= 129672 || x >= 129680 && x <= 129725 || x >= 129727 && x <= 129733 || x >= 129742 && x <= 129755 || x >= 129760 && x <= 129768 || x >= 129776 && x <= 129784 || x >= 131072 && x <= 196605 || x >= 196608 && x <= 262141;
}

// node_modules/get-east-asian-width/index.js
var _isNarrowWidth = (codePoint) => !(isFullWidth(codePoint) || isWide(codePoint));

// src/utils/get-string-width.js
var notAsciiRegex = /[^\x20-\x7F]/;
function getStringWidth(text) {
  if (!text) {
    return 0;
  }
  if (!notAsciiRegex.test(text)) {
    return text.length;
  }
  text = text.replace(emoji_regex_default(), "  ");
  let width = 0;
  for (const character of text) {
    const codePoint = character.codePointAt(0);
    if (codePoint <= 31 || codePoint >= 127 && codePoint <= 159) {
      continue;
    }
    if (codePoint >= 768 && codePoint <= 879) {
      continue;
    }
    width += _isNarrowWidth(codePoint) ? 1 : 2;
  }
  return width;
}
var get_string_width_default = getStringWidth;

// src/document/utils.js
var getDocParts = (doc) => {
  if (Array.isArray(doc)) {
    return doc;
  }
  if (doc.type !== DOC_TYPE_FILL) {
    throw new Error(`Expect doc to be 'array' or '${DOC_TYPE_FILL}'.`);
  }
  return doc.parts;
};
function mapDoc(doc, cb) {
  if (typeof doc === "string") {
    return cb(doc);
  }
  const mapped = /* @__PURE__ */ new Map();
  return rec(doc);
  function rec(doc2) {
    if (mapped.has(doc2)) {
      return mapped.get(doc2);
    }
    const result = process2(doc2);
    mapped.set(doc2, result);
    return result;
  }
  function process2(doc2) {
    switch (get_doc_type_default(doc2)) {
      case DOC_TYPE_ARRAY:
        return cb(doc2.map(rec));
      case DOC_TYPE_FILL:
        return cb({
          ...doc2,
          parts: doc2.parts.map(rec)
        });
      case DOC_TYPE_IF_BREAK:
        return cb({
          ...doc2,
          breakContents: rec(doc2.breakContents),
          flatContents: rec(doc2.flatContents)
        });
      case DOC_TYPE_GROUP: {
        let {
          expandedStates,
          contents
        } = doc2;
        if (expandedStates) {
          expandedStates = expandedStates.map(rec);
          contents = expandedStates[0];
        } else {
          contents = rec(contents);
        }
        return cb({
          ...doc2,
          contents,
          expandedStates
        });
      }
      case DOC_TYPE_ALIGN:
      case DOC_TYPE_INDENT:
      case DOC_TYPE_INDENT_IF_BREAK:
      case DOC_TYPE_LABEL:
      case DOC_TYPE_LINE_SUFFIX:
        return cb({
          ...doc2,
          contents: rec(doc2.contents)
        });
      case DOC_TYPE_STRING:
      case DOC_TYPE_CURSOR:
      case DOC_TYPE_TRIM:
      case DOC_TYPE_LINE_SUFFIX_BOUNDARY:
      case DOC_TYPE_LINE:
      case DOC_TYPE_BREAK_PARENT:
        return cb(doc2);
      default:
        throw new invalid_doc_error_default(doc2);
    }
  }
}
function findInDoc(doc, fn, defaultValue) {
  let result = defaultValue;
  let shouldSkipFurtherProcessing = false;
  function findInDocOnEnterFn(doc2) {
    if (shouldSkipFurtherProcessing) {
      return false;
    }
    const maybeResult = fn(doc2);
    if (maybeResult !== void 0) {
      shouldSkipFurtherProcessing = true;
      result = maybeResult;
    }
  }
  traverse_doc_default(doc, findInDocOnEnterFn);
  return result;
}
function willBreakFn(doc) {
  if (doc.type === DOC_TYPE_GROUP && doc.break) {
    return true;
  }
  if (doc.type === DOC_TYPE_LINE && doc.hard) {
    return true;
  }
  if (doc.type === DOC_TYPE_BREAK_PARENT) {
    return true;
  }
}
function willBreak(doc) {
  return findInDoc(doc, willBreakFn, false);
}
function breakParentGroup(groupStack) {
  if (groupStack.length > 0) {
    const parentGroup = at_default(
      /* isOptionalObject*/
      false,
      groupStack,
      -1
    );
    if (!parentGroup.expandedStates && !parentGroup.break) {
      parentGroup.break = "propagated";
    }
  }
  return null;
}
function propagateBreaks(doc) {
  const alreadyVisitedSet = /* @__PURE__ */ new Set();
  const groupStack = [];
  function propagateBreaksOnEnterFn(doc2) {
    if (doc2.type === DOC_TYPE_BREAK_PARENT) {
      breakParentGroup(groupStack);
    }
    if (doc2.type === DOC_TYPE_GROUP) {
      groupStack.push(doc2);
      if (alreadyVisitedSet.has(doc2)) {
        return false;
      }
      alreadyVisitedSet.add(doc2);
    }
  }
  function propagateBreaksOnExitFn(doc2) {
    if (doc2.type === DOC_TYPE_GROUP) {
      const group2 = groupStack.pop();
      if (group2.break) {
        breakParentGroup(groupStack);
      }
    }
  }
  traverse_doc_default(
    doc,
    propagateBreaksOnEnterFn,
    propagateBreaksOnExitFn,
    /* shouldTraverseConditionalGroups */
    true
  );
}
function removeLinesFn(doc) {
  if (doc.type === DOC_TYPE_LINE && !doc.hard) {
    return doc.soft ? "" : " ";
  }
  if (doc.type === DOC_TYPE_IF_BREAK) {
    return doc.flatContents;
  }
  return doc;
}
function removeLines(doc) {
  return mapDoc(doc, removeLinesFn);
}
function stripTrailingHardlineFromParts(parts) {
  parts = [...parts];
  while (parts.length >= 2 && at_default(
    /* isOptionalObject*/
    false,
    parts,
    -2
  ).type === DOC_TYPE_LINE && at_default(
    /* isOptionalObject*/
    false,
    parts,
    -1
  ).type === DOC_TYPE_BREAK_PARENT) {
    parts.length -= 2;
  }
  if (parts.length > 0) {
    const lastPart = stripTrailingHardlineFromDoc(at_default(
      /* isOptionalObject*/
      false,
      parts,
      -1
    ));
    parts[parts.length - 1] = lastPart;
  }
  return parts;
}
function stripTrailingHardlineFromDoc(doc) {
  switch (get_doc_type_default(doc)) {
    case DOC_TYPE_ALIGN:
    case DOC_TYPE_INDENT:
    case DOC_TYPE_INDENT_IF_BREAK:
    case DOC_TYPE_GROUP:
    case DOC_TYPE_LINE_SUFFIX:
    case DOC_TYPE_LABEL: {
      const contents = stripTrailingHardlineFromDoc(doc.contents);
      return {
        ...doc,
        contents
      };
    }
    case DOC_TYPE_IF_BREAK:
      return {
        ...doc,
        breakContents: stripTrailingHardlineFromDoc(doc.breakContents),
        flatContents: stripTrailingHardlineFromDoc(doc.flatContents)
      };
    case DOC_TYPE_FILL:
      return {
        ...doc,
        parts: stripTrailingHardlineFromParts(doc.parts)
      };
    case DOC_TYPE_ARRAY:
      return stripTrailingHardlineFromParts(doc);
    case DOC_TYPE_STRING:
      return doc.replace(/[\n\r]*$/, "");
    case DOC_TYPE_CURSOR:
    case DOC_TYPE_TRIM:
    case DOC_TYPE_LINE_SUFFIX_BOUNDARY:
    case DOC_TYPE_LINE:
    case DOC_TYPE_BREAK_PARENT:
      break;
    default:
      throw new invalid_doc_error_default(doc);
  }
  return doc;
}
function stripTrailingHardline(doc) {
  return stripTrailingHardlineFromDoc(cleanDoc(doc));
}
function cleanDocFn(doc) {
  switch (get_doc_type_default(doc)) {
    case DOC_TYPE_FILL:
      if (doc.parts.every((part) => part === "")) {
        return "";
      }
      break;
    case DOC_TYPE_GROUP:
      if (!doc.contents && !doc.id && !doc.break && !doc.expandedStates) {
        return "";
      }
      if (doc.contents.type === DOC_TYPE_GROUP && doc.contents.id === doc.id && doc.contents.break === doc.break && doc.contents.expandedStates === doc.expandedStates) {
        return doc.contents;
      }
      break;
    case DOC_TYPE_ALIGN:
    case DOC_TYPE_INDENT:
    case DOC_TYPE_INDENT_IF_BREAK:
    case DOC_TYPE_LINE_SUFFIX:
      if (!doc.contents) {
        return "";
      }
      break;
    case DOC_TYPE_IF_BREAK:
      if (!doc.flatContents && !doc.breakContents) {
        return "";
      }
      break;
    case DOC_TYPE_ARRAY: {
      const parts = [];
      for (const part of doc) {
        if (!part) {
          continue;
        }
        const [currentPart, ...restParts] = Array.isArray(part) ? part : [part];
        if (typeof currentPart === "string" && typeof at_default(
          /* isOptionalObject*/
          false,
          parts,
          -1
        ) === "string") {
          parts[parts.length - 1] += currentPart;
        } else {
          parts.push(currentPart);
        }
        parts.push(...restParts);
      }
      if (parts.length === 0) {
        return "";
      }
      if (parts.length === 1) {
        return parts[0];
      }
      return parts;
    }
    case DOC_TYPE_STRING:
    case DOC_TYPE_CURSOR:
    case DOC_TYPE_TRIM:
    case DOC_TYPE_LINE_SUFFIX_BOUNDARY:
    case DOC_TYPE_LINE:
    case DOC_TYPE_LABEL:
    case DOC_TYPE_BREAK_PARENT:
      break;
    default:
      throw new invalid_doc_error_default(doc);
  }
  return doc;
}
function cleanDoc(doc) {
  return mapDoc(doc, (currentDoc) => cleanDocFn(currentDoc));
}
function replaceEndOfLine(doc, replacement = literalline) {
  return mapDoc(doc, (currentDoc) => typeof currentDoc === "string" ? join$1(replacement, currentDoc.split("\n")) : currentDoc);
}
function canBreakFn(doc) {
  if (doc.type === DOC_TYPE_LINE) {
    return true;
  }
}
function canBreak(doc) {
  return findInDoc(doc, canBreakFn, false);
}

// src/document/printer.js
var MODE_BREAK = Symbol("MODE_BREAK");
var MODE_FLAT = Symbol("MODE_FLAT");
var CURSOR_PLACEHOLDER = Symbol("cursor");
function rootIndent() {
  return {
    value: "",
    length: 0,
    queue: []
  };
}
function makeIndent(ind, options) {
  return generateInd(ind, {
    type: "indent"
  }, options);
}
function makeAlign(indent2, widthOrDoc, options) {
  if (widthOrDoc === Number.NEGATIVE_INFINITY) {
    return indent2.root || rootIndent();
  }
  if (widthOrDoc < 0) {
    return generateInd(indent2, {
      type: "dedent"
    }, options);
  }
  if (!widthOrDoc) {
    return indent2;
  }
  if (widthOrDoc.type === "root") {
    return {
      ...indent2,
      root: indent2
    };
  }
  const alignType = typeof widthOrDoc === "string" ? "stringAlign" : "numberAlign";
  return generateInd(indent2, {
    type: alignType,
    n: widthOrDoc
  }, options);
}
function generateInd(ind, newPart, options) {
  const queue = newPart.type === "dedent" ? ind.queue.slice(0, -1) : [...ind.queue, newPart];
  let value = "";
  let length = 0;
  let lastTabs = 0;
  let lastSpaces = 0;
  for (const part of queue) {
    switch (part.type) {
      case "indent":
        flush();
        if (options.useTabs) {
          addTabs(1);
        } else {
          addSpaces(options.tabWidth);
        }
        break;
      case "stringAlign":
        flush();
        value += part.n;
        length += part.n.length;
        break;
      case "numberAlign":
        lastTabs += 1;
        lastSpaces += part.n;
        break;
      default:
        throw new Error(`Unexpected type '${part.type}'`);
    }
  }
  flushSpaces();
  return {
    ...ind,
    value,
    length,
    queue
  };
  function addTabs(count) {
    value += "	".repeat(count);
    length += options.tabWidth * count;
  }
  function addSpaces(count) {
    value += " ".repeat(count);
    length += count;
  }
  function flush() {
    if (options.useTabs) {
      flushTabs();
    } else {
      flushSpaces();
    }
  }
  function flushTabs() {
    if (lastTabs > 0) {
      addTabs(lastTabs);
    }
    resetLast();
  }
  function flushSpaces() {
    if (lastSpaces > 0) {
      addSpaces(lastSpaces);
    }
    resetLast();
  }
  function resetLast() {
    lastTabs = 0;
    lastSpaces = 0;
  }
}
function trim2(out) {
  let trimCount = 0;
  let cursorCount = 0;
  let outIndex = out.length;
  outer:
    while (outIndex--) {
      const last = out[outIndex];
      if (last === CURSOR_PLACEHOLDER) {
        cursorCount++;
        continue;
      }
      for (let charIndex = last.length - 1; charIndex >= 0; charIndex--) {
        const char = last[charIndex];
        if (char === " " || char === "	") {
          trimCount++;
        } else {
          out[outIndex] = last.slice(0, charIndex + 1);
          break outer;
        }
      }
    }
  if (trimCount > 0 || cursorCount > 0) {
    out.length = outIndex + 1;
    while (cursorCount-- > 0) {
      out.push(CURSOR_PLACEHOLDER);
    }
  }
  return trimCount;
}
function fits(next, restCommands, width, hasLineSuffix, groupModeMap, mustBeFlat) {
  if (width === Number.POSITIVE_INFINITY) {
    return true;
  }
  let restIdx = restCommands.length;
  const cmds = [next];
  const out = [];
  while (width >= 0) {
    if (cmds.length === 0) {
      if (restIdx === 0) {
        return true;
      }
      cmds.push(restCommands[--restIdx]);
      continue;
    }
    const {
      mode,
      doc
    } = cmds.pop();
    switch (get_doc_type_default(doc)) {
      case DOC_TYPE_STRING:
        out.push(doc);
        width -= get_string_width_default(doc);
        break;
      case DOC_TYPE_ARRAY:
      case DOC_TYPE_FILL: {
        const parts = getDocParts(doc);
        for (let i = parts.length - 1; i >= 0; i--) {
          cmds.push({
            mode,
            doc: parts[i]
          });
        }
        break;
      }
      case DOC_TYPE_INDENT:
      case DOC_TYPE_ALIGN:
      case DOC_TYPE_INDENT_IF_BREAK:
      case DOC_TYPE_LABEL:
        cmds.push({
          mode,
          doc: doc.contents
        });
        break;
      case DOC_TYPE_TRIM:
        width += trim2(out);
        break;
      case DOC_TYPE_GROUP: {
        if (mustBeFlat && doc.break) {
          return false;
        }
        const groupMode = doc.break ? MODE_BREAK : mode;
        const contents = doc.expandedStates && groupMode === MODE_BREAK ? at_default(
          /* isOptionalObject*/
          false,
          doc.expandedStates,
          -1
        ) : doc.contents;
        cmds.push({
          mode: groupMode,
          doc: contents
        });
        break;
      }
      case DOC_TYPE_IF_BREAK: {
        const groupMode = doc.groupId ? groupModeMap[doc.groupId] || MODE_FLAT : mode;
        const contents = groupMode === MODE_BREAK ? doc.breakContents : doc.flatContents;
        if (contents) {
          cmds.push({
            mode,
            doc: contents
          });
        }
        break;
      }
      case DOC_TYPE_LINE:
        if (mode === MODE_BREAK || doc.hard) {
          return true;
        }
        if (!doc.soft) {
          out.push(" ");
          width--;
        }
        break;
      case DOC_TYPE_LINE_SUFFIX:
        hasLineSuffix = true;
        break;
      case DOC_TYPE_LINE_SUFFIX_BOUNDARY:
        if (hasLineSuffix) {
          return false;
        }
        break;
    }
  }
  return false;
}
function printDocToString(doc, options) {
  const groupModeMap = {};
  const width = options.printWidth;
  const newLine = convertEndOfLineToChars(options.endOfLine);
  let pos = 0;
  const cmds = [{
    ind: rootIndent(),
    mode: MODE_BREAK,
    doc
  }];
  const out = [];
  let shouldRemeasure = false;
  const lineSuffix2 = [];
  let printedCursorCount = 0;
  propagateBreaks(doc);
  while (cmds.length > 0) {
    const {
      ind,
      mode,
      doc: doc2
    } = cmds.pop();
    switch (get_doc_type_default(doc2)) {
      case DOC_TYPE_STRING: {
        const formatted = newLine !== "\n" ? string_replace_all_default(
          /* isOptionalObject*/
          false,
          doc2,
          "\n",
          newLine
        ) : doc2;
        out.push(formatted);
        if (cmds.length > 0) {
          pos += get_string_width_default(formatted);
        }
        break;
      }
      case DOC_TYPE_ARRAY:
        for (let i = doc2.length - 1; i >= 0; i--) {
          cmds.push({
            ind,
            mode,
            doc: doc2[i]
          });
        }
        break;
      case DOC_TYPE_CURSOR:
        if (printedCursorCount >= 2) {
          throw new Error("There are too many 'cursor' in doc.");
        }
        out.push(CURSOR_PLACEHOLDER);
        printedCursorCount++;
        break;
      case DOC_TYPE_INDENT:
        cmds.push({
          ind: makeIndent(ind, options),
          mode,
          doc: doc2.contents
        });
        break;
      case DOC_TYPE_ALIGN:
        cmds.push({
          ind: makeAlign(ind, doc2.n, options),
          mode,
          doc: doc2.contents
        });
        break;
      case DOC_TYPE_TRIM:
        pos -= trim2(out);
        break;
      case DOC_TYPE_GROUP:
        switch (mode) {
          case MODE_FLAT:
            if (!shouldRemeasure) {
              cmds.push({
                ind,
                mode: doc2.break ? MODE_BREAK : MODE_FLAT,
                doc: doc2.contents
              });
              break;
            }
          case MODE_BREAK: {
            shouldRemeasure = false;
            const next = {
              ind,
              mode: MODE_FLAT,
              doc: doc2.contents
            };
            const rem = width - pos;
            const hasLineSuffix = lineSuffix2.length > 0;
            if (!doc2.break && fits(next, cmds, rem, hasLineSuffix, groupModeMap)) {
              cmds.push(next);
            } else {
              if (doc2.expandedStates) {
                const mostExpanded = at_default(
                  /* isOptionalObject*/
                  false,
                  doc2.expandedStates,
                  -1
                );
                if (doc2.break) {
                  cmds.push({
                    ind,
                    mode: MODE_BREAK,
                    doc: mostExpanded
                  });
                  break;
                } else {
                  for (let i = 1; i < doc2.expandedStates.length + 1; i++) {
                    if (i >= doc2.expandedStates.length) {
                      cmds.push({
                        ind,
                        mode: MODE_BREAK,
                        doc: mostExpanded
                      });
                      break;
                    } else {
                      const state = doc2.expandedStates[i];
                      const cmd = {
                        ind,
                        mode: MODE_FLAT,
                        doc: state
                      };
                      if (fits(cmd, cmds, rem, hasLineSuffix, groupModeMap)) {
                        cmds.push(cmd);
                        break;
                      }
                    }
                  }
                }
              } else {
                cmds.push({
                  ind,
                  mode: MODE_BREAK,
                  doc: doc2.contents
                });
              }
            }
            break;
          }
        }
        if (doc2.id) {
          groupModeMap[doc2.id] = at_default(
            /* isOptionalObject*/
            false,
            cmds,
            -1
          ).mode;
        }
        break;
      case DOC_TYPE_FILL: {
        const rem = width - pos;
        const {
          parts
        } = doc2;
        if (parts.length === 0) {
          break;
        }
        const [content, whitespace] = parts;
        const contentFlatCmd = {
          ind,
          mode: MODE_FLAT,
          doc: content
        };
        const contentBreakCmd = {
          ind,
          mode: MODE_BREAK,
          doc: content
        };
        const contentFits = fits(contentFlatCmd, [], rem, lineSuffix2.length > 0, groupModeMap, true);
        if (parts.length === 1) {
          if (contentFits) {
            cmds.push(contentFlatCmd);
          } else {
            cmds.push(contentBreakCmd);
          }
          break;
        }
        const whitespaceFlatCmd = {
          ind,
          mode: MODE_FLAT,
          doc: whitespace
        };
        const whitespaceBreakCmd = {
          ind,
          mode: MODE_BREAK,
          doc: whitespace
        };
        if (parts.length === 2) {
          if (contentFits) {
            cmds.push(whitespaceFlatCmd, contentFlatCmd);
          } else {
            cmds.push(whitespaceBreakCmd, contentBreakCmd);
          }
          break;
        }
        parts.splice(0, 2);
        const remainingCmd = {
          ind,
          mode,
          doc: fill(parts)
        };
        const secondContent = parts[0];
        const firstAndSecondContentFlatCmd = {
          ind,
          mode: MODE_FLAT,
          doc: [content, whitespace, secondContent]
        };
        const firstAndSecondContentFits = fits(firstAndSecondContentFlatCmd, [], rem, lineSuffix2.length > 0, groupModeMap, true);
        if (firstAndSecondContentFits) {
          cmds.push(remainingCmd, whitespaceFlatCmd, contentFlatCmd);
        } else if (contentFits) {
          cmds.push(remainingCmd, whitespaceBreakCmd, contentFlatCmd);
        } else {
          cmds.push(remainingCmd, whitespaceBreakCmd, contentBreakCmd);
        }
        break;
      }
      case DOC_TYPE_IF_BREAK:
      case DOC_TYPE_INDENT_IF_BREAK: {
        const groupMode = doc2.groupId ? groupModeMap[doc2.groupId] : mode;
        if (groupMode === MODE_BREAK) {
          const breakContents = doc2.type === DOC_TYPE_IF_BREAK ? doc2.breakContents : doc2.negate ? doc2.contents : indent$1(doc2.contents);
          if (breakContents) {
            cmds.push({
              ind,
              mode,
              doc: breakContents
            });
          }
        }
        if (groupMode === MODE_FLAT) {
          const flatContents = doc2.type === DOC_TYPE_IF_BREAK ? doc2.flatContents : doc2.negate ? indent$1(doc2.contents) : doc2.contents;
          if (flatContents) {
            cmds.push({
              ind,
              mode,
              doc: flatContents
            });
          }
        }
        break;
      }
      case DOC_TYPE_LINE_SUFFIX:
        lineSuffix2.push({
          ind,
          mode,
          doc: doc2.contents
        });
        break;
      case DOC_TYPE_LINE_SUFFIX_BOUNDARY:
        if (lineSuffix2.length > 0) {
          cmds.push({
            ind,
            mode,
            doc: hardlineWithoutBreakParent
          });
        }
        break;
      case DOC_TYPE_LINE:
        switch (mode) {
          case MODE_FLAT:
            if (!doc2.hard) {
              if (!doc2.soft) {
                out.push(" ");
                pos += 1;
              }
              break;
            } else {
              shouldRemeasure = true;
            }
          case MODE_BREAK:
            if (lineSuffix2.length > 0) {
              cmds.push({
                ind,
                mode,
                doc: doc2
              }, ...lineSuffix2.reverse());
              lineSuffix2.length = 0;
              break;
            }
            if (doc2.literal) {
              if (ind.root) {
                out.push(newLine, ind.root.value);
                pos = ind.root.length;
              } else {
                out.push(newLine);
                pos = 0;
              }
            } else {
              pos -= trim2(out);
              out.push(newLine + ind.value);
              pos = ind.length;
            }
            break;
        }
        break;
      case DOC_TYPE_LABEL:
        cmds.push({
          ind,
          mode,
          doc: doc2.contents
        });
        break;
      case DOC_TYPE_BREAK_PARENT:
        break;
      default:
        throw new invalid_doc_error_default(doc2);
    }
    if (cmds.length === 0 && lineSuffix2.length > 0) {
      cmds.push(...lineSuffix2.reverse());
      lineSuffix2.length = 0;
    }
  }
  const cursorPlaceholderIndex = out.indexOf(CURSOR_PLACEHOLDER);
  if (cursorPlaceholderIndex !== -1) {
    const otherCursorPlaceholderIndex = out.indexOf(CURSOR_PLACEHOLDER, cursorPlaceholderIndex + 1);
    const beforeCursor = out.slice(0, cursorPlaceholderIndex).join("");
    const aroundCursor = out.slice(cursorPlaceholderIndex + 1, otherCursorPlaceholderIndex).join("");
    const afterCursor = out.slice(otherCursorPlaceholderIndex + 1).join("");
    return {
      formatted: beforeCursor + aroundCursor + afterCursor,
      cursorNodeStart: beforeCursor.length,
      cursorNodeText: aroundCursor
    };
  }
  return {
    formatted: out.join("")
  };
}

// src/document/public.js
var builders = {
  join: join$1,
  line: line$1,
  softline: softline$1,
  hardline: hardline$1,
  literalline,
  group: group$1,
  conditionalGroup,
  fill,
  lineSuffix,
  lineSuffixBoundary,
  cursor,
  breakParent: breakParent$1,
  ifBreak: ifBreak$1,
  trim: trim$1,
  indent: indent$1,
  indentIfBreak,
  align: align$1,
  addAlignmentToDoc,
  markAsRoot,
  dedentToRoot,
  dedent,
  hardlineWithoutBreakParent,
  literallineWithoutBreakParent,
  label,
  // TODO: Remove this in v4
  concat: (parts) => parts
};
var printer = { printDocToString };
var utils = {
  willBreak,
  traverseDoc: traverse_doc_default,
  findInDoc,
  mapDoc,
  removeLines,
  stripTrailingHardline,
  replaceEndOfLine,
  canBreak
};

//
// Generated by scripts/regen-nonascii-map.js
// on node v18.16.0 with unicode 15.0.
//
/**
 * @internal
 *
 * Map of non-ascii characters that are valid in an identifier. Each pair of
 * numbers represents an inclusive range of code points.
 */
//prettier-ignore
const nonAsciiIdentifierMap = [
    0xa0, 0x377,
    0x37a, 0x37f,
    0x384, 0x38a,
    0x38c, 0x38c,
    0x38e, 0x3a1,
    0x3a3, 0x52f,
    0x531, 0x556,
    0x559, 0x58a,
    0x58d, 0x58f,
    0x591, 0x5c7,
    0x5d0, 0x5ea,
    0x5ef, 0x5f4,
    0x600, 0x70d,
    0x70f, 0x74a,
    0x74d, 0x7b1,
    0x7c0, 0x7fa,
    0x7fd, 0x82d,
    0x830, 0x83e,
    0x840, 0x85b,
    0x85e, 0x85e,
    0x860, 0x86a,
    0x870, 0x88e,
    0x890, 0x891,
    0x898, 0x983,
    0x985, 0x98c,
    0x98f, 0x990,
    0x993, 0x9a8,
    0x9aa, 0x9b0,
    0x9b2, 0x9b2,
    0x9b6, 0x9b9,
    0x9bc, 0x9c4,
    0x9c7, 0x9c8,
    0x9cb, 0x9ce,
    0x9d7, 0x9d7,
    0x9dc, 0x9dd,
    0x9df, 0x9e3,
    0x9e6, 0x9fe,
    0xa01, 0xa03,
    0xa05, 0xa0a,
    0xa0f, 0xa10,
    0xa13, 0xa28,
    0xa2a, 0xa30,
    0xa32, 0xa33,
    0xa35, 0xa36,
    0xa38, 0xa39,
    0xa3c, 0xa3c,
    0xa3e, 0xa42,
    0xa47, 0xa48,
    0xa4b, 0xa4d,
    0xa51, 0xa51,
    0xa59, 0xa5c,
    0xa5e, 0xa5e,
    0xa66, 0xa76,
    0xa81, 0xa83,
    0xa85, 0xa8d,
    0xa8f, 0xa91,
    0xa93, 0xaa8,
    0xaaa, 0xab0,
    0xab2, 0xab3,
    0xab5, 0xab9,
    0xabc, 0xac5,
    0xac7, 0xac9,
    0xacb, 0xacd,
    0xad0, 0xad0,
    0xae0, 0xae3,
    0xae6, 0xaf1,
    0xaf9, 0xaff,
    0xb01, 0xb03,
    0xb05, 0xb0c,
    0xb0f, 0xb10,
    0xb13, 0xb28,
    0xb2a, 0xb30,
    0xb32, 0xb33,
    0xb35, 0xb39,
    0xb3c, 0xb44,
    0xb47, 0xb48,
    0xb4b, 0xb4d,
    0xb55, 0xb57,
    0xb5c, 0xb5d,
    0xb5f, 0xb63,
    0xb66, 0xb77,
    0xb82, 0xb83,
    0xb85, 0xb8a,
    0xb8e, 0xb90,
    0xb92, 0xb95,
    0xb99, 0xb9a,
    0xb9c, 0xb9c,
    0xb9e, 0xb9f,
    0xba3, 0xba4,
    0xba8, 0xbaa,
    0xbae, 0xbb9,
    0xbbe, 0xbc2,
    0xbc6, 0xbc8,
    0xbca, 0xbcd,
    0xbd0, 0xbd0,
    0xbd7, 0xbd7,
    0xbe6, 0xbfa,
    0xc00, 0xc0c,
    0xc0e, 0xc10,
    0xc12, 0xc28,
    0xc2a, 0xc39,
    0xc3c, 0xc44,
    0xc46, 0xc48,
    0xc4a, 0xc4d,
    0xc55, 0xc56,
    0xc58, 0xc5a,
    0xc5d, 0xc5d,
    0xc60, 0xc63,
    0xc66, 0xc6f,
    0xc77, 0xc8c,
    0xc8e, 0xc90,
    0xc92, 0xca8,
    0xcaa, 0xcb3,
    0xcb5, 0xcb9,
    0xcbc, 0xcc4,
    0xcc6, 0xcc8,
    0xcca, 0xccd,
    0xcd5, 0xcd6,
    0xcdd, 0xcde,
    0xce0, 0xce3,
    0xce6, 0xcef,
    0xcf1, 0xcf3,
    0xd00, 0xd0c,
    0xd0e, 0xd10,
    0xd12, 0xd44,
    0xd46, 0xd48,
    0xd4a, 0xd4f,
    0xd54, 0xd63,
    0xd66, 0xd7f,
    0xd81, 0xd83,
    0xd85, 0xd96,
    0xd9a, 0xdb1,
    0xdb3, 0xdbb,
    0xdbd, 0xdbd,
    0xdc0, 0xdc6,
    0xdca, 0xdca,
    0xdcf, 0xdd4,
    0xdd6, 0xdd6,
    0xdd8, 0xddf,
    0xde6, 0xdef,
    0xdf2, 0xdf4,
    0xe01, 0xe3a,
    0xe3f, 0xe5b,
    0xe81, 0xe82,
    0xe84, 0xe84,
    0xe86, 0xe8a,
    0xe8c, 0xea3,
    0xea5, 0xea5,
    0xea7, 0xebd,
    0xec0, 0xec4,
    0xec6, 0xec6,
    0xec8, 0xece,
    0xed0, 0xed9,
    0xedc, 0xedf,
    0xf00, 0xf47,
    0xf49, 0xf6c,
    0xf71, 0xf97,
    0xf99, 0xfbc,
    0xfbe, 0xfcc,
    0xfce, 0xfda,
    0x1000, 0x10c5,
    0x10c7, 0x10c7,
    0x10cd, 0x10cd,
    0x10d0, 0x1248,
    0x124a, 0x124d,
    0x1250, 0x1256,
    0x1258, 0x1258,
    0x125a, 0x125d,
    0x1260, 0x1288,
    0x128a, 0x128d,
    0x1290, 0x12b0,
    0x12b2, 0x12b5,
    0x12b8, 0x12be,
    0x12c0, 0x12c0,
    0x12c2, 0x12c5,
    0x12c8, 0x12d6,
    0x12d8, 0x1310,
    0x1312, 0x1315,
    0x1318, 0x135a,
    0x135d, 0x137c,
    0x1380, 0x1399,
    0x13a0, 0x13f5,
    0x13f8, 0x13fd,
    0x1400, 0x169c,
    0x16a0, 0x16f8,
    0x1700, 0x1715,
    0x171f, 0x1736,
    0x1740, 0x1753,
    0x1760, 0x176c,
    0x176e, 0x1770,
    0x1772, 0x1773,
    0x1780, 0x17dd,
    0x17e0, 0x17e9,
    0x17f0, 0x17f9,
    0x1800, 0x1819,
    0x1820, 0x1878,
    0x1880, 0x18aa,
    0x18b0, 0x18f5,
    0x1900, 0x191e,
    0x1920, 0x192b,
    0x1930, 0x193b,
    0x1940, 0x1940,
    0x1944, 0x196d,
    0x1970, 0x1974,
    0x1980, 0x19ab,
    0x19b0, 0x19c9,
    0x19d0, 0x19da,
    0x19de, 0x1a1b,
    0x1a1e, 0x1a5e,
    0x1a60, 0x1a7c,
    0x1a7f, 0x1a89,
    0x1a90, 0x1a99,
    0x1aa0, 0x1aad,
    0x1ab0, 0x1ace,
    0x1b00, 0x1b4c,
    0x1b50, 0x1b7e,
    0x1b80, 0x1bf3,
    0x1bfc, 0x1c37,
    0x1c3b, 0x1c49,
    0x1c4d, 0x1c88,
    0x1c90, 0x1cba,
    0x1cbd, 0x1cc7,
    0x1cd0, 0x1cfa,
    0x1d00, 0x1f15,
    0x1f18, 0x1f1d,
    0x1f20, 0x1f45,
    0x1f48, 0x1f4d,
    0x1f50, 0x1f57,
    0x1f59, 0x1f59,
    0x1f5b, 0x1f5b,
    0x1f5d, 0x1f5d,
    0x1f5f, 0x1f7d,
    0x1f80, 0x1fb4,
    0x1fb6, 0x1fc4,
    0x1fc6, 0x1fd3,
    0x1fd6, 0x1fdb,
    0x1fdd, 0x1fef,
    0x1ff2, 0x1ff4,
    0x1ff6, 0x1ffe,
    0x2000, 0x200d,
    0x2010, 0x2027,
    0x202a, 0x2064,
    0x2066, 0x2071,
    0x2074, 0x208e,
    0x2090, 0x209c,
    0x20a0, 0x20c0,
    0x20d0, 0x20f0,
    0x2100, 0x218b,
    0x2190, 0x2426,
    0x2440, 0x244a,
    0x2460, 0x2b73,
    0x2b76, 0x2b95,
    0x2b97, 0x2cf3,
    0x2cf9, 0x2d25,
    0x2d27, 0x2d27,
    0x2d2d, 0x2d2d,
    0x2d30, 0x2d67,
    0x2d6f, 0x2d70,
    0x2d7f, 0x2d96,
    0x2da0, 0x2da6,
    0x2da8, 0x2dae,
    0x2db0, 0x2db6,
    0x2db8, 0x2dbe,
    0x2dc0, 0x2dc6,
    0x2dc8, 0x2dce,
    0x2dd0, 0x2dd6,
    0x2dd8, 0x2dde,
    0x2de0, 0x2e5d,
    0x2e80, 0x2e99,
    0x2e9b, 0x2ef3,
    0x2f00, 0x2fd5,
    0x2ff0, 0x2ffb,
    0x3000, 0x303f,
    0x3041, 0x3096,
    0x3099, 0x30ff,
    0x3105, 0x312f,
    0x3131, 0x318e,
    0x3190, 0x31e3,
    0x31f0, 0x321e,
    0x3220, 0xa48c,
    0xa490, 0xa4c6,
    0xa4d0, 0xa62b,
    0xa640, 0xa6f7,
    0xa700, 0xa7ca,
    0xa7d0, 0xa7d1,
    0xa7d3, 0xa7d3,
    0xa7d5, 0xa7d9,
    0xa7f2, 0xa82c,
    0xa830, 0xa839,
    0xa840, 0xa877,
    0xa880, 0xa8c5,
    0xa8ce, 0xa8d9,
    0xa8e0, 0xa953,
    0xa95f, 0xa97c,
    0xa980, 0xa9cd,
    0xa9cf, 0xa9d9,
    0xa9de, 0xa9fe,
    0xaa00, 0xaa36,
    0xaa40, 0xaa4d,
    0xaa50, 0xaa59,
    0xaa5c, 0xaac2,
    0xaadb, 0xaaf6,
    0xab01, 0xab06,
    0xab09, 0xab0e,
    0xab11, 0xab16,
    0xab20, 0xab26,
    0xab28, 0xab2e,
    0xab30, 0xab6b,
    0xab70, 0xabed,
    0xabf0, 0xabf9,
    0xac00, 0xd7a3,
    0xd7b0, 0xd7c6,
    0xd7cb, 0xd7fb,
    0xf900, 0xfa6d,
    0xfa70, 0xfad9,
    0xfb00, 0xfb06,
    0xfb13, 0xfb17,
    0xfb1d, 0xfb36,
    0xfb38, 0xfb3c,
    0xfb3e, 0xfb3e,
    0xfb40, 0xfb41,
    0xfb43, 0xfb44,
    0xfb46, 0xfbc2,
    0xfbd3, 0xfd8f,
    0xfd92, 0xfdc7,
    0xfdcf, 0xfdcf,
    0xfdf0, 0xfe19,
    0xfe20, 0xfe52,
    0xfe54, 0xfe66,
    0xfe68, 0xfe6b,
    0xfe70, 0xfe74,
    0xfe76, 0xfefc,
    0xfeff, 0xfeff,
    0xff01, 0xffbe,
    0xffc2, 0xffc7,
    0xffca, 0xffcf,
    0xffd2, 0xffd7,
    0xffda, 0xffdc,
    0xffe0, 0xffe6,
    0xffe8, 0xffee,
    0xfff9, 0xfffc,
    0x10000, 0x1000b,
    0x1000d, 0x10026,
    0x10028, 0x1003a,
    0x1003c, 0x1003d,
    0x1003f, 0x1004d,
    0x10050, 0x1005d,
    0x10080, 0x100fa,
    0x10100, 0x10102,
    0x10107, 0x10133,
    0x10137, 0x1018e,
    0x10190, 0x1019c,
    0x101a0, 0x101a0,
    0x101d0, 0x101fd,
    0x10280, 0x1029c,
    0x102a0, 0x102d0,
    0x102e0, 0x102fb,
    0x10300, 0x10323,
    0x1032d, 0x1034a,
    0x10350, 0x1037a,
    0x10380, 0x1039d,
    0x1039f, 0x103c3,
    0x103c8, 0x103d5,
    0x10400, 0x1049d,
    0x104a0, 0x104a9,
    0x104b0, 0x104d3,
    0x104d8, 0x104fb,
    0x10500, 0x10527,
    0x10530, 0x10563,
    0x1056f, 0x1057a,
    0x1057c, 0x1058a,
    0x1058c, 0x10592,
    0x10594, 0x10595,
    0x10597, 0x105a1,
    0x105a3, 0x105b1,
    0x105b3, 0x105b9,
    0x105bb, 0x105bc,
    0x10600, 0x10736,
    0x10740, 0x10755,
    0x10760, 0x10767,
    0x10780, 0x10785,
    0x10787, 0x107b0,
    0x107b2, 0x107ba,
    0x10800, 0x10805,
    0x10808, 0x10808,
    0x1080a, 0x10835,
    0x10837, 0x10838,
    0x1083c, 0x1083c,
    0x1083f, 0x10855,
    0x10857, 0x1089e,
    0x108a7, 0x108af,
    0x108e0, 0x108f2,
    0x108f4, 0x108f5,
    0x108fb, 0x1091b,
    0x1091f, 0x10939,
    0x1093f, 0x1093f,
    0x10980, 0x109b7,
    0x109bc, 0x109cf,
    0x109d2, 0x10a03,
    0x10a05, 0x10a06,
    0x10a0c, 0x10a13,
    0x10a15, 0x10a17,
    0x10a19, 0x10a35,
    0x10a38, 0x10a3a,
    0x10a3f, 0x10a48,
    0x10a50, 0x10a58,
    0x10a60, 0x10a9f,
    0x10ac0, 0x10ae6,
    0x10aeb, 0x10af6,
    0x10b00, 0x10b35,
    0x10b39, 0x10b55,
    0x10b58, 0x10b72,
    0x10b78, 0x10b91,
    0x10b99, 0x10b9c,
    0x10ba9, 0x10baf,
    0x10c00, 0x10c48,
    0x10c80, 0x10cb2,
    0x10cc0, 0x10cf2,
    0x10cfa, 0x10d27,
    0x10d30, 0x10d39,
    0x10e60, 0x10e7e,
    0x10e80, 0x10ea9,
    0x10eab, 0x10ead,
    0x10eb0, 0x10eb1,
    0x10efd, 0x10f27,
    0x10f30, 0x10f59,
    0x10f70, 0x10f89,
    0x10fb0, 0x10fcb,
    0x10fe0, 0x10ff6,
    0x11000, 0x1104d,
    0x11052, 0x11075,
    0x1107f, 0x110c2,
    0x110cd, 0x110cd,
    0x110d0, 0x110e8,
    0x110f0, 0x110f9,
    0x11100, 0x11134,
    0x11136, 0x11147,
    0x11150, 0x11176,
    0x11180, 0x111df,
    0x111e1, 0x111f4,
    0x11200, 0x11211,
    0x11213, 0x11241,
    0x11280, 0x11286,
    0x11288, 0x11288,
    0x1128a, 0x1128d,
    0x1128f, 0x1129d,
    0x1129f, 0x112a9,
    0x112b0, 0x112ea,
    0x112f0, 0x112f9,
    0x11300, 0x11303,
    0x11305, 0x1130c,
    0x1130f, 0x11310,
    0x11313, 0x11328,
    0x1132a, 0x11330,
    0x11332, 0x11333,
    0x11335, 0x11339,
    0x1133b, 0x11344,
    0x11347, 0x11348,
    0x1134b, 0x1134d,
    0x11350, 0x11350,
    0x11357, 0x11357,
    0x1135d, 0x11363,
    0x11366, 0x1136c,
    0x11370, 0x11374,
    0x11400, 0x1145b,
    0x1145d, 0x11461,
    0x11480, 0x114c7,
    0x114d0, 0x114d9,
    0x11580, 0x115b5,
    0x115b8, 0x115dd,
    0x11600, 0x11644,
    0x11650, 0x11659,
    0x11660, 0x1166c,
    0x11680, 0x116b9,
    0x116c0, 0x116c9,
    0x11700, 0x1171a,
    0x1171d, 0x1172b,
    0x11730, 0x11746,
    0x11800, 0x1183b,
    0x118a0, 0x118f2,
    0x118ff, 0x11906,
    0x11909, 0x11909,
    0x1190c, 0x11913,
    0x11915, 0x11916,
    0x11918, 0x11935,
    0x11937, 0x11938,
    0x1193b, 0x11946,
    0x11950, 0x11959,
    0x119a0, 0x119a7,
    0x119aa, 0x119d7,
    0x119da, 0x119e4,
    0x11a00, 0x11a47,
    0x11a50, 0x11aa2,
    0x11ab0, 0x11af8,
    0x11b00, 0x11b09,
    0x11c00, 0x11c08,
    0x11c0a, 0x11c36,
    0x11c38, 0x11c45,
    0x11c50, 0x11c6c,
    0x11c70, 0x11c8f,
    0x11c92, 0x11ca7,
    0x11ca9, 0x11cb6,
    0x11d00, 0x11d06,
    0x11d08, 0x11d09,
    0x11d0b, 0x11d36,
    0x11d3a, 0x11d3a,
    0x11d3c, 0x11d3d,
    0x11d3f, 0x11d47,
    0x11d50, 0x11d59,
    0x11d60, 0x11d65,
    0x11d67, 0x11d68,
    0x11d6a, 0x11d8e,
    0x11d90, 0x11d91,
    0x11d93, 0x11d98,
    0x11da0, 0x11da9,
    0x11ee0, 0x11ef8,
    0x11f00, 0x11f10,
    0x11f12, 0x11f3a,
    0x11f3e, 0x11f59,
    0x11fb0, 0x11fb0,
    0x11fc0, 0x11ff1,
    0x11fff, 0x12399,
    0x12400, 0x1246e,
    0x12470, 0x12474,
    0x12480, 0x12543,
    0x12f90, 0x12ff2,
    0x13000, 0x13455,
    0x14400, 0x14646,
    0x16800, 0x16a38,
    0x16a40, 0x16a5e,
    0x16a60, 0x16a69,
    0x16a6e, 0x16abe,
    0x16ac0, 0x16ac9,
    0x16ad0, 0x16aed,
    0x16af0, 0x16af5,
    0x16b00, 0x16b45,
    0x16b50, 0x16b59,
    0x16b5b, 0x16b61,
    0x16b63, 0x16b77,
    0x16b7d, 0x16b8f,
    0x16e40, 0x16e9a,
    0x16f00, 0x16f4a,
    0x16f4f, 0x16f87,
    0x16f8f, 0x16f9f,
    0x16fe0, 0x16fe4,
    0x16ff0, 0x16ff1,
    0x17000, 0x187f7,
    0x18800, 0x18cd5,
    0x18d00, 0x18d08,
    0x1aff0, 0x1aff3,
    0x1aff5, 0x1affb,
    0x1affd, 0x1affe,
    0x1b000, 0x1b122,
    0x1b132, 0x1b132,
    0x1b150, 0x1b152,
    0x1b155, 0x1b155,
    0x1b164, 0x1b167,
    0x1b170, 0x1b2fb,
    0x1bc00, 0x1bc6a,
    0x1bc70, 0x1bc7c,
    0x1bc80, 0x1bc88,
    0x1bc90, 0x1bc99,
    0x1bc9c, 0x1bca3,
    0x1cf00, 0x1cf2d,
    0x1cf30, 0x1cf46,
    0x1cf50, 0x1cfc3,
    0x1d000, 0x1d0f5,
    0x1d100, 0x1d126,
    0x1d129, 0x1d1ea,
    0x1d200, 0x1d245,
    0x1d2c0, 0x1d2d3,
    0x1d2e0, 0x1d2f3,
    0x1d300, 0x1d356,
    0x1d360, 0x1d378,
    0x1d400, 0x1d454,
    0x1d456, 0x1d49c,
    0x1d49e, 0x1d49f,
    0x1d4a2, 0x1d4a2,
    0x1d4a5, 0x1d4a6,
    0x1d4a9, 0x1d4ac,
    0x1d4ae, 0x1d4b9,
    0x1d4bb, 0x1d4bb,
    0x1d4bd, 0x1d4c3,
    0x1d4c5, 0x1d505,
    0x1d507, 0x1d50a,
    0x1d50d, 0x1d514,
    0x1d516, 0x1d51c,
    0x1d51e, 0x1d539,
    0x1d53b, 0x1d53e,
    0x1d540, 0x1d544,
    0x1d546, 0x1d546,
    0x1d54a, 0x1d550,
    0x1d552, 0x1d6a5,
    0x1d6a8, 0x1d7cb,
    0x1d7ce, 0x1da8b,
    0x1da9b, 0x1da9f,
    0x1daa1, 0x1daaf,
    0x1df00, 0x1df1e,
    0x1df25, 0x1df2a,
    0x1e000, 0x1e006,
    0x1e008, 0x1e018,
    0x1e01b, 0x1e021,
    0x1e023, 0x1e024,
    0x1e026, 0x1e02a,
    0x1e030, 0x1e06d,
    0x1e08f, 0x1e08f,
    0x1e100, 0x1e12c,
    0x1e130, 0x1e13d,
    0x1e140, 0x1e149,
    0x1e14e, 0x1e14f,
    0x1e290, 0x1e2ae,
    0x1e2c0, 0x1e2f9,
    0x1e2ff, 0x1e2ff,
    0x1e4d0, 0x1e4f9,
    0x1e7e0, 0x1e7e6,
    0x1e7e8, 0x1e7eb,
    0x1e7ed, 0x1e7ee,
    0x1e7f0, 0x1e7fe,
    0x1e800, 0x1e8c4,
    0x1e8c7, 0x1e8d6,
    0x1e900, 0x1e94b,
    0x1e950, 0x1e959,
    0x1e95e, 0x1e95f,
    0x1ec71, 0x1ecb4,
    0x1ed01, 0x1ed3d,
    0x1ee00, 0x1ee03,
    0x1ee05, 0x1ee1f,
    0x1ee21, 0x1ee22,
    0x1ee24, 0x1ee24,
    0x1ee27, 0x1ee27,
    0x1ee29, 0x1ee32,
    0x1ee34, 0x1ee37,
    0x1ee39, 0x1ee39,
    0x1ee3b, 0x1ee3b,
    0x1ee42, 0x1ee42,
    0x1ee47, 0x1ee47,
    0x1ee49, 0x1ee49,
    0x1ee4b, 0x1ee4b,
    0x1ee4d, 0x1ee4f,
    0x1ee51, 0x1ee52,
    0x1ee54, 0x1ee54,
    0x1ee57, 0x1ee57,
    0x1ee59, 0x1ee59,
    0x1ee5b, 0x1ee5b,
    0x1ee5d, 0x1ee5d,
    0x1ee5f, 0x1ee5f,
    0x1ee61, 0x1ee62,
    0x1ee64, 0x1ee64,
    0x1ee67, 0x1ee6a,
    0x1ee6c, 0x1ee72,
    0x1ee74, 0x1ee77,
    0x1ee79, 0x1ee7c,
    0x1ee7e, 0x1ee7e,
    0x1ee80, 0x1ee89,
    0x1ee8b, 0x1ee9b,
    0x1eea1, 0x1eea3,
    0x1eea5, 0x1eea9,
    0x1eeab, 0x1eebb,
    0x1eef0, 0x1eef1,
    0x1f000, 0x1f02b,
    0x1f030, 0x1f093,
    0x1f0a0, 0x1f0ae,
    0x1f0b1, 0x1f0bf,
    0x1f0c1, 0x1f0cf,
    0x1f0d1, 0x1f0f5,
    0x1f100, 0x1f1ad,
    0x1f1e6, 0x1f202,
    0x1f210, 0x1f23b,
    0x1f240, 0x1f248,
    0x1f250, 0x1f251,
    0x1f260, 0x1f265,
    0x1f300, 0x1f6d7,
    0x1f6dc, 0x1f6ec,
    0x1f6f0, 0x1f6fc,
    0x1f700, 0x1f776,
    0x1f77b, 0x1f7d9,
    0x1f7e0, 0x1f7eb,
    0x1f7f0, 0x1f7f0,
    0x1f800, 0x1f80b,
    0x1f810, 0x1f847,
    0x1f850, 0x1f859,
    0x1f860, 0x1f887,
    0x1f890, 0x1f8ad,
    0x1f8b0, 0x1f8b1,
    0x1f900, 0x1fa53,
    0x1fa60, 0x1fa6d,
    0x1fa70, 0x1fa7c,
    0x1fa80, 0x1fa88,
    0x1fa90, 0x1fabd,
    0x1fabf, 0x1fac5,
    0x1face, 0x1fadb,
    0x1fae0, 0x1fae8,
    0x1faf0, 0x1faf8,
    0x1fb00, 0x1fb92,
    0x1fb94, 0x1fbca,
    0x1fbf0, 0x1fbf9,
    0x20000, 0x2a6df,
    0x2a700, 0x2b739,
    0x2b740, 0x2b81d,
    0x2b820, 0x2cea1,
    0x2ceb0, 0x2ebe0,
    0x2f800, 0x2fa1d,
    0x30000, 0x3134a,
    0x31350, 0x323af,
    0xe0001, 0xe0001,
    0xe0020, 0xe007f,
    0xe0100, 0xe01ef,
];

function utf16CodeUnits(codePoint) {
    return codePoint >= 0x10000 ? 2 : 1;
}
function isHighSurrogate(ch) {
    return ch >= 0xd800 && ch <= 0xdbff;
}
function isLowSurrogate(ch) {
    return ch >= 0xdc00 && ch <= 0xdfff;
}
function isLineBreak(ch) {
    return ch === 10 /* CharCode.LineFeed */ || ch === 13 /* CharCode.CarriageReturn */;
}
function isAsciiWhiteSpaceSingleLine(ch) {
    return (ch === 32 /* CharCode.Space */ ||
        ch === 9 /* CharCode.Tab */ ||
        ch === 11 /* CharCode.VerticalTab */ ||
        ch === 12 /* CharCode.FormFeed */);
}
function isNonAsciiWhiteSpaceSingleLine(ch) {
    return (ch === 133 /* CharCode.NextLine */ || // not considered a line break
        ch === 8206 /* CharCode.LeftToRightMark */ ||
        ch === 8207 /* CharCode.RightToLeftMark */ ||
        ch === 8232 /* CharCode.LineSeparator */ ||
        ch === 8233 /* CharCode.ParagraphSeparator */);
}
function isWhiteSpace(ch) {
    return isWhiteSpaceSingleLine(ch) || isLineBreak(ch);
}
function isWhiteSpaceSingleLine(ch) {
    return (isAsciiWhiteSpaceSingleLine(ch) ||
        (ch > 127 /* CharCode.MaxAscii */ && isNonAsciiWhiteSpaceSingleLine(ch)));
}
function trim(str) {
    let start = 0;
    let end = str.length - 1;
    if (!isWhiteSpace(str.charCodeAt(start)) && !isWhiteSpace(str.charCodeAt(end))) {
        return str;
    }
    while (isWhiteSpace(str.charCodeAt(start))) {
        start++;
    }
    while (isWhiteSpace(str.charCodeAt(end))) {
        end--;
    }
    return str.substring(start, end + 1);
}
function isDigit(ch) {
    return ch >= 48 /* CharCode._0 */ && ch <= 57 /* CharCode._9 */;
}
function isHexDigit(ch) {
    return (isDigit(ch) || (ch >= 65 /* CharCode.A */ && ch <= 70 /* CharCode.F */) || (ch >= 97 /* CharCode.a */ && ch <= 102 /* CharCode.f */));
}
function isBinaryDigit(ch) {
    return ch === 48 /* CharCode._0 */ || ch === 49 /* CharCode._1 */;
}
function isLowercaseAsciiLetter(ch) {
    return ch >= 97 /* CharCode.a */ && ch <= 122 /* CharCode.z */;
}
function isAsciiIdentifierStart(ch) {
    return ((ch >= 65 /* CharCode.A */ && ch <= 90 /* CharCode.Z */) ||
        (ch >= 97 /* CharCode.a */ && ch <= 122 /* CharCode.z */) ||
        ch === 36 /* CharCode.$ */ ||
        ch === 95 /* CharCode._ */);
}
function isAsciiIdentifierContinue(ch) {
    return ((ch >= 65 /* CharCode.A */ && ch <= 90 /* CharCode.Z */) ||
        (ch >= 97 /* CharCode.a */ && ch <= 122 /* CharCode.z */) ||
        (ch >= 48 /* CharCode._0 */ && ch <= 57 /* CharCode._9 */) ||
        ch === 36 /* CharCode.$ */ ||
        ch === 95 /* CharCode._ */);
}
function isIdentifierStart(codePoint) {
    return (isAsciiIdentifierStart(codePoint) ||
        (codePoint > 127 /* CharCode.MaxAscii */ && isNonAsciiIdentifierCharacter(codePoint)));
}
function isIdentifierContinue(codePoint) {
    return (isAsciiIdentifierContinue(codePoint) ||
        (codePoint > 127 /* CharCode.MaxAscii */ && isNonAsciiIdentifierCharacter(codePoint)));
}
function isNonAsciiIdentifierCharacter(codePoint) {
    return lookupInNonAsciiMap(codePoint, nonAsciiIdentifierMap);
}
function codePointBefore(text, pos) {
    if (pos <= 0 || pos >= text.length) {
        return undefined;
    }
    const ch = text.charCodeAt(pos - 1);
    if (!isLowSurrogate(ch) || !isHighSurrogate(text.charCodeAt(pos - 2))) {
        return ch;
    }
    return text.codePointAt(pos - 2);
}
function lookupInNonAsciiMap(codePoint, map) {
    // Perform binary search in one of the Unicode range maps
    let lo = 0;
    let hi = map.length;
    let mid;
    while (lo + 1 < hi) {
        mid = lo + (hi - lo) / 2;
        // mid has to be even to catch a range's beginning
        mid -= mid % 2;
        if (map[mid] <= codePoint && codePoint <= map[mid + 1]) {
            return true;
        }
        if (codePoint < map[mid]) {
            hi = mid;
        }
        else {
            lo = mid + 2;
        }
    }
    return false;
}

// All conflict markers consist of the same character repeated seven times.  If it is
// a <<<<<<< or >>>>>>> marker then it is also followed by a space.
const mergeConflictMarkerLength = 7;
var Token;
(function (Token) {
    Token[Token["None"] = 0] = "None";
    Token[Token["Invalid"] = 1] = "Invalid";
    Token[Token["EndOfFile"] = 2] = "EndOfFile";
    Token[Token["Identifier"] = 3] = "Identifier";
    Token[Token["NumericLiteral"] = 4] = "NumericLiteral";
    Token[Token["StringLiteral"] = 5] = "StringLiteral";
    Token[Token["StringTemplateHead"] = 6] = "StringTemplateHead";
    Token[Token["StringTemplateMiddle"] = 7] = "StringTemplateMiddle";
    Token[Token["StringTemplateTail"] = 8] = "StringTemplateTail";
    // Add new tokens above if they don't fit any of the categories below
    ///////////////////////////////////////////////////////////////
    // Trivia
    /**@internal */ Token[Token["__StartTrivia"] = 9] = "__StartTrivia";
    Token[Token["SingleLineComment"] = 9] = "SingleLineComment";
    Token[Token["MultiLineComment"] = 10] = "MultiLineComment";
    Token[Token["NewLine"] = 11] = "NewLine";
    Token[Token["Whitespace"] = 12] = "Whitespace";
    Token[Token["ConflictMarker"] = 13] = "ConflictMarker";
    // Add new trivia above
    /** @internal */ Token[Token["__EndTrivia"] = 14] = "__EndTrivia";
    ///////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////
    // Doc comment content
    /** @internal */ Token[Token["__StartDocComment"] = 14] = "__StartDocComment";
    Token[Token["DocText"] = 14] = "DocText";
    Token[Token["DocCodeSpan"] = 15] = "DocCodeSpan";
    Token[Token["DocCodeFenceDelimiter"] = 16] = "DocCodeFenceDelimiter";
    /** @internal */ Token[Token["__EndDocComment"] = 17] = "__EndDocComment";
    ///////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////
    // Punctuation
    /** @internal */ Token[Token["__StartPunctuation"] = 17] = "__StartPunctuation";
    Token[Token["OpenBrace"] = 17] = "OpenBrace";
    Token[Token["CloseBrace"] = 18] = "CloseBrace";
    Token[Token["OpenParen"] = 19] = "OpenParen";
    Token[Token["CloseParen"] = 20] = "CloseParen";
    Token[Token["OpenBracket"] = 21] = "OpenBracket";
    Token[Token["CloseBracket"] = 22] = "CloseBracket";
    Token[Token["Dot"] = 23] = "Dot";
    Token[Token["Ellipsis"] = 24] = "Ellipsis";
    Token[Token["Semicolon"] = 25] = "Semicolon";
    Token[Token["Comma"] = 26] = "Comma";
    Token[Token["LessThan"] = 27] = "LessThan";
    Token[Token["GreaterThan"] = 28] = "GreaterThan";
    Token[Token["Equals"] = 29] = "Equals";
    Token[Token["Ampersand"] = 30] = "Ampersand";
    Token[Token["Bar"] = 31] = "Bar";
    Token[Token["Question"] = 32] = "Question";
    Token[Token["Colon"] = 33] = "Colon";
    Token[Token["ColonColon"] = 34] = "ColonColon";
    Token[Token["At"] = 35] = "At";
    Token[Token["AtAt"] = 36] = "AtAt";
    Token[Token["Hash"] = 37] = "Hash";
    Token[Token["Star"] = 38] = "Star";
    Token[Token["ForwardSlash"] = 39] = "ForwardSlash";
    Token[Token["Plus"] = 40] = "Plus";
    Token[Token["Hyphen"] = 41] = "Hyphen";
    Token[Token["Exclamation"] = 42] = "Exclamation";
    Token[Token["LessThanEquals"] = 43] = "LessThanEquals";
    Token[Token["GreaterThanEquals"] = 44] = "GreaterThanEquals";
    Token[Token["AmpsersandAmpersand"] = 45] = "AmpsersandAmpersand";
    Token[Token["BarBar"] = 46] = "BarBar";
    Token[Token["EqualsEquals"] = 47] = "EqualsEquals";
    Token[Token["ExclamationEquals"] = 48] = "ExclamationEquals";
    Token[Token["EqualsGreaterThan"] = 49] = "EqualsGreaterThan";
    // Add new punctuation above
    /** @internal */ Token[Token["__EndPunctuation"] = 50] = "__EndPunctuation";
    ///////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////
    // Statement keywords
    /** @internal */ Token[Token["__StartKeyword"] = 50] = "__StartKeyword";
    /** @internal */ Token[Token["__StartStatementKeyword"] = 50] = "__StartStatementKeyword";
    Token[Token["ImportKeyword"] = 50] = "ImportKeyword";
    Token[Token["ModelKeyword"] = 51] = "ModelKeyword";
    Token[Token["ScalarKeyword"] = 52] = "ScalarKeyword";
    Token[Token["NamespaceKeyword"] = 53] = "NamespaceKeyword";
    Token[Token["UsingKeyword"] = 54] = "UsingKeyword";
    Token[Token["OpKeyword"] = 55] = "OpKeyword";
    Token[Token["EnumKeyword"] = 56] = "EnumKeyword";
    Token[Token["AliasKeyword"] = 57] = "AliasKeyword";
    Token[Token["IsKeyword"] = 58] = "IsKeyword";
    Token[Token["InterfaceKeyword"] = 59] = "InterfaceKeyword";
    Token[Token["UnionKeyword"] = 60] = "UnionKeyword";
    Token[Token["ProjectionKeyword"] = 61] = "ProjectionKeyword";
    Token[Token["ElseKeyword"] = 62] = "ElseKeyword";
    Token[Token["IfKeyword"] = 63] = "IfKeyword";
    Token[Token["DecKeyword"] = 64] = "DecKeyword";
    Token[Token["FnKeyword"] = 65] = "FnKeyword";
    Token[Token["ValueOfKeyword"] = 66] = "ValueOfKeyword";
    // Add new statement keyword above
    /** @internal */ Token[Token["__EndStatementKeyword"] = 67] = "__EndStatementKeyword";
    ///////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////
    /** @internal */ Token[Token["__StartModifierKeyword"] = 67] = "__StartModifierKeyword";
    Token[Token["ExternKeyword"] = 67] = "ExternKeyword";
    /** @internal */ Token[Token["__EndModifierKeyword"] = 68] = "__EndModifierKeyword";
    ///////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////
    // Other keywords
    Token[Token["ExtendsKeyword"] = 68] = "ExtendsKeyword";
    Token[Token["TrueKeyword"] = 69] = "TrueKeyword";
    Token[Token["FalseKeyword"] = 70] = "FalseKeyword";
    Token[Token["ReturnKeyword"] = 71] = "ReturnKeyword";
    Token[Token["VoidKeyword"] = 72] = "VoidKeyword";
    Token[Token["NeverKeyword"] = 73] = "NeverKeyword";
    Token[Token["UnknownKeyword"] = 74] = "UnknownKeyword";
    // Add new non-statement keyword above
    /** @internal */ Token[Token["__EndKeyword"] = 75] = "__EndKeyword";
    ///////////////////////////////////////////////////////////////
    /** @internal */ Token[Token["__Count"] = 75] = "__Count";
})(Token || (Token = {}));
/** @internal */
const TokenDisplay = getTokenDisplayTable([
    [Token.None, "none"],
    [Token.Invalid, "invalid"],
    [Token.EndOfFile, "end of file"],
    [Token.SingleLineComment, "single-line comment"],
    [Token.MultiLineComment, "multi-line comment"],
    [Token.ConflictMarker, "conflict marker"],
    [Token.NumericLiteral, "numeric literal"],
    [Token.StringLiteral, "string literal"],
    [Token.StringTemplateHead, "string template head"],
    [Token.StringTemplateMiddle, "string template middle"],
    [Token.StringTemplateTail, "string template tail"],
    [Token.NewLine, "newline"],
    [Token.Whitespace, "whitespace"],
    [Token.DocCodeFenceDelimiter, "doc code fence delimiter"],
    [Token.DocCodeSpan, "doc code span"],
    [Token.DocText, "doc text"],
    [Token.OpenBrace, "'{'"],
    [Token.CloseBrace, "'}'"],
    [Token.OpenParen, "'('"],
    [Token.CloseParen, "')'"],
    [Token.OpenBracket, "'['"],
    [Token.CloseBracket, "']'"],
    [Token.Dot, "'.'"],
    [Token.Ellipsis, "'...'"],
    [Token.Semicolon, "';'"],
    [Token.Comma, "','"],
    [Token.LessThan, "'<'"],
    [Token.GreaterThan, "'>'"],
    [Token.Equals, "'='"],
    [Token.Ampersand, "'&'"],
    [Token.Bar, "'|'"],
    [Token.Question, "'?'"],
    [Token.Colon, "':'"],
    [Token.ColonColon, "'::'"],
    [Token.At, "'@'"],
    [Token.AtAt, "'@@'"],
    [Token.Hash, "'#'"],
    [Token.Star, "'*'"],
    [Token.ForwardSlash, "'/'"],
    [Token.Plus, "'+'"],
    [Token.Hyphen, "'-'"],
    [Token.Exclamation, "'!'"],
    [Token.LessThanEquals, "'<='"],
    [Token.GreaterThanEquals, "'>='"],
    [Token.AmpsersandAmpersand, "'&&'"],
    [Token.BarBar, "'||'"],
    [Token.EqualsEquals, "'=='"],
    [Token.ExclamationEquals, "'!='"],
    [Token.EqualsGreaterThan, "'=>'"],
    [Token.Identifier, "identifier"],
    [Token.ImportKeyword, "'import'"],
    [Token.ModelKeyword, "'model'"],
    [Token.ScalarKeyword, "'scalar'"],
    [Token.NamespaceKeyword, "'namespace'"],
    [Token.UsingKeyword, "'using'"],
    [Token.OpKeyword, "'op'"],
    [Token.EnumKeyword, "'enum'"],
    [Token.AliasKeyword, "'alias'"],
    [Token.IsKeyword, "'is'"],
    [Token.InterfaceKeyword, "'interface'"],
    [Token.UnionKeyword, "'union'"],
    [Token.ProjectionKeyword, "'projection'"],
    [Token.ElseKeyword, "'else'"],
    [Token.IfKeyword, "'if'"],
    [Token.DecKeyword, "'dec'"],
    [Token.FnKeyword, "'fn'"],
    [Token.ValueOfKeyword, "'valueof'"],
    [Token.ExtendsKeyword, "'extends'"],
    [Token.TrueKeyword, "'true'"],
    [Token.FalseKeyword, "'false'"],
    [Token.ReturnKeyword, "'return'"],
    [Token.VoidKeyword, "'void'"],
    [Token.NeverKeyword, "'never'"],
    [Token.UnknownKeyword, "'unknown'"],
    [Token.ExternKeyword, "'extern'"],
]);
/** @internal */
const Keywords = new Map([
    ["import", Token.ImportKeyword],
    ["model", Token.ModelKeyword],
    ["scalar", Token.ScalarKeyword],
    ["namespace", Token.NamespaceKeyword],
    ["interface", Token.InterfaceKeyword],
    ["union", Token.UnionKeyword],
    ["if", Token.IfKeyword],
    ["else", Token.ElseKeyword],
    ["projection", Token.ProjectionKeyword],
    ["using", Token.UsingKeyword],
    ["op", Token.OpKeyword],
    ["extends", Token.ExtendsKeyword],
    ["is", Token.IsKeyword],
    ["enum", Token.EnumKeyword],
    ["alias", Token.AliasKeyword],
    ["dec", Token.DecKeyword],
    ["fn", Token.FnKeyword],
    ["valueof", Token.ValueOfKeyword],
    ["true", Token.TrueKeyword],
    ["false", Token.FalseKeyword],
    ["return", Token.ReturnKeyword],
    ["void", Token.VoidKeyword],
    ["never", Token.NeverKeyword],
    ["unknown", Token.UnknownKeyword],
    ["extern", Token.ExternKeyword],
]);
var TokenFlags;
(function (TokenFlags) {
    TokenFlags[TokenFlags["None"] = 0] = "None";
    TokenFlags[TokenFlags["Escaped"] = 1] = "Escaped";
    TokenFlags[TokenFlags["TripleQuoted"] = 2] = "TripleQuoted";
    TokenFlags[TokenFlags["Unterminated"] = 4] = "Unterminated";
    TokenFlags[TokenFlags["NonAscii"] = 8] = "NonAscii";
    TokenFlags[TokenFlags["DocComment"] = 16] = "DocComment";
    TokenFlags[TokenFlags["Backticked"] = 32] = "Backticked";
})(TokenFlags || (TokenFlags = {}));
function isTrivia(token) {
    return token >= Token.__StartTrivia && token < Token.__EndTrivia;
}
function isComment(token) {
    return token === Token.SingleLineComment || token === Token.MultiLineComment;
}
function isKeyword(token) {
    return token >= Token.__StartKeyword && token < Token.__EndKeyword;
}
function isPunctuation(token) {
    return token >= Token.__StartPunctuation && token < Token.__EndPunctuation;
}
function isModifier(token) {
    return token >= Token.__StartModifierKeyword && token < Token.__EndModifierKeyword;
}
function isStatementKeyword(token) {
    return token >= Token.__StartStatementKeyword && token < Token.__EndStatementKeyword;
}
function createScanner(source, diagnosticHandler) {
    const file = typeof source === "string" ? createSourceFile(source, "<anonymous file>") : source;
    const input = file.text;
    let position = 0;
    let endPosition = input.length;
    let token = Token.None;
    let tokenPosition = -1;
    let tokenFlags = TokenFlags.None;
    // Skip BOM
    if (position < endPosition && input.charCodeAt(position) === 65279 /* CharCode.ByteOrderMark */) {
        position++;
    }
    return {
        get position() {
            return position;
        },
        get token() {
            return token;
        },
        get tokenPosition() {
            return tokenPosition;
        },
        get tokenFlags() {
            return tokenFlags;
        },
        file,
        scan,
        scanRange,
        scanDoc,
        reScanStringTemplate,
        findTripleQuotedStringIndent,
        unindentAndUnescapeTripleQuotedString,
        eof,
        getTokenText,
        getTokenValue,
    };
    function eof() {
        return position >= endPosition;
    }
    function getTokenText() {
        return input.substring(tokenPosition, position);
    }
    function getTokenValue() {
        switch (token) {
            case Token.StringLiteral:
            case Token.StringTemplateHead:
            case Token.StringTemplateMiddle:
            case Token.StringTemplateTail:
                return getStringTokenValue(token, tokenFlags);
            case Token.Identifier:
                return getIdentifierTokenValue();
            default:
                return getTokenText();
        }
    }
    function lookAhead(offset) {
        const p = position + offset;
        if (p >= endPosition) {
            return Number.NaN;
        }
        return input.charCodeAt(p);
    }
    function scan() {
        tokenPosition = position;
        tokenFlags = TokenFlags.None;
        if (!eof()) {
            const ch = input.charCodeAt(position);
            switch (ch) {
                case 13 /* CharCode.CarriageReturn */:
                    if (lookAhead(1) === 10 /* CharCode.LineFeed */) {
                        position++;
                    }
                // fallthrough
                case 10 /* CharCode.LineFeed */:
                    return next(Token.NewLine);
                case 32 /* CharCode.Space */:
                case 9 /* CharCode.Tab */:
                case 11 /* CharCode.VerticalTab */:
                case 12 /* CharCode.FormFeed */:
                    return scanWhitespace();
                case 40 /* CharCode.OpenParen */:
                    return next(Token.OpenParen);
                case 41 /* CharCode.CloseParen */:
                    return next(Token.CloseParen);
                case 44 /* CharCode.Comma */:
                    return next(Token.Comma);
                case 58 /* CharCode.Colon */:
                    return lookAhead(1) === 58 /* CharCode.Colon */ ? next(Token.ColonColon, 2) : next(Token.Colon);
                case 59 /* CharCode.Semicolon */:
                    return next(Token.Semicolon);
                case 91 /* CharCode.OpenBracket */:
                    return next(Token.OpenBracket);
                case 93 /* CharCode.CloseBracket */:
                    return next(Token.CloseBracket);
                case 123 /* CharCode.OpenBrace */:
                    return next(Token.OpenBrace);
                case 125 /* CharCode.CloseBrace */:
                    return next(Token.CloseBrace);
                case 64 /* CharCode.At */:
                    return lookAhead(1) === 64 /* CharCode.At */ ? next(Token.AtAt, 2) : next(Token.At);
                case 35 /* CharCode.Hash */:
                    return next(Token.Hash);
                case 43 /* CharCode.Plus */:
                    return isDigit(lookAhead(1)) ? scanSignedNumber() : next(Token.Plus);
                case 45 /* CharCode.Minus */:
                    return isDigit(lookAhead(1)) ? scanSignedNumber() : next(Token.Hyphen);
                case 42 /* CharCode.Asterisk */:
                    return next(Token.Star);
                case 63 /* CharCode.Question */:
                    return next(Token.Question);
                case 38 /* CharCode.Ampersand */:
                    return lookAhead(1) === 38 /* CharCode.Ampersand */
                        ? next(Token.AmpsersandAmpersand, 2)
                        : next(Token.Ampersand);
                case 46 /* CharCode.Dot */:
                    return lookAhead(1) === 46 /* CharCode.Dot */ && lookAhead(2) === 46 /* CharCode.Dot */
                        ? next(Token.Ellipsis, 3)
                        : next(Token.Dot);
                case 47 /* CharCode.Slash */:
                    switch (lookAhead(1)) {
                        case 47 /* CharCode.Slash */:
                            return scanSingleLineComment();
                        case 42 /* CharCode.Asterisk */:
                            return scanMultiLineComment();
                    }
                    return next(Token.ForwardSlash);
                case 48 /* CharCode._0 */:
                    switch (lookAhead(1)) {
                        case 120 /* CharCode.x */:
                            return scanHexNumber();
                        case 98 /* CharCode.b */:
                            return scanBinaryNumber();
                    }
                // fallthrough
                case 49 /* CharCode._1 */:
                case 50 /* CharCode._2 */:
                case 51 /* CharCode._3 */:
                case 52 /* CharCode._4 */:
                case 53 /* CharCode._5 */:
                case 54 /* CharCode._6 */:
                case 55 /* CharCode._7 */:
                case 56 /* CharCode._8 */:
                case 57 /* CharCode._9 */:
                    return scanNumber();
                case 60 /* CharCode.LessThan */:
                    if (atConflictMarker())
                        return scanConflictMarker();
                    return lookAhead(1) === 61 /* CharCode.Equals */
                        ? next(Token.LessThanEquals, 2)
                        : next(Token.LessThan);
                case 62 /* CharCode.GreaterThan */:
                    if (atConflictMarker())
                        return scanConflictMarker();
                    return lookAhead(1) === 61 /* CharCode.Equals */
                        ? next(Token.GreaterThanEquals, 2)
                        : next(Token.GreaterThan);
                case 61 /* CharCode.Equals */:
                    if (atConflictMarker())
                        return scanConflictMarker();
                    switch (lookAhead(1)) {
                        case 61 /* CharCode.Equals */:
                            return next(Token.EqualsEquals, 2);
                        case 62 /* CharCode.GreaterThan */:
                            return next(Token.EqualsGreaterThan, 2);
                    }
                    return next(Token.Equals);
                case 124 /* CharCode.Bar */:
                    if (atConflictMarker())
                        return scanConflictMarker();
                    return lookAhead(1) === 124 /* CharCode.Bar */ ? next(Token.BarBar, 2) : next(Token.Bar);
                case 34 /* CharCode.DoubleQuote */:
                    return lookAhead(1) === 34 /* CharCode.DoubleQuote */ && lookAhead(2) === 34 /* CharCode.DoubleQuote */
                        ? scanString(TokenFlags.TripleQuoted)
                        : scanString(TokenFlags.None);
                case 33 /* CharCode.Exclamation */:
                    return lookAhead(1) === 61 /* CharCode.Equals */
                        ? next(Token.ExclamationEquals, 2)
                        : next(Token.Exclamation);
                case 96 /* CharCode.Backtick */:
                    return scanBacktickedIdentifier();
                default:
                    if (isLowercaseAsciiLetter(ch)) {
                        return scanIdentifierOrKeyword();
                    }
                    if (isAsciiIdentifierStart(ch)) {
                        return scanIdentifier();
                    }
                    if (ch <= 127 /* CharCode.MaxAscii */) {
                        return scanInvalidCharacter();
                    }
                    return scanNonAsciiToken();
            }
        }
        return (token = Token.EndOfFile);
    }
    function scanDoc() {
        tokenPosition = position;
        tokenFlags = TokenFlags.None;
        if (!eof()) {
            const ch = input.charCodeAt(position);
            switch (ch) {
                case 13 /* CharCode.CarriageReturn */:
                    if (lookAhead(1) === 10 /* CharCode.LineFeed */) {
                        position++;
                    }
                // fallthrough
                case 10 /* CharCode.LineFeed */:
                    return next(Token.NewLine);
                case 32 /* CharCode.Space */:
                case 9 /* CharCode.Tab */:
                case 11 /* CharCode.VerticalTab */:
                case 12 /* CharCode.FormFeed */:
                    return scanWhitespace();
                case 125 /* CharCode.CloseBrace */:
                    return next(Token.CloseBrace);
                case 64 /* CharCode.At */:
                    return next(Token.At);
                case 42 /* CharCode.Asterisk */:
                    return next(Token.Star);
                case 96 /* CharCode.Backtick */:
                    return lookAhead(1) === 96 /* CharCode.Backtick */ && lookAhead(2) === 96 /* CharCode.Backtick */
                        ? next(Token.DocCodeFenceDelimiter, 3)
                        : scanDocCodeSpan();
                case 60 /* CharCode.LessThan */:
                case 62 /* CharCode.GreaterThan */:
                case 61 /* CharCode.Equals */:
                case 124 /* CharCode.Bar */:
                    if (atConflictMarker())
                        return scanConflictMarker();
                    return next(Token.DocText);
                case 45 /* CharCode.Minus */:
                    return next(Token.Hyphen);
            }
            if (isAsciiIdentifierStart(ch)) {
                return scanIdentifier();
            }
            if (ch <= 127 /* CharCode.MaxAscii */) {
                return next(Token.DocText);
            }
            const cp = input.codePointAt(position);
            if (isIdentifierStart(cp)) {
                return scanNonAsciiIdentifier(cp);
            }
            return scanUnknown(Token.DocText);
        }
        return (token = Token.EndOfFile);
    }
    function reScanStringTemplate(lastTokenFlags) {
        position = tokenPosition;
        tokenFlags = TokenFlags.None;
        return scanStringTemplateSpan(lastTokenFlags);
    }
    function scanRange(range, callback) {
        const savedPosition = position;
        const savedEndPosition = endPosition;
        const savedToken = token;
        const savedTokenPosition = tokenPosition;
        const savedTokenFlags = tokenFlags;
        position = range.pos;
        endPosition = range.end;
        token = Token.None;
        tokenPosition = -1;
        tokenFlags = TokenFlags.None;
        const result = callback();
        position = savedPosition;
        endPosition = savedEndPosition;
        token = savedToken;
        tokenPosition = savedTokenPosition;
        tokenFlags = savedTokenFlags;
        return result;
    }
    function next(t, count = 1) {
        position += count;
        return (token = t);
    }
    function unterminated(t) {
        tokenFlags |= TokenFlags.Unterminated;
        error({ code: "unterminated", format: { token: TokenDisplay[t] } });
        return (token = t);
    }
    function scanNonAsciiToken() {
        tokenFlags |= TokenFlags.NonAscii;
        const ch = input.charCodeAt(position);
        if (isNonAsciiWhiteSpaceSingleLine(ch)) {
            return scanWhitespace();
        }
        const cp = input.codePointAt(position);
        if (isNonAsciiIdentifierCharacter(cp)) {
            return scanNonAsciiIdentifier(cp);
        }
        return scanInvalidCharacter();
    }
    function scanInvalidCharacter() {
        token = scanUnknown(Token.Invalid);
        error({ code: "invalid-character" });
        return token;
    }
    function scanUnknown(t) {
        const codePoint = input.codePointAt(position);
        return (token = next(t, utf16CodeUnits(codePoint)));
    }
    function error(report, pos, end) {
        const diagnostic = createDiagnostic({
            ...report,
            target: { file, pos: pos !== null && pos !== void 0 ? pos : tokenPosition, end: end !== null && end !== void 0 ? end : position },
        });
        diagnosticHandler(diagnostic);
    }
    function scanWhitespace() {
        do {
            position++;
        } while (!eof() && isWhiteSpaceSingleLine(input.charCodeAt(position)));
        return (token = Token.Whitespace);
    }
    function scanSignedNumber() {
        position++; // consume '+/-'
        return scanNumber();
    }
    function scanNumber() {
        scanKnownDigits();
        if (!eof() && input.charCodeAt(position) === 46 /* CharCode.Dot */) {
            position++;
            scanRequiredDigits();
        }
        if (!eof() && input.charCodeAt(position) === 101 /* CharCode.e */) {
            position++;
            const ch = input.charCodeAt(position);
            if (ch === 43 /* CharCode.Plus */ || ch === 45 /* CharCode.Minus */) {
                position++;
            }
            scanRequiredDigits();
        }
        return (token = Token.NumericLiteral);
    }
    function scanKnownDigits() {
        do {
            position++;
        } while (!eof() && isDigit(input.charCodeAt(position)));
    }
    function scanRequiredDigits() {
        if (eof() || !isDigit(input.charCodeAt(position))) {
            error({ code: "digit-expected" });
            return;
        }
        scanKnownDigits();
    }
    function scanHexNumber() {
        position += 2; // consume '0x'
        if (eof() || !isHexDigit(input.charCodeAt(position))) {
            error({ code: "hex-digit-expected" });
            return (token = Token.NumericLiteral);
        }
        do {
            position++;
        } while (!eof() && isHexDigit(input.charCodeAt(position)));
        return (token = Token.NumericLiteral);
    }
    function scanBinaryNumber() {
        position += 2; // consume '0b'
        if (eof() || !isBinaryDigit(input.charCodeAt(position))) {
            error({ code: "binary-digit-expected" });
            return (token = Token.NumericLiteral);
        }
        do {
            position++;
        } while (!eof() && isBinaryDigit(input.charCodeAt(position)));
        return (token = Token.NumericLiteral);
    }
    function scanSingleLineComment() {
        position = skipSingleLineComment(input, position, endPosition);
        return (token = Token.SingleLineComment);
    }
    function scanMultiLineComment() {
        token = Token.MultiLineComment;
        if (lookAhead(2) === 42 /* CharCode.Asterisk */) {
            tokenFlags |= TokenFlags.DocComment;
        }
        const [newPosition, terminated] = skipMultiLineComment(input, position);
        position = newPosition;
        return terminated ? token : unterminated(token);
    }
    function scanDocCodeSpan() {
        position++; // consume '`'
        loop: for (; !eof(); position++) {
            const ch = input.charCodeAt(position);
            switch (ch) {
                case 96 /* CharCode.Backtick */:
                    position++;
                    return (token = Token.DocCodeSpan);
                case 13 /* CharCode.CarriageReturn */:
                case 10 /* CharCode.LineFeed */:
                    break loop;
            }
        }
        return unterminated(Token.DocCodeSpan);
    }
    function scanString(tokenFlags) {
        if (tokenFlags & TokenFlags.TripleQuoted) {
            position += 3; // consume '"""'
        }
        else {
            position++; // consume '"'
        }
        return scanStringLiteralLike(tokenFlags, Token.StringTemplateHead, Token.StringLiteral);
    }
    function scanStringTemplateSpan(tokenFlags) {
        position++; // consume '{'
        return scanStringLiteralLike(tokenFlags, Token.StringTemplateMiddle, Token.StringTemplateTail);
    }
    function scanStringLiteralLike(requestedTokenFlags, template, tail) {
        const multiLine = requestedTokenFlags & TokenFlags.TripleQuoted;
        tokenFlags = requestedTokenFlags;
        loop: for (; !eof(); position++) {
            const ch = input.charCodeAt(position);
            switch (ch) {
                case 92 /* CharCode.Backslash */:
                    tokenFlags |= TokenFlags.Escaped;
                    position++;
                    if (eof()) {
                        break loop;
                    }
                    continue;
                case 34 /* CharCode.DoubleQuote */:
                    if (multiLine) {
                        if (lookAhead(1) === 34 /* CharCode.DoubleQuote */ && lookAhead(2) === 34 /* CharCode.DoubleQuote */) {
                            position += 3;
                            token = tail;
                            return tail;
                        }
                        else {
                            continue;
                        }
                    }
                    else {
                        position++;
                        token = tail;
                        return tail;
                    }
                case 36 /* CharCode.$ */:
                    if (lookAhead(1) === 123 /* CharCode.OpenBrace */) {
                        position += 2;
                        token = template;
                        return template;
                    }
                    continue;
                case 13 /* CharCode.CarriageReturn */:
                case 10 /* CharCode.LineFeed */:
                    if (multiLine) {
                        continue;
                    }
                    else {
                        break loop;
                    }
            }
        }
        return unterminated(tail);
    }
    function getStringLiteralOffsetStart(token, tokenFlags) {
        switch (token) {
            case Token.StringLiteral:
            case Token.StringTemplateHead:
                return tokenFlags & TokenFlags.TripleQuoted ? 3 : 1; // """ or "
            default:
                return 1; // {
        }
    }
    function getStringLiteralOffsetEnd(token, tokenFlags) {
        switch (token) {
            case Token.StringLiteral:
            case Token.StringTemplateTail:
                return tokenFlags & TokenFlags.TripleQuoted ? 3 : 1; // """ or "
            default:
                return 2; // ${
        }
    }
    function getStringTokenValue(token, tokenFlags) {
        if (tokenFlags & TokenFlags.TripleQuoted) {
            const start = tokenPosition;
            const end = position;
            const [indentationStart, indentationEnd] = findTripleQuotedStringIndent(start, end);
            return unindentAndUnescapeTripleQuotedString(start, end, indentationStart, indentationEnd, token, tokenFlags);
        }
        const startOffset = getStringLiteralOffsetStart(token, tokenFlags);
        const endOffset = getStringLiteralOffsetEnd(token, tokenFlags);
        const start = tokenPosition + startOffset;
        const end = tokenFlags & TokenFlags.Unterminated ? position : position - endOffset;
        if (tokenFlags & TokenFlags.Escaped) {
            return unescapeString(start, end);
        }
        return input.substring(start, end);
    }
    function getIdentifierTokenValue() {
        const start = tokenFlags & TokenFlags.Backticked ? tokenPosition + 1 : tokenPosition;
        const end = tokenFlags & TokenFlags.Backticked && !(tokenFlags & TokenFlags.Unterminated)
            ? position - 1
            : position;
        const text = tokenFlags & TokenFlags.Escaped ? unescapeString(start, end) : input.substring(start, end);
        if (tokenFlags & TokenFlags.NonAscii) {
            return text.normalize("NFC");
        }
        return text;
    }
    function findTripleQuotedStringIndent(start, end) {
        end = end - 3; // Remove the """
        // remove whitespace before closing delimiter and record it as required
        // indentation for all lines
        const indentationEnd = end;
        while (end > start && isWhiteSpaceSingleLine(input.charCodeAt(end - 1))) {
            end--;
        }
        const indentationStart = end;
        // remove required final line break
        if (isLineBreak(input.charCodeAt(end - 1))) {
            if (isCrlf(end - 2, 0, end)) {
                end--;
            }
            end--;
        }
        else {
            error({ code: "no-new-line-end-triple-quote" });
        }
        return [indentationStart, indentationEnd];
    }
    function unindentAndUnescapeTripleQuotedString(start, end, indentationStart, indentationEnd, token, tokenFlags) {
        const startOffset = getStringLiteralOffsetStart(token, tokenFlags);
        const endOffset = getStringLiteralOffsetEnd(token, tokenFlags);
        start = start + startOffset;
        end = tokenFlags & TokenFlags.Unterminated ? end : end - endOffset;
        if (token === Token.StringLiteral || token === Token.StringTemplateHead) {
            // ignore leading whitespace before required initial line break
            while (start < end && isWhiteSpaceSingleLine(input.charCodeAt(start))) {
                start++;
            }
            // remove required initial line break
            if (isLineBreak(input.charCodeAt(start))) {
                if (isCrlf(start, start, end)) {
                    start++;
                }
                start++;
            }
            else {
                error({ code: "no-new-line-start-triple-quote" });
            }
        }
        if (token === Token.StringLiteral || token === Token.StringTemplateTail) {
            while (end > start && isWhiteSpaceSingleLine(input.charCodeAt(end - 1))) {
                end--;
            }
            // remove required final line break
            if (isLineBreak(input.charCodeAt(end - 1))) {
                if (isCrlf(end - 2, start, end)) {
                    end--;
                }
                end--;
            }
            else {
                error({ code: "no-new-line-end-triple-quote" });
            }
        }
        let skipUnindentOnce = false;
        // We are resuming from the middle of a line so we want to keep text as it is from there.
        if (token === Token.StringTemplateMiddle || token === Token.StringTemplateTail) {
            skipUnindentOnce = true;
        }
        // remove required matching indentation from each line and unescape in the
        // process of doing so
        let result = "";
        let pos = start;
        while (pos < end) {
            if (skipUnindentOnce) {
                skipUnindentOnce = false;
            }
            else {
                // skip indentation at start of line
                start = skipMatchingIndentation(pos, end, indentationStart, indentationEnd);
            }
            let ch;
            while (pos < end && !isLineBreak((ch = input.charCodeAt(pos)))) {
                if (ch !== 92 /* CharCode.Backslash */) {
                    pos++;
                    continue;
                }
                result += input.substring(start, pos);
                if (pos === end - 1) {
                    error({ code: "invalid-escape-sequence" }, pos, pos);
                    pos++;
                }
                else {
                    result += unescapeOne(pos);
                    pos += 2;
                }
                start = pos;
            }
            if (pos < end) {
                if (isCrlf(pos, start, end)) {
                    // CRLF in multi-line string is normalized to LF in string value.
                    // This keeps program behavior unchanged by line-ending conversion.
                    result += input.substring(start, pos);
                    result += "\n";
                    pos += 2;
                }
                else {
                    pos++; // include non-CRLF newline
                    result += input.substring(start, pos);
                }
                start = pos;
            }
        }
        result += input.substring(start, pos);
        return result;
    }
    function isCrlf(pos, start, end) {
        return (pos >= start &&
            pos < end - 1 &&
            input.charCodeAt(pos) === 13 /* CharCode.CarriageReturn */ &&
            input.charCodeAt(pos + 1) === 10 /* CharCode.LineFeed */);
    }
    function skipMatchingIndentation(pos, end, indentationStart, indentationEnd) {
        let indentationPos = indentationStart;
        end = Math.min(end, pos + (indentationEnd - indentationStart));
        while (pos < end) {
            const ch = input.charCodeAt(pos);
            if (isLineBreak(ch)) {
                // allow subset of indentation if line has only whitespace
                break;
            }
            if (ch !== input.charCodeAt(indentationPos)) {
                error({ code: "triple-quote-indent" });
                break;
            }
            indentationPos++;
            pos++;
        }
        return pos;
    }
    function unescapeString(start, end) {
        let result = "";
        let pos = start;
        while (pos < end) {
            const ch = input.charCodeAt(pos);
            if (ch !== 92 /* CharCode.Backslash */) {
                pos++;
                continue;
            }
            if (pos === end - 1) {
                error({ code: "invalid-escape-sequence" }, pos, pos);
                break;
            }
            result += input.substring(start, pos);
            result += unescapeOne(pos);
            pos += 2;
            start = pos;
        }
        result += input.substring(start, pos);
        return result;
    }
    function unescapeOne(pos) {
        const ch = input.charCodeAt(pos + 1);
        switch (ch) {
            case 114 /* CharCode.r */:
                return "\r";
            case 110 /* CharCode.n */:
                return "\n";
            case 116 /* CharCode.t */:
                return "\t";
            case 34 /* CharCode.DoubleQuote */:
                return '"';
            case 92 /* CharCode.Backslash */:
                return "\\";
            case 36 /* CharCode.$ */:
                return "$";
            case 96 /* CharCode.Backtick */:
                return "`";
            default:
                error({ code: "invalid-escape-sequence" }, pos, pos + 2);
                return String.fromCharCode(ch);
        }
    }
    function scanIdentifierOrKeyword() {
        let count = 0;
        let ch = input.charCodeAt(position);
        while (true) {
            position++;
            count++;
            if (eof()) {
                break;
            }
            ch = input.charCodeAt(position);
            if (count < 10 /* KeywordLimit.MaxLength */ && isLowercaseAsciiLetter(ch)) {
                continue;
            }
            if (isAsciiIdentifierContinue(ch)) {
                return scanIdentifier();
            }
            if (ch > 127 /* CharCode.MaxAscii */) {
                const cp = input.codePointAt(position);
                if (isNonAsciiIdentifierCharacter(cp)) {
                    return scanNonAsciiIdentifier(cp);
                }
            }
            break;
        }
        if (count >= 2 /* KeywordLimit.MinLength */ && count <= 10 /* KeywordLimit.MaxLength */) {
            const keyword = Keywords.get(getTokenText());
            if (keyword) {
                return (token = keyword);
            }
        }
        return (token = Token.Identifier);
    }
    function scanIdentifier() {
        let ch;
        do {
            position++;
            if (eof()) {
                return (token = Token.Identifier);
            }
        } while (isAsciiIdentifierContinue((ch = input.charCodeAt(position))));
        if (ch > 127 /* CharCode.MaxAscii */) {
            const cp = input.codePointAt(position);
            if (isNonAsciiIdentifierCharacter(cp)) {
                return scanNonAsciiIdentifier(cp);
            }
        }
        return (token = Token.Identifier);
    }
    function scanBacktickedIdentifier() {
        position++; // consume '`'
        tokenFlags |= TokenFlags.Backticked;
        loop: for (; !eof(); position++) {
            const ch = input.charCodeAt(position);
            switch (ch) {
                case 92 /* CharCode.Backslash */:
                    position++;
                    tokenFlags |= TokenFlags.Escaped;
                    continue;
                case 96 /* CharCode.Backtick */:
                    position++;
                    return (token = Token.Identifier);
                case 13 /* CharCode.CarriageReturn */:
                case 10 /* CharCode.LineFeed */:
                    break loop;
                default:
                    if (ch > 127 /* CharCode.MaxAscii */) {
                        tokenFlags |= TokenFlags.NonAscii;
                    }
            }
        }
        return unterminated(Token.Identifier);
    }
    function scanNonAsciiIdentifier(startCodePoint) {
        tokenFlags |= TokenFlags.NonAscii;
        let cp = startCodePoint;
        do {
            position += utf16CodeUnits(cp);
        } while (!eof() && isIdentifierContinue((cp = input.codePointAt(position))));
        return (token = Token.Identifier);
    }
    function atConflictMarker() {
        return isConflictMarker(input, position, endPosition);
    }
    function scanConflictMarker() {
        const marker = input.charCodeAt(position);
        position += mergeConflictMarkerLength;
        error({ code: "conflict-marker" });
        if (marker === 60 /* CharCode.LessThan */ || marker === 62 /* CharCode.GreaterThan */) {
            // Consume everything from >>>>>>> or <<<<<<< to the end of the line.
            while (position < endPosition && !isLineBreak(input.charCodeAt(position))) {
                position++;
            }
        }
        else {
            // Consume everything from the start of a ||||||| or =======
            // marker to the start of the next ======= or >>>>>>> marker.
            while (position < endPosition) {
                const ch = input.charCodeAt(position);
                if ((ch === 61 /* CharCode.Equals */ || ch === 62 /* CharCode.GreaterThan */) &&
                    ch !== marker &&
                    isConflictMarker(input, position, endPosition)) {
                    break;
                }
                position++;
            }
        }
        return (token = Token.ConflictMarker);
    }
}
function skipTrivia(input, position, endPosition = input.length) {
    while (position < endPosition) {
        const ch = input.charCodeAt(position);
        if (isWhiteSpace(ch)) {
            position++;
            continue;
        }
        if (ch === 47 /* CharCode.Slash */) {
            switch (input.charCodeAt(position + 1)) {
                case 47 /* CharCode.Slash */:
                    position = skipSingleLineComment(input, position, endPosition);
                    continue;
                case 42 /* CharCode.Asterisk */:
                    position = skipMultiLineComment(input, position, endPosition)[0];
                    continue;
            }
        }
        break;
    }
    return position;
}
function skipWhiteSpace(input, position, endPosition = input.length) {
    while (position < endPosition) {
        const ch = input.charCodeAt(position);
        if (!isWhiteSpace(ch)) {
            break;
        }
        position++;
    }
    return position;
}
function skipSingleLineComment(input, position, endPosition = input.length) {
    position += 2; // consume '//'
    for (; position < endPosition; position++) {
        if (isLineBreak(input.charCodeAt(position))) {
            break;
        }
    }
    return position;
}
function skipMultiLineComment(input, position, endPosition = input.length) {
    position += 2; // consume '/*'
    for (; position < endPosition; position++) {
        if (input.charCodeAt(position) === 42 /* CharCode.Asterisk */ &&
            input.charCodeAt(position + 1) === 47 /* CharCode.Slash */) {
            return [position + 2, true];
        }
    }
    return [position, false];
}
function isConflictMarker(input, position, endPosition = input.length) {
    // Conflict markers must be at the start of a line.
    const ch = input.charCodeAt(position);
    if (position === 0 || isLineBreak(input.charCodeAt(position - 1))) {
        if (position + mergeConflictMarkerLength < endPosition) {
            for (let i = 0; i < mergeConflictMarkerLength; i++) {
                if (input.charCodeAt(position + i) !== ch) {
                    return false;
                }
            }
            return (ch === 61 /* CharCode.Equals */ ||
                input.charCodeAt(position + mergeConflictMarkerLength) === 32 /* CharCode.Space */);
        }
    }
    return false;
}
function getTokenDisplayTable(entries) {
    const table = new Array(entries.length);
    for (const [token, display] of entries) {
        compilerAssert(token >= 0 && token < Token.__Count, `Invalid entry in token display table, ${token}, ${Token[token]}, ${display}`);
        compilerAssert(!table[token], `Duplicate entry in token display table for: ${token}, ${Token[token]}, ${display}`);
        table[token] = display;
    }
    for (let token = 0; token < Token.__Count; token++) {
        compilerAssert(table[token], `Missing entry in token display table: ${token}, ${Token[token]}`);
    }
    return table;
}

var lu=Object.create;var $e=Object.defineProperty;var fu=Object.getOwnPropertyDescriptor;var Fu=Object.getOwnPropertyNames;var pu=Object.getPrototypeOf,du=Object.prototype.hasOwnProperty;var mu=(e,t)=>()=>(e&&(t=e(e=0)),t);var Me=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),We=(e,t)=>{for(var r in t)$e(e,r,{get:t[r],enumerable:!0});},nr=(e,t,r,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let o of Fu(t))!du.call(e,o)&&o!==r&&$e(e,o,{get:()=>t[o],enumerable:!(n=fu(t,o))||n.enumerable});return e};var he=(e,t,r)=>(r=e!=null?lu(pu(e)):{},nr(t||!e||!e.__esModule?$e(r,"default",{value:e,enumerable:!0}):r,e)),Eu=e=>nr($e({},"__esModule",{value:!0}),e);var Cu=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)};var ht=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r);};var ce=(e,t,r)=>(Cu(e,t,"access private method"),r);var or=Me(gt=>{Object.defineProperty(gt,"__esModule",{value:!0});gt.default=ur;function ur(){}ur.prototype={diff:function(t,r){var n=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{},o=n.callback;typeof n=="function"&&(o=n,n={}),this.options=n;var u=this;function i(F){return o?(setTimeout(function(){o(void 0,F);},0),!0):F}t=this.castInput(t),r=this.castInput(r),t=this.removeEmpty(this.tokenize(t)),r=this.removeEmpty(this.tokenize(r));var s=r.length,D=t.length,a=1,c=s+D;n.maxEditLength&&(c=Math.min(c,n.maxEditLength));var d=[{newPos:-1,components:[]}],f=this.extractCommon(d[0],r,t,0);if(d[0].newPos+1>=s&&f+1>=D)return i([{value:this.join(r),count:r.length}]);function p(){for(var F=-1*a;F<=a;F+=2){var m=void 0,E=d[F-1],C=d[F+1],g=(C?C.newPos:0)-F;E&&(d[F-1]=void 0);var h=E&&E.newPos+1<s,B=C&&0<=g&&g<D;if(!h&&!B){d[F]=void 0;continue}if(!h||B&&E.newPos<C.newPos?(m=yu(C),u.pushComponent(m.components,void 0,!0)):(m=E,m.newPos++,u.pushComponent(m.components,!0,void 0)),g=u.extractCommon(m,r,t,F),m.newPos+1>=s&&g+1>=D)return i(gu(u,m.components,r,t,u.useLongestToken));d[F]=m;}a++;}if(o)(function F(){setTimeout(function(){if(a>c)return o();p()||F();},0);})();else for(;a<=c;){var l=p();if(l)return l}},pushComponent:function(t,r,n){var o=t[t.length-1];o&&o.added===r&&o.removed===n?t[t.length-1]={count:o.count+1,added:r,removed:n}:t.push({count:1,added:r,removed:n});},extractCommon:function(t,r,n,o){for(var u=r.length,i=n.length,s=t.newPos,D=s-o,a=0;s+1<u&&D+1<i&&this.equals(r[s+1],n[D+1]);)s++,D++,a++;return a&&t.components.push({count:a}),t.newPos=s,D},equals:function(t,r){return this.options.comparator?this.options.comparator(t,r):t===r||this.options.ignoreCase&&t.toLowerCase()===r.toLowerCase()},removeEmpty:function(t){for(var r=[],n=0;n<t.length;n++)t[n]&&r.push(t[n]);return r},castInput:function(t){return t},tokenize:function(t){return t.split("")},join:function(t){return t.join("")}};function gu(e,t,r,n,o){for(var u=0,i=t.length,s=0,D=0;u<i;u++){var a=t[u];if(a.removed){if(a.value=e.join(n.slice(D,D+a.count)),D+=a.count,u&&t[u-1].added){var d=t[u-1];t[u-1]=t[u],t[u]=d;}}else {if(!a.added&&o){var c=r.slice(s,s+a.count);c=c.map(function(p,l){var F=n[D+l];return F.length>p.length?F:p}),a.value=e.join(c);}else a.value=e.join(r.slice(s,s+a.count));s+=a.count,a.added||(D+=a.count);}}var f=t[i-1];return i>1&&typeof f.value=="string"&&(f.added||f.removed)&&e.equals("",f.value)&&(t[i-2].value+=f.value,t.pop()),t}function yu(e){return {newPos:e.newPos,components:e.components.slice(0)}}});var ir=Me(ye=>{Object.defineProperty(ye,"__esModule",{value:!0});ye.diffArrays=_u;ye.arrayDiff=void 0;var Au=Bu(or());function Bu(e){return e&&e.__esModule?e:{default:e}}var ge=new Au.default;ye.arrayDiff=ge;ge.tokenize=function(e){return e.slice()};ge.join=ge.removeEmpty=function(e){return e};function _u(e,t,r){return ge.diff(e,t,r)}});var Pe=Me((ps,jr)=>{var Yr=new Proxy(String,{get:()=>Yr});jr.exports=Yr;});var Fn={};We(Fn,{default:()=>uo,shouldHighlight:()=>no});var no,uo,pn=mu(()=>{no=()=>!1,uo=String;});var yn=Me(Ft=>{Object.defineProperty(Ft,"__esModule",{value:!0});Ft.codeFrameColumns=gn;Ft.default=ao;var dn=(pn(),Eu(Fn)),mn=oo(Pe(),!0);function hn(e){if(typeof WeakMap!="function")return null;var t=new WeakMap,r=new WeakMap;return (hn=function(n){return n?r:t})(e)}function oo(e,t){if(!t&&e&&e.__esModule)return e;if(e===null||typeof e!="object"&&typeof e!="function")return {default:e};var r=hn(t);if(r&&r.has(e))return r.get(e);var n={__proto__:null},o=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var u in e)if(u!=="default"&&Object.prototype.hasOwnProperty.call(e,u)){var i=o?Object.getOwnPropertyDescriptor(e,u):null;i&&(i.get||i.set)?Object.defineProperty(n,u,i):n[u]=e[u];}return n.default=e,r&&r.set(e,n),n}var jt;function io(e){if(e){return (jt)!=null||(jt=new mn.default.constructor({enabled:!0,level:1})),jt}return mn.default}var En=!1;function so(e){return {gutter:e.grey,marker:e.red.bold,message:e.red.bold}}var Cn=/\r\n|[\n\r\u2028\u2029]/;function Do(e,t,r){let n=Object.assign({column:0,line:-1},e.start),o=Object.assign({},n,e.end),{linesAbove:u=2,linesBelow:i=3}=r||{},s=n.line,D=n.column,a=o.line,c=o.column,d=Math.max(s-(u+1),0),f=Math.min(t.length,a+i);s===-1&&(d=0),a===-1&&(f=t.length);let p=a-s,l={};if(p)for(let F=0;F<=p;F++){let m=F+s;if(!D)l[m]=!0;else if(F===0){let E=t[m-1].length;l[m]=[D,E-D+1];}else if(F===p)l[m]=[0,c];else {let E=t[m-F].length;l[m]=[0,E];}}else D===c?D?l[s]=[D,0]:l[s]=!0:l[s]=[D,c-D];return {start:d,end:f,markerLines:l}}function gn(e,t,r={}){let n=(r.highlightCode||r.forceColor)&&(0, dn.shouldHighlight)(r),o=io(r.forceColor),u=so(o),i=(F,m)=>n?F(m):m,s=e.split(Cn),{start:D,end:a,markerLines:c}=Do(t,s,r),d=t.start&&typeof t.start.column=="number",f=String(a).length,l=(n?(0, dn.default)(e,r):e).split(Cn,a).slice(D,a).map((F,m)=>{let E=D+1+m,g=` ${` ${E}`.slice(-f)} |`,h=c[E],B=!c[E+1];if(h){let Z="";if(Array.isArray(h)){let $=F.slice(0,Math.max(h[0]-1,0)).replace(/[^\t]/g," "),Q=h[1]||1;Z=[`
 `,i(u.gutter,g.replace(/\d/g," "))," ",$,i(u.marker,"^").repeat(Q)].join(""),B&&r.message&&(Z+=" "+i(u.message,r.message));}return [i(u.marker,">"),i(u.gutter,g),F.length>0?` ${F}`:"",Z].join("")}else return ` ${i(u.gutter,g)}${F.length>0?` ${F}`:""}`}).join(`
`);return r.message&&!d&&(l=`${" ".repeat(f+1)}${r.message}
${l}`),n?o.reset(l):l}function ao(e,t,r,n={}){if(!En){En=!0;let u="Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";{let i=new Error(u);i.name="DeprecationWarning",console.warn(new Error(u));}}return r=Math.max(r,0),gn(e,{start:{column:r,line:t}},n)}});var tr={};We(tr,{__debug:()=>ri,check:()=>ei,doc:()=>er,format:()=>cu,formatWithCursor:()=>au,getSupportInfo:()=>ti,util:()=>Qt,version:()=>Du});var hu=(e,t,r,n)=>{if(!(e&&t==null))return t.replaceAll?t.replaceAll(r,n):r.global?t.replace(r,n):t.split(r).join(n)},ee=hu;var Kn=he(ir(),1);var M="string",j="array",W="cursor",T="indent",S="align",v="trim",_="group",k="fill",x="if-break",P="indent-if-break",L="line-suffix",I="line-suffix-boundary",A="line",O="label",b="break-parent",Ue=new Set([W,T,S,v,_,k,x,P,L,I,A,O,b]);function xu(e){if(typeof e=="string")return M;if(Array.isArray(e))return j;if(!e)return;let{type:t}=e;if(Ue.has(t))return t}var U=xu;var ku=e=>new Intl.ListFormat("en-US",{type:"disjunction"}).format(e);function bu(e){let t=e===null?"null":typeof e;if(t!=="string"&&t!=="object")return `Unexpected doc '${t}', 
Expected it to be 'string' or 'object'.`;if(U(e))throw new Error("doc is valid.");let r=Object.prototype.toString.call(e);if(r!=="[object Object]")return `Unexpected doc '${r}'.`;let n=ku([...Ue].map(o=>`'${o}'`));return `Unexpected doc.type '${e.type}'.
Expected it to be ${n}.`}var yt=class extends Error{name="InvalidDocError";constructor(t){super(bu(t)),this.doc=t;}},q=yt;var sr={};function wu(e,t,r,n){let o=[e];for(;o.length>0;){let u=o.pop();if(u===sr){r(o.pop());continue}r&&o.push(u,sr);let i=U(u);if(!i)throw new q(u);if((t==null?void 0:t(u))!==!1)switch(i){case j:case k:{let s=i===j?u:u.parts;for(let D=s.length,a=D-1;a>=0;--a)o.push(s[a]);break}case x:o.push(u.flatContents,u.breakContents);break;case _:if(n&&u.expandedStates)for(let s=u.expandedStates.length,D=s-1;D>=0;--D)o.push(u.expandedStates[D]);else o.push(u.contents);break;case S:case T:case P:case O:case L:o.push(u.contents);break;case M:case W:case v:case I:case A:case b:break;default:throw new q(u)}}}var Ae=wu;var Dr=()=>{},ze=Dr;function ie(e){return {type:T,contents:e}}function oe(e,t){return {type:S,contents:t,n:e}}function At(e,t={}){return ze(t.expandedStates),{type:_,id:t.id,contents:e,break:!!t.shouldBreak,expandedStates:t.expandedStates}}function ar(e){return oe(Number.NEGATIVE_INFINITY,e)}function cr(e){return oe({type:"root"},e)}function lr(e){return oe(-1,e)}function fr(e,t){return At(e[0],{...t,expandedStates:e})}function Ge(e){return {type:k,parts:e}}function Fr(e,t="",r={}){return {type:x,breakContents:e,flatContents:t,groupId:r.groupId}}function pr(e,t){return {type:P,contents:e,groupId:t.groupId,negate:t.negate}}function Be(e){return {type:L,contents:e}}var dr={type:I},le={type:b},mr={type:v},_e={type:A,hard:!0},Bt={type:A,hard:!0,literal:!0},Ke={type:A},Er={type:A,soft:!0},G=[_e,le],He=[Bt,le],xe={type:W};function ke(e,t){let r=[];for(let n=0;n<t.length;n++)n!==0&&r.push(e),r.push(t[n]);return r}function qe(e,t,r){let n=e;if(t>0){for(let o=0;o<Math.floor(t/r);++o)n=ie(n);n=oe(t%r,n),n=oe(Number.NEGATIVE_INFINITY,n);}return n}function Cr(e,t){return e?{type:O,label:e,contents:t}:t}var Ou=(e,t,r)=>{if(!(e&&t==null))return Array.isArray(t)||typeof t=="string"?t[r<0?t.length+r:r]:t.at(r)},y=Ou;function hr(e){let t=e.indexOf("\r");return t>=0?e.charAt(t+1)===`
`?"crlf":"cr":"lf"}function be(e){switch(e){case"cr":return "\r";case"crlf":return `\r
`;default:return `
`}}function _t(e,t){let r;switch(t){case`
`:r=/\n/g;break;case"\r":r=/\r/g;break;case`\r
`:r=/\r\n/g;break;default:throw new Error(`Unexpected "eol" ${JSON.stringify(t)}.`)}let n=e.match(r);return n?n.length:0}function gr(e){return ee(!1,e,/\r\n?/g,`
`)}var yr=()=>/[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;function Ar(e){return e===12288||e>=65281&&e<=65376||e>=65504&&e<=65510}function Br(e){return e>=4352&&e<=4447||e===8986||e===8987||e===9001||e===9002||e>=9193&&e<=9196||e===9200||e===9203||e===9725||e===9726||e===9748||e===9749||e>=9800&&e<=9811||e===9855||e===9875||e===9889||e===9898||e===9899||e===9917||e===9918||e===9924||e===9925||e===9934||e===9940||e===9962||e===9970||e===9971||e===9973||e===9978||e===9981||e===9989||e===9994||e===9995||e===10024||e===10060||e===10062||e>=10067&&e<=10069||e===10071||e>=10133&&e<=10135||e===10160||e===10175||e===11035||e===11036||e===11088||e===11093||e>=11904&&e<=11929||e>=11931&&e<=12019||e>=12032&&e<=12245||e>=12272&&e<=12287||e>=12289&&e<=12350||e>=12353&&e<=12438||e>=12441&&e<=12543||e>=12549&&e<=12591||e>=12593&&e<=12686||e>=12688&&e<=12771||e>=12783&&e<=12830||e>=12832&&e<=12871||e>=12880&&e<=19903||e>=19968&&e<=42124||e>=42128&&e<=42182||e>=43360&&e<=43388||e>=44032&&e<=55203||e>=63744&&e<=64255||e>=65040&&e<=65049||e>=65072&&e<=65106||e>=65108&&e<=65126||e>=65128&&e<=65131||e>=94176&&e<=94180||e===94192||e===94193||e>=94208&&e<=100343||e>=100352&&e<=101589||e>=101632&&e<=101640||e>=110576&&e<=110579||e>=110581&&e<=110587||e===110589||e===110590||e>=110592&&e<=110882||e===110898||e>=110928&&e<=110930||e===110933||e>=110948&&e<=110951||e>=110960&&e<=111355||e===126980||e===127183||e===127374||e>=127377&&e<=127386||e>=127488&&e<=127490||e>=127504&&e<=127547||e>=127552&&e<=127560||e===127568||e===127569||e>=127584&&e<=127589||e>=127744&&e<=127776||e>=127789&&e<=127797||e>=127799&&e<=127868||e>=127870&&e<=127891||e>=127904&&e<=127946||e>=127951&&e<=127955||e>=127968&&e<=127984||e===127988||e>=127992&&e<=128062||e===128064||e>=128066&&e<=128252||e>=128255&&e<=128317||e>=128331&&e<=128334||e>=128336&&e<=128359||e===128378||e===128405||e===128406||e===128420||e>=128507&&e<=128591||e>=128640&&e<=128709||e===128716||e>=128720&&e<=128722||e>=128725&&e<=128727||e>=128732&&e<=128735||e===128747||e===128748||e>=128756&&e<=128764||e>=128992&&e<=129003||e===129008||e>=129292&&e<=129338||e>=129340&&e<=129349||e>=129351&&e<=129535||e>=129648&&e<=129660||e>=129664&&e<=129672||e>=129680&&e<=129725||e>=129727&&e<=129733||e>=129742&&e<=129755||e>=129760&&e<=129768||e>=129776&&e<=129784||e>=131072&&e<=196605||e>=196608&&e<=262141}var _r=e=>!(Ar(e)||Br(e));var Nu=/[^\x20-\x7F]/;function Tu(e){if(!e)return 0;if(!Nu.test(e))return e.length;e=e.replace(yr(),"  ");let t=0;for(let r of e){let n=r.codePointAt(0);n<=31||n>=127&&n<=159||n>=768&&n<=879||(t+=_r(n)?1:2);}return t}var we=Tu;var br=e=>{if(Array.isArray(e))return e;if(e.type!==k)throw new Error(`Expect doc to be 'array' or '${k}'.`);return e.parts};function Ne(e,t){if(typeof e=="string")return t(e);let r=new Map;return n(e);function n(u){if(r.has(u))return r.get(u);let i=o(u);return r.set(u,i),i}function o(u){switch(U(u)){case j:return t(u.map(n));case k:return t({...u,parts:u.parts.map(n)});case x:return t({...u,breakContents:n(u.breakContents),flatContents:n(u.flatContents)});case _:{let{expandedStates:i,contents:s}=u;return i?(i=i.map(n),s=i[0]):s=n(s),t({...u,contents:s,expandedStates:i})}case S:case T:case P:case O:case L:return t({...u,contents:n(u.contents)});case M:case W:case v:case I:case A:case b:return t(u);default:throw new q(u)}}}function Je(e,t,r){let n=r,o=!1;function u(i){if(o)return !1;let s=t(i);s!==void 0&&(o=!0,n=s);}return Ae(e,u),n}function Su(e){if(e.type===_&&e.break||e.type===A&&e.hard||e.type===b)return !0}function wr(e){return Je(e,Su,!1)}function xr(e){if(e.length>0){let t=y(!1,e,-1);!t.expandedStates&&!t.break&&(t.break="propagated");}return null}function Or(e){let t=new Set,r=[];function n(u){if(u.type===b&&xr(r),u.type===_){if(r.push(u),t.has(u))return !1;t.add(u);}}function o(u){u.type===_&&r.pop().break&&xr(r);}Ae(e,n,o,!0);}function vu(e){return e.type===A&&!e.hard?e.soft?"":" ":e.type===x?e.flatContents:e}function Nr(e){return Ne(e,vu)}function kr(e){for(e=[...e];e.length>=2&&y(!1,e,-2).type===A&&y(!1,e,-1).type===b;)e.length-=2;if(e.length>0){let t=Oe(y(!1,e,-1));e[e.length-1]=t;}return e}function Oe(e){switch(U(e)){case S:case T:case P:case _:case L:case O:{let t=Oe(e.contents);return {...e,contents:t}}case x:return {...e,breakContents:Oe(e.breakContents),flatContents:Oe(e.flatContents)};case k:return {...e,parts:kr(e.parts)};case j:return kr(e);case M:return e.replace(/[\n\r]*$/,"");case W:case v:case I:case A:case b:break;default:throw new q(e)}return e}function Xe(e){return Oe(Lu(e))}function Pu(e){switch(U(e)){case k:if(e.parts.every(t=>t===""))return "";break;case _:if(!e.contents&&!e.id&&!e.break&&!e.expandedStates)return "";if(e.contents.type===_&&e.contents.id===e.id&&e.contents.break===e.break&&e.contents.expandedStates===e.expandedStates)return e.contents;break;case S:case T:case P:case L:if(!e.contents)return "";break;case x:if(!e.flatContents&&!e.breakContents)return "";break;case j:{let t=[];for(let r of e){if(!r)continue;let[n,...o]=Array.isArray(r)?r:[r];typeof n=="string"&&typeof y(!1,t,-1)=="string"?t[t.length-1]+=n:t.push(n),t.push(...o);}return t.length===0?"":t.length===1?t[0]:t}case M:case W:case v:case I:case A:case O:case b:break;default:throw new q(e)}return e}function Lu(e){return Ne(e,t=>Pu(t))}function Tr(e,t=He){return Ne(e,r=>typeof r=="string"?ke(t,r.split(`
`)):r)}function Iu(e){if(e.type===A)return !0}function Sr(e){return Je(e,Iu,!1)}function Ze(e,t){return e.type===O?{...e,contents:t(e.contents)}:t(e)}var R=Symbol("MODE_BREAK"),K=Symbol("MODE_FLAT"),Te=Symbol("cursor");function vr(){return {value:"",length:0,queue:[]}}function Ru(e,t){return xt(e,{type:"indent"},t)}function Yu(e,t,r){return t===Number.NEGATIVE_INFINITY?e.root||vr():t<0?xt(e,{type:"dedent"},r):t?t.type==="root"?{...e,root:e}:xt(e,{type:typeof t=="string"?"stringAlign":"numberAlign",n:t},r):e}function xt(e,t,r){let n=t.type==="dedent"?e.queue.slice(0,-1):[...e.queue,t],o="",u=0,i=0,s=0;for(let l of n)switch(l.type){case"indent":c(),r.useTabs?D(1):a(r.tabWidth);break;case"stringAlign":c(),o+=l.n,u+=l.n.length;break;case"numberAlign":i+=1,s+=l.n;break;default:throw new Error(`Unexpected type '${l.type}'`)}return f(),{...e,value:o,length:u,queue:n};function D(l){o+="	".repeat(l),u+=r.tabWidth*l;}function a(l){o+=" ".repeat(l),u+=l;}function c(){r.useTabs?d():f();}function d(){i>0&&D(i),p();}function f(){s>0&&a(s),p();}function p(){i=0,s=0;}}function kt(e){let t=0,r=0,n=e.length;e:for(;n--;){let o=e[n];if(o===Te){r++;continue}for(let u=o.length-1;u>=0;u--){let i=o[u];if(i===" "||i==="	")t++;else {e[n]=o.slice(0,u+1);break e}}}if(t>0||r>0)for(e.length=n+1;r-- >0;)e.push(Te);return t}function Qe(e,t,r,n,o,u){if(r===Number.POSITIVE_INFINITY)return !0;let i=t.length,s=[e],D=[];for(;r>=0;){if(s.length===0){if(i===0)return !0;s.push(t[--i]);continue}let{mode:a,doc:c}=s.pop();switch(U(c)){case M:D.push(c),r-=we(c);break;case j:case k:{let d=br(c);for(let f=d.length-1;f>=0;f--)s.push({mode:a,doc:d[f]});break}case T:case S:case P:case O:s.push({mode:a,doc:c.contents});break;case v:r+=kt(D);break;case _:{if(u&&c.break)return !1;let d=c.break?R:a,f=c.expandedStates&&d===R?y(!1,c.expandedStates,-1):c.contents;s.push({mode:d,doc:f});break}case x:{let f=(c.groupId?o[c.groupId]||K:a)===R?c.breakContents:c.flatContents;f&&s.push({mode:a,doc:f});break}case A:if(a===R||c.hard)return !0;c.soft||(D.push(" "),r--);break;case L:n=!0;break;case I:if(n)return !1;break}}return !1}function fe(e,t){let r={},n=t.printWidth,o=be(t.endOfLine),u=0,i=[{ind:vr(),mode:R,doc:e}],s=[],D=!1,a=[],c=0;for(Or(e);i.length>0;){let{ind:f,mode:p,doc:l}=i.pop();switch(U(l)){case M:{let F=o!==`
`?ee(!1,l,`
`,o):l;s.push(F),i.length>0&&(u+=we(F));break}case j:for(let F=l.length-1;F>=0;F--)i.push({ind:f,mode:p,doc:l[F]});break;case W:if(c>=2)throw new Error("There are too many 'cursor' in doc.");s.push(Te),c++;break;case T:i.push({ind:Ru(f,t),mode:p,doc:l.contents});break;case S:i.push({ind:Yu(f,l.n,t),mode:p,doc:l.contents});break;case v:u-=kt(s);break;case _:switch(p){case K:if(!D){i.push({ind:f,mode:l.break?R:K,doc:l.contents});break}case R:{D=!1;let F={ind:f,mode:K,doc:l.contents},m=n-u,E=a.length>0;if(!l.break&&Qe(F,i,m,E,r))i.push(F);else if(l.expandedStates){let C=y(!1,l.expandedStates,-1);if(l.break){i.push({ind:f,mode:R,doc:C});break}else for(let g=1;g<l.expandedStates.length+1;g++)if(g>=l.expandedStates.length){i.push({ind:f,mode:R,doc:C});break}else {let h=l.expandedStates[g],B={ind:f,mode:K,doc:h};if(Qe(B,i,m,E,r)){i.push(B);break}}}else i.push({ind:f,mode:R,doc:l.contents});break}}l.id&&(r[l.id]=y(!1,i,-1).mode);break;case k:{let F=n-u,{parts:m}=l;if(m.length===0)break;let[E,C]=m,g={ind:f,mode:K,doc:E},h={ind:f,mode:R,doc:E},B=Qe(g,[],F,a.length>0,r,!0);if(m.length===1){B?i.push(g):i.push(h);break}let Z={ind:f,mode:K,doc:C},$={ind:f,mode:R,doc:C};if(m.length===2){B?i.push(Z,g):i.push($,h);break}m.splice(0,2);let Q={ind:f,mode:p,doc:Ge(m)},rr=m[0];Qe({ind:f,mode:K,doc:[E,C,rr]},[],F,a.length>0,r,!0)?i.push(Q,Z,g):B?i.push(Q,$,g):i.push(Q,$,h);break}case x:case P:{let F=l.groupId?r[l.groupId]:p;if(F===R){let m=l.type===x?l.breakContents:l.negate?l.contents:ie(l.contents);m&&i.push({ind:f,mode:p,doc:m});}if(F===K){let m=l.type===x?l.flatContents:l.negate?ie(l.contents):l.contents;m&&i.push({ind:f,mode:p,doc:m});}break}case L:a.push({ind:f,mode:p,doc:l.contents});break;case I:a.length>0&&i.push({ind:f,mode:p,doc:_e});break;case A:switch(p){case K:if(l.hard)D=!0;else {l.soft||(s.push(" "),u+=1);break}case R:if(a.length>0){i.push({ind:f,mode:p,doc:l},...a.reverse()),a.length=0;break}l.literal?f.root?(s.push(o,f.root.value),u=f.root.length):(s.push(o),u=0):(u-=kt(s),s.push(o+f.value),u=f.length);break}break;case O:i.push({ind:f,mode:p,doc:l.contents});break;case b:break;default:throw new q(l)}i.length===0&&a.length>0&&(i.push(...a.reverse()),a.length=0);}let d=s.indexOf(Te);if(d!==-1){let f=s.indexOf(Te,d+1),p=s.slice(0,d).join(""),l=s.slice(d+1,f).join(""),F=s.slice(f+1).join("");return {formatted:p+l+F,cursorNodeStart:p.length,cursorNodeText:l}}return {formatted:s.join("")}}function J(e){var t;if(!e)return "";if(Array.isArray(e)){let r=[];for(let n of e)if(Array.isArray(n))r.push(...J(n));else {let o=J(n);o!==""&&r.push(o);}return r}return e.type===x?{...e,breakContents:J(e.breakContents),flatContents:J(e.flatContents)}:e.type===_?{...e,contents:J(e.contents),expandedStates:(t=e.expandedStates)==null?void 0:t.map(J)}:e.type===k?{type:"fill",parts:e.parts.map(J)}:e.contents?{...e,contents:J(e.contents)}:e}function Pr(e){let t=Object.create(null),r=new Set;return n(J(e));function n(u,i,s){var D,a;if(typeof u=="string")return JSON.stringify(u);if(Array.isArray(u)){let c=u.map(n).filter(Boolean);return c.length===1?c[0]:`[${c.join(", ")}]`}if(u.type===A){let c=((D=s==null?void 0:s[i+1])==null?void 0:D.type)===b;return u.literal?c?"literalline":"literallineWithoutBreakParent":u.hard?c?"hardline":"hardlineWithoutBreakParent":u.soft?"softline":"line"}if(u.type===b)return ((a=s==null?void 0:s[i-1])==null?void 0:a.type)===A&&s[i-1].hard?void 0:"breakParent";if(u.type===v)return "trim";if(u.type===T)return "indent("+n(u.contents)+")";if(u.type===S)return u.n===Number.NEGATIVE_INFINITY?"dedentToRoot("+n(u.contents)+")":u.n<0?"dedent("+n(u.contents)+")":u.n.type==="root"?"markAsRoot("+n(u.contents)+")":"align("+JSON.stringify(u.n)+", "+n(u.contents)+")";if(u.type===x)return "ifBreak("+n(u.breakContents)+(u.flatContents?", "+n(u.flatContents):"")+(u.groupId?(u.flatContents?"":', ""')+`, { groupId: ${o(u.groupId)} }`:"")+")";if(u.type===P){let c=[];u.negate&&c.push("negate: true"),u.groupId&&c.push(`groupId: ${o(u.groupId)}`);let d=c.length>0?`, { ${c.join(", ")} }`:"";return `indentIfBreak(${n(u.contents)}${d})`}if(u.type===_){let c=[];u.break&&u.break!=="propagated"&&c.push("shouldBreak: true"),u.id&&c.push(`id: ${o(u.id)}`);let d=c.length>0?`, { ${c.join(", ")} }`:"";return u.expandedStates?`conditionalGroup([${u.expandedStates.map(f=>n(f)).join(",")}]${d})`:`group(${n(u.contents)}${d})`}if(u.type===k)return `fill([${u.parts.map(c=>n(c)).join(", ")}])`;if(u.type===L)return "lineSuffix("+n(u.contents)+")";if(u.type===I)return "lineSuffixBoundary";if(u.type===O)return `label(${JSON.stringify(u.label)}, ${n(u.contents)})`;throw new Error("Unknown doc type "+u.type)}function o(u){if(typeof u!="symbol")return JSON.stringify(String(u));if(u in t)return t[u];let i=u.description||"symbol";for(let s=0;;s++){let D=i+(s>0?` #${s}`:"");if(!r.has(D))return r.add(D),t[u]=`Symbol.for(${JSON.stringify(D)})`}}}function ju(e,t,r=0){let n=0;for(let o=r;o<e.length;++o)e[o]==="	"?n=n+t-n%t:n++;return n}var Fe=ju;var Se=class extends Error{name="ConfigError"},ve=class extends Error{name="UndefinedParserError"};var Lr={cursorOffset:{category:"Special",type:"int",default:-1,range:{start:-1,end:1/0,step:1},description:"Print (to stderr) where a cursor at the given position would move to after formatting.",cliCategory:"Editor"},endOfLine:{category:"Global",type:"choice",default:"lf",description:"Which end of line characters to apply.",choices:[{value:"lf",description:"Line Feed only (\\n), common on Linux and macOS as well as inside git repos"},{value:"crlf",description:"Carriage Return + Line Feed characters (\\r\\n), common on Windows"},{value:"cr",description:"Carriage Return character only (\\r), used very rarely"},{value:"auto",description:`Maintain existing
(mixed values within one file are normalised by looking at what's used after the first line)`}]},filepath:{category:"Special",type:"path",description:"Specify the input filepath. This will be used to do parser inference.",cliName:"stdin-filepath",cliCategory:"Other",cliDescription:"Path to the file to pretend that stdin comes from."},insertPragma:{category:"Special",type:"boolean",default:!1,description:"Insert @format pragma into file's first docblock comment.",cliCategory:"Other"},parser:{category:"Global",type:"choice",default:void 0,description:"Which parser to use.",exception:e=>typeof e=="string"||typeof e=="function",choices:[{value:"flow",description:"Flow"},{value:"babel",description:"JavaScript"},{value:"babel-flow",description:"Flow"},{value:"babel-ts",description:"TypeScript"},{value:"typescript",description:"TypeScript"},{value:"acorn",description:"JavaScript"},{value:"espree",description:"JavaScript"},{value:"meriyah",description:"JavaScript"},{value:"css",description:"CSS"},{value:"less",description:"Less"},{value:"scss",description:"SCSS"},{value:"json",description:"JSON"},{value:"json5",description:"JSON5"},{value:"json-stringify",description:"JSON.stringify"},{value:"graphql",description:"GraphQL"},{value:"markdown",description:"Markdown"},{value:"mdx",description:"MDX"},{value:"vue",description:"Vue"},{value:"yaml",description:"YAML"},{value:"glimmer",description:"Ember / Handlebars"},{value:"html",description:"HTML"},{value:"angular",description:"Angular"},{value:"lwc",description:"Lightning Web Components"}]},plugins:{type:"path",array:!0,default:[{value:[]}],category:"Global",description:"Add a plugin. Multiple plugins can be passed as separate `--plugin`s.",exception:e=>typeof e=="string"||typeof e=="object",cliName:"plugin",cliCategory:"Config"},printWidth:{category:"Global",type:"int",default:80,description:"The line length where Prettier will try wrap.",range:{start:0,end:1/0,step:1}},rangeEnd:{category:"Special",type:"int",default:1/0,range:{start:0,end:1/0,step:1},description:`Format code ending at a given character offset (exclusive).
The range will extend forwards to the end of the selected statement.`,cliCategory:"Editor"},rangeStart:{category:"Special",type:"int",default:0,range:{start:0,end:1/0,step:1},description:`Format code starting at a given character offset.
The range will extend backwards to the start of the first line containing the selected statement.`,cliCategory:"Editor"},requirePragma:{category:"Special",type:"boolean",default:!1,description:`Require either '@prettier' or '@format' to be present in the file's first docblock comment
in order for it to be formatted.`,cliCategory:"Other"},tabWidth:{type:"int",category:"Global",default:2,description:"Number of spaces per indentation level.",range:{start:0,end:1/0,step:1}},useTabs:{category:"Global",type:"boolean",default:!1,description:"Indent with tabs instead of spaces."},embeddedLanguageFormatting:{category:"Global",type:"choice",default:"auto",description:"Control how Prettier formats quoted code embedded in the file.",choices:[{value:"auto",description:"Format embedded code if Prettier can automatically identify it."},{value:"off",description:"Never automatically format embedded code."}]}};function et({plugins:e=[],showDeprecated:t=!1}={}){let r=e.flatMap(o=>o.languages??[]),n=[];for(let o of $u(Object.assign({},...e.map(({options:u})=>u),Lr)))!t&&o.deprecated||(Array.isArray(o.choices)&&(t||(o.choices=o.choices.filter(u=>!u.deprecated)),o.name==="parser"&&(o.choices=[...o.choices,...Vu(o.choices,r,e)])),o.pluginDefaults=Object.fromEntries(e.filter(u=>{var i;return ((i=u.defaultOptions)==null?void 0:i[o.name])!==void 0}).map(u=>[u.name,u.defaultOptions[o.name]])),n.push(o));return {languages:r,options:n}}function*Vu(e,t,r){let n=new Set(e.map(o=>o.value));for(let o of t)if(o.parsers){for(let u of o.parsers)if(!n.has(u)){n.add(u);let i=r.find(D=>D.parsers&&Object.prototype.hasOwnProperty.call(D.parsers,u)),s=o.name;i!=null&&i.name&&(s+=` (plugin: ${i.name})`),yield {value:u,description:s};}}}function $u(e){let t=[];for(let[r,n]of Object.entries(e)){let o={name:r,...n};Array.isArray(o.default)&&(o.default=y(!1,o.default,-1).value),t.push(o);}return t}var Mu=e=>String(e).split(/[/\\]/).pop();function Ir(e,t){if(!t)return;let r=Mu(t).toLowerCase();return e.find(n=>{var o,u;return ((o=n.extensions)==null?void 0:o.some(i=>r.endsWith(i)))||((u=n.filenames)==null?void 0:u.some(i=>i.toLowerCase()===r))})}function Wu(e,t){if(t)return e.find(({name:r})=>r.toLowerCase()===t)??e.find(({aliases:r})=>r==null?void 0:r.includes(t))??e.find(({extensions:r})=>r==null?void 0:r.includes(`.${t}`))}function Uu(e,t){let r=e.plugins.flatMap(o=>o.languages??[]),n=Wu(r,t.language)??Ir(r,t.physicalFile)??Ir(r,t.file)??(t.physicalFile,void 0);return n==null?void 0:n.parsers[0]}var Rr=Uu;var te={key:e=>/^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(e)?e:JSON.stringify(e),value(e){if(e===null||typeof e!="object")return JSON.stringify(e);if(Array.isArray(e))return `[${e.map(r=>te.value(r)).join(", ")}]`;let t=Object.keys(e);return t.length===0?"{}":`{ ${t.map(r=>`${te.key(r)}: ${te.value(e[r])}`).join(", ")} }`},pair:({key:e,value:t})=>te.value({[e]:t})};var bt=he(Pe(),1),Vr=(e,t,{descriptor:r})=>{let n=[`${bt.default.yellow(typeof e=="string"?r.key(e):r.pair(e))} is deprecated`];return t&&n.push(`we now treat it as ${bt.default.blue(typeof t=="string"?r.key(t):r.pair(t))}`),n.join("; ")+"."};var se=he(Pe(),1);var tt=Symbol.for("vnopts.VALUE_NOT_EXIST"),pe=Symbol.for("vnopts.VALUE_UNCHANGED");var $r=" ".repeat(2),Wr=(e,t,r)=>{let{text:n,list:o}=r.normalizeExpectedResult(r.schemas[e].expected(r)),u=[];return n&&u.push(Mr(e,t,n,r.descriptor)),o&&u.push([Mr(e,t,o.title,r.descriptor)].concat(o.values.map(i=>Ur(i,r.loggerPrintWidth))).join(`
`)),zr(u,r.loggerPrintWidth)};function Mr(e,t,r,n){return [`Invalid ${se.default.red(n.key(e))} value.`,`Expected ${se.default.blue(r)},`,`but received ${t===tt?se.default.gray("nothing"):se.default.red(n.value(t))}.`].join(" ")}function Ur({text:e,list:t},r){let n=[];return e&&n.push(`- ${se.default.blue(e)}`),t&&n.push([`- ${se.default.blue(t.title)}:`].concat(t.values.map(o=>Ur(o,r-$r.length).replace(/^|\n/g,`$&${$r}`))).join(`
`)),zr(n,r)}function zr(e,t){if(e.length===1)return e[0];let[r,n]=e,[o,u]=e.map(i=>i.split(`
`,1)[0].length);return o>t&&o>u?n:r}var Nt=he(Pe(),1);var wt=[],Gr=[];function Ot(e,t){if(e===t)return 0;let r=e;e.length>t.length&&(e=t,t=r);let n=e.length,o=t.length;for(;n>0&&e.charCodeAt(~-n)===t.charCodeAt(~-o);)n--,o--;let u=0;for(;u<n&&e.charCodeAt(u)===t.charCodeAt(u);)u++;if(n-=u,o-=u,n===0)return o;let i,s,D,a,c=0,d=0;for(;c<n;)Gr[c]=e.charCodeAt(u+c),wt[c]=++c;for(;d<o;)for(i=t.charCodeAt(u+d),D=d++,s=d,c=0;c<n;c++)a=i===Gr[c]?D:D+1,D=wt[c],s=wt[c]=D>s?a>s?s+1:a:a>D?D+1:a;return s}var rt=(e,t,{descriptor:r,logger:n,schemas:o})=>{let u=[`Ignored unknown option ${Nt.default.yellow(r.pair({key:e,value:t}))}.`],i=Object.keys(o).sort().find(s=>Ot(e,s)<3);i&&u.push(`Did you mean ${Nt.default.blue(r.key(i))}?`),n.warn(u.join(" "));};var zu=["default","expected","validate","deprecated","forward","redirect","overlap","preprocess","postprocess"];function Gu(e,t){let r=new e(t),n=Object.create(r);for(let o of zu)o in t&&(n[o]=Ku(t[o],r,w.prototype[o].length));return n}var w=class{static create(t){return Gu(this,t)}constructor(t){this.name=t.name;}default(t){}expected(t){return "nothing"}validate(t,r){return !1}deprecated(t,r){return !1}forward(t,r){}redirect(t,r){}overlap(t,r,n){return t}preprocess(t,r){return t}postprocess(t,r){return pe}};function Ku(e,t,r){return typeof e=="function"?(...n)=>e(...n.slice(0,r-1),t,...n.slice(r-1)):()=>e}var nt=class extends w{constructor(t){super(t),this._sourceName=t.sourceName;}expected(t){return t.schemas[this._sourceName].expected(t)}validate(t,r){return r.schemas[this._sourceName].validate(t,r)}redirect(t,r){return this._sourceName}};var ut=class extends w{expected(){return "anything"}validate(){return !0}};var ot=class extends w{constructor({valueSchema:t,name:r=t.name,...n}){super({...n,name:r}),this._valueSchema=t;}expected(t){let{text:r,list:n}=t.normalizeExpectedResult(this._valueSchema.expected(t));return {text:r&&`an array of ${r}`,list:n&&{title:"an array of the following values",values:[{list:n}]}}}validate(t,r){if(!Array.isArray(t))return !1;let n=[];for(let o of t){let u=r.normalizeValidateResult(this._valueSchema.validate(o,r),o);u!==!0&&n.push(u.value);}return n.length===0?!0:{value:n}}deprecated(t,r){let n=[];for(let o of t){let u=r.normalizeDeprecatedResult(this._valueSchema.deprecated(o,r),o);u!==!1&&n.push(...u.map(({value:i})=>({value:[i]})));}return n}forward(t,r){let n=[];for(let o of t){let u=r.normalizeForwardResult(this._valueSchema.forward(o,r),o);n.push(...u.map(Kr));}return n}redirect(t,r){let n=[],o=[];for(let u of t){let i=r.normalizeRedirectResult(this._valueSchema.redirect(u,r),u);"remain"in i&&n.push(i.remain),o.push(...i.redirect.map(Kr));}return n.length===0?{redirect:o}:{redirect:o,remain:n}}overlap(t,r){return t.concat(r)}};function Kr({from:e,to:t}){return {from:[e],to:t}}var it=class extends w{expected(){return "true or false"}validate(t){return typeof t=="boolean"}};function qr(e,t){let r=Object.create(null);for(let n of e){let o=n[t];if(r[o])throw new Error(`Duplicate ${t} ${JSON.stringify(o)}`);r[o]=n;}return r}function Jr(e,t){let r=new Map;for(let n of e){let o=n[t];if(r.has(o))throw new Error(`Duplicate ${t} ${JSON.stringify(o)}`);r.set(o,n);}return r}function Xr(){let e=Object.create(null);return t=>{let r=JSON.stringify(t);return e[r]?!0:(e[r]=!0,!1)}}function Zr(e,t){let r=[],n=[];for(let o of e)t(o)?r.push(o):n.push(o);return [r,n]}function Qr(e){return e===Math.floor(e)}function en(e,t){if(e===t)return 0;let r=typeof e,n=typeof t,o=["undefined","object","boolean","number","string"];return r!==n?o.indexOf(r)-o.indexOf(n):r!=="string"?Number(e)-Number(t):e.localeCompare(t)}function tn(e){return (...t)=>{let r=e(...t);return typeof r=="string"?new Error(r):r}}function Tt(e){return e===void 0?{}:e}function St(e){if(typeof e=="string")return {text:e};let{text:t,list:r}=e;return Hu((t||r)!==void 0,"Unexpected `expected` result, there should be at least one field."),r?{text:t,list:{title:r.title,values:r.values.map(St)}}:{text:t}}function vt(e,t){return e===!0?!0:e===!1?{value:t}:e}function Pt(e,t,r=!1){return e===!1?!1:e===!0?r?!0:[{value:t}]:"value"in e?[e]:e.length===0?!1:e}function Hr(e,t){return typeof e=="string"||"key"in e?{from:t,to:e}:"from"in e?{from:e.from,to:e.to}:{from:t,to:e.to}}function st(e,t){return e===void 0?[]:Array.isArray(e)?e.map(r=>Hr(r,t)):[Hr(e,t)]}function Lt(e,t){let r=st(typeof e=="object"&&"redirect"in e?e.redirect:e,t);return r.length===0?{remain:t,redirect:r}:typeof e=="object"&&"remain"in e?{remain:e.remain,redirect:r}:{redirect:r}}function Hu(e,t){if(!e)throw new Error(t)}var Dt=class extends w{constructor(t){super(t),this._choices=Jr(t.choices.map(r=>r&&typeof r=="object"?r:{value:r}),"value");}expected({descriptor:t}){let r=Array.from(this._choices.keys()).map(i=>this._choices.get(i)).filter(({hidden:i})=>!i).map(i=>i.value).sort(en).map(t.value),n=r.slice(0,-2),o=r.slice(-2);return {text:n.concat(o.join(" or ")).join(", "),list:{title:"one of the following values",values:r}}}validate(t){return this._choices.has(t)}deprecated(t){let r=this._choices.get(t);return r&&r.deprecated?{value:t}:!1}forward(t){let r=this._choices.get(t);return r?r.forward:void 0}redirect(t){let r=this._choices.get(t);return r?r.redirect:void 0}};var at=class extends w{expected(){return "a number"}validate(t,r){return typeof t=="number"}};var ct=class extends at{expected(){return "an integer"}validate(t,r){return r.normalizeValidateResult(super.validate(t,r),t)===!0&&Qr(t)}};var Le=class extends w{expected(){return "a string"}validate(t){return typeof t=="string"}};var rn=te,nn=rt,un=Wr,on=Vr;var lt=class{constructor(t,r){let{logger:n=console,loggerPrintWidth:o=80,descriptor:u=rn,unknown:i=nn,invalid:s=un,deprecated:D=on,missing:a=()=>!1,required:c=()=>!1,preprocess:d=p=>p,postprocess:f=()=>pe}=r||{};this._utils={descriptor:u,logger:n||{warn:()=>{}},loggerPrintWidth:o,schemas:qr(t,"name"),normalizeDefaultResult:Tt,normalizeExpectedResult:St,normalizeDeprecatedResult:Pt,normalizeForwardResult:st,normalizeRedirectResult:Lt,normalizeValidateResult:vt},this._unknownHandler=i,this._invalidHandler=tn(s),this._deprecatedHandler=D,this._identifyMissing=(p,l)=>!(p in l)||a(p,l),this._identifyRequired=c,this._preprocess=d,this._postprocess=f,this.cleanHistory();}cleanHistory(){this._hasDeprecationWarned=Xr();}normalize(t){let r={},o=[this._preprocess(t,this._utils)],u=()=>{for(;o.length!==0;){let i=o.shift(),s=this._applyNormalization(i,r);o.push(...s);}};u();for(let i of Object.keys(this._utils.schemas)){let s=this._utils.schemas[i];if(!(i in r)){let D=Tt(s.default(this._utils));"value"in D&&o.push({[i]:D.value});}}u();for(let i of Object.keys(this._utils.schemas)){if(!(i in r))continue;let s=this._utils.schemas[i],D=r[i],a=s.postprocess(D,this._utils);a!==pe&&(this._applyValidation(a,i,s),r[i]=a);}return this._applyPostprocess(r),this._applyRequiredCheck(r),r}_applyNormalization(t,r){let n=[],{knownKeys:o,unknownKeys:u}=this._partitionOptionKeys(t);for(let i of o){let s=this._utils.schemas[i],D=s.preprocess(t[i],this._utils);this._applyValidation(D,i,s);let a=({from:p,to:l})=>{n.push(typeof l=="string"?{[l]:p}:{[l.key]:l.value});},c=({value:p,redirectTo:l})=>{let F=Pt(s.deprecated(p,this._utils),D,!0);if(F!==!1)if(F===!0)this._hasDeprecationWarned(i)||this._utils.logger.warn(this._deprecatedHandler(i,l,this._utils));else for(let{value:m}of F){let E={key:i,value:m};if(!this._hasDeprecationWarned(E)){let C=typeof l=="string"?{key:l,value:m}:l;this._utils.logger.warn(this._deprecatedHandler(E,C,this._utils));}}};st(s.forward(D,this._utils),D).forEach(a);let f=Lt(s.redirect(D,this._utils),D);if(f.redirect.forEach(a),"remain"in f){let p=f.remain;r[i]=i in r?s.overlap(r[i],p,this._utils):p,c({value:p});}for(let{from:p,to:l}of f.redirect)c({value:p,redirectTo:l});}for(let i of u){let s=t[i];this._applyUnknownHandler(i,s,r,(D,a)=>{n.push({[D]:a});});}return n}_applyRequiredCheck(t){for(let r of Object.keys(this._utils.schemas))if(this._identifyMissing(r,t)&&this._identifyRequired(r))throw this._invalidHandler(r,tt,this._utils)}_partitionOptionKeys(t){let[r,n]=Zr(Object.keys(t).filter(o=>!this._identifyMissing(o,t)),o=>o in this._utils.schemas);return {knownKeys:r,unknownKeys:n}}_applyValidation(t,r,n){let o=vt(n.validate(t,this._utils),t);if(o!==!0)throw this._invalidHandler(r,o.value,this._utils)}_applyUnknownHandler(t,r,n,o){let u=this._unknownHandler(t,r,this._utils);if(u)for(let i of Object.keys(u)){if(this._identifyMissing(i,u))continue;let s=u[i];i in this._utils.schemas?o(i,s):n[i]=s;}}_applyPostprocess(t){let r=this._postprocess(t,this._utils);if(r!==pe){if(r.delete)for(let n of r.delete)delete t[n];if(r.override){let{knownKeys:n,unknownKeys:o}=this._partitionOptionKeys(r.override);for(let u of n){let i=r.override[u];this._applyValidation(i,u,this._utils.schemas[u]),t[u]=i;}for(let u of o){let i=r.override[u];this._applyUnknownHandler(u,i,t,(s,D)=>{let a=this._utils.schemas[s];this._applyValidation(D,s,a),t[s]=D;});}}}}};var It;function Ju(e,t,{logger:r=!1,isCLI:n=!1,passThrough:o=!1,FlagSchema:u,descriptor:i}={}){if(n){if(!u)throw new Error("'FlagSchema' option is required.");if(!i)throw new Error("'descriptor' option is required.")}else i=te;let s=o?Array.isArray(o)?(f,p)=>o.includes(f)?{[f]:p}:void 0:(f,p)=>({[f]:p}):(f,p,l)=>{let{_:F,...m}=l.schemas;return rt(f,p,{...l,schemas:m})},D=Xu(t,{isCLI:n,FlagSchema:u}),a=new lt(D,{logger:r,unknown:s,descriptor:i}),c=r!==!1;c&&It&&(a._hasDeprecationWarned=It);let d=a.normalize(e);return c&&(It=a._hasDeprecationWarned),d}function Xu(e,{isCLI:t,FlagSchema:r}){let n=[];t&&n.push(ut.create({name:"_"}));for(let o of e)n.push(Zu(o,{isCLI:t,optionInfos:e,FlagSchema:r})),o.alias&&t&&n.push(nt.create({name:o.alias,sourceName:o.name}));return n}function Zu(e,{isCLI:t,optionInfos:r,FlagSchema:n}){let{name:o}=e,u={name:o},i,s={};switch(e.type){case"int":i=ct,t&&(u.preprocess=Number);break;case"string":i=Le;break;case"choice":i=Dt,u.choices=e.choices.map(D=>D!=null&&D.redirect?{...D,redirect:{to:{key:e.name,value:D.redirect}}}:D);break;case"boolean":i=it;break;case"flag":i=n,u.flags=r.flatMap(D=>[D.alias,D.description&&D.name,D.oppositeDescription&&`no-${D.name}`].filter(Boolean));break;case"path":i=Le;break;default:throw new Error(`Unexpected type ${e.type}`)}if(e.exception?u.validate=(D,a,c)=>e.exception(D)||a.validate(D,c):u.validate=(D,a,c)=>D===void 0||a.validate(D,c),e.redirect&&(s.redirect=D=>D?{to:{key:e.redirect.option,value:e.redirect.value}}:void 0),e.deprecated&&(s.deprecated=!0),t&&!e.array){let D=u.preprocess||(a=>a);u.preprocess=(a,c,d)=>c.preprocess(D(Array.isArray(a)?y(!1,a,-1):a),d);}return e.array?ot.create({...t?{preprocess:D=>Array.isArray(D)?D:[D]}:{},...s,valueSchema:i.create(u)}):i.create({...u,...s})}var sn=Ju;function Rt(e,t){if(!t)throw new Error("parserName is required.");for(let n=e.length-1;n>=0;n--){let o=e[n];if(o.parsers&&Object.prototype.hasOwnProperty.call(o.parsers,t))return o}let r=`Couldn't resolve parser "${t}".`;throw r+=" Plugins must be explicitly added to the standalone bundle.",new Se(r)}function Dn(e,t){if(!t)throw new Error("astFormat is required.");for(let n=e.length-1;n>=0;n--){let o=e[n];if(o.printers&&Object.prototype.hasOwnProperty.call(o.printers,t))return o}let r=`Couldn't find plugin for AST format "${t}".`;throw r+=" Plugins must be explicitly added to the standalone bundle.",new Se(r)}function ft({plugins:e,parser:t}){let r=Rt(e,t);return Yt(r,t)}function Yt(e,t){let r=e.parsers[t];return typeof r=="function"?r():r}function an(e,t){let r=e.printers[t];return typeof r=="function"?r():r}var cn={astFormat:"estree",printer:{},originalText:void 0,locStart:null,locEnd:null};async function Qu(e,t={}){var d;let r={...e};if(!r.parser)if(r.filepath){if(r.parser=Rr(r,{physicalFile:r.filepath}),!r.parser)throw new ve(`No parser could be inferred for file "${r.filepath}".`)}else throw new ve("No parser and no file path given, couldn't infer a parser.");let n=et({plugins:e.plugins,showDeprecated:!0}).options,o={...cn,...Object.fromEntries(n.filter(f=>f.default!==void 0).map(f=>[f.name,f.default]))},u=Rt(r.plugins,r.parser),i=await Yt(u,r.parser);r.astFormat=i.astFormat,r.locEnd=i.locEnd,r.locStart=i.locStart;let s=(d=u.printers)!=null&&d[i.astFormat]?u:Dn(r.plugins,i.astFormat),D=await an(s,i.astFormat);r.printer=D;let a=s.defaultOptions?Object.fromEntries(Object.entries(s.defaultOptions).filter(([,f])=>f!==void 0)):{},c={...o,...a};for(let[f,p]of Object.entries(c))(r[f]===null||r[f]===void 0)&&(r[f]=p);return r.parser==="json"&&(r.trailingComma="none"),sn(r,n,{passThrough:Object.keys(cn),...t})}var re=Qu;var ln=new Set(["tokens","comments","parent","enclosingNode","precedingNode","followingNode"]),eo=e=>Object.keys(e).filter(t=>!ln.has(t));function to(e){return e?t=>e(t,ln):eo}var H=to;function ro(e,t){let{printer:{massageAstNode:r,getVisitorKeys:n}}=t;if(!r)return e;let o=H(n),u=r.ignoredProperties??new Set;return i(e);function i(s,D){if(!(s!==null&&typeof s=="object"))return s;if(Array.isArray(s))return s.map(f=>i(f,D)).filter(Boolean);let a={},c=new Set(o(s));for(let f in s)!Object.prototype.hasOwnProperty.call(s,f)||u.has(f)||(c.has(f)?a[f]=i(s[f],s):a[f]=s[f]);let d=r(s,a,D);if(d!==null)return d??a}}var fn=ro;var An=he(yn(),1);async function co(e,t){let r=await ft(t),n=r.preprocess?r.preprocess(e,t):e;t.originalText=n;let o;try{o=await r.parse(n,t,t);}catch(u){lo(u,e);}return {text:n,ast:o}}function lo(e,t){let{loc:r}=e;if(r){let n=(0, An.codeFrameColumns)(t,r,{highlightCode:!0});throw e.message+=`
`+n,e.codeFrame=n,e}throw e}var De=co;var Ie,$t,de,pt,Vt=class{constructor(t){ht(this,Ie);ht(this,de);this.stack=[t];}get key(){let{stack:t,siblings:r}=this;return y(!1,t,r===null?-2:-4)??null}get index(){return this.siblings===null?null:y(!1,this.stack,-2)}get node(){return y(!1,this.stack,-1)}get parent(){return this.getNode(1)}get grandparent(){return this.getNode(2)}get isInArray(){return this.siblings!==null}get siblings(){let{stack:t}=this,r=y(!1,t,-3);return Array.isArray(r)?r:null}get next(){let{siblings:t}=this;return t===null?null:t[this.index+1]}get previous(){let{siblings:t}=this;return t===null?null:t[this.index-1]}get isFirst(){return this.index===0}get isLast(){let{siblings:t,index:r}=this;return t!==null&&r===t.length-1}get isRoot(){return this.stack.length===1}get root(){return this.stack[0]}get ancestors(){return [...ce(this,de,pt).call(this)]}getName(){let{stack:t}=this,{length:r}=t;return r>1?y(!1,t,-2):null}getValue(){return y(!1,this.stack,-1)}getNode(t=0){let r=ce(this,Ie,$t).call(this,t);return r===-1?null:this.stack[r]}getParentNode(t=0){return this.getNode(t+1)}call(t,...r){let{stack:n}=this,{length:o}=n,u=y(!1,n,-1);for(let i of r)u=u[i],n.push(i,u);try{return t(this)}finally{n.length=o;}}callParent(t,r=0){let n=ce(this,Ie,$t).call(this,r+1),o=this.stack.splice(n+1);try{return t(this)}finally{this.stack.push(...o);}}each(t,...r){let{stack:n}=this,{length:o}=n,u=y(!1,n,-1);for(let i of r)u=u[i],n.push(i,u);try{for(let i=0;i<u.length;++i)n.push(i,u[i]),t(this,i,u),n.length-=2;}finally{n.length=o;}}map(t,...r){let n=[];return this.each((o,u,i)=>{n[u]=t(o,u,i);},...r),n}match(...t){let r=this.stack.length-1,n=null,o=this.stack[r--];for(let u of t){if(o===void 0)return !1;let i=null;if(typeof n=="number"&&(i=n,n=this.stack[r--],o=this.stack[r--]),u&&!u(o,n,i))return !1;n=this.stack[r--],o=this.stack[r--];}return !0}findAncestor(t){for(let r of ce(this,de,pt).call(this))if(t(r))return r}hasAncestor(t){for(let r of ce(this,de,pt).call(this))if(t(r))return !0;return !1}};Ie=new WeakSet,$t=function(t){let{stack:r}=this;for(let n=r.length-1;n>=0;n-=2)if(!Array.isArray(r[n])&&--t<0)return n;return -1},de=new WeakSet,pt=function*(){let{stack:t}=this;for(let r=t.length-3;r>=0;r-=2){let n=t[r];Array.isArray(n)||(yield n);}};var Bn=Vt;var _n=new Proxy(()=>{},{get:()=>_n}),Re=_n;function me(e){return (t,r,n)=>{let o=!!(n!=null&&n.backwards);if(r===!1)return !1;let{length:u}=t,i=r;for(;i>=0&&i<u;){let s=t.charAt(i);if(e instanceof RegExp){if(!e.test(s))return i}else if(!e.includes(s))return i;o?i--:i++;}return i===-1||i===u?i:!1}}var xn=me(/\s/),N=me(" 	"),dt=me(",; 	"),mt=me(/[^\n\r]/);function fo(e,t,r){let n=!!(r!=null&&r.backwards);if(t===!1)return !1;let o=e.charAt(t);if(n){if(e.charAt(t-1)==="\r"&&o===`
`)return t-2;if(o===`
`||o==="\r"||o==="\u2028"||o==="\u2029")return t-1}else {if(o==="\r"&&e.charAt(t+1)===`
`)return t+2;if(o===`
`||o==="\r"||o==="\u2028"||o==="\u2029")return t+1}return t}var Y=fo;function Fo(e,t,r={}){let n=N(e,r.backwards?t-1:t,r),o=Y(e,n,r);return n!==o}var V=Fo;function po(e){return Array.isArray(e)&&e.length>0}var Mt=po;function mo(e){return e!==null&&typeof e=="object"}var kn=mo;function*Wt(e,t){let{getVisitorKeys:r,filter:n=()=>!0}=t,o=u=>kn(u)&&n(u);for(let u of r(e)){let i=e[u];if(Array.isArray(i))for(let s of i)o(s)&&(yield s);else o(i)&&(yield i);}}function*bn(e,t){let r=[e];for(let n=0;n<r.length;n++){let o=r[n];for(let u of Wt(o,t))yield u,r.push(u);}}function Eo(e){let t=e.type||e.kind||"(unknown type)",r=String(e.name||e.id&&(typeof e.id=="object"?e.id.name:e.id)||e.key&&(typeof e.key=="object"?e.key.name:e.key)||e.value&&(typeof e.value=="object"?"":String(e.value))||e.operator||"");return r.length>20&&(r=r.slice(0,19)+"\u2026"),t+(r?" "+r:"")}function Ut(e,t){(e.comments??(e.comments=[])).push(t),t.printed=!1,t.nodeDescription=Eo(e);}function ne(e,t){t.leading=!0,t.trailing=!1,Ut(e,t);}function X(e,t,r){t.leading=!1,t.trailing=!1,r&&(t.marker=r),Ut(e,t);}function ue(e,t){t.leading=!1,t.trailing=!0,Ut(e,t);}var zt=new WeakMap;function Et(e,t){if(zt.has(e))return zt.get(e);let{printer:{getCommentChildNodes:r,canAttachComment:n,getVisitorKeys:o},locStart:u,locEnd:i}=t;if(!n)return [];let s=((r==null?void 0:r(e,t))??[...Wt(e,{getVisitorKeys:H(o)})]).flatMap(D=>n(D)?[D]:Et(D,t));return s.sort((D,a)=>u(D)-u(a)||i(D)-i(a)),zt.set(e,s),s}function On(e,t,r,n){let{locStart:o,locEnd:u}=r,i=o(t),s=u(t),D=Et(e,r),a,c,d=0,f=D.length;for(;d<f;){let p=d+f>>1,l=D[p],F=o(l),m=u(l);if(F<=i&&s<=m)return On(l,t,r,l);if(m<=i){a=l,d=p+1;continue}if(s<=F){c=l,f=p;continue}throw new Error("Comment location overlaps with node location")}if((n==null?void 0:n.type)==="TemplateLiteral"){let{quasis:p}=n,l=Kt(p,t,r);a&&Kt(p,a,r)!==l&&(a=null),c&&Kt(p,c,r)!==l&&(c=null);}return {enclosingNode:n,precedingNode:a,followingNode:c}}var Gt=()=>!1;function Nn(e,t){let{comments:r}=e;if(delete e.comments,!Mt(r)||!t.printer.canAttachComment)return;let n=[],{locStart:o,locEnd:u,printer:{experimentalFeatures:{avoidAstMutation:i=!1}={},handleComments:s={}},originalText:D}=t,{ownLine:a=Gt,endOfLine:c=Gt,remaining:d=Gt}=s,f=r.map((p,l)=>({...On(e,p,t),comment:p,text:D,options:t,ast:e,isLastComment:r.length-1===l}));for(let[p,l]of f.entries()){let{comment:F,precedingNode:m,enclosingNode:E,followingNode:C,text:g,options:h,ast:B,isLastComment:Z}=l;if(h.parser==="json"||h.parser==="json5"||h.parser==="__js_expression"||h.parser==="__ts_expression"||h.parser==="__vue_expression"||h.parser==="__vue_ts_expression"){if(o(F)-o(B)<=0){ne(B,F);continue}if(u(F)-u(B)>=0){ue(B,F);continue}}let $;if(i?$=[l]:(F.enclosingNode=E,F.precedingNode=m,F.followingNode=C,$=[F,g,h,B,Z]),Co(g,h,f,p))F.placement="ownLine",a(...$)||(C?ne(C,F):m?ue(m,F):E?X(E,F):X(B,F));else if(ho(g,h,f,p))F.placement="endOfLine",c(...$)||(m?ue(m,F):C?ne(C,F):E?X(E,F):X(B,F));else if(F.placement="remaining",!d(...$))if(m&&C){let Q=n.length;Q>0&&n[Q-1].followingNode!==C&&wn(n,h),n.push(l);}else m?ue(m,F):C?ne(C,F):E?X(E,F):X(B,F);}if(wn(n,t),!i)for(let p of r)delete p.precedingNode,delete p.enclosingNode,delete p.followingNode;}var Tn=e=>!/[\S\n\u2028\u2029]/.test(e);function Co(e,t,r,n){let{comment:o,precedingNode:u}=r[n],{locStart:i,locEnd:s}=t,D=i(o);if(u)for(let a=n-1;a>=0;a--){let{comment:c,precedingNode:d}=r[a];if(d!==u||!Tn(e.slice(s(c),D)))break;D=i(c);}return V(e,D,{backwards:!0})}function ho(e,t,r,n){let{comment:o,followingNode:u}=r[n],{locStart:i,locEnd:s}=t,D=s(o);if(u)for(let a=n+1;a<r.length;a++){let{comment:c,followingNode:d}=r[a];if(d!==u||!Tn(e.slice(D,i(c))))break;D=s(c);}return V(e,D)}function wn(e,t){var s,D;let r=e.length;if(r===0)return;let{precedingNode:n,followingNode:o}=e[0],u=t.locStart(o),i;for(i=r;i>0;--i){let{comment:a,precedingNode:c,followingNode:d}=e[i-1];Re.strictEqual(c,n),Re.strictEqual(d,o);let f=t.originalText.slice(t.locEnd(a),u);if(((D=(s=t.printer).isGap)==null?void 0:D.call(s,f,t))??/^[\s(]*$/.test(f))u=t.locStart(a);else break}for(let[a,{comment:c}]of e.entries())a<i?ue(n,c):ne(o,c);for(let a of [n,o])a.comments&&a.comments.length>1&&a.comments.sort((c,d)=>t.locStart(c)-t.locStart(d));e.length=0;}function Kt(e,t,r){let n=r.locStart(t)-1;for(let o=1;o<e.length;++o)if(n<r.locStart(e[o]))return o-1;return 0}function go(e,t){let r=t-1;r=N(e,r,{backwards:!0}),r=Y(e,r,{backwards:!0}),r=N(e,r,{backwards:!0});let n=Y(e,r,{backwards:!0});return r!==n}var Ye=go;function Sn(e,t){let r=e.node;return r.printed=!0,t.printer.printComment(e,t)}function yo(e,t){var c;let r=e.node,n=[Sn(e,t)],{printer:o,originalText:u,locStart:i,locEnd:s}=t;if((c=o.isBlockComment)==null?void 0:c.call(o,r)){let d=V(u,s(r))?V(u,i(r),{backwards:!0})?G:Ke:" ";n.push(d);}else n.push(G);let a=Y(u,N(u,s(r)));return a!==!1&&V(u,a)&&n.push(G),n}function Ao(e,t,r){var a;let n=e.node,o=Sn(e,t),{printer:u,originalText:i,locStart:s}=t,D=(a=u.isBlockComment)==null?void 0:a.call(u,n);if(r!=null&&r.hasLineSuffix&&!(r!=null&&r.isBlock)||V(i,s(n),{backwards:!0})){let c=Ye(i,s(n));return {doc:Be([G,c?G:"",o]),isBlock:D,hasLineSuffix:!0}}return !D||r!=null&&r.hasLineSuffix?{doc:[Be([" ",o]),le],isBlock:D,hasLineSuffix:!0}:{doc:[" ",o],isBlock:D,hasLineSuffix:!1}}function Bo(e,t){let r=e.node;if(!r)return {};let n=t[Symbol.for("printedComments")];if((r.comments||[]).filter(D=>!n.has(D)).length===0)return {leading:"",trailing:""};let u=[],i=[],s;return e.each(()=>{let D=e.node;if(n!=null&&n.has(D))return;let{leading:a,trailing:c}=D;a?u.push(yo(e,t)):c&&(s=Ao(e,t,s),i.push(s.doc));},"comments"),{leading:u,trailing:i}}function vn(e,t,r){let{leading:n,trailing:o}=Bo(e,r);return !n&&!o?t:Ze(t,u=>[n,u,o])}function Pn(e){let{[Symbol.for("comments")]:t,[Symbol.for("printedComments")]:r}=e;for(let n of t){if(!n.printed&&!r.has(n))throw new Error('Comment "'+n.value.trim()+'" was not printed. Please report this error!');delete n.printed;}}async function Ln(e,t,r,n,o){let{embeddedLanguageFormatting:u,printer:{embed:i,hasPrettierIgnore:s=()=>!1,getVisitorKeys:D}}=r;if(!i||u!=="auto")return;if(i.length>2)throw new Error("printer.embed has too many parameters. The API changed in Prettier v3. Please update your plugin. See https://prettier.io/docs/en/plugins.html#optional-embed");let a=H(i.getVisitorKeys??D),c=[];p();let d=e.stack;for(let{print:l,node:F,pathStack:m}of c)try{e.stack=m;let E=await l(f,t,e,r);E&&o.set(F,E);}catch(E){if(globalThis.PRETTIER_DEBUG)throw E}e.stack=d;function f(l,F){return _o(l,F,r,n)}function p(){let{node:l}=e;if(l===null||typeof l!="object"||s(e))return;for(let m of a(l))Array.isArray(l[m])?e.each(p,m):e.call(p,m);let F=i(e,r);if(F){if(typeof F=="function"){c.push({print:F,node:l,pathStack:[...e.stack]});return}o.set(l,F);}}}async function _o(e,t,r,n){let o=await re({...r,...t,parentParser:r.parser,originalText:e},{passThrough:!0}),{ast:u}=await De(e,o),i=await n(u,o);return Xe(i)}function ko(e,t){let{originalText:r,[Symbol.for("comments")]:n,locStart:o,locEnd:u,[Symbol.for("printedComments")]:i}=t,{node:s}=e,D=o(s),a=u(s);for(let c of n)o(c)>=D&&u(c)<=a&&i.add(c);return r.slice(D,a)}var Rn=ko;async function je(e,t){({ast:e}=await Ht(e,t));let r=new Map,n=new Bn(e),u=new Map;await Ln(n,s,t,je,u);let i=await Yn(n,t,s,void 0,u);return Pn(t),i;function s(a,c){return a===void 0||a===n?D(c):Array.isArray(a)?n.call(()=>D(c),...a):n.call(()=>D(c),a)}function D(a){let c=n.node;if(c==null)return "";let d=c&&typeof c=="object"&&a===void 0;if(d&&r.has(c))return r.get(c);let f=Yn(n,t,s,a,u);return d&&r.set(c,f),f}}function Yn(e,t,r,n,o){var D;let{node:u}=e,{printer:i}=t,s;return (D=i.hasPrettierIgnore)!=null&&D.call(i,e)?s=Rn(e,t):o.has(u)?s=o.get(u):s=i.print(e,t,r,n),u===t.cursorNode&&(s=Ze(s,a=>[xe,a,xe])),i.printComment&&(!i.willPrintOwnComments||!i.willPrintOwnComments(e,t))&&(s=vn(e,s,t)),s}async function Ht(e,t){let r=e.comments??[];t[Symbol.for("comments")]=r,t[Symbol.for("tokens")]=e.tokens??[],t[Symbol.for("printedComments")]=new Set,Nn(e,t);let{printer:{preprocess:n}}=t;return e=n?await n(e,t):e,{ast:e,comments:r}}var bo=({parser:e})=>e==="json"||e==="json5"||e==="json-stringify";function wo(e,t){let r=[e.node,...e.parentNodes],n=new Set([t.node,...t.parentNodes]);return r.find(o=>$n.has(o.type)&&n.has(o))}function jn(e){let t=e.length-1;for(;;){let r=e[t];if((r==null?void 0:r.type)==="Program"||(r==null?void 0:r.type)==="File")t--;else break}return e.slice(0,t+1)}function Oo(e,t,{locStart:r,locEnd:n}){let o=e.node,u=t.node;if(o===u)return {startNode:o,endNode:u};let i=r(e.node);for(let D of jn(t.parentNodes))if(r(D)>=i)u=D;else break;let s=n(t.node);for(let D of jn(e.parentNodes)){if(n(D)<=s)o=D;else break;if(o===u)break}return {startNode:o,endNode:u}}function qt(e,t,r,n,o=[],u){let{locStart:i,locEnd:s}=r,D=i(e),a=s(e);if(!(t>a||t<D||u==="rangeEnd"&&t===D||u==="rangeStart"&&t===a)){for(let c of Et(e,r)){let d=qt(c,t,r,n,[e,...o],u);if(d)return d}if(!n||n(e,o[0]))return {node:e,parentNodes:o}}}function No(e,t){return t!=="DeclareExportDeclaration"&&e!=="TypeParameterDeclaration"&&(e==="Directive"||e==="TypeAlias"||e==="TSExportAssignment"||e.startsWith("Declare")||e.startsWith("TSDeclare")||e.endsWith("Statement")||e.endsWith("Declaration"))}var $n=new Set(["JsonRoot","ObjectExpression","ArrayExpression","StringLiteral","NumericLiteral","BooleanLiteral","NullLiteral","UnaryExpression","TemplateLiteral"]),To=new Set(["OperationDefinition","FragmentDefinition","VariableDefinition","TypeExtensionDefinition","ObjectTypeDefinition","FieldDefinition","DirectiveDefinition","EnumTypeDefinition","EnumValueDefinition","InputValueDefinition","InputObjectTypeDefinition","SchemaDefinition","OperationTypeDefinition","InterfaceTypeDefinition","UnionTypeDefinition","ScalarTypeDefinition"]);function Vn(e,t,r){if(!t)return !1;switch(e.parser){case"flow":case"babel":case"babel-flow":case"babel-ts":case"typescript":case"acorn":case"espree":case"meriyah":case"__babel_estree":return No(t.type,r==null?void 0:r.type);case"json":case"json5":case"json-stringify":return $n.has(t.type);case"graphql":return To.has(t.kind);case"vue":return t.tag!=="root"}return !1}function Mn(e,t,r){let{rangeStart:n,rangeEnd:o,locStart:u,locEnd:i}=t;Re.ok(o>n);let s=e.slice(n,o).search(/\S/),D=s===-1;if(!D)for(n+=s;o>n&&!/\S/.test(e[o-1]);--o);let a=qt(r,n,t,(p,l)=>Vn(t,p,l),[],"rangeStart"),c=D?a:qt(r,o,t,p=>Vn(t,p),[],"rangeEnd");if(!a||!c)return {rangeStart:0,rangeEnd:0};let d,f;if(bo(t)){let p=wo(a,c);d=p,f=p;}else ({startNode:d,endNode:f}=Oo(a,c,t));return {rangeStart:Math.min(u(d),u(f)),rangeEnd:Math.max(i(d),i(f))}}function So(e,t){let{cursorOffset:r,locStart:n,locEnd:o}=t,u=H(t.printer.getVisitorKeys),i=D=>n(D)<=r&&o(D)>=r,s=e;for(let D of bn(e,{getVisitorKeys:u,filter:i}))s=D;return s}var Wn=So;var Hn="\uFEFF",Un=Symbol("cursor");async function qn(e,t,r=0){if(!e||e.trim().length===0)return {formatted:"",cursorOffset:-1,comments:[]};let{ast:n,text:o}=await De(e,t);t.cursorOffset>=0&&(t.cursorNode=Wn(n,t));let u=await je(n,t);r>0&&(u=qe([G,u],r,t.tabWidth));let i=fe(u,t);if(r>0){let D=i.formatted.trim();i.cursorNodeStart!==void 0&&(i.cursorNodeStart-=i.formatted.indexOf(D)),i.formatted=D+be(t.endOfLine);}let s=t[Symbol.for("comments")];if(t.cursorOffset>=0){let D,a,c,d,f;if(t.cursorNode&&i.cursorNodeText?(D=t.locStart(t.cursorNode),a=o.slice(D,t.locEnd(t.cursorNode)),c=t.cursorOffset-D,d=i.cursorNodeStart,f=i.cursorNodeText):(D=0,a=o,c=t.cursorOffset,d=0,f=i.formatted),a===f)return {formatted:i.formatted,cursorOffset:d+c,comments:s};let p=a.split("");p.splice(c,0,Un);let l=f.split(""),F=(0, Kn.diffArrays)(p,l),m=d;for(let E of F)if(E.removed){if(E.value.includes(Un))break}else m+=E.count;return {formatted:i.formatted,cursorOffset:m,comments:s}}return {formatted:i.formatted,cursorOffset:-1,comments:s}}async function vo(e,t){let{ast:r,text:n}=await De(e,t),{rangeStart:o,rangeEnd:u}=Mn(n,t,r),i=n.slice(o,u),s=Math.min(o,n.lastIndexOf(`
`,o)+1),D=n.slice(s,o).match(/^\s*/)[0],a=Fe(D,t.tabWidth),c=await qn(i,{...t,rangeStart:0,rangeEnd:Number.POSITIVE_INFINITY,cursorOffset:t.cursorOffset>o&&t.cursorOffset<=u?t.cursorOffset-o:-1,endOfLine:"lf"},a),d=c.formatted.trimEnd(),{cursorOffset:f}=t;f>u?f+=d.length-i.length:c.cursorOffset>=0&&(f=c.cursorOffset+o);let p=n.slice(0,o)+d+n.slice(u);if(t.endOfLine!=="lf"){let l=be(t.endOfLine);f>=0&&l===`\r
`&&(f+=_t(p.slice(0,f),`
`)),p=ee(!1,p,`
`,l);}return {formatted:p,cursorOffset:f,comments:c.comments}}function Jt(e,t,r){return typeof t!="number"||Number.isNaN(t)||t<0||t>e.length?r:t}function zn(e,t){let{cursorOffset:r,rangeStart:n,rangeEnd:o}=t;return r=Jt(e,r,-1),n=Jt(e,n,0),o=Jt(e,o,e.length),{...t,cursorOffset:r,rangeStart:n,rangeEnd:o}}function Jn(e,t){let{cursorOffset:r,rangeStart:n,rangeEnd:o,endOfLine:u}=zn(e,t),i=e.charAt(0)===Hn;if(i&&(e=e.slice(1),r--,n--,o--),u==="auto"&&(u=hr(e)),e.includes("\r")){let s=D=>_t(e.slice(0,Math.max(D,0)),`\r
`);r-=s(r),n-=s(n),o-=s(o),e=gr(e);}return {hasBOM:i,text:e,options:zn(e,{...t,cursorOffset:r,rangeStart:n,rangeEnd:o,endOfLine:u})}}async function Gn(e,t){let r=await ft(t);return !r.hasPragma||r.hasPragma(e)}async function Xt(e,t){let{hasBOM:r,text:n,options:o}=Jn(e,await re(t));if(o.rangeStart>=o.rangeEnd&&n!==""||o.requirePragma&&!await Gn(n,o))return {formatted:e,cursorOffset:t.cursorOffset,comments:[]};let u;return o.rangeStart>0||o.rangeEnd<n.length?u=await vo(n,o):(!o.requirePragma&&o.insertPragma&&o.printer.insertPragma&&!await Gn(n,o)&&(n=o.printer.insertPragma(n)),u=await qn(n,o)),r&&(u.formatted=Hn+u.formatted,u.cursorOffset>=0&&u.cursorOffset++),u}async function Xn(e,t,r){let{text:n,options:o}=Jn(e,await re(t)),u=await De(n,o);return r&&(r.preprocessForPrint&&(u.ast=await Ht(u.ast,o)),r.massage&&(u.ast=fn(u.ast,o))),u}async function Zn(e,t){t=await re(t);let r=await je(e,t);return fe(r,t)}async function Qn(e,t){let r=Pr(e),{formatted:n}=await Xt(r,{...t,parser:"__js_expression"});return n}async function eu(e,t){t=await re(t);let{ast:r}=await De(e,t);return je(r,t)}async function tu(e,t){return fe(e,await re(t))}var Qt={};We(Qt,{addDanglingComment:()=>X,addLeadingComment:()=>ne,addTrailingComment:()=>ue,getAlignmentSize:()=>Fe,getIndentSize:()=>nu,getMaxContinuousCount:()=>ru,getNextNonSpaceNonCommentCharacter:()=>iu,getNextNonSpaceNonCommentCharacterIndex:()=>Go,getStringWidth:()=>we,hasNewline:()=>V,hasNewlineInRange:()=>uu,hasSpaces:()=>ou,isNextLineEmpty:()=>Jo,isNextLineEmptyAfterIndex:()=>Ct,isPreviousLineEmpty:()=>Ho,makeString:()=>su,skip:()=>me,skipEverythingButNewLine:()=>mt,skipInlineComment:()=>Ee,skipNewline:()=>Y,skipSpaces:()=>N,skipToLineEnd:()=>dt,skipTrailingComment:()=>Ce,skipWhitespace:()=>xn});function Lo(e,t){if(t===!1)return !1;if(e.charAt(t)==="/"&&e.charAt(t+1)==="*"){for(let r=t+2;r<e.length;++r)if(e.charAt(r)==="*"&&e.charAt(r+1)==="/")return r+2}return t}var Ee=Lo;function Io(e,t){return t===!1?!1:e.charAt(t)==="/"&&e.charAt(t+1)==="/"?mt(e,t):t}var Ce=Io;function Ro(e,t){let r=null,n=t;for(;n!==r;)r=n,n=N(e,n),n=Ee(e,n),n=Ce(e,n),n=Y(e,n);return n}var Ve=Ro;function Yo(e,t){let r=null,n=t;for(;n!==r;)r=n,n=dt(e,n),n=Ee(e,n),n=N(e,n);return n=Ce(e,n),n=Y(e,n),n!==!1&&V(e,n)}var Ct=Yo;function Zt(e){if(typeof e!="string")throw new TypeError("Expected a string");return e.replace(/[|\\{}()[\]^$+*?.]/g,"\\$&").replace(/-/g,"\\x2d")}function jo(e,t){let r=e.match(new RegExp(`(${Zt(t)})+`,"g"));return r===null?0:r.reduce((n,o)=>Math.max(n,o.length/t.length),0)}var ru=jo;function Vo(e,t){let r=e.lastIndexOf(`
`);return r===-1?0:Fe(e.slice(r+1).match(/^[\t ]*/)[0],t)}var nu=Vo;function $o(e,t,r){for(let n=t;n<r;++n)if(e.charAt(n)===`
`)return !0;return !1}var uu=$o;function Mo(e,t,r={}){return N(e,r.backwards?t-1:t,r)!==t}var ou=Mo;function Wo(e,t){let r=Ve(e,t);return r===!1?"":e.charAt(r)}var iu=Wo;function Uo(e,t,r){let n=t==='"'?"'":'"',u=ee(!1,e,/\\(.)|(["'])/gs,(i,s,D)=>s===n?s:D===t?"\\"+D:D||(r&&/^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(s)?s:"\\"+s));return t+u+t}var su=Uo;function zo(e,t,r){return Ve(e,r(t))}function Go(e,t){return arguments.length===2||typeof t=="number"?Ve(e,t):zo(...arguments)}function Ko(e,t,r){return Ye(e,r(t))}function Ho(e,t){return arguments.length===2||typeof t=="number"?Ye(e,t):Ko(...arguments)}function qo(e,t,r){return Ct(e,r(t))}function Jo(e,t){return arguments.length===2||typeof t=="number"?Ct(e,t):qo(...arguments)}var er={};We(er,{builders:()=>Xo,printer:()=>Zo,utils:()=>Qo});var Xo={join:ke,line:Ke,softline:Er,hardline:G,literalline:He,group:At,conditionalGroup:fr,fill:Ge,lineSuffix:Be,lineSuffixBoundary:dr,cursor:xe,breakParent:le,ifBreak:Fr,trim:mr,indent:ie,indentIfBreak:pr,align:oe,addAlignmentToDoc:qe,markAsRoot:cr,dedentToRoot:ar,dedent:lr,hardlineWithoutBreakParent:_e,literallineWithoutBreakParent:Bt,label:Cr,concat:e=>e},Zo={printDocToString:fe},Qo={willBreak:wr,traverseDoc:Ae,findInDoc:Je,mapDoc:Ne,removeLines:Nr,stripTrailingHardline:Xe,replaceEndOfLine:Tr,canBreak:Sr};var Du="3.1.1";function ae(e,t=1){return async(...r)=>{let n=r[t]??{},o=n.plugins??[];return r[t]={...n,plugins:Array.isArray(o)?o:Object.values(o)},e(...r)}}var au=ae(Xt);async function cu(e,t){let{formatted:r}=await au(e,{...t,cursorOffset:-1});return r}async function ei(e,t){return await cu(e,t)===e}var ti=ae(et,0),ri={parse:ae(Xn),formatAST:ae(Zn),formatDoc:ae(Qn),printToDoc:ae(eu),printDocToString:ae(tu)};

const util = Qt;

/**
 * Override the default behavior to attach comments to syntax node.
 */
const commentHandler = {
    ownLine: (comment, text, options, ast, isLastComment) => [
        addEmptyInterfaceComment,
        addEmptyModelComment,
        addCommentBetweenAnnotationsAndNode,
        handleOnlyComments,
    ].some((x) => x({ comment, text, options, ast: ast, isLastComment })),
};
/**
 * When a comment is on an empty interface make sure it gets added as a dangling comment on it and not on the identifier.
 *
 * @example
 *
 * interface Foo {
 *   // My comment
 * }
 */
function addEmptyInterfaceComment({ comment, ast }) {
    const { precedingNode, enclosingNode } = comment;
    if (enclosingNode &&
        enclosingNode.kind === SyntaxKind.InterfaceStatement &&
        enclosingNode.operations.length === 0 &&
        precedingNode &&
        precedingNode.kind === SyntaxKind.Identifier) {
        util.addDanglingComment(enclosingNode, comment, undefined);
        return true;
    }
    return false;
}
/**
 * When a comment is in between a node and its annotations(Decorator, directives, doc comments).
 *
 * @example
 *
 * @foo
 * // My comment
 * @bar
 * model Foo {
 * }
 */
function addCommentBetweenAnnotationsAndNode({ comment }) {
    const { enclosingNode, precedingNode } = comment;
    if (precedingNode &&
        (precedingNode.kind === SyntaxKind.DecoratorExpression ||
            precedingNode.kind === SyntaxKind.DirectiveExpression ||
            precedingNode.kind === SyntaxKind.Doc) &&
        enclosingNode &&
        (enclosingNode.kind === SyntaxKind.NamespaceStatement ||
            enclosingNode.kind === SyntaxKind.ModelStatement ||
            enclosingNode.kind === SyntaxKind.EnumStatement ||
            enclosingNode.kind === SyntaxKind.OperationStatement ||
            enclosingNode.kind === SyntaxKind.ScalarStatement ||
            enclosingNode.kind === SyntaxKind.InterfaceStatement ||
            enclosingNode.kind === SyntaxKind.ModelProperty ||
            enclosingNode.kind === SyntaxKind.EnumMember ||
            enclosingNode.kind === SyntaxKind.UnionStatement)) {
        util.addTrailingComment(precedingNode, comment);
        return true;
    }
    return false;
}
/**
 * When a comment is on an empty model make sure it gets added as a dangling comment on it and not on the identifier.
 *
 * @example
 *
 * model Foo {
 *   // My comment
 * }
 */
function addEmptyModelComment({ comment }) {
    const { precedingNode, enclosingNode } = comment;
    if (enclosingNode &&
        enclosingNode.kind === SyntaxKind.ModelStatement &&
        enclosingNode.properties.length === 0 &&
        precedingNode &&
        (precedingNode === enclosingNode.is ||
            precedingNode === enclosingNode.id ||
            precedingNode === enclosingNode.extends)) {
        util.addDanglingComment(enclosingNode, comment, undefined);
        return true;
    }
    return false;
}
function handleOnlyComments({ comment, ast, isLastComment }) {
    var _a, _b;
    const { enclosingNode } = comment;
    if (((_a = ast === null || ast === void 0 ? void 0 : ast.statements) === null || _a === void 0 ? void 0 : _a.length) === 0) {
        if (isLastComment) {
            util.addDanglingComment(ast, comment, undefined);
        }
        else {
            util.addLeadingComment(ast, comment);
        }
        return true;
    }
    if ((enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.kind) === SyntaxKind.TypeSpecScript &&
        enclosingNode.statements.length === 0 &&
        ((_b = enclosingNode.directives) === null || _b === void 0 ? void 0 : _b.length) === 0) {
        if (isLastComment) {
            util.addDanglingComment(enclosingNode, comment, undefined);
        }
        else {
            util.addLeadingComment(enclosingNode, comment);
        }
        return true;
    }
    return false;
}

/**
 * Check if the current path should be wrapped in parentheses
 * @param path Prettier print path.
 * @param options Prettier options
 */
function needsParens(path, options) {
    const parent = path.getParentNode();
    if (!parent) {
        return false;
    }
    // eslint-disable-next-line deprecation/deprecation
    const node = path.getValue();
    switch (node.kind) {
        case SyntaxKind.ValueOfExpression:
            return (parent.kind === SyntaxKind.UnionExpression ||
                parent.kind === SyntaxKind.ArrayExpression ||
                parent.kind === SyntaxKind.IntersectionExpression);
        case SyntaxKind.IntersectionExpression:
            return (parent.kind === SyntaxKind.UnionExpression || parent.kind === SyntaxKind.ArrayExpression);
        case SyntaxKind.UnionExpression:
            return (parent.kind === SyntaxKind.IntersectionExpression ||
                parent.kind === SyntaxKind.ArrayExpression);
        case SyntaxKind.ProjectionLogicalExpression:
            return parent.kind === SyntaxKind.ProjectionLogicalExpression;
        case SyntaxKind.ProjectionArithmeticExpression:
            return parent.kind === SyntaxKind.ProjectionArithmeticExpression;
        default:
            return false;
    }
}

const { align, breakParent, group, hardline, ifBreak, indent, join, line, softline } = builders;
const { isNextLineEmpty } = util;
/**
 * If the decorators for that node should try to be kept inline.
 */
const DecoratorsTryInline = {
    modelProperty: true,
    enumMember: true,
    unionVariant: true,
};
const typespecPrinter = {
    print: printTypeSpec,
    isBlockComment: (node) => isBlockComment(node),
    canAttachComment: canAttachComment,
    printComment: printComment,
    handleComments: commentHandler,
};
function printTypeSpec(
// Path to the AST node to print
path, options, print) {
    const node = path.getValue();
    const docs = printDocComments(path, options, print);
    const directives = shouldPrintDirective(node) ? printDirectives(path, options, print) : "";
    const printedNode = printNode(path, options, print);
    const value = needsParens(path) ? ["(", printedNode, ")"] : printedNode;
    const parts = [docs, directives, value];
    if (node.kind === SyntaxKind.TypeSpecScript) {
        // For TypeSpecScript(root of typespec document) we had a new line at the end.
        // This must be done here so the hardline entry can be the last item of the doc array returned by the printer
        // so the markdown(and other embedded formatter) can omit that extra line.
        parts.push(hardline);
    }
    return parts;
}
function shouldPrintDirective(node) {
    // Model property handle printing directive itself.
    return node.kind !== SyntaxKind.ModelProperty;
}
function printNode(
// Path to the AST node to print
path, options, print) {
    const node = path.getValue();
    switch (node.kind) {
        // Root
        case SyntaxKind.TypeSpecScript:
            return printTypeSpecScript(path, options, print);
        // Statements
        case SyntaxKind.ImportStatement:
            return [`import "${node.path.value}";`];
        case SyntaxKind.UsingStatement:
            return [`using `, path.call(print, "name"), `;`];
        case SyntaxKind.OperationStatement:
            return printOperationStatement(path, options, print);
        case SyntaxKind.OperationSignatureDeclaration:
            return printOperationSignatureDeclaration(path, options, print);
        case SyntaxKind.OperationSignatureReference:
            return printOperationSignatureReference(path, options, print);
        case SyntaxKind.NamespaceStatement:
            return printNamespaceStatement(path, options, print);
        case SyntaxKind.ModelStatement:
            return printModelStatement(path, options, print);
        case SyntaxKind.ScalarStatement:
            return printScalarStatement(path, options, print);
        case SyntaxKind.AliasStatement:
            return printAliasStatement(path, options, print);
        case SyntaxKind.EnumStatement:
            return printEnumStatement(path, options, print);
        case SyntaxKind.UnionStatement:
            return printUnionStatement(path, options, print);
        case SyntaxKind.InterfaceStatement:
            return printInterfaceStatement(path, options, print);
        // Others.
        case SyntaxKind.Identifier:
            return printIdentifier(node);
        case SyntaxKind.StringLiteral:
            return printStringLiteral(path, options);
        case SyntaxKind.NumericLiteral:
            return printNumberLiteral(path, options);
        case SyntaxKind.BooleanLiteral:
            return printBooleanLiteral(path);
        case SyntaxKind.ModelExpression:
            return printModelExpression(path, options, print);
        case SyntaxKind.ModelProperty:
            return printModelProperty(path, options, print);
        case SyntaxKind.DecoratorExpression:
            return printDecorator(path, options, print);
        case SyntaxKind.AugmentDecoratorStatement:
            return printAugmentDecorator(path, options, print);
        case SyntaxKind.DirectiveExpression:
            return printDirective(path, options, print);
        case SyntaxKind.UnionExpression:
            return printUnion(path, options, print);
        case SyntaxKind.IntersectionExpression:
            return printIntersection(path, options, print);
        case SyntaxKind.ArrayExpression:
            return printArray(path, options, print);
        case SyntaxKind.TupleExpression:
            return printTuple(path, options, print);
        case SyntaxKind.MemberExpression:
            return printMemberExpression(path, options, print);
        case SyntaxKind.EnumMember:
            return printEnumMember(path, options, print);
        case SyntaxKind.EnumSpreadMember:
            return printEnumSpreadMember(path, options, print);
        case SyntaxKind.UnionVariant:
            return printUnionVariant(path, options, print);
        case SyntaxKind.TypeReference:
            return printTypeReference(path, options, print);
        case SyntaxKind.ValueOfExpression:
            return printValueOfExpression(path, options, print);
        case SyntaxKind.TemplateParameterDeclaration:
            return printTemplateParameterDeclaration(path, options, print);
        case SyntaxKind.ModelSpreadProperty:
            return printModelSpread(path, options, print);
        case SyntaxKind.DecoratorDeclarationStatement:
            return printDecoratorDeclarationStatement(path, options, print);
        case SyntaxKind.FunctionDeclarationStatement:
            return printFunctionDeclarationStatement(path, options, print);
        case SyntaxKind.FunctionParameter:
            return printFunctionParameterDeclaration(path, options, print);
        case SyntaxKind.ExternKeyword:
            return "extern";
        case SyntaxKind.VoidKeyword:
            return "void";
        case SyntaxKind.NeverKeyword:
            return "never";
        case SyntaxKind.UnknownKeyword:
            return "unknown";
        case SyntaxKind.ProjectionStatement:
            return printProjectionStatement(path, options, print);
        case SyntaxKind.ProjectionModelSelector:
            return "model";
        case SyntaxKind.ProjectionModelPropertySelector:
            return "modelproperty";
        case SyntaxKind.ProjectionOperationSelector:
            return "op";
        case SyntaxKind.ProjectionUnionSelector:
            return "union";
        case SyntaxKind.ProjectionUnionVariantSelector:
            return "unionvariant";
        case SyntaxKind.ProjectionInterfaceSelector:
            return "interface";
        case SyntaxKind.ProjectionEnumSelector:
            return "enum";
        case SyntaxKind.ProjectionEnumMemberSelector:
            return "enummember";
        case SyntaxKind.Projection:
            return printProjection(path, options, print);
        case SyntaxKind.ProjectionParameterDeclaration:
            return printProjectionParameterDeclaration(path, options, print);
        case SyntaxKind.ProjectionExpressionStatement:
            return printProjectionExpressionStatement(path, options, print);
        case SyntaxKind.ProjectionIfExpression:
            return printProjectionIfExpressionNode(path, options, print);
        case SyntaxKind.ProjectionBlockExpression:
            return printProjectionBlockExpressionNode(path, options, print);
        case SyntaxKind.ProjectionMemberExpression:
            return printProjectionMemberExpression(path, options, print);
        case SyntaxKind.ProjectionLogicalExpression:
        case SyntaxKind.ProjectionEqualityExpression:
        case SyntaxKind.ProjectionRelationalExpression:
        case SyntaxKind.ProjectionArithmeticExpression:
            return printProjectionLeftRightExpression(path, options, print);
        case SyntaxKind.ProjectionUnaryExpression:
            return printProjectionUnaryExpression(path, options, print);
        case SyntaxKind.ProjectionCallExpression:
            return printProjectionCallExpression(path, options, print);
        case SyntaxKind.ProjectionLambdaExpression:
            return printProjectionLambdaExpression(path, options, print);
        case SyntaxKind.ProjectionLambdaParameterDeclaration:
            return printProjectionLambdaParameterDeclaration(path, options, print);
        case SyntaxKind.ProjectionModelExpression:
            return printModelExpression(path, options, print);
        case SyntaxKind.ProjectionModelProperty:
            return printModelProperty(path, options, print);
        case SyntaxKind.ProjectionModelSpreadProperty:
            return printModelSpread(path, options, print);
        case SyntaxKind.ProjectionTupleExpression:
            return printTuple(path, options, print);
        case SyntaxKind.ProjectionDecoratorReferenceExpression:
            return path.call(print, "target");
        case SyntaxKind.Return:
            return printReturnExpression(path, options, print);
        case SyntaxKind.Doc:
            return printDoc(path, options);
        case SyntaxKind.DocText:
        case SyntaxKind.DocParamTag:
        case SyntaxKind.DocTemplateTag:
        case SyntaxKind.DocReturnsTag:
        case SyntaxKind.DocErrorsTag:
        case SyntaxKind.DocUnknownTag:
            // https://github.com/microsoft/typespec/issues/1319 Tracks pretty-printing doc comments.
            compilerAssert(false, "Currently, doc comments are only handled as regular comments and we do not opt in to parsing them so we shouldn't reach here.");
            return "";
        case SyntaxKind.EmptyStatement:
            return "";
        case SyntaxKind.StringTemplateExpression:
            return printStringTemplateExpression(path, options, print);
        case SyntaxKind.StringTemplateSpan:
        case SyntaxKind.StringTemplateHead:
        case SyntaxKind.StringTemplateMiddle:
        case SyntaxKind.StringTemplateTail:
        case SyntaxKind.JsSourceFile:
        case SyntaxKind.JsNamespaceDeclaration:
        case SyntaxKind.InvalidStatement:
            return getRawText(node, options);
        default:
            return getRawText(node, options);
    }
}
function printTypeSpecScript(path, options, print) {
    const node = path.getValue();
    const nodeHasComments = hasComments(node, CommentCheckFlags.Dangling);
    const body = [];
    if (nodeHasComments) {
        body.push(printDanglingComments(path, options, { sameIndent: true }));
    }
    body.push(printStatementSequence(path, options, print, "statements"));
    return body;
}
function printAliasStatement(path, options, print) {
    const id = path.call(print, "id");
    const template = printTemplateParameters(path, options, print, "templateParameters");
    return ["alias ", id, template, " = ", path.call(print, "value"), ";"];
}
function printTemplateParameters(path, options, print, propertyName) {
    const node = path.getValue();
    const args = node[propertyName];
    if (args.length === 0) {
        return "";
    }
    const shouldHug = args.length === 1;
    if (shouldHug) {
        return ["<", join(", ", path.map(print, propertyName)), ">"];
    }
    else {
        const body = indent([softline, join([", ", softline], path.map(print, propertyName))]);
        return group(["<", body, softline, ">"]);
    }
}
function canAttachComment(node) {
    const kind = node.kind;
    return Boolean(kind &&
        kind !== SyntaxKind.LineComment &&
        kind !== SyntaxKind.BlockComment &&
        kind !== SyntaxKind.EmptyStatement &&
        kind !== SyntaxKind.DocParamTag &&
        kind !== SyntaxKind.DocReturnsTag &&
        kind !== SyntaxKind.DocTemplateTag &&
        kind !== SyntaxKind.DocText &&
        kind !== SyntaxKind.DocUnknownTag &&
        !(node.flags & 8 /* NodeFlags.Synthetic */));
}
function printComment(commentPath, options) {
    const comment = commentPath.getValue();
    comment.printed = true;
    switch (comment.kind) {
        case SyntaxKind.BlockComment:
            return printBlockComment(commentPath, options);
        case SyntaxKind.LineComment:
            return `${options.originalText.slice(comment.pos, comment.end).trimEnd()}`;
        default:
            throw new Error(`Not a comment: ${JSON.stringify(comment)}`);
    }
}
function printBlockComment(commentPath, options) {
    const comment = commentPath.getValue();
    const rawComment = options.originalText.slice(comment.pos + 2, comment.end - 2);
    const printed = isIndentableBlockComment(rawComment)
        ? printIndentableBlockCommentContent(rawComment)
        : rawComment;
    return ["/*", printed, "*/"];
}
function isIndentableBlockComment(rawComment) {
    // If the comment has multiple lines and every line starts with a star
    // we can fix the indentation of each line. The stars in the `/*` and
    // `*/` delimiters are not included in the comment value, so add them
    // back first.
    const lines = `*${rawComment}*`.split("\n");
    return lines.length > 1 && lines.every((line) => line.trim()[0] === "*");
}
function printIndentableBlockCommentContent(rawComment) {
    const lines = rawComment.split("\n");
    return [
        join(hardline, lines.map((line, index) => index === 0
            ? line.trimEnd()
            : " " + (index < lines.length - 1 ? line.trim() : line.trimStart()))),
    ];
}
/** Print a doc comment. */
function printDoc(path, options, print) {
    const node = path.getValue();
    const rawComment = options.originalText.slice(node.pos + 3, node.end - 2);
    const printed = isIndentableBlockComment(rawComment)
        ? printIndentableBlockCommentContent(rawComment)
        : rawComment.includes("\n")
            ? rawComment
            : ` ${rawComment.trim()} `;
    return ["/**", printed, "*/"];
}
function printDecorators(path, options, print, { tryInline }) {
    const node = path.getValue();
    if (node.decorators.length === 0) {
        return { decorators: "", multiline: false };
    }
    const shouldBreak = shouldDecoratorBreakLine(path, options, { tryInline });
    const decorators = path.map((x) => [print(x), ifBreak(line, " ")], "decorators");
    return {
        decorators: group([shouldBreak ? breakParent : "", decorators]),
        multiline: shouldBreak,
    };
}
/** Check if the decorators of the given node should be broken in sparate line */
function shouldDecoratorBreakLine(path, options, { tryInline }) {
    const node = path.getValue();
    return (!tryInline || node.decorators.length >= 3 || hasNewlineBetweenOrAfterDecorators(node, options));
}
/**
 * Check if there is already new lines in between the decorators of the node.
 */
function hasNewlineBetweenOrAfterDecorators(node, options) {
    return node.decorators.some((decorator) => util.hasNewline(options.originalText, decorator.end));
}
function printDecorator(path, options, print) {
    const args = printDecoratorArgs(path, options, print);
    return ["@", path.call(print, "target"), args];
}
function printAugmentDecorator(path, options, print) {
    const args = printAugmentDecoratorArgs(path, options, print);
    return ["@@", path.call(print, "target"), args, ";"];
}
function printAugmentDecoratorArgs(path, options, print) {
    return [
        "(",
        group([
            indent(join(", ", [
                path.call(print, "targetType"),
                ...path.map((arg) => [softline, print(arg)], "arguments"),
            ])),
            softline,
        ]),
        ")",
    ];
}
function printDocComments(path, options, print) {
    const node = path.getValue();
    if (node.docs === undefined || node.docs.length === 0) {
        return "";
    }
    const docs = path.map((x) => [print(x), line], "docs");
    return group([...docs, breakParent]);
}
function printDirectives(path, options, print) {
    const node = path.getValue();
    if (node.directives === undefined || node.directives.length === 0) {
        return "";
    }
    const directives = path.map((x) => [print(x), line], "directives");
    return group([...directives, breakParent]);
}
function printDirective(path, options, print) {
    const args = printDirectiveArgs(path, options, print);
    return ["#", path.call(print, "target"), " ", args];
}
function printDecoratorArgs(path, options, print) {
    const node = path.getValue();
    if (node.arguments.length === 0) {
        return "";
    }
    // So that decorator with single object arguments have ( and { hugging.
    // @deco({
    //   value: "foo"
    // })
    const shouldHug = node.arguments.length === 1 &&
        (node.arguments[0].kind === SyntaxKind.ModelExpression ||
            node.arguments[0].kind === SyntaxKind.StringLiteral);
    if (shouldHug) {
        return [
            "(",
            join(", ", path.map((arg) => [print(arg)], "arguments")),
            ")",
        ];
    }
    return [
        "(",
        group([
            indent(join(", ", path.map((arg) => [softline, print(arg)], "arguments"))),
            softline,
        ]),
        ")",
    ];
}
function printDirectiveArgs(path, options, print) {
    const node = path.getValue();
    if (node.arguments.length === 0) {
        return "";
    }
    return join(" ", path.map((arg) => [print(arg)], "arguments"));
}
function printEnumStatement(path, options, print) {
    const { decorators } = printDecorators(path, options, print, { tryInline: false });
    const id = path.call(print, "id");
    return [decorators, "enum ", id, " ", printEnumBlock(path, options, print)];
}
function printEnumBlock(path, options, print) {
    const node = path.getValue();
    if (node.members.length === 0) {
        return "{}";
    }
    const body = joinMembersInBlock(path, "members", options, print, ",", hardline);
    return group(["{", indent(body), hardline, "}"]);
}
function printEnumMember(path, options, print) {
    const node = path.getValue();
    const id = path.call(print, "id");
    const value = node.value ? [": ", path.call(print, "value")] : "";
    const { decorators } = printDecorators(path, options, print, {
        tryInline: DecoratorsTryInline.enumMember,
    });
    return [decorators, id, value];
}
function printEnumSpreadMember(path, options, print) {
    return ["...", path.call(print, "target")];
}
function printUnionStatement(path, options, print) {
    const id = path.call(print, "id");
    const { decorators } = printDecorators(path, options, print, { tryInline: false });
    const generic = printTemplateParameters(path, options, print, "templateParameters");
    return [decorators, "union ", id, generic, " ", printUnionVariantsBlock(path, options, print)];
}
function printUnionVariantsBlock(path, options, print) {
    const node = path.getValue();
    if (node.options.length === 0) {
        return "{}";
    }
    const body = joinMembersInBlock(path, "options", options, print, ",", hardline);
    return group(["{", indent(body), hardline, "}"]);
}
function printUnionVariant(path, options, print) {
    const id = path.node.id === undefined ? "" : [path.call(print, "id"), ": "];
    const { decorators } = printDecorators(path, options, print, {
        tryInline: DecoratorsTryInline.unionVariant,
    });
    return [decorators, id, path.call(print, "value")];
}
function printInterfaceStatement(path, options, print) {
    const id = path.call(print, "id");
    const { decorators } = printDecorators(path, options, print, { tryInline: false });
    const generic = printTemplateParameters(path, options, print, "templateParameters");
    const extendList = printInterfaceExtends(path, options, print);
    return [
        decorators,
        "interface ",
        id,
        generic,
        extendList,
        " ",
        printInterfaceMembers(path, options, print),
    ];
}
function printInterfaceExtends(path, options, print) {
    const node = path.getValue();
    if (node.extends.length === 0) {
        return "";
    }
    const keyword = "extends ";
    return [group(indent([line, keyword, indent(join([",", line], path.map(print, "extends")))]))];
}
function printInterfaceMembers(path, options, print) {
    const node = path.getValue();
    const hasOperations = node.operations.length > 0;
    const nodeHasComments = hasComments(node, CommentCheckFlags.Dangling);
    if (!hasOperations && !nodeHasComments) {
        return "{}";
    }
    const lastOperation = node.operations[node.operations.length - 1];
    const parts = [];
    path.each((operationPath) => {
        const node = operationPath.getValue();
        const printed = print(operationPath);
        parts.push(printed);
        if (node !== lastOperation) {
            parts.push(hardline);
            if (isNextLineEmpty(options.originalText, node, options.locEnd)) {
                parts.push(hardline);
            }
        }
    }, "operations");
    const body = [hardline, parts];
    if (nodeHasComments) {
        body.push(printDanglingComments(path, options, { sameIndent: true }));
    }
    return group(["{", indent(body), hardline, "}"]);
}
function printDanglingComments(path, options, { sameIndent }) {
    const node = path.getValue();
    const parts = [];
    if (!node || !node.comments) {
        return "";
    }
    path.each((commentPath) => {
        const comment = commentPath.getValue();
        if (!comment.leading && !comment.trailing) {
            parts.push(printComment(path, options));
        }
    }, "comments");
    if (parts.length === 0) {
        return "";
    }
    if (sameIndent) {
        return join(hardline, parts);
    }
    return indent([hardline, join(hardline, parts)]);
}
/**
 * Handle printing an intersection node.
 * @example `Foo & Bar` or `{foo: string} & {bar: string}`
 *
 * @param path Prettier AST Path.
 * @param options Prettier options
 * @param print Prettier child print callback.
 * @returns Prettier document.
 */
function printIntersection(path, options, print) {
    const node = path.getValue();
    const types = path.map(print, "options");
    const result = [];
    let wasIndented = false;
    for (let i = 0; i < types.length; ++i) {
        if (i === 0) {
            result.push(types[i]);
        }
        else if (isModelNode(node.options[i - 1]) && isModelNode(node.options[i])) {
            // If both are objects, don't indent
            result.push([" & ", wasIndented ? indent(types[i]) : types[i]]);
        }
        else if (!isModelNode(node.options[i - 1]) && !isModelNode(node.options[i])) {
            // If no object is involved, go to the next line if it breaks
            result.push(indent([" &", line, types[i]]));
        }
        else {
            // If you go from object to non-object or vis-versa, then inline it
            if (i > 1) {
                wasIndented = true;
            }
            result.push(" & ", i > 1 ? indent(types[i]) : types[i]);
        }
    }
    return group(result);
}
function isModelNode(node) {
    return node.kind === SyntaxKind.ModelExpression;
}
function printArray(path, options, print) {
    return [path.call(print, "elementType"), "[]"];
}
function printTuple(path, options, print) {
    return group([
        "[",
        indent(join(", ", path.map((arg) => [softline, print(arg)], "values"))),
        softline,
        "]",
    ]);
}
function printMemberExpression(path, options, print) {
    const node = path.getValue();
    return [node.base ? [path.call(print, "base"), node.selector] : "", path.call(print, "id")];
}
function printModelExpression(path, options, print) {
    const inBlock = isModelExpressionInBlock(path);
    const node = path.getValue();
    if (inBlock) {
        return group(printModelPropertiesBlock(path, options, print));
    }
    else {
        const properties = node.properties.length === 0
            ? ""
            : indent(joinMembersInBlock(path, "properties", options, print, ifBreak(",", ", "), softline));
        return group([properties, softline]);
    }
}
function printModelStatement(path, options, print) {
    const node = path.getValue();
    const id = path.call(print, "id");
    const heritage = node.extends
        ? [ifBreak(line, " "), "extends ", path.call(print, "extends")]
        : "";
    const isBase = node.is ? [ifBreak(line, " "), "is ", path.call(print, "is")] : "";
    const generic = printTemplateParameters(path, options, print, "templateParameters");
    const nodeHasComments = hasComments(node, CommentCheckFlags.Dangling);
    const shouldPrintBody = nodeHasComments || !(node.properties.length === 0 && node.is);
    const body = shouldPrintBody ? [" ", printModelPropertiesBlock(path, options, print)] : ";";
    return [
        printDecorators(path, options, print, { tryInline: false }).decorators,
        "model ",
        id,
        generic,
        group(indent(["", heritage, isBase])),
        body,
    ];
}
function printModelPropertiesBlock(path, options, print) {
    var _a;
    const node = path.getValue();
    const hasProperties = node.properties && node.properties.length > 0;
    const nodeHasComments = hasComments(node, CommentCheckFlags.Dangling);
    if (!hasProperties && !nodeHasComments) {
        return "{}";
    }
    const tryInline = ((_a = path.getParentNode()) === null || _a === void 0 ? void 0 : _a.kind) === SyntaxKind.TemplateParameterDeclaration;
    const lineDoc = tryInline ? softline : hardline;
    const seperator = isModelAValue(path) ? "," : ";";
    const body = [joinMembersInBlock(path, "properties", options, print, seperator, lineDoc)];
    if (nodeHasComments) {
        body.push(printDanglingComments(path, options, { sameIndent: true }));
    }
    return group(["{", indent(body), lineDoc, "}"]);
}
/**
 * Join members nodes that are in a block by adding extra new lines when needed.(e.g. when there are decorators or doc comments )
 * @param path Prettier AST Path.
 * @param options Prettier options
 * @param print Prettier print callback
 * @param separator Separator
 * @param regularLine What line to use when we should split lines
 * @returns
 */
function joinMembersInBlock(path, member, options, print, separator, regularLine = hardline) {
    const doc = [regularLine];
    const propertyContainerNode = path.getValue();
    let newLineBeforeNextProp = false;
    path.each((item, propertyIndex) => {
        const isFirst = propertyIndex === 0;
        const isLast = propertyIndex === propertyContainerNode[member].length - 1;
        const shouldWrapInNewLines = shouldWrapMemberInNewLines(item, options);
        if ((newLineBeforeNextProp || shouldWrapInNewLines) && !isFirst) {
            doc.push(hardline);
            newLineBeforeNextProp = false;
        }
        doc.push(print(item));
        if (isLast) {
            doc.push(ifBreak(separator));
        }
        else {
            doc.push(separator);
            doc.push(regularLine);
            if (shouldWrapInNewLines) {
                newLineBeforeNextProp = true;
            }
        }
    }, member);
    return doc;
}
/**
 * Check if property item (PropertyNode, SpreadProperty) should be wrapped in new lines.
 * It can be wrapped for the following reasons:
 * - has decorators on lines above
 * - has leading comments
 */
function shouldWrapMemberInNewLines(path, options) {
    var _a;
    const node = path.getValue();
    return ((node.kind !== SyntaxKind.ModelSpreadProperty &&
        node.kind !== SyntaxKind.ProjectionModelSpreadProperty &&
        node.kind !== SyntaxKind.EnumSpreadMember &&
        shouldDecoratorBreakLine(path, options, {
            tryInline: DecoratorsTryInline.modelProperty,
        })) ||
        hasComments(node, CommentCheckFlags.Leading) ||
        (node.docs && ((_a = node.docs) === null || _a === void 0 ? void 0 : _a.length) > 0));
}
/**
 * Figure out if this model is being used as a definition or value.
 * @returns true if the model is used as a value(e.g. decorator value), false if it is used as a model definition.
 */
function isModelAValue(path) {
    let count = 0;
    let node = path.getValue();
    do {
        switch (node.kind) {
            case SyntaxKind.ModelStatement:
            case SyntaxKind.AliasStatement:
            case SyntaxKind.OperationStatement:
                return false;
            case SyntaxKind.DecoratorExpression:
                return true;
        }
    } while ((node = path.getParentNode(count++)));
    return true;
}
function printModelProperty(path, options, print) {
    const node = path.getValue();
    const { decorators } = printDecorators(path, options, print, {
        tryInline: DecoratorsTryInline.modelProperty,
    });
    const id = printIdentifier(node.id);
    return [
        printDirectives(path, options, print),
        decorators,
        id,
        node.optional ? "?: " : ": ",
        path.call(print, "value"),
        node.default ? [" = ", path.call(print, "default")] : "",
    ];
}
function printIdentifier(id, options) {
    return printId(id.sv);
}
function printId(sv) {
    if (needBacktick(sv)) {
        const escapedString = sv
            .replace(/\\/g, "\\\\")
            .replace(/\n/g, "\\n")
            .replace(/\r/g, "\\r")
            .replace(/\t/g, "\\t")
            .replace(/`/g, "\\`");
        return `\`${escapedString}\``;
    }
    else {
        return sv;
    }
}
function needBacktick(sv) {
    if (sv.length === 0) {
        return false;
    }
    if (Keywords.has(sv)) {
        return true;
    }
    let cp = sv.codePointAt(0);
    if (!isIdentifierStart(cp)) {
        return true;
    }
    let pos = 0;
    do {
        pos += utf16CodeUnits(cp);
    } while (pos < sv.length && isIdentifierContinue((cp = sv.codePointAt(pos))));
    return pos < sv.length;
}
function isModelExpressionInBlock(path) {
    const parent = path.getParentNode();
    switch (parent === null || parent === void 0 ? void 0 : parent.kind) {
        case SyntaxKind.OperationSignatureDeclaration:
            return parent.parameters !== path.getNode();
        default:
            return true;
    }
}
function printScalarStatement(path, options, print) {
    const node = path.getValue();
    const id = path.call(print, "id");
    const template = printTemplateParameters(path, options, print, "templateParameters");
    const heritage = node.extends
        ? [ifBreak(line, " "), "extends ", path.call(print, "extends")]
        : "";
    return [
        printDecorators(path, options, print, { tryInline: false }).decorators,
        "scalar ",
        id,
        template,
        group(indent(["", heritage])),
        ";",
    ];
}
function printNamespaceStatement(path, options, print) {
    const names = path.map(print, "ids");
    const currentNode = path.getNode();
    const suffix = (currentNode === null || currentNode === void 0 ? void 0 : currentNode.statements) === undefined
        ? ";"
        : [
            " {",
            indent([hardline, printStatementSequence(path, options, print, "statements")]),
            hardline,
            "}",
        ];
    const { decorators } = printDecorators(path, options, print, { tryInline: false });
    return [decorators, `namespace `, join(".", names), suffix];
}
function printOperationSignatureDeclaration(path, options, print) {
    return ["(", path.call(print, "parameters"), "): ", path.call(print, "returnType")];
}
function printOperationSignatureReference(path, options, print) {
    return [" is ", path.call(print, "baseOperation")];
}
function printOperationStatement(path, options, print) {
    var _a;
    const inInterface = ((_a = path.getParentNode()) === null || _a === void 0 ? void 0 : _a.kind) === SyntaxKind.InterfaceStatement;
    const templateParams = printTemplateParameters(path, options, print, "templateParameters");
    const { decorators } = printDecorators(path, options, print, {
        tryInline: true,
    });
    return [
        decorators,
        inInterface ? "" : "op ",
        path.call(print, "id"),
        templateParams,
        path.call(print, "signature"),
        `;`,
    ];
}
function printStatementSequence(path, options, print, property) {
    const node = path.getValue();
    const parts = [];
    const lastStatement = getLastStatement(node[property]);
    path.each((statementPath) => {
        const node = path.getValue();
        if (node.kind === SyntaxKind.EmptyStatement) {
            return;
        }
        const printed = print(statementPath);
        parts.push(printed);
        if (node !== lastStatement) {
            parts.push(hardline);
            if (isNextLineEmpty(options.originalText, node, options.locEnd)) {
                parts.push(hardline);
            }
        }
    }, property);
    return parts;
}
function getLastStatement(statements) {
    for (let i = statements.length - 1; i >= 0; i--) {
        const statement = statements[i];
        if (statement.kind !== SyntaxKind.EmptyStatement) {
            return statement;
        }
    }
    return undefined;
}
function printUnion(path, options, print) {
    const node = path.getValue();
    const shouldHug = shouldHugType(node);
    const types = path.map((typePath) => {
        let printedType = print(typePath);
        if (!shouldHug) {
            printedType = align(2, printedType);
        }
        return printedType;
    }, "options");
    if (shouldHug) {
        return join(" | ", types);
    }
    const code = [ifBreak([line , "| "], ""), join([line, "| "], types)];
    return group(indent(code));
}
function shouldHugType(node) {
    if (node.kind === SyntaxKind.UnionExpression || node.kind === SyntaxKind.IntersectionExpression) {
        return node.options.length < 4;
    }
    return false;
}
function printTypeReference(path, options, print) {
    const type = path.call(print, "target");
    const template = printTemplateParameters(path, options, print, "arguments");
    return [type, template];
}
function printValueOfExpression(path, options, print) {
    const type = path.call(print, "target");
    return ["valueof ", type];
}
function printTemplateParameterDeclaration(path, options, print) {
    const node = path.getValue();
    return [
        path.call(print, "id"),
        node.constraint ? [" extends ", path.call(print, "constraint")] : "",
        node.default ? [" = ", path.call(print, "default")] : "",
    ];
}
function printModelSpread(path, options, print) {
    return ["...", path.call(print, "target")];
}
function printDecoratorDeclarationStatement(path, options, print) {
    const id = path.call(print, "id");
    const parameters = [
        group([
            indent(join(", ", [
                [softline, path.call(print, "target")],
                ...path.map((arg) => [softline, print(arg)], "parameters"),
            ])),
            softline,
        ]),
    ];
    return [printModifiers(path, options, print), "dec ", id, "(", parameters, ")", ";"];
}
function printFunctionDeclarationStatement(path, options, print) {
    const node = path.getValue();
    const id = path.call(print, "id");
    const parameters = [
        group([
            indent(join(", ", path.map((arg) => [softline, print(arg)], "parameters"))),
            softline,
        ]),
    ];
    const returnType = node.returnType ? [": ", path.call(print, "returnType")] : "";
    return [printModifiers(path, options, print), "fn ", id, "(", parameters, ")", returnType, ";"];
}
function printFunctionParameterDeclaration(path, options, print) {
    const node = path.getValue();
    const id = path.call(print, "id");
    const type = node.type ? [": ", path.call(print, "type")] : "";
    return [
        node.rest ? "..." : "",
        printDirectives(path, options, print),
        id,
        node.optional ? "?" : "",
        type,
    ];
}
function printModifiers(path, options, print) {
    const node = path.getValue();
    if (node.modifiers.length === 0) {
        return "";
    }
    return path.map((x) => [print(x), " "], "modifiers");
}
function printStringLiteral(path, options) {
    const node = path.getValue();
    return getRawText(node, options);
}
function printNumberLiteral(path, options) {
    const node = path.getValue();
    return getRawText(node, options);
}
function printBooleanLiteral(path, options) {
    const node = path.getValue();
    return node.value ? "true" : "false";
}
function printProjectionStatement(path, options, print) {
    const selector = path.call(print, "selector");
    const id = path.call(print, "id");
    const projections = path.map(print, "projections").flatMap((x) => [hardline, x]);
    return [
        "projection ",
        selector,
        "#",
        id,
        " {",
        indent(projections),
        projections.length > 0 ? hardline : "",
        "}",
    ];
}
function printProjection(path, options, print) {
    const node = path.getValue();
    const params = printProjectionParameters(path, options, print);
    const body = printProjectionExpressionStatements(path, options, print, "body");
    return [
        ...node.modifierIds.flatMap((i) => [i.sv, " "]),
        node.directionId.sv,
        params,
        " {",
        indent(body),
        hardline,
        "}",
    ];
}
function printProjectionParameters(path, options, print) {
    const node = path.getValue();
    const params = node.parameters;
    if (params.length === 0) {
        return "";
    }
    const shouldHug = params.length === 1;
    if (shouldHug) {
        return ["(", printItemList(path, options, print, "parameters"), ")"];
    }
    else {
        const body = indent([softline, join([", ", softline], path.map(print, "parameters"))]);
        return group(["(", body, softline, ")"]);
    }
}
function printProjectionExpressionStatements(path, options, print, key) {
    const parts = [hardline];
    const lastIndex = path.getValue()[key].length - 1;
    path.each((statementPath, index) => {
        const node = path.getValue();
        if (node.kind === SyntaxKind.EmptyStatement) {
            return;
        }
        const printed = print(statementPath);
        parts.push(printed);
        parts.push(";");
        if (index < lastIndex) {
            parts.push(hardline);
            if (isNextLineEmpty(options.originalText, node, options.locEnd)) {
                parts.push(hardline);
            }
        }
    }, key);
    return parts;
}
function printProjectionParameterDeclaration(path, options, print) {
    return path.call(print, "id");
}
function printProjectionExpressionStatement(path, options, print) {
    return path.call(print, "expr");
}
function printProjectionIfExpressionNode(path, options, print) {
    const node = path.getValue();
    const test = path.call(print, "test");
    const consequent = path.call(print, "consequent");
    const alternate = node.alternate ? [" else ", path.call(print, "alternate")] : "";
    return ["if ", test, " ", consequent, alternate];
}
function printProjectionBlockExpressionNode(path, options, print) {
    const node = path.getValue();
    if (node.statements.length === 0) {
        return "{}";
    }
    return [
        "{",
        indent(printProjectionExpressionStatements(path, options, print, "statements")),
        hardline,
        "}",
    ];
}
function printProjectionMemberExpression(path, options, print) {
    const node = path.getValue();
    return [path.call(print, "base"), node.selector, path.call(print, "id")];
}
function printProjectionLeftRightExpression(path, options, print) {
    const node = path.getValue();
    return [path.call(print, "left"), " ", node.op, " ", path.call(print, "right")];
}
function printProjectionUnaryExpression(path, options, print) {
    return ["!", path.call(print, "target")];
}
function printProjectionCallExpression(path, options, print) {
    const node = path.getValue();
    const target = path.call(print, "target");
    const params = printItemList(path, options, print, "arguments");
    if (node.callKind === "method") {
        return [target, "(", params, ")"];
    }
    else {
        return [target, "<", params, ">"];
    }
}
function printProjectionLambdaExpression(path, options, print) {
    return [
        "(",
        printItemList(path, options, print, "parameters"),
        ")",
        " => ",
        path.call(print, "body"),
    ];
}
function printProjectionLambdaParameterDeclaration(path, options, print) {
    return path.call(print, "id");
}
function printReturnExpression(path, options, print) {
    return ["return ", path.call(print, "value")];
}
function printStringTemplateExpression(path, options, print) {
    const node = path.node;
    const content = [
        getRawText(node.head, options),
        path.map((span) => {
            const expression = span.call(print, "expression");
            return [expression, getRawText(span.node.literal, options)];
        }, "spans"),
    ];
    return content;
}
function printItemList(path, options, print, key) {
    return join(", ", path.map(print, key));
}
/**
 * @param node Node that has postition information.
 * @param options Prettier options
 * @returns Raw text in the file for the given node.
 */
function getRawText(node, options) {
    return options.originalText.slice(node.pos, node.end);
}
function hasComments(node, flags) {
    if (!node.comments || node.comments.length === 0) {
        return false;
    }
    const test = getCommentTestFunction(flags);
    return test ? node.comments.some(test) : true;
}
var CommentCheckFlags;
(function (CommentCheckFlags) {
    /** Check comment is a leading comment */
    CommentCheckFlags[CommentCheckFlags["Leading"] = 2] = "Leading";
    /** Check comment is a trailing comment */
    CommentCheckFlags[CommentCheckFlags["Trailing"] = 4] = "Trailing";
    /** Check comment is a dangling comment */
    CommentCheckFlags[CommentCheckFlags["Dangling"] = 8] = "Dangling";
    /** Check comment is a block comment */
    CommentCheckFlags[CommentCheckFlags["Block"] = 16] = "Block";
    /** Check comment is a line comment */
    CommentCheckFlags[CommentCheckFlags["Line"] = 32] = "Line";
    /** Check comment is a `prettier-ignore` comment */
    CommentCheckFlags[CommentCheckFlags["PrettierIgnore"] = 64] = "PrettierIgnore";
    /** Check comment is the first attached comment */
    CommentCheckFlags[CommentCheckFlags["First"] = 128] = "First";
    /** Check comment is the last attached comment */
    CommentCheckFlags[CommentCheckFlags["Last"] = 256] = "Last";
})(CommentCheckFlags || (CommentCheckFlags = {}));
function getCommentTestFunction(flags) {
    if (flags) {
        return (comment, index, comments) => !((flags & CommentCheckFlags.Leading && !comment.leading) ||
            (flags & CommentCheckFlags.Trailing && !comment.trailing) ||
            (flags & CommentCheckFlags.Dangling && (comment.leading || comment.trailing)) ||
            (flags & CommentCheckFlags.Block && !isBlockComment(comment)) ||
            (flags & CommentCheckFlags.Line && !isLineComment(comment)) ||
            (flags & CommentCheckFlags.First && index !== 0) ||
            (flags & CommentCheckFlags.Last && index !== comments.length - 1));
    }
    return undefined;
}
function isBlockComment(comment) {
    return comment.kind === SyntaxKind.BlockComment;
}
function isLineComment(comment) {
    return comment.kind === SyntaxKind.BlockComment;
}

function isErrorType$1(type) {
    return type.kind === "Intrinsic" && type.name === "ErrorType";
}
function isVoidType(type) {
    return type.kind === "Intrinsic" && type.name === "void";
}
function isNeverType(type) {
    return type.kind === "Intrinsic" && type.name === "never";
}
function isUnknownType(type) {
    return type.kind === "Intrinsic" && type.name === "unknown";
}
function isNullType(type) {
    return type.kind === "Intrinsic" && type.name === "null";
}
/**
 * Lookup and find the node
 * @param node Node
 * @returns Template Parent node if applicable
 */
function getParentTemplateNode(node) {
    switch (node.kind) {
        case SyntaxKind.ModelStatement:
        case SyntaxKind.ScalarStatement:
        case SyntaxKind.OperationStatement:
        case SyntaxKind.InterfaceStatement:
            return node.templateParameters.length > 0 ? node : undefined;
        case SyntaxKind.OperationSignatureDeclaration:
        case SyntaxKind.ModelProperty:
        case SyntaxKind.ModelExpression:
            return node.parent ? getParentTemplateNode(node.parent) : undefined;
        default:
            return undefined;
    }
}
/**
 * Check the given type is a finished template instance.
 */
function isTemplateInstance(type) {
    const maybeTemplateType = type;
    return (maybeTemplateType.templateMapper !== undefined &&
        !maybeTemplateType.templateMapper.partial &&
        maybeTemplateType.isFinished);
}
/**
 * Check if the type is a declared type. This include:
 * - non templated type
 * - template declaration
 */
function isDeclaredType(type) {
    if (type.node === undefined) {
        return false;
    }
    const node = type.node;
    return (node.templateParameters === undefined || type.templateMapper === undefined);
}
/**
 * Resolve if the type is a template type declaration(Non initialized template type).
 */
function isTemplateDeclaration(type) {
    if (type.node === undefined) {
        return false;
    }
    const node = type.node;
    return (node.templateParameters &&
        node.templateParameters.length > 0 &&
        type.templateMapper === undefined);
}
/**
 * Resolve if the type was created from a template type or is a template type declaration.
 */
function isTemplateDeclarationOrInstance(type) {
    if (type.node === undefined) {
        return false;
    }
    const node = type.node;
    return node.templateParameters && node.templateParameters.length > 0;
}
/**
 * Check if the given namespace is the global namespace
 * @param program Program
 * @param namespace Namespace
 * @returns {boolean}
 */
function isGlobalNamespace(program, namespace) {
    return program.getGlobalNamespaceType() === namespace;
}
/**
 * Check if the given type is declared in the specified namespace or, optionally, its child namespaces.
 * @param type Type
 * @param namespace Namespace
 * @returns {boolean}
 */
function isDeclaredInNamespace(type, namespace, options = { recursive: true }) {
    let candidateNs = type.namespace;
    while (candidateNs) {
        if (candidateNs === namespace) {
            return true;
        }
        // Operations can be defined inside of an interface that is defined in the
        // desired namespace
        if (type.kind === "Operation" && type.interface && type.interface.namespace === namespace) {
            return true;
        }
        // If we are allowed to check recursively, walk up the namespace hierarchy
        candidateNs = options.recursive ? candidateNs.namespace : undefined;
    }
    return false;
}
function getFullyQualifiedSymbolName(sym, options) {
    if (!sym)
        return "";
    if (sym.symbolSource)
        sym = sym.symbolSource;
    const parent = sym.parent && !(sym.parent.flags & 2097152 /* SymbolFlags.SourceFile */) ? sym.parent : undefined;
    const name = sym.flags & 16384 /* SymbolFlags.Decorator */ ? sym.name.slice(1) : sym.name;
    if (parent === null || parent === void 0 ? void 0 : parent.name) {
        return `${getFullyQualifiedSymbolName(parent)}.${name}`;
    }
    else if (options === null || options === void 0 ? void 0 : options.useGlobalPrefixAtTopLevel) {
        return `global.${name}`;
    }
    else {
        return name;
    }
}

function getTypeName(type, options) {
    switch (type.kind) {
        case "Namespace":
            return getNamespaceFullName(type, options);
        case "TemplateParameter":
            return getIdentifierName(type.node.id.sv, options);
        case "Scalar":
            return getScalarName(type, options);
        case "Model":
            return getModelName(type, options);
        case "ModelProperty":
            return getModelPropertyName(type, options);
        case "Interface":
            return getInterfaceName(type, options);
        case "Operation":
            return getOperationName(type, options);
        case "Enum":
            return getEnumName(type, options);
        case "EnumMember":
            return `${getEnumName(type.enum, options)}.${getIdentifierName(type.name, options)}`;
        case "Union":
            return getUnionName(type, options);
        case "UnionVariant":
            return getTypeName(type.type, options);
        case "Tuple":
            return "[" + type.values.map((x) => getTypeName(x, options)).join(", ") + "]";
        case "StringTemplate":
            return "string";
        case "String":
        case "Number":
        case "Boolean":
            return type.value.toString();
        case "Intrinsic":
            return type.name;
        case "Value":
            return `valueof ${getTypeName(type.target, options)}`;
    }
    return "(unnamed type)";
}
function isStdNamespace(namespace) {
    var _a, _b, _c, _d;
    return ((namespace.name === "TypeSpec" && ((_a = namespace.namespace) === null || _a === void 0 ? void 0 : _a.name) === "") ||
        (namespace.name === "Reflection" &&
            ((_b = namespace.namespace) === null || _b === void 0 ? void 0 : _b.name) === "TypeSpec" &&
            ((_d = (_c = namespace.namespace) === null || _c === void 0 ? void 0 : _c.namespace) === null || _d === void 0 ? void 0 : _d.name) === ""));
}
/**
 * Return the full name of the namespace(e.g. "Foo.Bar")
 * @param type namespace type
 * @param options
 * @returns
 */
function getNamespaceFullName(type, options) {
    const filter = options === null || options === void 0 ? void 0 : options.namespaceFilter;
    const segments = [];
    let current = type;
    while (current && current.name !== "") {
        if (filter && !filter(current)) {
            break;
        }
        segments.unshift(getIdentifierName(current.name, options));
        current = current.namespace;
    }
    return segments.join(".");
}
function getNamespacePrefix(type, options) {
    if (type === undefined || isStdNamespace(type)) {
        return "";
    }
    const namespaceFullName = getNamespaceFullName(type, options);
    return namespaceFullName !== "" ? namespaceFullName + "." : "";
}
function getEnumName(e, options) {
    return `${getNamespacePrefix(e.namespace, options)}${getIdentifierName(e.name, options)}`;
}
function getScalarName(scalar, options) {
    return `${getNamespacePrefix(scalar.namespace, options)}${getIdentifierName(scalar.name, options)}`;
}
function getModelName(model, options) {
    var _a, _b;
    const nsPrefix = getNamespacePrefix(model.namespace, options);
    if (model.name === "" && model.properties.size === 0) {
        return "{}";
    }
    if (model.indexer && model.indexer.key.kind === "Scalar") {
        if (model.name === "Array" && isInTypeSpecNamespace(model)) {
            return `${getTypeName(model.indexer.value, options)}[]`;
        }
    }
    if (model.name === "") {
        return nsPrefix + "(anonymous model)";
    }
    const modelName = nsPrefix + getIdentifierName(model.name, options);
    if (isTemplateInstance(model)) {
        // template instantiation
        const args = model.templateMapper.args.map((x) => getTypeName(x, options));
        return `${modelName}<${args.join(", ")}>`;
    }
    else if (((_b = (_a = model.node) === null || _a === void 0 ? void 0 : _a.templateParameters) === null || _b === void 0 ? void 0 : _b.length) > 0) {
        // template
        const params = model.node.templateParameters.map((t) => getIdentifierName(t.id.sv, options));
        return `${modelName}<${params.join(", ")}>`;
    }
    else {
        // regular old model.
        return modelName;
    }
}
function getUnionName(type, options) {
    const nsPrefix = getNamespacePrefix(type.namespace, options);
    const typeName = type.name
        ? getIdentifierName(type.name, options)
        : [...type.variants.values()].map((x) => getTypeName(x.type, options)).join(" | ");
    return nsPrefix + typeName;
}
/**
 * Check if the given namespace is the standard library `TypeSpec` namespace.
 */
function isTypeSpecNamespace(namespace) {
    var _a;
    return namespace.name === "TypeSpec" && ((_a = namespace.namespace) === null || _a === void 0 ? void 0 : _a.name) === "";
}
/**
 * Check if the given type is defined right in the TypeSpec namespace.
 */
function isInTypeSpecNamespace(type) {
    return Boolean(type.namespace && isTypeSpecNamespace(type.namespace));
}
function getModelPropertyName(prop, options) {
    const modelName = prop.model ? getModelName(prop.model, options) : undefined;
    return `${modelName !== null && modelName !== void 0 ? modelName : "(anonymous model)"}.${prop.name}`;
}
function getInterfaceName(iface, options) {
    let interfaceName = getIdentifierName(iface.name, options);
    if (isTemplateInstance(iface)) {
        interfaceName += `<${iface.templateMapper.args
            .map((x) => getTypeName(x, options))
            .join(", ")}>`;
    }
    return `${getNamespacePrefix(iface.namespace, options)}${interfaceName}`;
}
function getOperationName(op, options) {
    return `${getNamespacePrefix(op.namespace, options)}${getIdentifierName(op.name, options)}`;
}
function getIdentifierName(name, options) {
    return (options === null || options === void 0 ? void 0 : options.printable) ? printId(name) : name;
}

/**
 * Validate the decorator target is matching the expected value.
 * @param program
 * @param target
 * @param expectedType
 * @param decoratorName
 * @returns
 */
function validateDecoratorTarget(context, target, decoratorName, expectedType) {
    const isCorrectType = isTypeSpecValueTypeOf(target, expectedType);
    if (!isCorrectType) {
        reportDiagnostic(context.program, {
            code: "decorator-wrong-target",
            format: {
                decorator: decoratorName,
                to: target.kind,
            },
            target: context.decoratorTarget,
        });
        return false;
    }
    return true;
}
function isIntrinsicType(program, type, kind) {
    var _a;
    return ignoreDiagnostics(program.checker.isTypeAssignableTo((_a = type.projectionBase) !== null && _a !== void 0 ? _a : type, program.checker.getStdType(kind), type));
}
/**
 * @deprecated this function is deprecated use decorator definition in typespec instead or check assignability directly.
 */
function validateDecoratorTargetIntrinsic(context, target, decoratorName, expectedType) {
    const expectedTypeStrs = typeof expectedType === "string" ? [expectedType] : expectedType;
    const expectedTypes = expectedTypeStrs.map((x) => context.program.checker.getStdType(x));
    const type = getPropertyType(target);
    const isCorrect = expectedTypes.some((x) => context.program.checker.isTypeAssignableTo(type, x, type)[0]);
    if (!isCorrect) {
        context.program.reportDiagnostic(createDiagnostic({
            code: "decorator-wrong-target",
            format: {
                decorator: decoratorName,
                to: `type it is not one of: ${expectedTypeStrs.join(", ")}`,
            },
            target: context.decoratorTarget,
        }));
        return false;
    }
    return true;
}
/** @deprecated use isTypeSpecValueTypeOf */
const isCadlValueTypeOf = isTypeSpecValueTypeOf;
/**
 * Check if the given target is of any of the typespec types.
 * @param target Target to validate.
 * @param expectedType One or multiple allowed typespec types.
 * @returns boolean if the target is of one of the allowed types.
 */
function isTypeSpecValueTypeOf(target, expectedType) {
    const kind = getTypeKind(target);
    if (kind === undefined) {
        return false;
    }
    return typeof expectedType === "string"
        ? expectedType === "Any" || kind === expectedType
        : expectedType.includes("Any") || expectedType.includes(kind);
}
function getTypeKind(target) {
    switch (typeof target) {
        case "object":
            return target.kind;
        case "string":
            return "String";
        case "number":
            return "Number";
        case "boolean":
            return "Boolean";
        default:
            return undefined;
    }
}
/**
 * Validate a decorator parameter has the correct type.
 * @param program Program
 * @param target Decorator target
 * @param value Value of the parameter.
 * @param expectedType Expected type or list of expected type
 * @returns true if the value is of one of the type in the list of expected types. If not emit a diagnostic.
 * @deprecated use @see createDecoratorDefinition#validate instead.
 */
function validateDecoratorParamType(program, target, value, expectedType) {
    if (!isTypeSpecValueTypeOf(value, expectedType)) {
        reportDiagnostic(program, {
            code: "invalid-argument",
            format: {
                value: prettyValue(program, value),
                expected: typeof expectedType === "string" ? expectedType : expectedType.join(", "),
            },
            target,
        });
        return false;
    }
    return true;
}
/**
 * @deprecated use extern dec definition in typespec instead.
 */
function createDecoratorDefinition(definition) {
    const minParams = definition.args.filter((x) => !x.optional).length;
    const maxParams = definition.spreadArgs ? undefined : definition.args.length;
    function validate(context, target, args) {
        var _a;
        if (!validateDecoratorTarget(context, target, definition.name, definition.target) ||
            !validateDecoratorParamCount(context, minParams, maxParams, args)) {
            return false;
        }
        for (const [index, arg] of args.entries()) {
            const paramDefinition = (_a = definition.args[index]) !== null && _a !== void 0 ? _a : definition.spreadArgs;
            if (arg === undefined) {
                if (!paramDefinition.optional) {
                    reportDiagnostic(context.program, {
                        code: "invalid-argument",
                        format: {
                            value: "undefined",
                            expected: expectedTypeList(paramDefinition.kind),
                        },
                        target: context.getArgumentTarget(index),
                    });
                    return false;
                }
            }
            else if (!isTypeSpecValueTypeOf(arg, paramDefinition.kind)) {
                reportDiagnostic(context.program, {
                    code: "invalid-argument",
                    format: {
                        value: prettyValue(context.program, arg),
                        expected: expectedTypeList(paramDefinition.kind),
                    },
                    target: context.getArgumentTarget(index),
                });
                return false;
            }
        }
        return true;
    }
    return {
        validate(context, target, parameters) {
            return validate(context, target, parameters);
        },
    };
}
function expectedTypeList(expectedType) {
    return typeof expectedType === "string" ? expectedType : expectedType.join(", ");
}
function validateDecoratorParamCount(context, min, max, parameters) {
    let missing = 0;
    for (let i = parameters.length - 1; i >= 0; i--) {
        if (parameters[i] === undefined) {
            missing++;
        }
        else {
            break;
        }
    }
    const parameterCount = parameters.length - missing;
    if (parameterCount < min || (max !== undefined && parameterCount > max)) {
        if (min === max) {
            reportDiagnostic(context.program, {
                code: "invalid-argument-count",
                format: {
                    actual: parameterCount.toString(),
                    expected: min.toString(),
                },
                target: context.decoratorTarget,
            });
        }
        else {
            reportDiagnostic(context.program, {
                code: "invalid-argument-count",
                format: {
                    actual: parameterCount.toString(),
                    expected: `${min}-${max === undefined ? "infinity" : max.toString()}`,
                },
                target: context.decoratorTarget,
            });
        }
        return false;
    }
    return true;
}
function prettyValue(program, value) {
    if (typeof value === "object" && value !== null && "kind" in value) {
        return getTypeName(value);
    }
    return value;
}
/** @deprecated use typespecTypeToJson */
const cadlTypeToJson = typespecTypeToJson;
/**
 * Convert a typespec type to a serializable Json object.
 * Emits diagnostics if the given type is invalid
 * @param typespecType The type to convert to Json data
 * @param target The diagnostic target in case of errors.
 */
function typespecTypeToJson(typespecType, target) {
    if (typeof typespecType !== "object") {
        return [typespecType, []];
    }
    return typespecTypeToJsonInternal(typespecType, target, []);
}
function typespecTypeToJsonInternal(typespecType, target, path) {
    var _a;
    switch (typespecType.kind) {
        case "String":
        case "Boolean":
        case "Number":
            return [typespecType.value, []];
        case "EnumMember":
            return [(_a = typespecType.value) !== null && _a !== void 0 ? _a : typespecType.name, []];
        case "Tuple": {
            const result = [];
            for (const [index, type] of typespecType.values.entries()) {
                const [item, diagnostics] = typespecTypeToJsonInternal(type, target, [
                    ...path,
                    index.toString(),
                ]);
                if (diagnostics.length > 0) {
                    return [undefined, diagnostics];
                }
                result.push(item);
            }
            return [result, []];
        }
        case "Model": {
            const result = {};
            for (const [name, type] of typespecType.properties.entries()) {
                const [item, diagnostics] = typespecTypeToJsonInternal(type.type, target, [
                    ...path,
                    name.toString(),
                ]);
                if (diagnostics.length > 0) {
                    return [undefined, diagnostics];
                }
                result[name] = item;
            }
            return [result, []];
        }
        default:
            const diagnostic = path.length === 0
                ? createDiagnostic({
                    code: "invalid-value",
                    format: {
                        kind: typespecType.kind,
                    },
                    target,
                })
                : createDiagnostic({
                    code: "invalid-value",
                    messageId: "atPath",
                    format: {
                        kind: typespecType.kind,
                        path: path.join("."),
                    },
                    target,
                });
            return [undefined, [diagnostic]];
    }
}
function validateDecoratorUniqueOnNode(context, type, decorator) {
    compilerAssert("decorators" in type, "Type should have decorators");
    const sameDecorators = type.decorators.filter((x) => {
        var _a, _b;
        return x.decorator === decorator &&
            ((_a = x.node) === null || _a === void 0 ? void 0 : _a.kind) === SyntaxKind.DecoratorExpression &&
            ((_b = x.node) === null || _b === void 0 ? void 0 : _b.parent) === type.node;
    });
    if (sameDecorators.length > 1) {
        reportDiagnostic(context.program, {
            code: "duplicate-decorator",
            format: { decoratorName: "@" + decorator.name.slice(1) },
            target: context.decoratorTarget,
        });
        return false;
    }
    return true;
}
/**
 * Validate that a given decorator is not on a type or any of its base types.
 * Useful to check for decorator usage that conflicts with another decorator.
 * @param context Decorator context
 * @param type The type to check
 * @param badDecorator The decorator we don't want present
 * @param givenDecorator The decorator that is the reason why we don't want the bad decorator present
 * @param includeHeritage Whether to check base types for the bad decorator too
 * @returns Whether the decorator application is valid
 */
function validateDecoratorNotOnType(context, type, badDecorator, givenDecorator) {
    compilerAssert("decorators" in type, "Type should have decorators");
    const decAppsToCheck = [];
    let base = type;
    while (base) {
        decAppsToCheck.push(...base.decorators);
        base = getHeritage(base);
    }
    for (const decapp of decAppsToCheck) {
        if (decapp.decorator === badDecorator) {
            reportDiagnostic(context.program, {
                code: "decorator-conflict",
                format: {
                    decoratorName: "@" + badDecorator.name.slice(1),
                    otherDecoratorName: "@" + givenDecorator.name.slice(1),
                },
                target: context.decoratorTarget,
            });
            return false;
        }
    }
    return true;
    function getHeritage(type) {
        if (type.kind === "Model") {
            return type.baseModel;
        }
        else if (type.kind === "Scalar") {
            return type.baseScalar;
        }
        else {
            return undefined;
        }
    }
}

function createStateSymbol$1(name) {
    return Symbol.for(`TypeSpec.${name}`);
}
const deprecatedKey = createStateSymbol$1("deprecated");
/**
 * Check if the given type is deprecated
 * @param program Program
 * @param type Type
 */
function isDeprecated(program, type) {
    return program.stateMap(deprecatedKey).has(type);
}
/**
 * Returns complete deprecation details for the given type or node
 * @param program Program
 * @param typeOrNode A Type or Node to check for deprecation
 */
function getDeprecationDetails(program, typeOrNode) {
    var _a;
    function isType(maybeType) {
        return typeof maybeType.kind === "string";
    }
    // If we're looking at a type, pull the deprecation details from the state map
    if (isType(typeOrNode)) {
        return program.stateMap(deprecatedKey).get(typeOrNode);
    }
    else {
        // Look at the node for a deprecation directive
        const deprecatedDirective = ((_a = typeOrNode.directives) !== null && _a !== void 0 ? _a : []).find((directive) => directive.target.sv === "deprecated");
        if ((deprecatedDirective === null || deprecatedDirective === void 0 ? void 0 : deprecatedDirective.arguments[0].kind) === SyntaxKind.StringLiteral) {
            return {
                message: deprecatedDirective.arguments[0].value,
            };
        }
    }
    return undefined;
}
/**
 * Mark the given type as deprecated with the provided details.
 * @param program Program
 * @param type Type
 * @param details Details of the deprecation
 */
function markDeprecated(program, type, details) {
    program.stateMap(deprecatedKey).set(type, details);
}

const serviceDetailsKey = Symbol.for("@typespec/compiler.services");
function getServiceMap(program) {
    return program.stateMap(serviceDetailsKey);
}
/**
 * List all the services defined in the typespec program
 * @param program Program
 * @returns List of service.
 */
function listServices(program) {
    return [...getServiceMap(program).values()];
}
/**
 * Get the service information for the given namespace.
 * @param program Program
 * @param namespace Service namespace
 * @returns Service information or undefined if namespace is not a service namespace.
 */
function getService(program, namespace) {
    return getServiceMap(program).get(namespace);
}
/**
 * Check if the namespace is defined as a service.
 * @param program Program
 * @param namespace Namespace
 * @returns Boolean
 */
function isService(program, namespace) {
    return getServiceMap(program).has(namespace);
}
/**
 * Mark the given namespace as a service.
 * @param program Program
 * @param namespace Namespace
 * @param details Service details
 */
function addService(program, namespace, details = {}) {
    var _a;
    const serviceMap = getServiceMap(program);
    const existing = (_a = serviceMap.get(namespace)) !== null && _a !== void 0 ? _a : {};
    serviceMap.set(namespace, { ...existing, ...details, type: namespace });
}
function $service(context, target, options) {
    var _a, _b;
    validateDecoratorUniqueOnNode(context, target, $service);
    const serviceDetails = {};
    const title = (_a = options === null || options === void 0 ? void 0 : options.properties.get("title")) === null || _a === void 0 ? void 0 : _a.type;
    const version = (_b = options === null || options === void 0 ? void 0 : options.properties.get("version")) === null || _b === void 0 ? void 0 : _b.type;
    if (title) {
        if (title.kind === "String") {
            serviceDetails.title = title.value;
        }
        else {
            reportDiagnostic(context.program, {
                code: "unassignable",
                format: { value: getTypeName(title), targetType: "String" },
                target: context.getArgumentTarget(0),
            });
        }
    }
    if (version) {
        if (version.kind === "String") {
            serviceDetails.version = version.value;
        }
        else {
            reportDiagnostic(context.program, {
                code: "unassignable",
                format: { value: getTypeName(version), targetType: "String" },
                target: context.getArgumentTarget(0),
            });
        }
    }
    addService(context.program, target, serviceDetails);
}

const namespace = "TypeSpec";
function replaceTemplatedStringFromProperties(formatString, sourceObject) {
    // Template parameters are not valid source objects, just skip them
    if (sourceObject.kind === "TemplateParameter") {
        return formatString;
    }
    return formatString.replace(/{(\w+)}/g, (_, propName) => {
        return sourceObject[propName];
    });
}
function createStateSymbol(name) {
    return Symbol.for(`TypeSpec.${name}`);
}
const summaryKey = createStateSymbol("summary");
/**
 * @summary attaches a documentation string. It is typically used to give a short, single-line
 * description, and can be used in combination with or instead of @doc.
 *
 * The first argument to @summary is a string, which may contain template parameters, enclosed in braces,
 * which are replaced with an attribute for the type (commonly "name") passed as the second (optional) argument.
 *
 * @summary can be specified on any language element -- a model, an operation, a namespace, etc.
 */
function $summary(context, target, text, sourceObject) {
    if (sourceObject) {
        text = replaceTemplatedStringFromProperties(text, sourceObject);
    }
    context.program.stateMap(summaryKey).set(target, text);
}
function getSummary(program, type) {
    return program.stateMap(summaryKey).get(type);
}
const docsKey = createStateSymbol("docs");
const returnsDocsKey = createStateSymbol("returnsDocs");
const errorsDocsKey = createStateSymbol("errorDocs");
/**
 * @doc attaches a documentation string. Works great with multi-line string literals.
 *
 * The first argument to @doc is a string, which may contain template parameters, enclosed in braces,
 * which are replaced with an attribute for the type (commonly "name") passed as the second (optional) argument.
 *
 * @doc can be specified on any language element -- a model, an operation, a namespace, etc.
 */
function $doc(context, target, text, sourceObject) {
    validateDecoratorUniqueOnNode(context, target, $doc);
    if (sourceObject) {
        text = replaceTemplatedStringFromProperties(text, sourceObject);
    }
    setDocData(context.program, target, "self", { value: text, source: "decorator" });
}
/**
 * @internal to be used to set the `@doc` from doc comment.
 */
function $docFromComment(context, target, key, text) {
    setDocData(context.program, target, key, { value: text, source: "comment" });
}
function getDocKey(target) {
    switch (target) {
        case "self":
            return docsKey;
        case "returns":
            return returnsDocsKey;
        case "errors":
            return errorsDocsKey;
    }
}
function setDocData(program, target, key, data) {
    program.stateMap(getDocKey(key)).set(target, data);
}
/**
 * Get the documentation information for the given type. In most cases you probably just want to use {@link getDoc}
 * @param program Program
 * @param target Type
 * @returns Doc data with source information.
 */
function getDocDataInternal(program, target, key) {
    return program.stateMap(getDocKey(key)).get(target);
}
/**
 * Get the documentation information for the given type. In most cases you probably just want to use {@link getDoc}
 * @param program Program
 * @param target Type
 * @returns Doc data with source information.
 */
function getDocData(program, target) {
    return getDocDataInternal(program, target, "self");
}
/**
 * Get the documentation string for the given type.
 * @param program Program
 * @param target Type
 * @returns Documentation value
 */
function getDoc(program, target) {
    var _a;
    return (_a = getDocDataInternal(program, target, "self")) === null || _a === void 0 ? void 0 : _a.value;
}
function $returnsDoc(context, target, text) {
    validateDecoratorUniqueOnNode(context, target, $doc);
    setDocData(context.program, target, "returns", { value: text, source: "decorator" });
}
/**
 * Get the documentation information for the return success types of an operation. In most cases you probably just want to use {@link getReturnsDoc}
 * @param program Program
 * @param target Type
 * @returns Doc data with source information.
 */
function getReturnsDocData(program, target) {
    return getDocDataInternal(program, target, "returns");
}
/**
 * Get the documentation string for the return success types of an operation.
 * @param program Program
 * @param target Type
 * @returns Documentation value
 */
function getReturnsDoc(program, target) {
    var _a;
    return (_a = getDocDataInternal(program, target, "returns")) === null || _a === void 0 ? void 0 : _a.value;
}
function $errorsDoc(context, target, text) {
    validateDecoratorUniqueOnNode(context, target, $doc);
    setDocData(context.program, target, "errors", { value: text, source: "decorator" });
}
/**
 * Get the documentation information for the return errors types of an operation. In most cases you probably just want to use {@link getErrorsDoc}
 * @param program Program
 * @param target Type
 * @returns Doc data with source information.
 */
function getErrorsDocData(program, target) {
    return getDocDataInternal(program, target, "errors");
}
/**
 * Get the documentation string for the return errors types of an operation.
 * @param program Program
 * @param target Type
 * @returns Documentation value
 */
function getErrorsDoc(program, target) {
    var _a;
    return (_a = getDocDataInternal(program, target, "errors")) === null || _a === void 0 ? void 0 : _a.value;
}
function $inspectType(program, target, text) {
    // eslint-disable-next-line no-console
    if (text)
        console.log(text);
    // eslint-disable-next-line no-console
    console.dir(target, { depth: 3 });
}
function $inspectTypeName(program, target, text) {
    // eslint-disable-next-line no-console
    if (text)
        console.log(text);
    // eslint-disable-next-line no-console
    console.log(getTypeName(target));
}
const indexTypeKey = createStateSymbol("index");
function $indexer(context, target, key, value) {
    const indexer = { key, value };
    context.program.stateMap(indexTypeKey).set(target, indexer);
}
function getIndexer(program, target) {
    return program.stateMap(indexTypeKey).get(target);
}
function isStringType(program, target) {
    const coreType = program.checker.getStdType("string");
    const stringType = target.projector ? target.projector.projectType(coreType) : coreType;
    return (target.kind === "Scalar" && program.checker.isTypeAssignableTo(target, stringType, target)[0]);
}
function isNumericType(program, target) {
    const coreType = program.checker.getStdType("numeric");
    const numericType = target.projector ? target.projector.projectType(coreType) : coreType;
    return (target.kind === "Scalar" && program.checker.isTypeAssignableTo(target, numericType, target)[0]);
}
/**
 * Check the given type is matching the given condition or is a union of null and types matching the condition.
 * @param type Type to test
 * @param condition Condition
 * @returns Boolean
 */
function isTypeIn(type, condition) {
    if (type.kind === "Union") {
        return [...type.variants.values()].some((v) => condition(v.type));
    }
    return condition(type);
}
function validateTargetingANumeric(context, target, decoratorName) {
    const valid = isTypeIn(getPropertyType(target), (x) => isNumericType(context.program, x));
    if (!valid) {
        reportDiagnostic(context.program, {
            code: "decorator-wrong-target",
            format: {
                decorator: decoratorName,
                to: `type it is not a numeric`,
            },
            target: context.decoratorTarget,
        });
    }
    return valid;
}
/**
 * Validate the given target is a string type or a union containing at least a string type.
 */
function validateTargetingAString(context, target, decoratorName) {
    const valid = isTypeIn(getPropertyType(target), (x) => isStringType(context.program, x));
    if (!valid) {
        reportDiagnostic(context.program, {
            code: "decorator-wrong-target",
            format: {
                decorator: decoratorName,
                to: `type it is not a string`,
            },
            target: context.decoratorTarget,
        });
    }
    return valid;
}
/**
 * @param type Model type
 */
function isArrayModelType(program, type) {
    return Boolean(type.indexer && type.indexer.key.name === "integer");
}
/**
 * Check if a model is an array type.
 * @param type Model type
 */
function isRecordModelType(program, type) {
    return Boolean(type.indexer && type.indexer.key.name === "string");
}
/**
 * Return the type of the property or the model itself.
 */
function getPropertyType(target) {
    if (target.kind === "ModelProperty") {
        return target.type;
    }
    else {
        return target;
    }
}
// -- @error decorator ----------------------
const errorKey = createStateSymbol("error");
/**
 * `@error` decorator marks a model as an error type.
 *
 * `@error` can only be specified on a model.
 */
function $error(context, entity) {
    validateDecoratorUniqueOnNode(context, entity, $error);
    context.program.stateSet(errorKey).add(entity);
}
function isErrorModel(program, target) {
    return program.stateSet(errorKey).has(target);
}
// -- @format decorator ---------------------
const formatValuesKey = createStateSymbol("formatValues");
/**
 * `@format` - specify the data format hint for a string type
 *
 * The first argument is a string that identifies the format that the string type expects.  Any string
 * can be entered here, but a TypeSpec emitter must know how to interpret
 *
 * For TypeSpec specs that will be used with an OpenAPI emitter, the OpenAPI specification describes possible
 * valid values for a string type's format:
 *
 * https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#dataTypes
 *
 * `@format` can be specified on a type that extends from `string` or a `string`-typed model property.
 */
function $format(context, target, format) {
    validateDecoratorUniqueOnNode(context, target, $format);
    if (!validateTargetingAString(context, target, "@format")) {
        return;
    }
    const targetType = getPropertyType(target);
    if (targetType.kind === "Scalar" && isIntrinsicType(context.program, targetType, "bytes")) {
        reportDeprecated(context.program, "Using `@format` on a bytes scalar is deprecated. Use `@encode` instead. https://github.com/microsoft/typespec/issues/1873", target);
    }
    context.program.stateMap(formatValuesKey).set(target, format);
}
function getFormat(program, target) {
    return program.stateMap(formatValuesKey).get(target);
}
// -- @pattern decorator ---------------------
const patternValuesKey = createStateSymbol("patternValues");
function $pattern(context, target, pattern) {
    validateDecoratorUniqueOnNode(context, target, $pattern);
    if (!validateTargetingAString(context, target, "@pattern")) {
        return;
    }
    context.program.stateMap(patternValuesKey).set(target, pattern);
}
function getPattern(program, target) {
    return program.stateMap(patternValuesKey).get(target);
}
// -- @minLength decorator ---------------------
const minLengthValuesKey = createStateSymbol("minLengthValues");
function $minLength(context, target, minLength) {
    validateDecoratorUniqueOnNode(context, target, $minLength);
    if (!validateTargetingAString(context, target, "@minLength") ||
        !validateRange(context, minLength, getMaxLength(context.program, target))) {
        return;
    }
    context.program.stateMap(minLengthValuesKey).set(target, minLength);
}
function getMinLength(program, target) {
    return program.stateMap(minLengthValuesKey).get(target);
}
// -- @maxLength decorator ---------------------
const maxLengthValuesKey = createStateSymbol("maxLengthValues");
function $maxLength(context, target, maxLength) {
    validateDecoratorUniqueOnNode(context, target, $maxLength);
    if (!validateTargetingAString(context, target, "@maxLength") ||
        !validateRange(context, getMinLength(context.program, target), maxLength)) {
        return;
    }
    context.program.stateMap(maxLengthValuesKey).set(target, maxLength);
}
function getMaxLength(program, target) {
    return program.stateMap(maxLengthValuesKey).get(target);
}
// -- @minItems decorator ---------------------
const minItemsValuesKey = createStateSymbol("minItems");
function $minItems(context, target, minItems) {
    validateDecoratorUniqueOnNode(context, target, $minItems);
    if (!isArrayModelType(context.program, target.kind === "Model" ? target : target.type)) {
        reportDiagnostic(context.program, {
            code: "decorator-wrong-target",
            format: {
                decorator: "@minItems",
                to: `non Array type`,
            },
            target: context.decoratorTarget,
        });
    }
    if (!validateRange(context, minItems, getMaxItems(context.program, target))) {
        return;
    }
    context.program.stateMap(minItemsValuesKey).set(target, minItems);
}
function getMinItems(program, target) {
    return program.stateMap(minItemsValuesKey).get(target);
}
// -- @maxLength decorator ---------------------
const maxItemsValuesKey = createStateSymbol("maxItems");
function $maxItems(context, target, maxItems) {
    validateDecoratorUniqueOnNode(context, target, $maxItems);
    if (!isArrayModelType(context.program, target.kind === "Model" ? target : target.type)) {
        reportDiagnostic(context.program, {
            code: "decorator-wrong-target",
            format: {
                decorator: "@maxItems",
                to: `non Array type`,
            },
            target: context.decoratorTarget,
        });
    }
    if (!validateRange(context, getMinItems(context.program, target), maxItems)) {
        return;
    }
    context.program.stateMap(maxItemsValuesKey).set(target, maxItems);
}
function getMaxItems(program, target) {
    return program.stateMap(maxItemsValuesKey).get(target);
}
// -- @minValue decorator ---------------------
const minValuesKey = createStateSymbol("minValues");
function $minValue(context, target, minValue) {
    var _a;
    validateDecoratorUniqueOnNode(context, target, $minValue);
    validateDecoratorNotOnType(context, target, $minValueExclusive, $minValue);
    const { program } = context;
    if (!validateTargetingANumeric(context, target, "@minValue")) {
        return;
    }
    if (!validateRange(context, minValue, (_a = getMaxValue(context.program, target)) !== null && _a !== void 0 ? _a : getMaxValueExclusive(context.program, target))) {
        return;
    }
    program.stateMap(minValuesKey).set(target, minValue);
}
function getMinValue(program, target) {
    return program.stateMap(minValuesKey).get(target);
}
// -- @maxValue decorator ---------------------
const maxValuesKey = createStateSymbol("maxValues");
function $maxValue(context, target, maxValue) {
    var _a;
    validateDecoratorUniqueOnNode(context, target, $maxValue);
    validateDecoratorNotOnType(context, target, $maxValueExclusive, $maxValue);
    const { program } = context;
    if (!validateTargetingANumeric(context, target, "@maxValue")) {
        return;
    }
    if (!validateRange(context, (_a = getMinValue(context.program, target)) !== null && _a !== void 0 ? _a : getMinValueExclusive(context.program, target), maxValue)) {
        return;
    }
    program.stateMap(maxValuesKey).set(target, maxValue);
}
function getMaxValue(program, target) {
    return program.stateMap(maxValuesKey).get(target);
}
// -- @minValueExclusive decorator ---------------------
const minValueExclusiveKey = createStateSymbol("minValueExclusive");
function $minValueExclusive(context, target, minValueExclusive) {
    var _a;
    validateDecoratorUniqueOnNode(context, target, $minValueExclusive);
    validateDecoratorNotOnType(context, target, $minValue, $minValueExclusive);
    const { program } = context;
    if (!validateTargetingANumeric(context, target, "@minValueExclusive")) {
        return;
    }
    if (!validateRange(context, minValueExclusive, (_a = getMaxValue(context.program, target)) !== null && _a !== void 0 ? _a : getMaxValueExclusive(context.program, target))) {
        return;
    }
    program.stateMap(minValueExclusiveKey).set(target, minValueExclusive);
}
function getMinValueExclusive(program, target) {
    return program.stateMap(minValueExclusiveKey).get(target);
}
// -- @maxValueExclusive decorator ---------------------
const maxValueExclusiveKey = createStateSymbol("maxValueExclusive");
function $maxValueExclusive(context, target, maxValueExclusive) {
    var _a;
    validateDecoratorUniqueOnNode(context, target, $maxValueExclusive);
    validateDecoratorNotOnType(context, target, $maxValue, $maxValueExclusive);
    const { program } = context;
    if (!validateTargetingANumeric(context, target, "@maxValueExclusive")) {
        return;
    }
    if (!validateRange(context, (_a = getMinValue(context.program, target)) !== null && _a !== void 0 ? _a : getMinValueExclusive(context.program, target), maxValueExclusive)) {
        return;
    }
    program.stateMap(maxValueExclusiveKey).set(target, maxValueExclusive);
}
function getMaxValueExclusive(program, target) {
    return program.stateMap(maxValueExclusiveKey).get(target);
}
// -- @secret decorator ---------------------
const secretTypesKey = createStateSymbol("secretTypes");
/**
 * Mark a string as a secret value that should be treated carefully to avoid exposure
 * @param context Decorator context
 * @param target Decorator target, either a string model or a property with type string.
 */
function $secret(context, target) {
    validateDecoratorUniqueOnNode(context, target, $secret);
    if (!validateTargetingAString(context, target, "@secret")) {
        return;
    }
    context.program.stateMap(secretTypesKey).set(target, true);
}
function isSecret(program, target) {
    return program.stateMap(secretTypesKey).get(target);
}
const encodeKey = createStateSymbol("encode");
function $encode(context, target, encoding, encodeAs) {
    var _a, _b;
    validateDecoratorUniqueOnNode(context, target, $encode);
    const encodeData = {
        encoding: typeof encoding === "string" ? encoding : (_b = (_a = encoding.value) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : encoding.name,
        type: encodeAs !== null && encodeAs !== void 0 ? encodeAs : context.program.checker.getStdType("string"),
    };
    const targetType = getPropertyType(target);
    if (targetType.kind !== "Scalar") {
        return;
    }
    validateEncodeData(context, targetType, encodeData);
    context.program.stateMap(encodeKey).set(target, encodeData);
}
function validateEncodeData(context, target, encodeData) {
    function check(validTargets, validEncodeTypes) {
        var _a;
        const checker = context.program.checker;
        const isTargetValid = validTargets.some((validTarget) => {
            var _a;
            return ignoreDiagnostics(checker.isTypeAssignableTo((_a = target.projectionBase) !== null && _a !== void 0 ? _a : target, checker.getStdType(validTarget), target));
        });
        if (!isTargetValid) {
            reportDiagnostic(context.program, {
                code: "invalid-encode",
                messageId: "wrongType",
                format: {
                    encoding: encodeData.encoding,
                    type: getTypeName(target),
                    expected: validTargets.join(", "),
                },
                target: context.decoratorTarget,
            });
        }
        const isEncodingTypeValid = validEncodeTypes.some((validEncoding) => {
            var _a;
            return ignoreDiagnostics(checker.isTypeAssignableTo((_a = encodeData.type.projectionBase) !== null && _a !== void 0 ? _a : encodeData.type, checker.getStdType(validEncoding), target));
        });
        if (!isEncodingTypeValid) {
            const typeName = getTypeName((_a = encodeData.type.projectionBase) !== null && _a !== void 0 ? _a : encodeData.type);
            reportDiagnostic(context.program, {
                code: "invalid-encode",
                messageId: ["unixTimestamp", "seconds"].includes(encodeData.encoding)
                    ? "wrongNumericEncodingType"
                    : "wrongEncodingType",
                format: {
                    encoding: encodeData.encoding,
                    type: getTypeName(target),
                    expected: validEncodeTypes.join(", "),
                    actual: typeName,
                },
                target: context.decoratorTarget,
            });
        }
    }
    switch (encodeData.encoding) {
        case "rfc3339":
            return check(["utcDateTime", "offsetDateTime"], ["string"]);
        case "rfc7231":
            return check(["utcDateTime", "offsetDateTime"], ["string"]);
        case "unixTimestamp":
            return check(["utcDateTime"], ["integer"]);
        case "seconds":
            return check(["duration"], ["numeric"]);
        case "base64":
            return check(["bytes"], ["string"]);
        case "base64url":
            return check(["bytes"], ["string"]);
    }
}
function getEncode(program, target) {
    return program.stateMap(encodeKey).get(target);
}
// -- @visibility decorator ---------------------
const visibilitySettingsKey = createStateSymbol("visibilitySettings");
function $visibility(context, target, ...visibilities) {
    validateDecoratorUniqueOnNode(context, target, $visibility);
    context.program.stateMap(visibilitySettingsKey).set(target, visibilities);
}
function getVisibility(program, target) {
    return program.stateMap(visibilitySettingsKey).get(target);
}
function clearVisibilities(program, target) {
    program.stateMap(visibilitySettingsKey).delete(target);
}
function $withVisibility(context, target, ...visibilities) {
    filterModelPropertiesInPlace(target, (p) => isVisible(context.program, p, visibilities));
    [...target.properties.values()].forEach((p) => clearVisibilities(context.program, p));
}
function isVisible(program, property, visibilities) {
    const propertyVisibilities = getVisibility(program, property);
    return !propertyVisibilities || propertyVisibilities.some((v) => visibilities.includes(v));
}
function filterModelPropertiesInPlace(model, filter) {
    for (const [key, prop] of model.properties) {
        if (!filter(prop)) {
            model.properties.delete(key);
        }
    }
}
// -- @withOptionalProperties decorator ---------------------
function $withOptionalProperties(context, target) {
    // Make all properties of the target type optional
    target.properties.forEach((p) => (p.optional = true));
}
// -- @withUpdateableProperties decorator ----------------------
function $withUpdateableProperties(context, target) {
    if (!validateDecoratorTarget(context, target, "@withUpdateableProperties", "Model")) {
        return;
    }
    filterModelPropertiesInPlace(target, (p) => isVisible(context.program, p, ["update"]));
}
// -- @withoutOmittedProperties decorator ----------------------
function $withoutOmittedProperties(context, target, omitProperties) {
    // Get the property or properties to omit
    const omitNames = new Set();
    if (omitProperties.kind === "String") {
        omitNames.add(omitProperties.value);
    }
    else {
        for (const variant of omitProperties.variants.values()) {
            if (variant.type.kind === "String") {
                omitNames.add(variant.type.value);
            }
        }
    }
    // Remove all properties to be omitted
    filterModelPropertiesInPlace(target, (prop) => !omitNames.has(prop.name));
}
// -- @withoutDefaultValues decorator ----------------------
function $withoutDefaultValues(context, target) {
    // remove all read-only properties from the target type
    target.properties.forEach((p) => delete p.default);
}
// -- @list decorator ---------------------
const listPropertiesKey = createStateSymbol("listProperties");
/**
 * @deprecated Use the `listsResource` decorator in `@typespec/rest` instead.
 */
function $list(context, target, listedType) {
    if (listedType && listedType.kind === "TemplateParameter") {
        // Silently return because this is probably being used in a templated interface
        return;
    }
    if (listedType && listedType.kind !== "Model") {
        reportDiagnostic(context.program, {
            code: "list-type-not-model",
            target: context.getArgumentTarget(0),
        });
        return;
    }
    context.program.stateMap(listPropertiesKey).set(target, listedType);
}
/**
 * @deprecated This function is unused and will be removed in a future release.
 */
function getListOperationType(program, target) {
    return program.stateMap(listPropertiesKey).get(target);
}
/**
 * @deprecated Use `isListOperation` in `@typespec/rest` instead.
 */
function isListOperation(program, target) {
    // The type stored for the operation
    return program.stateMap(listPropertiesKey).has(target);
}
// -- @tag decorator ---------------------
const tagPropertiesKey = createStateSymbol("tagProperties");
// Set a tag on an operation, interface, or namespace.  There can be multiple tags on an
// operation, interface, or namespace.
function $tag(context, target, tag) {
    const tags = context.program.stateMap(tagPropertiesKey).get(target);
    if (tags) {
        tags.push(tag);
    }
    else {
        context.program.stateMap(tagPropertiesKey).set(target, [tag]);
    }
}
// Return the tags set on an operation or namespace
function getTags(program, target) {
    return program.stateMap(tagPropertiesKey).get(target) || [];
}
// Merge the tags for a operation with the tags that are on the namespace or
// interface it resides within.
function getAllTags(program, target) {
    var _a;
    const tags = new Set();
    let current = target;
    while (current !== undefined) {
        for (const t of getTags(program, current)) {
            tags.add(t);
        }
        // Move up to the parent
        if (current.kind === "Operation") {
            current = (_a = current.interface) !== null && _a !== void 0 ? _a : current.namespace;
        }
        else {
            // Type is a namespace or interface
            current = current.namespace;
        }
    }
    return tags.size > 0 ? Array.from(tags).reverse() : undefined;
}
// -- @friendlyName decorator ---------------------
const friendlyNamesKey = createStateSymbol("friendlyNames");
function $friendlyName(context, target, friendlyName, sourceObject) {
    // If an object was passed in, use it to format the friendly name
    if (sourceObject) {
        friendlyName = replaceTemplatedStringFromProperties(friendlyName, sourceObject);
    }
    context.program.stateMap(friendlyNamesKey).set(target, friendlyName);
}
function getFriendlyName(program, target) {
    return program.stateMap(friendlyNamesKey).get(target);
}
const knownValuesKey = createStateSymbol("knownValues");
/**
 * `@knownValues` marks a string type with an enum that contains all known values
 *
 * The first parameter is a reference to an enum type that describes all possible values that the
 * type accepts.
 *
 * `@knownValues` can only be applied to model types that extend `string`.
 *
 * @param target Decorator target. Must be a string. (model Foo extends string)
 * @param knownValues Must be an enum.
 */
function $knownValues(context, target, knownValues) {
    const type = getPropertyType(target);
    if (!isStringType(context.program, type) && !isNumericType(context.program, type)) {
        context.program.reportDiagnostic(createDiagnostic({
            code: "decorator-wrong-target",
            format: { decorator: "@knownValues", to: "type, it is  not a string or numeric" },
            target,
        }));
        return;
    }
    for (const member of knownValues.members.values()) {
        const propertyType = getPropertyType(target);
        if (!isEnumMemberAssignableToType(context.program, propertyType, member)) {
            reportDiagnostic(context.program, {
                code: "known-values-invalid-enum",
                format: {
                    member: member.name,
                    type: getTypeName(propertyType),
                },
                target,
            });
            return;
        }
    }
    context.program.stateMap(knownValuesKey).set(target, knownValues);
}
function isEnumMemberAssignableToType(program, typeName, member) {
    const memberType = member.value !== undefined ? typeof member.value : "string";
    switch (memberType) {
        case "string":
            return isStringType(program, typeName);
        case "number":
            return isNumericType(program, typeName);
        default:
            return false;
    }
}
function getKnownValues(program, target) {
    return program.stateMap(knownValuesKey).get(target);
}
const keyKey = createStateSymbol("key");
/**
 * `@key` - mark a model property as the key to identify instances of that type
 *
 * The optional first argument accepts an alternate key name which may be used by emitters.
 * Otherwise, the name of the target property will be used.
 *
 * `@key` can only be applied to model properties.
 */
function $key(context, entity, altName) {
    // Ensure that the key property is not marked as optional
    if (entity.optional) {
        reportDiagnostic(context.program, {
            code: "no-optional-key",
            format: { propertyName: entity.name },
            target: entity,
        });
        return;
    }
    // Register the key property
    context.program.stateMap(keyKey).set(entity, altName || entity.name);
}
function isKey(program, property) {
    return program.stateMap(keyKey).has(property);
}
function getKeyName(program, property) {
    return program.stateMap(keyKey).get(property);
}
function $withDefaultKeyVisibility(context, entity, visibility) {
    const keyProperties = [];
    entity.properties.forEach((prop) => {
        // Keep track of any key property without a visibility
        if (isKey(context.program, prop) && !getVisibility(context.program, prop)) {
            keyProperties.push(prop);
        }
    });
    // For each key property without a visibility, clone it and add the specified
    // default visibility value
    keyProperties.forEach((keyProp) => {
        entity.properties.set(keyProp.name, context.program.checker.cloneType(keyProp, {
            decorators: [
                ...keyProp.decorators,
                {
                    decorator: $visibility,
                    args: [
                        { value: context.program.checker.createLiteralType(visibility), jsValue: visibility },
                    ],
                },
            ],
        }));
    });
}
/**
 * Mark a type as deprecated
 * @param context DecoratorContext
 * @param target Decorator target
 * @param message Deprecation target.
 *
 * @example
 * ``` @deprecated("Foo is deprecated, use Bar instead.")
 *     model Foo {}
 * ```
 */
function $deprecated(context, target, message) {
    markDeprecated(context.program, target, { message });
}
/**
 * Return the deprecated message or undefined if not deprecated
 * @param program Program
 * @param type Type
 */
function getDeprecated(program, type) {
    var _a;
    return (_a = getDeprecationDetails(program, type)) === null || _a === void 0 ? void 0 : _a.message;
}
const overloadedByKey = createStateSymbol("overloadedByKey");
const overloadsOperationKey = createStateSymbol("overloadsOperation");
/**
 * `@overload` - Indicate that the target overloads (specializes) the overloads type.
 * @param context DecoratorContext
 * @param target The specializing operation declaration
 * @param overloadBase The operation to be overloaded.
 */
function $overload(context, target, overloadBase) {
    var _a, _b, _c, _d;
    // Ensure that the overloaded method arguments are a subtype of the original operation.
    const [paramValid, paramDiagnostics] = context.program.checker.isTypeAssignableTo((_a = target.parameters.projectionBase) !== null && _a !== void 0 ? _a : target.parameters, (_b = overloadBase.parameters.projectionBase) !== null && _b !== void 0 ? _b : overloadBase.parameters, target);
    if (!paramValid)
        context.program.reportDiagnostics(paramDiagnostics);
    const [returnTypeValid, returnTypeDiagnostics] = context.program.checker.isTypeAssignableTo((_c = target.returnType.projectionBase) !== null && _c !== void 0 ? _c : target.returnType, (_d = overloadBase.returnType.projectionBase) !== null && _d !== void 0 ? _d : overloadBase.returnType, target);
    if (!returnTypeValid)
        context.program.reportDiagnostics(returnTypeDiagnostics);
    if (!areOperationsInSameContainer(target, overloadBase)) {
        reportDiagnostic(context.program, {
            code: "overload-same-parent",
            target: context.decoratorTarget,
        });
    }
    // Save the information about the overloaded operation
    context.program.stateMap(overloadsOperationKey).set(target, overloadBase);
    const existingOverloads = getOverloads(context.program, overloadBase) || new Array();
    context.program.stateMap(overloadedByKey).set(overloadBase, existingOverloads.concat(target));
}
function areOperationsInSameContainer(op1, op2) {
    return op1.interface || op2.interface
        ? equalsWithoutProjection(op1.interface, op2.interface)
        : op1.namespace === op2.namespace;
}
// note: because the 'interface' property of Operation types is projected after the
// type is finalized, the target operation or overloadBase may reference an un-projected
// interface at the time of decorator execution during projections.  This normalizes
// the interfaces to their unprojected form before comparison.
function equalsWithoutProjection(interface1, interface2) {
    if (interface1 === undefined || interface2 === undefined)
        return false;
    return getBaseInterface(interface1) === getBaseInterface(interface2);
}
function getBaseInterface(int1) {
    return int1.projectionSource === undefined
        ? int1
        : getBaseInterface(int1.projectionSource);
}
/**
 * Get all operations that are marked as overloads of the given operation
 * @param program Program
 * @param operation Operation
 * @returns An array of operations that overload the given operation.
 */
function getOverloads(program, operation) {
    return program.stateMap(overloadedByKey).get(operation);
}
/**
 * If the given operation overloads another operation, return that operation.
 * @param program Program
 * @param operation The operation to check for an overload target.
 * @returns The operation this operation overloads, if any.
 */
function getOverloadedOperation(program, operation) {
    return program.stateMap(overloadsOperationKey).get(operation);
}
const projectedNameKey = createStateSymbol("projectedNameKey");
/**
 * `@projectedName` - Indicate that this entity should be renamed according to the given projection.
 * @param context DecoratorContext
 * @param target The that should have a different name.
 * @param projectionName Name of the projection (e.g. "toJson", "toCSharp")
 * @param projectedName Name of the type should have in the scope of the projection specified.
 */
function $projectedName(context, target, projectionName, projectedName) {
    let map = context.program.stateMap(projectedNameKey).get(target);
    if (map === undefined) {
        map = new Map();
        context.program.stateMap(projectedNameKey).set(target, map);
    }
    map.set(projectionName, projectedName);
}
/**
 * @param program Program
 * @param target Target
 * @returns Map of the projected names for the given entity.
 */
function getProjectedNames(program, target) {
    return program.stateMap(projectedNameKey).get(target);
}
/**
 * Get the projected name of the given entity for the given projection.
 * @param program Program
 * @param target Target
 * @returns Projected name for the given projection
 */
function getProjectedName(program, target, projectionName) {
    var _a;
    return (_a = getProjectedNames(program, target)) === null || _a === void 0 ? void 0 : _a.get(projectionName);
}
/**
 * Get the projected name of the given entity for the given projection.
 * @param program Program
 * @param target Target
 * @returns Projected name for the given projection
 */
function hasProjectedName(program, target, projectionName) {
    var _a, _b;
    return (_b = (_a = getProjectedNames(program, target)) === null || _a === void 0 ? void 0 : _a.has(projectionName)) !== null && _b !== void 0 ? _b : false;
}
function validateRange(context, min, max) {
    if (min === undefined || max === undefined) {
        return true;
    }
    if (min > max) {
        reportDiagnostic(context.program, {
            code: "invalid-range",
            format: { start: min.toString(), end: max.toString() },
            target: context.decoratorTarget,
        });
        return false;
    }
    return true;
}
const discriminatorKey = createStateSymbol("discriminator");
function $discriminator(context, entity, propertyName) {
    const discriminator = { propertyName };
    if (entity.kind === "Union") {
        // we can validate discriminator up front for unions. Models are validated in the accessor as we might not have the reference to all derived types at this time.
        const [, diagnostics] = getDiscriminatedUnion(entity, discriminator);
        if (diagnostics.length > 0) {
            context.program.reportDiagnostics(diagnostics);
            return;
        }
    }
    context.program.stateMap(discriminatorKey).set(entity, discriminator);
}
function getDiscriminator(program, entity) {
    return program.stateMap(discriminatorKey).get(entity);
}
function getDiscriminatedTypes(program) {
    return [...program.stateMap(discriminatorKey).entries()];
}
const parameterVisibilityKey = createStateSymbol("parameterVisibility");
function $parameterVisibility(context, entity, ...visibilities) {
    validateDecoratorUniqueOnNode(context, entity, $parameterVisibility);
    context.program.stateMap(parameterVisibilityKey).set(entity, visibilities);
}
/**
 * Returns the visibilities of the parameters of the given operation, if provided with `@parameterVisibility`.
 *
 * @see {@link $parameterVisibility}
 */
function getParameterVisibility(program, entity) {
    return program.stateMap(parameterVisibilityKey).get(entity);
}
const returnTypeVisibilityKey = createStateSymbol("returnTypeVisibility");
function $returnTypeVisibility(context, entity, ...visibilities) {
    validateDecoratorUniqueOnNode(context, entity, $returnTypeVisibility);
    context.program.stateMap(returnTypeVisibilityKey).set(entity, visibilities);
}
/**
 * Returns the visibilities of the return type of the given operation, if provided with `@returnTypeVisibility`.
 *
 * @see {@link $returnTypeVisibility}
 */
function getReturnTypeVisibility(program, entity) {
    return program.stateMap(returnTypeVisibilityKey).get(entity);
}

var f0 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    $deprecated: $deprecated,
    $discriminator: $discriminator,
    $doc: $doc,
    $docFromComment: $docFromComment,
    $encode: $encode,
    $error: $error,
    $errorsDoc: $errorsDoc,
    $format: $format,
    $friendlyName: $friendlyName,
    $indexer: $indexer,
    $inspectType: $inspectType,
    $inspectTypeName: $inspectTypeName,
    $key: $key,
    $knownValues: $knownValues,
    $list: $list,
    $maxItems: $maxItems,
    $maxLength: $maxLength,
    $maxValue: $maxValue,
    $maxValueExclusive: $maxValueExclusive,
    $minItems: $minItems,
    $minLength: $minLength,
    $minValue: $minValue,
    $minValueExclusive: $minValueExclusive,
    $overload: $overload,
    $parameterVisibility: $parameterVisibility,
    $pattern: $pattern,
    $projectedName: $projectedName,
    $returnTypeVisibility: $returnTypeVisibility,
    $returnsDoc: $returnsDoc,
    $secret: $secret,
    $service: $service,
    $summary: $summary,
    $tag: $tag,
    $visibility: $visibility,
    $withDefaultKeyVisibility: $withDefaultKeyVisibility,
    $withOptionalProperties: $withOptionalProperties,
    $withUpdateableProperties: $withUpdateableProperties,
    $withVisibility: $withVisibility,
    $withoutDefaultValues: $withoutDefaultValues,
    $withoutOmittedProperties: $withoutOmittedProperties,
    addService: addService,
    getAllTags: getAllTags,
    getDeprecated: getDeprecated,
    getDiscriminatedTypes: getDiscriminatedTypes,
    getDiscriminator: getDiscriminator,
    getDoc: getDoc,
    getDocData: getDocData,
    getDocDataInternal: getDocDataInternal,
    getEncode: getEncode,
    getErrorsDoc: getErrorsDoc,
    getErrorsDocData: getErrorsDocData,
    getFormat: getFormat,
    getFriendlyName: getFriendlyName,
    getIndexer: getIndexer,
    getKeyName: getKeyName,
    getKnownValues: getKnownValues,
    getListOperationType: getListOperationType,
    getMaxItems: getMaxItems,
    getMaxLength: getMaxLength,
    getMaxValue: getMaxValue,
    getMaxValueExclusive: getMaxValueExclusive,
    getMinItems: getMinItems,
    getMinLength: getMinLength,
    getMinValue: getMinValue,
    getMinValueExclusive: getMinValueExclusive,
    getOverloadedOperation: getOverloadedOperation,
    getOverloads: getOverloads,
    getParameterVisibility: getParameterVisibility,
    getPattern: getPattern,
    getProjectedName: getProjectedName,
    getProjectedNames: getProjectedNames,
    getPropertyType: getPropertyType,
    getReturnTypeVisibility: getReturnTypeVisibility,
    getReturnsDoc: getReturnsDoc,
    getReturnsDocData: getReturnsDocData,
    getService: getService,
    getSummary: getSummary,
    getTags: getTags,
    getVisibility: getVisibility,
    hasProjectedName: hasProjectedName,
    isArrayModelType: isArrayModelType,
    isErrorModel: isErrorModel,
    isKey: isKey,
    isListOperation: isListOperation,
    isNumericType: isNumericType,
    isRecordModelType: isRecordModelType,
    isSecret: isSecret,
    isService: isService,
    isStringType: isStringType,
    isVisible: isVisible,
    listServices: listServices,
    namespace: namespace
});

/**
 * The fixed set of options for each of the kinds of delimited lists in TypeSpec.
 */
// eslint-disable-next-line @typescript-eslint/no-namespace
var ListKind;
(function (ListKind) {
    const PropertiesBase = {
        allowEmpty: true,
        toleratedDelimiterIsValid: true,
        trailingDelimiterIsValid: true,
        allowedStatementKeyword: Token.None,
    };
    ListKind.OperationParameters = {
        ...PropertiesBase,
        open: Token.OpenParen,
        close: Token.CloseParen,
        delimiter: Token.Comma,
        toleratedDelimiter: Token.Semicolon,
    };
    ListKind.DecoratorArguments = {
        ...ListKind.OperationParameters,
        invalidAnnotationTarget: "expression",
    };
    ListKind.ModelProperties = {
        ...PropertiesBase,
        open: Token.OpenBrace,
        close: Token.CloseBrace,
        delimiter: Token.Semicolon,
        toleratedDelimiter: Token.Comma,
    };
    ListKind.InterfaceMembers = {
        ...PropertiesBase,
        open: Token.OpenBrace,
        close: Token.CloseBrace,
        delimiter: Token.Semicolon,
        toleratedDelimiter: Token.Comma,
        toleratedDelimiterIsValid: false,
        allowedStatementKeyword: Token.OpKeyword,
    };
    ListKind.UnionVariants = {
        ...PropertiesBase,
        open: Token.OpenBrace,
        close: Token.CloseBrace,
        delimiter: Token.Semicolon,
        toleratedDelimiter: Token.Comma,
        toleratedDelimiterIsValid: true,
    };
    ListKind.EnumMembers = {
        ...ListKind.ModelProperties,
    };
    const ExpresionsBase = {
        allowEmpty: true,
        delimiter: Token.Comma,
        toleratedDelimiter: Token.Semicolon,
        toleratedDelimiterIsValid: false,
        trailingDelimiterIsValid: false,
        invalidAnnotationTarget: "expression",
        allowedStatementKeyword: Token.None,
    };
    ListKind.TemplateParameters = {
        ...ExpresionsBase,
        allowEmpty: false,
        open: Token.LessThan,
        close: Token.GreaterThan,
        invalidAnnotationTarget: "template parameter",
    };
    ListKind.TemplateArguments = {
        ...ListKind.TemplateParameters,
    };
    ListKind.CallArguments = {
        ...ExpresionsBase,
        allowEmpty: true,
        open: Token.OpenParen,
        close: Token.CloseParen,
    };
    ListKind.Heritage = {
        ...ExpresionsBase,
        allowEmpty: false,
        open: Token.None,
        close: Token.None,
    };
    ListKind.Tuple = {
        ...ExpresionsBase,
        allowEmpty: true,
        open: Token.OpenBracket,
        close: Token.CloseBracket,
    };
    ListKind.FunctionParameters = {
        ...ExpresionsBase,
        allowEmpty: true,
        open: Token.OpenParen,
        close: Token.CloseParen,
        invalidAnnotationTarget: "expression",
    };
    ListKind.ProjectionExpression = {
        ...ExpresionsBase,
        allowEmpty: true,
        open: Token.OpenParen,
        close: Token.CloseParen,
    };
    ListKind.ProjectionParameter = {
        ...ExpresionsBase,
        allowEmpty: true,
        open: Token.OpenParen,
        close: Token.CloseParen,
    };
})(ListKind || (ListKind = {}));
function parse$2(code, options = {}) {
    const parser = createParser(code, options);
    return parser.parseTypeSpecScript();
}
function parseStandaloneTypeReference(code) {
    const parser = createParser(code);
    const node = parser.parseStandaloneReferenceExpression();
    return [node, parser.parseDiagnostics];
}
function createParser(code, options = {}) {
    let parseErrorInNextFinishedNode = false;
    let previousTokenEnd = -1;
    let realPositionOfLastError = -1;
    let missingIdentifierCounter = 0;
    let treePrintable = true;
    let newLineIsTrivia = true;
    let currentMode = 0 /* ParseMode.Syntax */;
    const parseDiagnostics = [];
    const scanner = createScanner(code, reportDiagnostic);
    const comments = [];
    let docRanges = [];
    nextToken();
    return {
        parseDiagnostics,
        parseTypeSpecScript,
        parseStandaloneReferenceExpression,
    };
    function parseTypeSpecScript() {
        const statements = parseTypeSpecScriptItemList();
        return {
            kind: SyntaxKind.TypeSpecScript,
            statements,
            file: scanner.file,
            id: {
                kind: SyntaxKind.Identifier,
                sv: scanner.file.path,
                pos: 0,
                end: 0,
                flags: 8 /* NodeFlags.Synthetic */,
            },
            namespaces: [],
            usings: [],
            locals: undefined,
            inScopeNamespaces: [],
            parseDiagnostics,
            comments,
            printable: treePrintable,
            parseOptions: options,
            ...finishNode(0),
        };
    }
    /** Try to parse doc comments, directives and decorators in any order. */
    function parseAnnotations({ skipParsingDocNodes } = {}) {
        const directives = [];
        const decorators = [];
        const docs = [];
        let pos = tokenPos();
        if (!skipParsingDocNodes) {
            const [firstPos, addedDocs] = parseDocList();
            pos = firstPos;
            for (const doc of addedDocs) {
                docs.push(doc);
            }
        }
        while (token() === Token.Hash || token() === Token.At) {
            if (token() === Token.Hash) {
                directives.push(parseDirectiveExpression());
            }
            else if (token() === Token.At) {
                decorators.push(parseDecoratorExpression());
            }
            if (!skipParsingDocNodes) {
                const [_, addedDocs] = parseDocList();
                for (const doc of addedDocs) {
                    docs.push(doc);
                }
            }
        }
        return { pos, docs, directives, decorators };
    }
    function parseTypeSpecScriptItemList() {
        const stmts = [];
        let seenBlocklessNs = false;
        let seenDecl = false;
        let seenUsing = false;
        while (token() !== Token.EndOfFile) {
            const { pos, docs, directives, decorators } = parseAnnotations();
            const tok = token();
            let item;
            switch (tok) {
                case Token.AtAt:
                    reportInvalidDecorators(decorators, "augment decorator statement");
                    item = parseAugmentDecorator();
                    break;
                case Token.ImportKeyword:
                    reportInvalidDecorators(decorators, "import statement");
                    item = parseImportStatement();
                    break;
                case Token.ModelKeyword:
                    item = parseModelStatement(pos, decorators);
                    break;
                case Token.ScalarKeyword:
                    item = parseScalarStatement(pos, decorators);
                    break;
                case Token.NamespaceKeyword:
                    item = parseNamespaceStatement(pos, decorators, docs);
                    break;
                case Token.InterfaceKeyword:
                    item = parseInterfaceStatement(pos, decorators);
                    break;
                case Token.UnionKeyword:
                    item = parseUnionStatement(pos, decorators);
                    break;
                case Token.OpKeyword:
                    item = parseOperationStatement(pos, decorators);
                    break;
                case Token.EnumKeyword:
                    item = parseEnumStatement(pos, decorators);
                    break;
                case Token.AliasKeyword:
                    reportInvalidDecorators(decorators, "alias statement");
                    item = parseAliasStatement(pos);
                    break;
                case Token.UsingKeyword:
                    reportInvalidDecorators(decorators, "using statement");
                    item = parseUsingStatement(pos);
                    break;
                case Token.ProjectionKeyword:
                    reportInvalidDecorators(decorators, "projection statement");
                    item = parseProjectionStatement(pos);
                    break;
                case Token.Semicolon:
                    reportInvalidDecorators(decorators, "empty statement");
                    item = parseEmptyStatement(pos);
                    break;
                // Start of declaration with modifiers
                case Token.ExternKeyword:
                case Token.FnKeyword:
                case Token.DecKeyword:
                    item = parseDeclaration(pos);
                    break;
                default:
                    item = parseInvalidStatement(pos, decorators);
                    break;
            }
            mutate(item).directives = directives;
            if (tok !== Token.NamespaceKeyword) {
                mutate(item).docs = docs;
            }
            if (isBlocklessNamespace(item)) {
                if (seenBlocklessNs) {
                    error({ code: "multiple-blockless-namespace", target: item });
                }
                if (seenDecl) {
                    error({ code: "blockless-namespace-first", target: item });
                }
                seenBlocklessNs = true;
            }
            else if (item.kind === SyntaxKind.ImportStatement) {
                if (seenDecl || seenBlocklessNs || seenUsing) {
                    error({ code: "import-first", target: item });
                }
            }
            else if (item.kind === SyntaxKind.UsingStatement) {
                seenUsing = true;
            }
            else {
                seenDecl = true;
            }
            stmts.push(item);
        }
        return stmts;
    }
    function parseStatementList() {
        const stmts = [];
        while (token() !== Token.CloseBrace) {
            const { pos, docs, directives, decorators } = parseAnnotations();
            const tok = token();
            let item;
            switch (tok) {
                case Token.AtAt:
                    reportInvalidDecorators(decorators, "augment decorator statement");
                    item = parseAugmentDecorator();
                    break;
                case Token.ImportKeyword:
                    reportInvalidDecorators(decorators, "import statement");
                    item = parseImportStatement();
                    error({ code: "import-first", messageId: "topLevel", target: item });
                    break;
                case Token.ModelKeyword:
                    item = parseModelStatement(pos, decorators);
                    break;
                case Token.ScalarKeyword:
                    item = parseScalarStatement(pos, decorators);
                    break;
                case Token.NamespaceKeyword:
                    const ns = parseNamespaceStatement(pos, decorators, docs);
                    if (!Array.isArray(ns.statements)) {
                        error({ code: "blockless-namespace-first", messageId: "topLevel", target: ns });
                    }
                    item = ns;
                    break;
                case Token.InterfaceKeyword:
                    item = parseInterfaceStatement(pos, decorators);
                    break;
                case Token.UnionKeyword:
                    item = parseUnionStatement(pos, decorators);
                    break;
                case Token.OpKeyword:
                    item = parseOperationStatement(pos, decorators);
                    break;
                case Token.EnumKeyword:
                    item = parseEnumStatement(pos, decorators);
                    break;
                case Token.AliasKeyword:
                    reportInvalidDecorators(decorators, "alias statement");
                    item = parseAliasStatement(pos);
                    break;
                case Token.UsingKeyword:
                    reportInvalidDecorators(decorators, "using statement");
                    item = parseUsingStatement(pos);
                    break;
                case Token.ExternKeyword:
                case Token.FnKeyword:
                case Token.DecKeyword:
                    item = parseDeclaration(pos);
                    break;
                case Token.ProjectionKeyword:
                    reportInvalidDecorators(decorators, "project statement");
                    item = parseProjectionStatement(pos);
                    break;
                case Token.EndOfFile:
                    parseExpected(Token.CloseBrace);
                    return stmts;
                case Token.Semicolon:
                    reportInvalidDecorators(decorators, "empty statement");
                    item = parseEmptyStatement(pos);
                    break;
                default:
                    item = parseInvalidStatement(pos, decorators);
                    break;
            }
            mutate(item).directives = directives;
            if (tok !== Token.NamespaceKeyword) {
                mutate(item).docs = docs;
            }
            stmts.push(item);
        }
        return stmts;
    }
    function parseDecoratorList() {
        const decorators = [];
        while (token() === Token.At) {
            decorators.push(parseDecoratorExpression());
        }
        return decorators;
    }
    function parseDirectiveList() {
        const directives = [];
        while (token() === Token.Hash) {
            directives.push(parseDirectiveExpression());
        }
        return directives;
    }
    function parseNamespaceStatement(pos, decorators, docs) {
        parseExpected(Token.NamespaceKeyword);
        let currentName = parseIdentifierOrMemberExpression();
        const nsSegments = [];
        while (currentName.kind !== SyntaxKind.Identifier) {
            nsSegments.push(currentName.id);
            currentName = currentName.base;
        }
        nsSegments.push(currentName);
        const nextTok = parseExpectedOneOf(Token.Semicolon, Token.OpenBrace);
        let statements;
        if (nextTok === Token.OpenBrace) {
            statements = parseStatementList();
            parseExpected(Token.CloseBrace);
        }
        let outerNs = {
            kind: SyntaxKind.NamespaceStatement,
            decorators,
            docs: docs,
            id: nsSegments[0],
            locals: undefined,
            statements,
            ...finishNode(pos),
        };
        for (let i = 1; i < nsSegments.length; i++) {
            outerNs = {
                kind: SyntaxKind.NamespaceStatement,
                decorators: [],
                id: nsSegments[i],
                statements: outerNs,
                locals: undefined,
                ...finishNode(pos),
            };
        }
        return outerNs;
    }
    function parseInterfaceStatement(pos, decorators) {
        parseExpected(Token.InterfaceKeyword);
        const id = parseIdentifier();
        const templateParameters = parseTemplateParameterList();
        let extendList = [];
        if (token() === Token.ExtendsKeyword) {
            nextToken();
            extendList = parseList(ListKind.Heritage, parseReferenceExpression);
        }
        else if (token() === Token.Identifier) {
            error({ code: "token-expected", format: { token: "'extends' or '{'" } });
            nextToken();
        }
        const operations = parseList(ListKind.InterfaceMembers, (pos, decorators) => parseOperationStatement(pos, decorators, true));
        return {
            kind: SyntaxKind.InterfaceStatement,
            id,
            templateParameters,
            operations,
            extends: extendList,
            decorators,
            ...finishNode(pos),
        };
    }
    function parseTemplateParameterList() {
        const list = parseOptionalList(ListKind.TemplateParameters, parseTemplateParameter);
        let setDefault = false;
        for (const item of list) {
            if (!item.default && setDefault) {
                error({ code: "default-required", target: item });
                continue;
            }
            if (item.default) {
                setDefault = true;
            }
        }
        return list;
    }
    function parseUnionStatement(pos, decorators) {
        parseExpected(Token.UnionKeyword);
        const id = parseIdentifier();
        const templateParameters = parseTemplateParameterList();
        const options = parseList(ListKind.UnionVariants, parseUnionVariant);
        return {
            kind: SyntaxKind.UnionStatement,
            id,
            templateParameters,
            decorators,
            options,
            ...finishNode(pos),
        };
    }
    function parseUnionVariant(pos, decorators) {
        const idOrExpr = parseExpression();
        if (parseOptional(Token.Colon)) {
            let id = undefined;
            if (idOrExpr.kind !== SyntaxKind.TypeReference &&
                idOrExpr.kind !== SyntaxKind.StringLiteral) {
                error({ code: "token-expected", messageId: "identifier" });
            }
            else if (idOrExpr.kind === SyntaxKind.StringLiteral) {
                // convert string literal node to identifier node (back compat for string literal quoted properties)
                id = {
                    kind: SyntaxKind.Identifier,
                    sv: idOrExpr.value,
                    ...finishNode(idOrExpr.pos),
                };
            }
            else {
                const target = idOrExpr.target;
                if (target.kind === SyntaxKind.Identifier) {
                    id = target;
                }
                else {
                    error({ code: "token-expected", messageId: "identifier" });
                }
            }
            const value = parseExpression();
            return {
                kind: SyntaxKind.UnionVariant,
                id,
                value,
                decorators,
                ...finishNode(pos),
            };
        }
        return {
            kind: SyntaxKind.UnionVariant,
            id: undefined,
            value: idOrExpr,
            decorators,
            ...finishNode(pos),
        };
    }
    function parseUsingStatement(pos) {
        parseExpected(Token.UsingKeyword);
        const name = parseIdentifierOrMemberExpression(undefined, true);
        parseExpected(Token.Semicolon);
        return {
            kind: SyntaxKind.UsingStatement,
            name,
            ...finishNode(pos),
        };
    }
    function parseOperationStatement(pos, decorators, inInterface) {
        if (inInterface) {
            parseOptional(Token.OpKeyword);
        }
        else {
            parseExpected(Token.OpKeyword);
        }
        const id = parseIdentifier();
        const templateParameters = parseTemplateParameterList();
        // Make sure the next token is one that is expected
        const token = expectTokenIsOneOf(Token.OpenParen, Token.IsKeyword);
        // Check if we're parsing a declaration or reuse of another operation
        let signature;
        const signaturePos = tokenPos();
        if (token === Token.OpenParen) {
            const parameters = parseOperationParameters();
            parseExpected(Token.Colon);
            const returnType = parseExpression();
            signature = {
                kind: SyntaxKind.OperationSignatureDeclaration,
                parameters,
                returnType,
                ...finishNode(signaturePos),
            };
        }
        else {
            parseExpected(Token.IsKeyword);
            const opReference = parseReferenceExpression();
            signature = {
                kind: SyntaxKind.OperationSignatureReference,
                baseOperation: opReference,
                ...finishNode(signaturePos),
            };
        }
        // The interface parser handles semicolon parsing between statements
        if (!inInterface) {
            parseExpected(Token.Semicolon);
        }
        return {
            kind: SyntaxKind.OperationStatement,
            id,
            templateParameters,
            signature,
            decorators,
            ...finishNode(pos),
        };
    }
    function parseOperationParameters() {
        const pos = tokenPos();
        const properties = parseList(ListKind.OperationParameters, parseModelPropertyOrSpread);
        const parameters = {
            kind: SyntaxKind.ModelExpression,
            properties,
            ...finishNode(pos),
        };
        return parameters;
    }
    function parseModelStatement(pos, decorators) {
        parseExpected(Token.ModelKeyword);
        const id = parseIdentifier();
        const templateParameters = parseTemplateParameterList();
        expectTokenIsOneOf(Token.OpenBrace, Token.Equals, Token.ExtendsKeyword, Token.IsKeyword);
        const optionalExtends = parseOptionalModelExtends();
        const optionalIs = optionalExtends ? undefined : parseOptionalModelIs();
        let properties = [];
        if (optionalIs) {
            const tok = expectTokenIsOneOf(Token.Semicolon, Token.OpenBrace);
            if (tok === Token.Semicolon) {
                nextToken();
            }
            else {
                properties = parseList(ListKind.ModelProperties, parseModelPropertyOrSpread);
            }
        }
        else {
            properties = parseList(ListKind.ModelProperties, parseModelPropertyOrSpread);
        }
        return {
            kind: SyntaxKind.ModelStatement,
            id,
            extends: optionalExtends,
            is: optionalIs,
            templateParameters,
            decorators,
            properties,
            ...finishNode(pos),
        };
    }
    function parseOptionalModelExtends() {
        if (parseOptional(Token.ExtendsKeyword)) {
            return parseExpression();
        }
        return undefined;
    }
    function parseOptionalModelIs() {
        if (parseOptional(Token.IsKeyword)) {
            return parseExpression();
        }
        return;
    }
    function parseTemplateParameter() {
        const pos = tokenPos();
        const id = parseIdentifier();
        let constraint;
        if (parseOptional(Token.ExtendsKeyword)) {
            constraint = parseExpression();
        }
        let def;
        if (parseOptional(Token.Equals)) {
            def = parseExpression();
        }
        return {
            kind: SyntaxKind.TemplateParameterDeclaration,
            id,
            constraint,
            default: def,
            ...finishNode(pos),
        };
    }
    function parseModelPropertyOrSpread(pos, decorators) {
        return token() === Token.Ellipsis
            ? parseModelSpreadProperty(pos, decorators)
            : parseModelProperty(pos, decorators);
    }
    function parseModelSpreadProperty(pos, decorators) {
        parseExpected(Token.Ellipsis);
        reportInvalidDecorators(decorators, "spread property");
        // This could be broadened to allow any type expression
        const target = parseReferenceExpression();
        return {
            kind: SyntaxKind.ModelSpreadProperty,
            target,
            ...finishNode(pos),
        };
    }
    function parseModelProperty(pos, decorators) {
        const id = parseIdentifier({
            message: "property",
            allowStringLiteral: true,
        });
        const optional = parseOptional(Token.Question);
        parseExpected(Token.Colon);
        const value = parseExpression();
        const hasDefault = parseOptional(Token.Equals);
        const defaultValue = hasDefault ? parseExpression() : undefined;
        return {
            kind: SyntaxKind.ModelProperty,
            id,
            decorators,
            value,
            optional,
            default: defaultValue,
            ...finishNode(pos),
        };
    }
    function parseScalarStatement(pos, decorators) {
        parseExpected(Token.ScalarKeyword);
        const id = parseIdentifier();
        const templateParameters = parseTemplateParameterList();
        const optionalExtends = parseOptionalScalarExtends();
        return {
            kind: SyntaxKind.ScalarStatement,
            id,
            templateParameters,
            extends: optionalExtends,
            decorators,
            ...finishNode(pos),
        };
    }
    function parseOptionalScalarExtends() {
        if (parseOptional(Token.ExtendsKeyword)) {
            return parseReferenceExpression();
        }
        return undefined;
    }
    function parseEnumStatement(pos, decorators) {
        parseExpected(Token.EnumKeyword);
        const id = parseIdentifier();
        const members = parseList(ListKind.EnumMembers, parseEnumMemberOrSpread);
        return {
            kind: SyntaxKind.EnumStatement,
            id,
            decorators,
            members,
            ...finishNode(pos),
        };
    }
    function parseEnumMemberOrSpread(pos, decorators) {
        return token() === Token.Ellipsis
            ? parseEnumSpreadMember(pos, decorators)
            : parseEnumMember(pos, decorators);
    }
    function parseEnumSpreadMember(pos, decorators) {
        parseExpected(Token.Ellipsis);
        reportInvalidDecorators(decorators, "spread enum");
        const target = parseReferenceExpression();
        return {
            kind: SyntaxKind.EnumSpreadMember,
            target,
            ...finishNode(pos),
        };
    }
    function parseEnumMember(pos, decorators) {
        const id = parseIdentifier({
            message: "enumMember",
            allowStringLiteral: true,
        });
        let value;
        if (parseOptional(Token.Colon)) {
            const expr = parseExpression();
            if (expr.kind === SyntaxKind.StringLiteral || expr.kind === SyntaxKind.NumericLiteral) {
                value = expr;
            }
            else if (expr.kind === SyntaxKind.TypeReference &&
                expr.target.flags & 2 /* NodeFlags.ThisNodeHasError */) {
                parseErrorInNextFinishedNode = true;
            }
            else {
                error({ code: "token-expected", messageId: "numericOrStringLiteral", target: expr });
            }
        }
        return {
            kind: SyntaxKind.EnumMember,
            id,
            value,
            decorators,
            ...finishNode(pos),
        };
    }
    function parseAliasStatement(pos) {
        parseExpected(Token.AliasKeyword);
        const id = parseIdentifier();
        const templateParameters = parseTemplateParameterList();
        parseExpected(Token.Equals);
        const value = parseExpression();
        parseExpected(Token.Semicolon);
        return {
            kind: SyntaxKind.AliasStatement,
            id,
            templateParameters,
            value,
            ...finishNode(pos),
        };
    }
    function parseExpression() {
        return parseUnionExpressionOrHigher();
    }
    function parseUnionExpressionOrHigher() {
        const pos = tokenPos();
        parseOptional(Token.Bar);
        const node = parseIntersectionExpressionOrHigher();
        if (token() !== Token.Bar) {
            return node;
        }
        const options = [node];
        while (parseOptional(Token.Bar)) {
            const expr = parseIntersectionExpressionOrHigher();
            options.push(expr);
        }
        return {
            kind: SyntaxKind.UnionExpression,
            options,
            ...finishNode(pos),
        };
    }
    function parseIntersectionExpressionOrHigher() {
        const pos = tokenPos();
        parseOptional(Token.Ampersand);
        const node = parseArrayExpressionOrHigher();
        if (token() !== Token.Ampersand) {
            return node;
        }
        const options = [node];
        while (parseOptional(Token.Ampersand)) {
            const expr = parseArrayExpressionOrHigher();
            options.push(expr);
        }
        return {
            kind: SyntaxKind.IntersectionExpression,
            options,
            ...finishNode(pos),
        };
    }
    function parseArrayExpressionOrHigher() {
        const pos = tokenPos();
        let expr = parsePrimaryExpression();
        while (parseOptional(Token.OpenBracket)) {
            parseExpected(Token.CloseBracket);
            expr = {
                kind: SyntaxKind.ArrayExpression,
                elementType: expr,
                ...finishNode(pos),
            };
        }
        return expr;
    }
    function parseStandaloneReferenceExpression() {
        const expr = parseReferenceExpression();
        if (parseDiagnostics.length === 0 && token() !== Token.EndOfFile) {
            error({ code: "token-expected", messageId: "unexpected", format: { token: Token[token()] } });
        }
        return expr;
    }
    function parseValueOfExpression() {
        const pos = tokenPos();
        parseExpected(Token.ValueOfKeyword);
        const target = parseExpression();
        return {
            kind: SyntaxKind.ValueOfExpression,
            target,
            ...finishNode(pos),
        };
    }
    function parseReferenceExpression(message) {
        const pos = tokenPos();
        const target = parseIdentifierOrMemberExpression(message);
        const args = parseOptionalList(ListKind.TemplateArguments, parseExpression);
        return {
            kind: SyntaxKind.TypeReference,
            target,
            arguments: args,
            ...finishNode(pos),
        };
    }
    function parseAugmentDecorator() {
        const pos = tokenPos();
        parseExpected(Token.AtAt);
        // Error recovery: false arg here means don't treat a keyword as an
        // identifier. We want to parse `@ model Foo` as invalid decorator
        // `@<missing identifier>` applied to `model Foo`, and not as `@model`
        // applied to invalid statement `Foo`.
        const target = parseIdentifierOrMemberExpression(undefined, false);
        const args = parseOptionalList(ListKind.DecoratorArguments, parseExpression);
        if (args.length === 0) {
            error({ code: "augment-decorator-target" });
            return {
                kind: SyntaxKind.AugmentDecoratorStatement,
                target,
                targetType: {
                    kind: SyntaxKind.TypeReference,
                    target: createMissingIdentifier(),
                    arguments: [],
                    ...finishNode(pos),
                },
                arguments: [],
                ...finishNode(pos),
            };
        }
        let [targetEntity, ...decoratorArgs] = args;
        if (targetEntity.kind !== SyntaxKind.TypeReference) {
            error({ code: "augment-decorator-target", target: targetEntity });
            targetEntity = {
                kind: SyntaxKind.TypeReference,
                target: createMissingIdentifier(),
                arguments: [],
                ...finishNode(pos),
            };
        }
        parseExpected(Token.Semicolon);
        return {
            kind: SyntaxKind.AugmentDecoratorStatement,
            target,
            targetType: targetEntity,
            arguments: decoratorArgs,
            ...finishNode(pos),
        };
    }
    function parseImportStatement() {
        const pos = tokenPos();
        parseExpected(Token.ImportKeyword);
        const path = parseStringLiteral();
        parseExpected(Token.Semicolon);
        return {
            kind: SyntaxKind.ImportStatement,
            path,
            ...finishNode(pos),
        };
    }
    function parseDecoratorExpression() {
        const pos = tokenPos();
        parseExpected(Token.At);
        // Error recovery: false arg here means don't treat a keyword as an
        // identifier. We want to parse `@ model Foo` as invalid decorator
        // `@<missing identifier>` applied to `model Foo`, and not as `@model`
        // applied to invalid statement `Foo`.
        const target = parseIdentifierOrMemberExpression(undefined, false);
        const args = parseOptionalList(ListKind.DecoratorArguments, parseExpression);
        return {
            kind: SyntaxKind.DecoratorExpression,
            arguments: args,
            target,
            ...finishNode(pos),
        };
    }
    function parseDirectiveExpression() {
        const pos = tokenPos();
        parseExpected(Token.Hash);
        const target = parseIdentifier();
        if (target.sv !== "suppress" && target.sv !== "deprecated") {
            error({
                code: "unknown-directive",
                format: { id: target.sv },
                target: { pos, end: pos + target.sv.length },
                printable: true,
            });
        }
        // The newline will mark the end of the directive.
        newLineIsTrivia = false;
        const args = [];
        while (token() !== Token.NewLine && token() !== Token.EndOfFile) {
            const param = parseDirectiveParameter();
            if (param) {
                args.push(param);
            }
        }
        newLineIsTrivia = true;
        nextToken();
        return {
            kind: SyntaxKind.DirectiveExpression,
            arguments: args,
            target,
            ...finishNode(pos),
        };
    }
    function parseDirectiveParameter() {
        switch (token()) {
            case Token.Identifier:
                return parseIdentifier();
            case Token.StringLiteral:
                return parseStringLiteral();
            default:
                error({
                    code: "token-expected",
                    messageId: "unexpected",
                    format: { token: Token[token()] },
                });
                do {
                    nextToken();
                } while (!isStatementKeyword(token()) &&
                    token() !== Token.NewLine &&
                    token() !== Token.At &&
                    token() !== Token.Semicolon &&
                    token() !== Token.EndOfFile);
                return undefined;
        }
    }
    function parseIdentifierOrMemberExpression(message, recoverFromKeyword = true) {
        const pos = tokenPos();
        let base = parseIdentifier({
            message,
            recoverFromKeyword,
        });
        while (token() !== Token.EndOfFile) {
            if (parseOptional(Token.Dot)) {
                base = {
                    kind: SyntaxKind.MemberExpression,
                    base,
                    // Error recovery: false arg here means don't treat a keyword as an
                    // identifier after `.` in member expression. Otherwise we will
                    // parse `@Outer.<missing identifier> model M{}` as having decorator
                    // `@Outer.model` applied to invalid statement `M {}` instead of
                    // having incomplete decorator `@Outer.` applied to `model M {}`.
                    id: parseIdentifier({
                        recoverFromKeyword: false,
                    }),
                    selector: ".",
                    ...finishNode(pos),
                };
            }
            else if (parseOptional(Token.ColonColon)) {
                base = {
                    kind: SyntaxKind.MemberExpression,
                    base,
                    id: parseIdentifier(),
                    selector: "::",
                    ...finishNode(pos),
                };
            }
            else {
                break;
            }
        }
        return base;
    }
    function parsePrimaryExpression() {
        while (true) {
            switch (token()) {
                case Token.ValueOfKeyword:
                    return parseValueOfExpression();
                case Token.Identifier:
                    return parseReferenceExpression();
                case Token.StringLiteral:
                    return parseStringLiteral();
                case Token.StringTemplateHead:
                    return parseStringTemplateExpression();
                case Token.TrueKeyword:
                case Token.FalseKeyword:
                    return parseBooleanLiteral();
                case Token.NumericLiteral:
                    return parseNumericLiteral();
                case Token.OpenBrace:
                    return parseModelExpression();
                case Token.OpenBracket:
                    return parseTupleExpression();
                case Token.OpenParen:
                    return parseParenthesizedExpression();
                case Token.At:
                    const decorators = parseDecoratorList();
                    reportInvalidDecorators(decorators, "expression");
                    continue;
                case Token.Hash:
                    const directives = parseDirectiveList();
                    reportInvalidDirective(directives, "expression");
                    continue;
                case Token.VoidKeyword:
                    return parseVoidKeyword();
                case Token.NeverKeyword:
                    return parseNeverKeyword();
                case Token.UnknownKeyword:
                    return parseUnknownKeyword();
                default:
                    return parseReferenceExpression("expression");
            }
        }
    }
    function parseExternKeyword() {
        const pos = tokenPos();
        parseExpected(Token.ExternKeyword);
        return {
            kind: SyntaxKind.ExternKeyword,
            ...finishNode(pos),
        };
    }
    function parseVoidKeyword() {
        const pos = tokenPos();
        parseExpected(Token.VoidKeyword);
        return {
            kind: SyntaxKind.VoidKeyword,
            ...finishNode(pos),
        };
    }
    function parseNeverKeyword() {
        const pos = tokenPos();
        parseExpected(Token.NeverKeyword);
        return {
            kind: SyntaxKind.NeverKeyword,
            ...finishNode(pos),
        };
    }
    function parseUnknownKeyword() {
        const pos = tokenPos();
        parseExpected(Token.UnknownKeyword);
        return {
            kind: SyntaxKind.UnknownKeyword,
            ...finishNode(pos),
        };
    }
    function parseParenthesizedExpression() {
        const pos = tokenPos();
        parseExpected(Token.OpenParen);
        const expr = parseExpression();
        parseExpected(Token.CloseParen);
        return { ...expr, ...finishNode(pos) };
    }
    function parseTupleExpression() {
        const pos = tokenPos();
        const values = parseList(ListKind.Tuple, parseExpression);
        return {
            kind: SyntaxKind.TupleExpression,
            values,
            ...finishNode(pos),
        };
    }
    function parseModelExpression() {
        const pos = tokenPos();
        const properties = parseList(ListKind.ModelProperties, parseModelPropertyOrSpread);
        return {
            kind: SyntaxKind.ModelExpression,
            properties,
            ...finishNode(pos),
        };
    }
    function parseStringLiteral() {
        const pos = tokenPos();
        const value = tokenValue();
        parseExpected(Token.StringLiteral);
        return {
            kind: SyntaxKind.StringLiteral,
            value,
            ...finishNode(pos),
        };
    }
    function parseStringTemplateExpression() {
        const pos = tokenPos();
        const head = parseStringTemplateHead();
        const spans = parseStringTemplateSpans(head.tokenFlags);
        const last = spans[spans.length - 1];
        if (head.tokenFlags & TokenFlags.TripleQuoted) {
            const [indentationsStart, indentationEnd] = scanner.findTripleQuotedStringIndent(last.literal.pos, last.literal.end);
            mutate(head).value = scanner.unindentAndUnescapeTripleQuotedString(head.pos, head.end, indentationsStart, indentationEnd, Token.StringTemplateHead, head.tokenFlags);
            for (const span of spans) {
                mutate(span.literal).value = scanner.unindentAndUnescapeTripleQuotedString(span.literal.pos, span.literal.end, indentationsStart, indentationEnd, span === last ? Token.StringTemplateTail : Token.StringTemplateMiddle, head.tokenFlags);
            }
        }
        return {
            kind: SyntaxKind.StringTemplateExpression,
            head,
            spans,
            ...finishNode(pos),
        };
    }
    function parseStringTemplateHead() {
        const pos = tokenPos();
        const flags = tokenFlags();
        const text = flags & TokenFlags.TripleQuoted ? "" : tokenValue();
        parseExpected(Token.StringTemplateHead);
        return {
            kind: SyntaxKind.StringTemplateHead,
            value: text,
            tokenFlags: flags,
            ...finishNode(pos),
        };
    }
    function parseStringTemplateSpans(tokenFlags) {
        const list = [];
        let node;
        do {
            node = parseTemplateTypeSpan(tokenFlags);
            list.push(node);
        } while (node.literal.kind === SyntaxKind.StringTemplateMiddle);
        return list;
    }
    function parseTemplateTypeSpan(tokenFlags) {
        const pos = tokenPos();
        const expression = parseExpression();
        const literal = parseLiteralOfTemplateSpan(tokenFlags);
        return {
            kind: SyntaxKind.StringTemplateSpan,
            literal,
            expression,
            ...finishNode(pos),
        };
    }
    function parseLiteralOfTemplateSpan(headTokenFlags) {
        const pos = tokenPos();
        const flags = tokenFlags();
        const text = flags & TokenFlags.TripleQuoted ? "" : tokenValue();
        if (token() === Token.CloseBrace) {
            nextStringTemplateToken(headTokenFlags);
            return parseTemplateMiddleOrTemplateTail();
        }
        else {
            parseExpected(Token.StringTemplateTail);
            return {
                kind: SyntaxKind.StringTemplateTail,
                value: text,
                tokenFlags: flags,
                ...finishNode(pos),
            };
        }
    }
    function parseTemplateMiddleOrTemplateTail() {
        const pos = tokenPos();
        const flags = tokenFlags();
        const text = flags & TokenFlags.TripleQuoted ? "" : tokenValue();
        const kind = token() === Token.StringTemplateMiddle
            ? SyntaxKind.StringTemplateMiddle
            : SyntaxKind.StringTemplateTail;
        nextToken();
        return {
            kind,
            value: text,
            tokenFlags: flags,
            ...finishNode(pos),
        };
    }
    function parseNumericLiteral() {
        const pos = tokenPos();
        const valueAsString = tokenValue();
        const value = Number(valueAsString);
        parseExpected(Token.NumericLiteral);
        return {
            kind: SyntaxKind.NumericLiteral,
            value,
            valueAsString,
            ...finishNode(pos),
        };
    }
    function parseBooleanLiteral() {
        const pos = tokenPos();
        const token = parseExpectedOneOf(Token.TrueKeyword, Token.FalseKeyword);
        const value = token === Token.TrueKeyword;
        return {
            kind: SyntaxKind.BooleanLiteral,
            value,
            ...finishNode(pos),
        };
    }
    function parseIdentifier(options) {
        var _a;
        if ((options === null || options === void 0 ? void 0 : options.recoverFromKeyword) !== false && isKeyword(token())) {
            error({ code: "reserved-identifier" });
        }
        else if (token() !== Token.Identifier &&
            (!(options === null || options === void 0 ? void 0 : options.allowStringLiteral) || token() !== Token.StringLiteral)) {
            // Error recovery: when we fail to parse an identifier or expression,
            // we insert a synthesized identifier with a unique name.
            error({ code: "token-expected", messageId: (_a = options === null || options === void 0 ? void 0 : options.message) !== null && _a !== void 0 ? _a : "identifier" });
            return createMissingIdentifier();
        }
        const pos = tokenPos();
        const sv = tokenValue();
        nextToken();
        return {
            kind: SyntaxKind.Identifier,
            sv,
            ...finishNode(pos),
        };
    }
    function parseDeclaration(pos) {
        const modifiers = parseModifiers();
        switch (token()) {
            case Token.DecKeyword:
                return parseDecoratorDeclarationStatement(pos, modifiers);
            case Token.FnKeyword:
                return parseFunctionDeclarationStatement(pos, modifiers);
        }
        return parseInvalidStatement(pos, []);
    }
    function parseModifiers() {
        const modifiers = [];
        let modifier;
        while ((modifier = parseModifier())) {
            modifiers.push(modifier);
        }
        return modifiers;
    }
    function parseModifier() {
        switch (token()) {
            case Token.ExternKeyword:
                return parseExternKeyword();
            default:
                return undefined;
        }
    }
    function parseDecoratorDeclarationStatement(pos, modifiers) {
        const modifierFlags = modifiersToFlags(modifiers);
        parseExpected(Token.DecKeyword);
        const id = parseIdentifier();
        let [target, ...parameters] = parseFunctionParameters();
        if (target === undefined) {
            error({ code: "decorator-decl-target", target: { pos, end: previousTokenEnd } });
            target = {
                kind: SyntaxKind.FunctionParameter,
                id: createMissingIdentifier(),
                type: createMissingIdentifier(),
                optional: false,
                rest: false,
                ...finishNode(pos),
            };
        }
        if (target.optional) {
            error({ code: "decorator-decl-target", messageId: "required" });
        }
        parseExpected(Token.Semicolon);
        return {
            kind: SyntaxKind.DecoratorDeclarationStatement,
            modifiers,
            modifierFlags,
            id,
            target,
            parameters,
            ...finishNode(pos),
        };
    }
    function parseFunctionDeclarationStatement(pos, modifiers) {
        const modifierFlags = modifiersToFlags(modifiers);
        parseExpected(Token.FnKeyword);
        const id = parseIdentifier();
        const parameters = parseFunctionParameters();
        let returnType;
        if (parseOptional(Token.Colon)) {
            returnType = parseExpression();
        }
        parseExpected(Token.Semicolon);
        return {
            kind: SyntaxKind.FunctionDeclarationStatement,
            modifiers,
            modifierFlags,
            id,
            parameters,
            returnType,
            ...finishNode(pos),
        };
    }
    function parseFunctionParameters() {
        const parameters = parseList(ListKind.FunctionParameters, parseFunctionParameter);
        let foundOptional = false;
        for (const [index, item] of parameters.entries()) {
            if (!item.optional && foundOptional) {
                error({ code: "required-parameter-first", target: item });
                continue;
            }
            if (item.optional) {
                foundOptional = true;
            }
            if (item.rest && item.optional) {
                error({ code: "rest-parameter-required", target: item });
            }
            if (item.rest && index !== parameters.length - 1) {
                error({ code: "rest-parameter-last", target: item });
            }
        }
        return parameters;
    }
    function parseFunctionParameter() {
        const pos = tokenPos();
        const rest = parseOptional(Token.Ellipsis);
        const id = parseIdentifier({ message: "property" });
        const optional = parseOptional(Token.Question);
        let type;
        if (parseOptional(Token.Colon)) {
            type = parseExpression();
        }
        return {
            kind: SyntaxKind.FunctionParameter,
            id,
            type,
            optional,
            rest,
            ...finishNode(pos),
        };
    }
    function modifiersToFlags(modifiers) {
        let flags = 0 /* ModifierFlags.None */;
        for (const modifier of modifiers) {
            switch (modifier.kind) {
                case SyntaxKind.ExternKeyword:
                    flags |= 2 /* ModifierFlags.Extern */;
                    break;
            }
        }
        return flags;
    }
    function parseProjectionStatement(pos) {
        parseExpected(Token.ProjectionKeyword);
        const selector = parseProjectionSelector();
        parseExpected(Token.Hash);
        const id = parseIdentifier();
        parseExpected(Token.OpenBrace);
        const projectionMap = new Map();
        const projections = [];
        while (token() === Token.Identifier) {
            const projection = parseProjection();
            if (projection.direction !== "<error>") {
                if (projectionMap.has(projection.direction)) {
                    error({ code: "duplicate-symbol", target: projection, format: { name: "projection" } });
                }
                else {
                    projectionMap.set(projection.direction, projection);
                }
            }
            // NOTE: Don't drop projections with error in direction definition from the AST.
            projections.push(projection);
        }
        parseExpected(Token.CloseBrace);
        return {
            kind: SyntaxKind.ProjectionStatement,
            selector,
            projections,
            preTo: projectionMap.get("pre_to"),
            preFrom: projectionMap.get("pre_from"),
            from: projectionMap.get("from"),
            to: projectionMap.get("to"),
            id,
            ...finishNode(pos),
        };
    }
    function parseProjection() {
        const pos = tokenPos();
        let directionId = parseIdentifier({ message: "projectionDirection" });
        let direction;
        const modifierIds = [];
        let isPre = false;
        if (directionId.sv === "pre") {
            isPre = true;
            modifierIds.push(directionId);
            directionId = parseIdentifier({ message: "projectionDirection" });
        }
        if (directionId.sv !== "to" && directionId.sv !== "from") {
            error({ code: "token-expected", messageId: "projectionDirection" });
            direction = "<error>";
        }
        else if (isPre) {
            direction = directionId.sv === "to" ? "pre_to" : "pre_from";
        }
        else {
            direction = directionId.sv;
        }
        let parameters;
        if (token() === Token.OpenParen) {
            parameters = parseList(ListKind.ProjectionParameter, parseProjectionParameter);
        }
        else {
            parameters = [];
        }
        parseExpected(Token.OpenBrace);
        const body = parseProjectionStatementList();
        parseExpected(Token.CloseBrace);
        return {
            kind: SyntaxKind.Projection,
            body,
            direction,
            directionId,
            modifierIds,
            parameters,
            ...finishNode(pos),
        };
    }
    function parseProjectionParameter() {
        const pos = tokenPos();
        const id = parseIdentifier();
        return {
            kind: SyntaxKind.ProjectionParameterDeclaration,
            id,
            ...finishNode(pos),
        };
    }
    function parseProjectionStatementList() {
        const stmts = [];
        while (token() !== Token.CloseBrace) {
            const startPos = tokenPos();
            if (token() === Token.EndOfFile) {
                error({ code: "token-expected", messageId: "default", format: { token: "}" } });
                break;
            }
            const expr = parseProjectionExpressionStatement();
            stmts.push(expr);
            if (tokenPos() === startPos) {
                // we didn't manage to parse anything, so break out
                // and we'll report errors elsewhere.
                break;
            }
        }
        return stmts;
    }
    function parseProjectionExpressionStatement() {
        const pos = tokenPos();
        const expr = parseProjectionExpression();
        parseExpected(Token.Semicolon);
        return {
            kind: SyntaxKind.ProjectionExpressionStatement,
            expr,
            ...finishNode(pos),
        };
    }
    function parseProjectionExpression() {
        return parseProjectionReturnExpressionOrHigher();
    }
    function parseProjectionReturnExpressionOrHigher() {
        if (token() === Token.ReturnKeyword) {
            const pos = tokenPos();
            parseExpected(Token.ReturnKeyword);
            return {
                kind: SyntaxKind.Return,
                value: parseProjectionExpression(),
                ...finishNode(pos),
            };
        }
        return parseProjectionLogicalOrExpressionOrHigher();
    }
    function parseProjectionLogicalOrExpressionOrHigher() {
        let expr = parseProjectionLogicalAndExpressionOrHigher();
        while (token() !== Token.EndOfFile) {
            const pos = expr.pos;
            if (parseOptional(Token.BarBar)) {
                expr = {
                    kind: SyntaxKind.ProjectionLogicalExpression,
                    op: "||",
                    left: expr,
                    right: parseProjectionLogicalAndExpressionOrHigher(),
                    ...finishNode(pos),
                };
            }
            else {
                break;
            }
        }
        return expr;
    }
    function parseProjectionLogicalAndExpressionOrHigher() {
        let expr = parseProjectionEqualityExpressionOrHigher();
        while (token() !== Token.EndOfFile) {
            const pos = expr.pos;
            if (parseOptional(Token.AmpsersandAmpersand)) {
                expr = {
                    kind: SyntaxKind.ProjectionLogicalExpression,
                    op: "&&",
                    left: expr,
                    right: parseProjectionEqualityExpressionOrHigher(),
                    ...finishNode(pos),
                };
            }
            else {
                break;
            }
        }
        return expr;
    }
    function parseProjectionEqualityExpressionOrHigher() {
        let expr = parseProjectionRelationalExpressionOrHigher();
        while (token() !== Token.EndOfFile) {
            const pos = expr.pos;
            const tok = token();
            if (tok === Token.EqualsEquals || tok === Token.ExclamationEquals) {
                const op = tokenValue();
                nextToken();
                expr = {
                    kind: SyntaxKind.ProjectionEqualityExpression,
                    op,
                    left: expr,
                    right: parseProjectionRelationalExpressionOrHigher(),
                    ...finishNode(pos),
                };
            }
            else {
                break;
            }
        }
        return expr;
    }
    function parseProjectionRelationalExpressionOrHigher() {
        let expr = parseProjectionAdditiveExpressionOrHigher();
        while (token() !== Token.EndOfFile) {
            const pos = expr.pos;
            const tok = token();
            if (tok === Token.LessThan ||
                tok === Token.LessThanEquals ||
                tok === Token.GreaterThan ||
                tok === Token.GreaterThanEquals) {
                const op = tokenValue();
                nextToken();
                expr = {
                    kind: SyntaxKind.ProjectionRelationalExpression,
                    op,
                    left: expr,
                    right: parseProjectionAdditiveExpressionOrHigher(),
                    ...finishNode(pos),
                };
            }
            else {
                break;
            }
        }
        return expr;
    }
    function parseProjectionAdditiveExpressionOrHigher() {
        let expr = parseProjectionMultiplicativeExpressionOrHigher();
        while (token() !== Token.EndOfFile) {
            const pos = expr.pos;
            const tok = token();
            if (tok === Token.Plus || tok === Token.Hyphen) {
                const op = tokenValue();
                nextToken();
                expr = {
                    kind: SyntaxKind.ProjectionArithmeticExpression,
                    op,
                    left: expr,
                    right: parseProjectionMultiplicativeExpressionOrHigher(),
                    ...finishNode(pos),
                };
            }
            else {
                break;
            }
        }
        return expr;
    }
    function parseProjectionMultiplicativeExpressionOrHigher() {
        let expr = parseProjectionUnaryExpressionOrHigher();
        while (token() !== Token.EndOfFile) {
            const pos = expr.pos;
            const tok = token();
            if (tok === Token.ForwardSlash || tok === Token.Star) {
                const op = tokenValue();
                nextToken();
                expr = {
                    kind: SyntaxKind.ProjectionArithmeticExpression,
                    op,
                    left: expr,
                    right: parseProjectionUnaryExpressionOrHigher(),
                    ...finishNode(pos),
                };
            }
            else {
                break;
            }
        }
        return expr;
    }
    function parseProjectionUnaryExpressionOrHigher() {
        if (token() === Token.Exclamation) {
            const pos = tokenPos();
            nextToken();
            return {
                kind: SyntaxKind.ProjectionUnaryExpression,
                op: "!",
                target: parseProjectionUnaryExpressionOrHigher(),
                ...finishNode(pos),
            };
        }
        return parseProjectionCallExpressionOrHigher();
    }
    function parseProjectionCallExpressionOrHigher() {
        let expr = parseProjectionDecoratorReferenceExpressionOrHigher();
        while (token() !== Token.EndOfFile) {
            const pos = expr.pos;
            expr = parseProjectionMemberExpressionRest(expr, pos);
            if (token() === Token.OpenParen) {
                expr = {
                    kind: SyntaxKind.ProjectionCallExpression,
                    callKind: "method",
                    target: expr,
                    arguments: parseList(ListKind.CallArguments, parseProjectionExpression),
                    ...finishNode(pos),
                };
            }
            else {
                break;
            }
        }
        return expr;
    }
    function parseProjectionDecoratorReferenceExpressionOrHigher() {
        if (token() === Token.At) {
            const pos = tokenPos();
            nextToken();
            return {
                kind: SyntaxKind.ProjectionDecoratorReferenceExpression,
                target: parseIdentifierOrMemberExpression(undefined, true),
                ...finishNode(pos),
            };
        }
        return parseProjectionMemberExpressionOrHigher();
    }
    function parseProjectionMemberExpressionOrHigher() {
        const pos = tokenPos();
        let expr = parseProjectionPrimaryExpression();
        expr = parseProjectionMemberExpressionRest(expr, pos);
        return expr;
    }
    function parseProjectionMemberExpressionRest(expr, pos) {
        while (token() !== Token.EndOfFile) {
            if (parseOptional(Token.Dot)) {
                expr = {
                    kind: SyntaxKind.ProjectionMemberExpression,
                    base: expr,
                    id: parseIdentifier(),
                    selector: ".",
                    ...finishNode(pos),
                };
            }
            else if (parseOptional(Token.ColonColon)) {
                expr = {
                    kind: SyntaxKind.ProjectionMemberExpression,
                    base: expr,
                    id: parseIdentifier(),
                    selector: "::",
                    ...finishNode(pos),
                };
            }
            else {
                break;
            }
        }
        return expr;
    }
    function parseProjectionPrimaryExpression() {
        switch (token()) {
            case Token.IfKeyword:
                return parseProjectionIfExpression();
            case Token.NumericLiteral:
                return parseNumericLiteral();
            case Token.StringLiteral:
                return parseStringLiteral();
            case Token.TrueKeyword:
            case Token.FalseKeyword:
                return parseBooleanLiteral();
            case Token.OpenBracket:
                return parseProjectionTupleExpression();
            case Token.OpenBrace:
                return parseProjectionModelExpression();
            case Token.OpenParen:
                return parseProjectionLambdaOrParenthesizedExpression();
            case Token.VoidKeyword:
                return parseVoidKeyword();
            case Token.NeverKeyword:
                return parseNeverKeyword();
            case Token.UnknownKeyword:
                return parseUnknownKeyword();
            default:
                return parseIdentifier({ message: "expression" });
        }
    }
    function parseProjectionLambdaOrParenthesizedExpression() {
        const pos = tokenPos();
        const exprs = parseList(ListKind.ProjectionExpression, parseProjectionExpression);
        if (token() === Token.EqualsGreaterThan) {
            // unpack the exprs (which should be just identifiers) into a param list
            const params = [];
            for (const expr of exprs) {
                if (expr.kind === SyntaxKind.Identifier) {
                    params.push(withSymbol({
                        kind: SyntaxKind.ProjectionLambdaParameterDeclaration,
                        id: expr,
                        pos: expr.pos,
                        end: expr.end,
                        flags: 0 /* NodeFlags.None */,
                    }));
                }
                else {
                    error({ code: "token-expected", messageId: "identifier", target: expr });
                }
            }
            return parseProjectionLambdaExpressionRest(pos, params);
        }
        else {
            if (exprs.length === 0) {
                error({
                    code: "token-expected",
                    messageId: "expression",
                });
            }
            // verify we only have one entry
            for (let i = 1; i < exprs.length; i++) {
                error({
                    code: "token-expected",
                    messageId: "unexpected",
                    format: { token: "expression" },
                    target: exprs[i],
                });
            }
            return exprs[0];
        }
    }
    function parseProjectionLambdaExpressionRest(pos, parameters) {
        parseExpected(Token.EqualsGreaterThan);
        const body = parseProjectionBlockExpression();
        return {
            kind: SyntaxKind.ProjectionLambdaExpression,
            parameters,
            body,
            ...finishNode(pos),
        };
    }
    function parseProjectionModelExpression() {
        const pos = tokenPos();
        const properties = parseList(ListKind.ModelProperties, parseProjectionModelPropertyOrSpread);
        return {
            kind: SyntaxKind.ProjectionModelExpression,
            properties,
            ...finishNode(pos),
        };
    }
    function parseProjectionModelPropertyOrSpread(pos, decorators) {
        return token() === Token.Ellipsis
            ? parseProjectionModelSpreadProperty(pos, decorators)
            : parseProjectionModelProperty(pos, decorators);
    }
    function parseProjectionModelSpreadProperty(pos, decorators) {
        parseExpected(Token.Ellipsis);
        reportInvalidDecorators(decorators, "spread property");
        const target = parseProjectionExpression();
        return {
            kind: SyntaxKind.ProjectionModelSpreadProperty,
            target,
            ...finishNode(pos),
        };
    }
    function parseProjectionModelProperty(pos, decorators) {
        const id = parseIdentifier({ message: "property", allowStringLiteral: true });
        const optional = parseOptional(Token.Question);
        parseExpected(Token.Colon);
        const value = parseProjectionExpression();
        const hasDefault = parseOptional(Token.Equals);
        const defaultValue = hasDefault ? parseProjectionExpression() : undefined;
        return {
            kind: SyntaxKind.ProjectionModelProperty,
            id,
            decorators,
            value,
            optional,
            default: defaultValue,
            ...finishNode(pos),
        };
    }
    function parseProjectionIfExpression() {
        const pos = tokenPos();
        parseExpected(Token.IfKeyword);
        const test = parseProjectionExpression();
        const consequent = parseProjectionBlockExpression();
        let alternate = undefined;
        if (parseOptional(Token.ElseKeyword)) {
            if (token() === Token.IfKeyword) {
                alternate = parseProjectionIfExpression();
            }
            else {
                alternate = parseProjectionBlockExpression();
            }
        }
        return {
            kind: SyntaxKind.ProjectionIfExpression,
            test,
            consequent,
            alternate,
            ...finishNode(pos),
        };
    }
    function parseProjectionBlockExpression() {
        const pos = tokenPos();
        parseExpected(Token.OpenBrace);
        const statements = parseProjectionStatementList();
        parseExpected(Token.CloseBrace);
        return {
            kind: SyntaxKind.ProjectionBlockExpression,
            statements,
            ...finishNode(pos),
        };
    }
    function parseProjectionTupleExpression() {
        const pos = tokenPos();
        const values = parseList(ListKind.Tuple, parseProjectionExpression);
        return {
            kind: SyntaxKind.ProjectionTupleExpression,
            values,
            ...finishNode(pos),
        };
    }
    function parseProjectionSelector() {
        const pos = tokenPos();
        const selectorTok = expectTokenIsOneOf(Token.Identifier, Token.ModelKeyword, Token.OpKeyword, Token.InterfaceKeyword, Token.UnionKeyword, Token.EnumKeyword);
        switch (selectorTok) {
            case Token.Identifier:
                const id = parseIdentifierOrMemberExpression(undefined, true);
                if (id.kind === SyntaxKind.Identifier) {
                    switch (id.sv) {
                        case "modelproperty":
                            return {
                                kind: SyntaxKind.ProjectionModelPropertySelector,
                                ...finishNode(pos),
                            };
                        case "unionvariant":
                            return {
                                kind: SyntaxKind.ProjectionUnionVariantSelector,
                                ...finishNode(pos),
                            };
                        case "enummember":
                            return {
                                kind: SyntaxKind.ProjectionEnumMemberSelector,
                                ...finishNode(pos),
                            };
                    }
                }
                return id;
            case Token.ModelKeyword:
                nextToken();
                return {
                    kind: SyntaxKind.ProjectionModelSelector,
                    ...finishNode(pos),
                };
            case Token.OpKeyword:
                nextToken();
                return {
                    kind: SyntaxKind.ProjectionOperationSelector,
                    ...finishNode(pos),
                };
            case Token.InterfaceKeyword:
                nextToken();
                return {
                    kind: SyntaxKind.ProjectionInterfaceSelector,
                    ...finishNode(pos),
                };
            case Token.UnionKeyword:
                nextToken();
                return {
                    kind: SyntaxKind.ProjectionUnionSelector,
                    ...finishNode(pos),
                };
            case Token.EnumKeyword:
                nextToken();
                return {
                    kind: SyntaxKind.ProjectionEnumSelector,
                    ...finishNode(pos),
                };
            default:
                // recovery: return a missing identifier to use as the selector
                // we don't need to emit a diagnostic here as the `expectTokenOneOf` above
                // will have done so.
                return createMissingIdentifier();
        }
    }
    function parseRange(mode, range, callback) {
        const savedMode = currentMode;
        const result = scanner.scanRange(range, () => {
            currentMode = mode;
            nextToken();
            return callback();
        });
        currentMode = savedMode;
        return result;
    }
    /** Remove leading slash-star-star and trailing  star-slash (if terminated) from doc comment range. */
    function innerDocRange(range) {
        return {
            pos: range.pos + 3,
            end: tokenFlags() & TokenFlags.Unterminated ? range.end : range.end - 2,
        };
    }
    function parseDocList() {
        if (docRanges.length === 0 || options.docs === false) {
            return [tokenPos(), []];
        }
        const docs = [];
        for (const range of docRanges) {
            const doc = parseRange(1 /* ParseMode.Doc */, innerDocRange(range), () => parseDoc(range));
            docs.push(doc);
            if (range.comment) {
                mutate(range.comment).parsedAsDocs = true;
            }
        }
        return [docRanges[0].pos, docs];
    }
    function parseDoc(range) {
        const content = [];
        const tags = [];
        loop: while (true) {
            switch (token()) {
                case Token.EndOfFile:
                    break loop;
                case Token.At:
                    const tag = parseDocTag();
                    tags.push(tag);
                    break;
                default:
                    content.push(...parseDocContent());
                    break;
            }
        }
        return {
            kind: SyntaxKind.Doc,
            content,
            tags,
            ...finishNode(range.pos),
            end: range.end,
        };
    }
    function parseDocContent() {
        const parts = [];
        const source = scanner.file.text;
        const pos = tokenPos();
        let start = pos;
        let inCodeFence = false;
        loop: while (true) {
            switch (token()) {
                case Token.DocCodeFenceDelimiter:
                    inCodeFence = !inCodeFence;
                    nextToken();
                    break;
                case Token.NewLine:
                    parts.push(source.substring(start, tokenPos()));
                    parts.push("\n"); // normalize line endings
                    nextToken();
                    start = tokenPos();
                    while (parseOptional(Token.Whitespace))
                        ;
                    if (parseOptional(Token.Star)) {
                        parseOptional(Token.Whitespace);
                        start = tokenPos();
                        break;
                    }
                    break;
                case Token.EndOfFile:
                    break loop;
                case Token.At:
                    if (!inCodeFence) {
                        break loop;
                    }
                    nextToken();
                    break;
                default:
                    nextToken();
                    break;
            }
        }
        parts.push(source.substring(start, tokenPos()));
        const text = trim(parts.join(""));
        return [
            {
                kind: SyntaxKind.DocText,
                text,
                ...finishNode(pos),
            },
        ];
    }
    /**
     * Parses a documentation tag.
     *
     * @see <a href="https://microsoft.github.io/typespec/language-basics/documentation#doc-comments">TypeSpec documentation docs</a>
     */
    function parseDocTag() {
        const pos = tokenPos();
        parseExpected(Token.At);
        const tagName = parseDocIdentifier("tag");
        switch (tagName.sv) {
            case "param":
                return parseDocParamLikeTag(pos, tagName, SyntaxKind.DocParamTag, "param");
            case "template":
                return parseDocParamLikeTag(pos, tagName, SyntaxKind.DocTemplateTag, "templateParam");
            case "return":
            case "returns":
                return parseDocSimpleTag(pos, tagName, SyntaxKind.DocReturnsTag);
            case "errors":
                return parseDocSimpleTag(pos, tagName, SyntaxKind.DocErrorsTag);
            default:
                return parseDocSimpleTag(pos, tagName, SyntaxKind.DocUnknownTag);
        }
    }
    /**
     * Handles param-like documentation comment tags.
     * For example, `@param` and `@template`.
     */
    function parseDocParamLikeTag(pos, tagName, kind, messageId) {
        const name = parseDocIdentifier(messageId);
        parseOptionalHyphenDocParamLikeTag();
        const content = parseDocContent();
        return {
            kind,
            tagName,
            paramName: name,
            content,
            ...finishNode(pos),
        };
    }
    /**
     * Handles the optional hyphen in param-like documentation comment tags.
     *
     * TypeSpec recommends no hyphen, but supports a hyphen to match TSDoc.
     * (Original design discussion recorded in [2390].)
     *
     * [2390]: https://github.com/microsoft/typespec/issues/2390
     */
    function parseOptionalHyphenDocParamLikeTag() {
        while (parseOptional(Token.Whitespace))
            ; // Skip whitespace
        if (parseOptional(Token.Hyphen)) {
            // The doc content started with a hyphen, so skip subsequent whitespace
            // (The if statement already advanced past the hyphen itself.)
            while (parseOptional(Token.Whitespace))
                ;
        }
    }
    function parseDocSimpleTag(pos, tagName, kind) {
        const content = parseDocContent();
        return {
            kind,
            tagName,
            content,
            ...finishNode(pos),
        };
    }
    function parseDocIdentifier(messageId) {
        // We don't allow whitespace between @ and tag name, but allow
        // whitespace before all other identifiers.
        if (messageId !== "tag") {
            while (parseOptional(Token.Whitespace))
                ;
        }
        const pos = tokenPos();
        let sv;
        if (token() === Token.Identifier) {
            sv = tokenValue();
            nextToken();
        }
        else {
            sv = "";
            warning({ code: "doc-invalid-identifier", messageId });
        }
        return {
            kind: SyntaxKind.Identifier,
            sv,
            ...finishNode(pos),
        };
    }
    // utility functions
    function token() {
        return scanner.token;
    }
    function tokenFlags() {
        return scanner.tokenFlags;
    }
    function tokenValue() {
        return scanner.getTokenValue();
    }
    function tokenPos() {
        return scanner.tokenPosition;
    }
    function tokenEnd() {
        return scanner.position;
    }
    function nextToken() {
        // keep track of the previous token end separately from the current scanner
        // position as these will differ when the previous token had trailing
        // trivia, and we don't want to squiggle the trivia.
        previousTokenEnd = scanner.position;
        return currentMode === 0 /* ParseMode.Syntax */ ? nextSyntaxToken() : nextDocToken();
    }
    function nextSyntaxToken() {
        docRanges = [];
        for (;;) {
            scanner.scan();
            if (isTrivia(token())) {
                if (!newLineIsTrivia && token() === Token.NewLine) {
                    break;
                }
                let comment = undefined;
                if (options.comments && isComment(token())) {
                    comment = {
                        kind: token() === Token.SingleLineComment
                            ? SyntaxKind.LineComment
                            : SyntaxKind.BlockComment,
                        pos: tokenPos(),
                        end: tokenEnd(),
                    };
                    comments.push(comment);
                }
                if (tokenFlags() & TokenFlags.DocComment) {
                    docRanges.push({
                        pos: tokenPos(),
                        end: tokenEnd(),
                        comment: comment,
                    });
                }
            }
            else {
                break;
            }
        }
    }
    function nextDocToken() {
        // NOTE: trivia tokens are always significant in doc comments.
        scanner.scanDoc();
    }
    function nextStringTemplateToken(tokenFlags) {
        scanner.reScanStringTemplate(tokenFlags);
    }
    function createMissingIdentifier() {
        const pos = tokenPos();
        previousTokenEnd = pos;
        missingIdentifierCounter++;
        return {
            kind: SyntaxKind.Identifier,
            sv: "<missing identifier>" + missingIdentifierCounter,
            ...finishNode(pos),
        };
    }
    function finishNode(pos) {
        const flags = parseErrorInNextFinishedNode ? 2 /* NodeFlags.ThisNodeHasError */ : 0 /* NodeFlags.None */;
        parseErrorInNextFinishedNode = false;
        return withSymbol({ pos, end: previousTokenEnd, flags });
    }
    // pretend to add as symbol property, likely to a node that is being created.
    function withSymbol(obj) {
        return obj;
    }
    /**
     * Parse a delimited list of elements, including the surrounding open and
     * close punctuation
     *
     * This shared driver function is used to share sensitive error recovery code.
     * In particular, error recovery by inserting tokens deemed missing is
     * susceptible to getting stalled in a loop iteration without making any
     * progress, and we guard against this in a shared place here.
     *
     * Note that statement and decorator lists do not have this issue. We always
     * consume at least a real '@' for a decorator and if the leading token of a
     * statement is not one of our statement keywords, ';', or '@', it is consumed
     * as part of a bad statement. As such, parsing of decorators and statements
     * do not go through here.
     */
    function parseList(kind, parseItem) {
        if (kind.open !== Token.None) {
            parseExpected(kind.open);
        }
        if (kind.allowEmpty && parseOptional(kind.close)) {
            return [];
        }
        const items = [];
        while (true) {
            const startingPos = tokenPos();
            const { pos, docs, directives, decorators } = parseAnnotations({
                skipParsingDocNodes: Boolean(kind.invalidAnnotationTarget),
            });
            if (kind.invalidAnnotationTarget) {
                reportInvalidDecorators(decorators, kind.invalidAnnotationTarget);
                reportInvalidDirective(directives, kind.invalidAnnotationTarget);
            }
            if (directives.length === 0 && decorators.length === 0 && atEndOfListWithError(kind)) {
                // Error recovery: end surrounded list at statement keyword or end
                // of file. Note, however, that we must parse a missing element if
                // there were directives or decorators as we cannot drop those from
                // the tree.
                parseExpected(kind.close);
                break;
            }
            let item;
            if (kind.invalidAnnotationTarget) {
                item = parseItem();
            }
            else {
                item = parseItem(pos, decorators);
                mutate(item).docs = docs;
                mutate(item).directives = directives;
            }
            items.push(item);
            const delimiter = token();
            const delimiterPos = tokenPos();
            if (parseOptionalDelimiter(kind)) {
                // Delimiter found: check if it's trailing.
                if (parseOptional(kind.close)) {
                    if (!kind.trailingDelimiterIsValid) {
                        error({
                            code: "trailing-token",
                            format: { token: TokenDisplay[delimiter] },
                            target: {
                                pos: delimiterPos,
                                end: delimiterPos + 1,
                            },
                        });
                    }
                    // It was trailing and we've consumed the close token.
                    break;
                }
                // Not trailing. We can safely skip the progress check below here
                // because we know that we consumed a real delimiter.
                continue;
            }
            else if (kind.close === Token.None) {
                // If a list is *not* surrounded by punctuation, then the list ends when
                // there's no delimiter after an item.
                break;
            }
            else if (parseOptional(kind.close)) {
                // If a list *is* surrounded by punctuation, then the list ends when we
                // reach the close token.
                break;
            }
            else if (atEndOfListWithError(kind)) {
                // Error recovery: If a list *is* surrounded by punctuation, then
                // the list ends at statement keyword or end-of-file under the
                // assumption that the closing delimiter is missing. This check is
                // duplicated from above to preempt the parseExpected(delimeter)
                // below.
                parseExpected(kind.close);
                break;
            }
            else {
                // Error recovery: if a list kind *is* surrounded by punctuation and we
                // find neither a delimiter nor a close token after an item, then we
                // assume there is a missing delimiter between items.
                //
                // Example: `model M { a: B <missing semicolon> c: D }
                parseExpected(kind.delimiter);
            }
            if (startingPos === tokenPos()) {
                // Error recovery: we've inserted everything during this loop iteration
                // and haven't made any progress. Assume that the current token is a bad
                // representation of the end of the the list that we're trying to get
                // through.
                //
                // Simple repro: `model M { ]` would loop forever without this check.
                //
                parseExpected(kind.close);
                nextToken();
                // remove the item that was entirely inserted by error recovery.
                items.pop();
                break;
            }
        }
        return items;
    }
    /**
     * Parse a delimited list with surrounding open and close punctuation if the
     * open token is present. Otherwise, return an empty list.
     */
    function parseOptionalList(kind, parseItem) {
        return token() === kind.open ? parseList(kind, parseItem) : [];
    }
    function parseOptionalDelimiter(kind) {
        if (parseOptional(kind.delimiter)) {
            return true;
        }
        if (token() === kind.toleratedDelimiter) {
            if (!kind.toleratedDelimiterIsValid) {
                parseExpected(kind.delimiter);
            }
            nextToken();
            return true;
        }
        return false;
    }
    function atEndOfListWithError(kind) {
        return (kind.close !== Token.None &&
            (isStatementKeyword(token()) || token() === Token.EndOfFile) &&
            token() !== kind.allowedStatementKeyword);
    }
    function parseEmptyStatement(pos) {
        parseExpected(Token.Semicolon);
        return { kind: SyntaxKind.EmptyStatement, ...finishNode(pos) };
    }
    function parseInvalidStatement(pos, decorators) {
        // Error recovery: avoid an avalanche of errors when we get cornered into
        // parsing statements where none exist. Skip until we find a statement
        // keyword or decorator and only report one error for a contiguous range of
        // neither.
        do {
            nextToken();
        } while (!isStatementKeyword(token()) &&
            token() !== Token.At &&
            token() !== Token.Semicolon &&
            token() !== Token.EndOfFile);
        error({
            code: "token-expected",
            messageId: "statement",
            target: { pos, end: previousTokenEnd },
        });
        return { kind: SyntaxKind.InvalidStatement, decorators, ...finishNode(pos) };
    }
    function error(report) {
        var _a, _b, _c, _d, _e, _f;
        parseErrorInNextFinishedNode = true;
        const location = {
            file: scanner.file,
            pos: (_b = (_a = report.target) === null || _a === void 0 ? void 0 : _a.pos) !== null && _b !== void 0 ? _b : tokenPos(),
            end: (_d = (_c = report.target) === null || _c === void 0 ? void 0 : _c.end) !== null && _d !== void 0 ? _d : tokenEnd(),
        };
        if (!report.printable) {
            treePrintable = false;
        }
        // Error recovery: don't report more than 1 consecutive error at the same
        // position. The code path taken by error recovery after logging an error
        // can otherwise produce redundant and less decipherable errors, which this
        // suppresses.
        const realPos = (_f = (_e = report.target) === null || _e === void 0 ? void 0 : _e.realPos) !== null && _f !== void 0 ? _f : location.pos;
        if (realPositionOfLastError === realPos) {
            return;
        }
        realPositionOfLastError = realPos;
        const diagnostic = createDiagnostic({
            ...report,
            target: location,
        });
        assert(diagnostic.severity === "error", "This function is for reporting errors. Use warning() for warnings.");
        parseDiagnostics.push(diagnostic);
    }
    function warning(report) {
        var _a, _b, _c, _d;
        const location = {
            file: scanner.file,
            pos: (_b = (_a = report.target) === null || _a === void 0 ? void 0 : _a.pos) !== null && _b !== void 0 ? _b : tokenPos(),
            end: (_d = (_c = report.target) === null || _c === void 0 ? void 0 : _c.end) !== null && _d !== void 0 ? _d : tokenEnd(),
        };
        const diagnostic = createDiagnostic({
            ...report,
            target: location,
        });
        assert(diagnostic.severity === "warning", "This function is for reporting warnings only. Use error() for errors.");
        parseDiagnostics.push(diagnostic);
    }
    function reportDiagnostic(diagnostic) {
        if (diagnostic.severity === "error") {
            parseErrorInNextFinishedNode = true;
            treePrintable = false;
        }
        parseDiagnostics.push(diagnostic);
    }
    function assert(condition, message) {
        const location = {
            file: scanner.file,
            pos: tokenPos(),
            end: tokenEnd(),
        };
        compilerAssert(condition, message, location);
    }
    function reportInvalidDecorators(decorators, nodeName) {
        for (const decorator of decorators) {
            error({ code: "invalid-decorator-location", format: { nodeName }, target: decorator });
        }
    }
    function reportInvalidDirective(directives, nodeName) {
        for (const directive of directives) {
            error({ code: "invalid-directive-location", format: { nodeName }, target: directive });
        }
    }
    function parseExpected(expectedToken) {
        if (token() === expectedToken) {
            nextToken();
            return true;
        }
        const location = getAdjustedDefaultLocation(expectedToken);
        error({
            code: "token-expected",
            format: { token: TokenDisplay[expectedToken] },
            target: location,
            printable: isPunctuation(expectedToken),
        });
        return false;
    }
    function expectTokenIsOneOf(...args) {
        const tok = token();
        for (const expected of args) {
            if (expected === Token.None) {
                continue;
            }
            if (tok === expected) {
                return tok;
            }
        }
        errorTokenIsNotOneOf(...args);
        return Token.None;
    }
    function parseExpectedOneOf(...args) {
        const tok = expectTokenIsOneOf(...args);
        if (tok !== Token.None) {
            nextToken();
        }
        return tok;
    }
    function errorTokenIsNotOneOf(...args) {
        const location = getAdjustedDefaultLocation(args[0]);
        const displayList = args.map((t, i) => {
            if (i === args.length - 1) {
                return `or ${TokenDisplay[t]}`;
            }
            return TokenDisplay[t];
        });
        error({ code: "token-expected", format: { token: displayList.join(", ") }, target: location });
    }
    function parseOptional(optionalToken) {
        if (token() === optionalToken) {
            nextToken();
            return true;
        }
        return false;
    }
    function getAdjustedDefaultLocation(token) {
        // Put the squiggly immediately after prior token when missing punctuation.
        // Avoids saying ';' is expected far away after a long comment, for example.
        // It's also confusing to squiggle the current token even if its nearby
        // in this case.
        return isPunctuation(token)
            ? { pos: previousTokenEnd, end: previousTokenEnd + 1, realPos: tokenPos() }
            : undefined;
    }
}
function visitChildren(node, cb) {
    if (node.directives) {
        const result = visitEach(cb, node.directives);
        if (result)
            return result;
    }
    if (node.docs) {
        const result = visitEach(cb, node.docs);
        if (result)
            return result;
    }
    switch (node.kind) {
        case SyntaxKind.TypeSpecScript:
            return visitNode(cb, node.id) || visitEach(cb, node.statements);
        case SyntaxKind.ArrayExpression:
            return visitNode(cb, node.elementType);
        case SyntaxKind.AugmentDecoratorStatement:
            return (visitNode(cb, node.target) ||
                visitNode(cb, node.targetType) ||
                visitEach(cb, node.arguments));
        case SyntaxKind.DecoratorExpression:
            return visitNode(cb, node.target) || visitEach(cb, node.arguments);
        case SyntaxKind.DirectiveExpression:
            return visitNode(cb, node.target) || visitEach(cb, node.arguments);
        case SyntaxKind.ImportStatement:
            return visitNode(cb, node.path);
        case SyntaxKind.OperationStatement:
            return (visitEach(cb, node.decorators) ||
                visitNode(cb, node.id) ||
                visitEach(cb, node.templateParameters) ||
                visitNode(cb, node.signature));
        case SyntaxKind.OperationSignatureDeclaration:
            return visitNode(cb, node.parameters) || visitNode(cb, node.returnType);
        case SyntaxKind.OperationSignatureReference:
            return visitNode(cb, node.baseOperation);
        case SyntaxKind.NamespaceStatement:
            return (visitEach(cb, node.decorators) ||
                visitNode(cb, node.id) ||
                (isArray(node.statements) ? visitEach(cb, node.statements) : visitNode(cb, node.statements)));
        case SyntaxKind.InterfaceStatement:
            return (visitEach(cb, node.decorators) ||
                visitNode(cb, node.id) ||
                visitEach(cb, node.templateParameters) ||
                visitEach(cb, node.extends) ||
                visitEach(cb, node.operations));
        case SyntaxKind.UsingStatement:
            return visitNode(cb, node.name);
        case SyntaxKind.IntersectionExpression:
            return visitEach(cb, node.options);
        case SyntaxKind.MemberExpression:
            return visitNode(cb, node.base) || visitNode(cb, node.id);
        case SyntaxKind.ModelExpression:
            return visitEach(cb, node.properties);
        case SyntaxKind.ModelProperty:
            return (visitEach(cb, node.decorators) ||
                visitNode(cb, node.id) ||
                visitNode(cb, node.value) ||
                visitNode(cb, node.default));
        case SyntaxKind.ModelSpreadProperty:
            return visitNode(cb, node.target);
        case SyntaxKind.ModelStatement:
            return (visitEach(cb, node.decorators) ||
                visitNode(cb, node.id) ||
                visitEach(cb, node.templateParameters) ||
                visitNode(cb, node.extends) ||
                visitNode(cb, node.is) ||
                visitEach(cb, node.properties));
        case SyntaxKind.ScalarStatement:
            return (visitEach(cb, node.decorators) ||
                visitNode(cb, node.id) ||
                visitEach(cb, node.templateParameters) ||
                visitNode(cb, node.extends));
        case SyntaxKind.UnionStatement:
            return (visitEach(cb, node.decorators) ||
                visitNode(cb, node.id) ||
                visitEach(cb, node.templateParameters) ||
                visitEach(cb, node.options));
        case SyntaxKind.UnionVariant:
            return visitEach(cb, node.decorators) || visitNode(cb, node.id) || visitNode(cb, node.value);
        case SyntaxKind.EnumStatement:
            return (visitEach(cb, node.decorators) || visitNode(cb, node.id) || visitEach(cb, node.members));
        case SyntaxKind.EnumMember:
            return visitEach(cb, node.decorators) || visitNode(cb, node.id) || visitNode(cb, node.value);
        case SyntaxKind.EnumSpreadMember:
            return visitNode(cb, node.target);
        case SyntaxKind.AliasStatement:
            return (visitNode(cb, node.id) ||
                visitEach(cb, node.templateParameters) ||
                visitNode(cb, node.value));
        case SyntaxKind.DecoratorDeclarationStatement:
            return (visitEach(cb, node.modifiers) ||
                visitNode(cb, node.id) ||
                visitNode(cb, node.target) ||
                visitEach(cb, node.parameters));
        case SyntaxKind.FunctionDeclarationStatement:
            return (visitEach(cb, node.modifiers) ||
                visitNode(cb, node.id) ||
                visitEach(cb, node.parameters) ||
                visitNode(cb, node.returnType));
        case SyntaxKind.FunctionParameter:
            return visitNode(cb, node.id) || visitNode(cb, node.type);
        case SyntaxKind.TypeReference:
            return visitNode(cb, node.target) || visitEach(cb, node.arguments);
        case SyntaxKind.ValueOfExpression:
            return visitNode(cb, node.target);
        case SyntaxKind.TupleExpression:
            return visitEach(cb, node.values);
        case SyntaxKind.UnionExpression:
            return visitEach(cb, node.options);
        case SyntaxKind.Projection:
            return (visitNode(cb, node.directionId) ||
                visitEach(cb, node.modifierIds) ||
                visitEach(cb, node.parameters) ||
                visitEach(cb, node.body));
        case SyntaxKind.ProjectionExpressionStatement:
            return visitNode(cb, node.expr);
        case SyntaxKind.ProjectionCallExpression:
            return visitNode(cb, node.target) || visitEach(cb, node.arguments);
        case SyntaxKind.ProjectionMemberExpression:
            return visitNode(cb, node.base) || visitNode(cb, node.id);
        // binops
        case SyntaxKind.ProjectionLogicalExpression:
        case SyntaxKind.ProjectionRelationalExpression:
        case SyntaxKind.ProjectionArithmeticExpression:
        case SyntaxKind.ProjectionEqualityExpression:
            return visitNode(cb, node.left) || visitNode(cb, node.right);
        case SyntaxKind.ProjectionUnaryExpression:
            return visitNode(cb, node.target);
        case SyntaxKind.ProjectionModelExpression:
            return visitEach(cb, node.properties);
        case SyntaxKind.ProjectionModelProperty:
            return (visitEach(cb, node.decorators) ||
                visitNode(cb, node.id) ||
                visitNode(cb, node.value) ||
                visitNode(cb, node.default));
        case SyntaxKind.ProjectionModelSpreadProperty:
            return visitNode(cb, node.target);
        case SyntaxKind.ProjectionTupleExpression:
            return visitEach(cb, node.values);
        case SyntaxKind.ProjectionBlockExpression:
            return visitEach(cb, node.statements);
        case SyntaxKind.ProjectionIfExpression:
            return (visitNode(cb, node.test) || visitNode(cb, node.consequent) || visitNode(cb, node.alternate));
        case SyntaxKind.ProjectionLambdaExpression:
            return visitEach(cb, node.parameters) || visitNode(cb, node.body);
        case SyntaxKind.ProjectionStatement:
            return (visitNode(cb, node.id) || visitNode(cb, node.selector) || visitEach(cb, node.projections));
        case SyntaxKind.ProjectionDecoratorReferenceExpression:
            return visitNode(cb, node.target);
        case SyntaxKind.Return:
            return visitNode(cb, node.value);
        case SyntaxKind.InvalidStatement:
            return visitEach(cb, node.decorators);
        case SyntaxKind.TemplateParameterDeclaration:
            return (visitNode(cb, node.id) || visitNode(cb, node.constraint) || visitNode(cb, node.default));
        case SyntaxKind.ProjectionLambdaParameterDeclaration:
            return visitNode(cb, node.id);
        case SyntaxKind.ProjectionParameterDeclaration:
            return visitNode(cb, node.id);
        case SyntaxKind.Doc:
            return visitEach(cb, node.content) || visitEach(cb, node.tags);
        case SyntaxKind.DocParamTag:
        case SyntaxKind.DocTemplateTag:
            return (visitNode(cb, node.tagName) || visitNode(cb, node.paramName) || visitEach(cb, node.content));
        case SyntaxKind.DocReturnsTag:
        case SyntaxKind.DocErrorsTag:
        case SyntaxKind.DocUnknownTag:
            return visitNode(cb, node.tagName) || visitEach(cb, node.content);
        case SyntaxKind.StringTemplateExpression:
            return visitNode(cb, node.head) || visitEach(cb, node.spans);
        case SyntaxKind.StringTemplateSpan:
            return visitNode(cb, node.expression) || visitNode(cb, node.literal);
        // no children for the rest of these.
        case SyntaxKind.StringTemplateHead:
        case SyntaxKind.StringTemplateMiddle:
        case SyntaxKind.StringTemplateTail:
        case SyntaxKind.StringLiteral:
        case SyntaxKind.NumericLiteral:
        case SyntaxKind.BooleanLiteral:
        case SyntaxKind.Identifier:
        case SyntaxKind.EmptyStatement:
        case SyntaxKind.ProjectionModelSelector:
        case SyntaxKind.ProjectionModelPropertySelector:
        case SyntaxKind.ProjectionUnionSelector:
        case SyntaxKind.ProjectionUnionVariantSelector:
        case SyntaxKind.ProjectionInterfaceSelector:
        case SyntaxKind.ProjectionOperationSelector:
        case SyntaxKind.ProjectionEnumSelector:
        case SyntaxKind.ProjectionEnumMemberSelector:
        case SyntaxKind.VoidKeyword:
        case SyntaxKind.NeverKeyword:
        case SyntaxKind.ExternKeyword:
        case SyntaxKind.UnknownKeyword:
        case SyntaxKind.JsSourceFile:
        case SyntaxKind.JsNamespaceDeclaration:
        case SyntaxKind.DocText:
            return;
        default:
            return;
    }
}
function visitNode(cb, node) {
    return node && cb(node);
}
function visitEach(cb, nodes) {
    if (!nodes) {
        return;
    }
    for (const node of nodes) {
        const result = cb(node);
        if (result) {
            return result;
        }
    }
    return;
}
function getNodeAtPosition(script, position, filter = (node) => true) {
    return visit(script);
    function visit(node) {
        // We deliberately include the end position here because we need to hit
        // nodes when the cursor is positioned immediately after an identifier.
        // This is especially vital for completion. It's also generally OK
        // because the language doesn't (and should never) have syntax where you
        // could place the cursor ambiguously between two adjacent,
        // non-punctuation, non-trivia tokens that have no punctuation or trivia
        // separating them.
        if (node.pos <= position && position <= node.end) {
            // We only need to recursively visit children of nodes that satisfied
            // the condition above and therefore contain the given position. If a
            // node does not contain a position, then neither do its children.
            const child = visitChildren(node, visit);
            // A child match here is better than a self-match below as we want the
            // deepest (most specific) node. In other words, the search is depth
            // first. For example, consider `A<B<C>>`: If the cursor is on `B`,
            // then prefer B<C> over A<B<C>>.
            if (child) {
                return child;
            }
            if (filter(node)) {
                return node;
            }
        }
        return undefined;
    }
}
function hasParseError(node) {
    if (node.flags & 2 /* NodeFlags.ThisNodeHasError */) {
        return true;
    }
    checkForDescendantErrors(node);
    return node.flags & 4 /* NodeFlags.DescendantHasError */;
}
function checkForDescendantErrors(node) {
    if (node.flags & 1 /* NodeFlags.DescendantErrorsExamined */) {
        return;
    }
    mutate(node).flags |= 1 /* NodeFlags.DescendantErrorsExamined */;
    visitChildren(node, (child) => {
        if (child.flags & 2 /* NodeFlags.ThisNodeHasError */) {
            mutate(node).flags |= 4 /* NodeFlags.DescendantHasError */ | 1 /* NodeFlags.DescendantErrorsExamined */;
            return true;
        }
        checkForDescendantErrors(child);
        if (child.flags & 4 /* NodeFlags.DescendantHasError */) {
            mutate(node).flags |= 4 /* NodeFlags.DescendantHasError */ | 1 /* NodeFlags.DescendantErrorsExamined */;
            return true;
        }
        mutate(child).flags |= 1 /* NodeFlags.DescendantErrorsExamined */;
        return false;
    });
}
function isImportStatement(node) {
    return node.kind === SyntaxKind.ImportStatement;
}
function isBlocklessNamespace(node) {
    if (node.kind !== SyntaxKind.NamespaceStatement) {
        return false;
    }
    while (!isArray(node.statements) && node.statements) {
        node = node.statements;
    }
    return node.statements === undefined;
}
function getFirstAncestor(node, test) {
    for (let n = node.parent; n; n = n.parent) {
        if (test(n)) {
            return n;
        }
    }
    return undefined;
}
function getIdentifierContext(id) {
    const node = getFirstAncestor(id, (n) => n.kind !== SyntaxKind.MemberExpression);
    compilerAssert(node, "Identifier with no non-member-expression ancestor.");
    let kind;
    switch (node.kind) {
        case SyntaxKind.TypeReference:
            kind = IdentifierKind.TypeReference;
            break;
        case SyntaxKind.AugmentDecoratorStatement:
        case SyntaxKind.DecoratorExpression:
            kind = IdentifierKind.Decorator;
            break;
        case SyntaxKind.ProjectionCallExpression:
            kind = IdentifierKind.Function;
            break;
        case SyntaxKind.UsingStatement:
            kind = IdentifierKind.Using;
            break;
        default:
            kind =
                id.parent.id === id
                    ? IdentifierKind.Declaration
                    : IdentifierKind.Other;
            break;
    }
    return { node, kind };
}

// Use a regular expression to define the prefix for TypeSpec-exposed functions
// defined in JavaScript modules
const DecoratorFunctionPattern = /^\$/;
const SymbolTable = class extends Map {
    constructor(source) {
        super();
        this.duplicates = new Map();
        if (source) {
            for (const [key, value] of source) {
                // Note: shallow copy of value here so we can mutate flags on set.
                super.set(key, { ...value });
            }
            for (const [key, value] of source.duplicates) {
                this.duplicates.set(key, new Set(value));
            }
        }
    }
    // First set for a given key wins, but record all duplicates for diagnostics.
    set(key, value) {
        const existing = super.get(key);
        if (existing === undefined) {
            super.set(key, value);
        }
        else {
            if (existing.flags & 524288 /* SymbolFlags.Using */) {
                mutate(existing).flags |= 1048576 /* SymbolFlags.DuplicateUsing */;
            }
            const duplicateArray = this.duplicates.get(existing);
            if (duplicateArray) {
                duplicateArray.add(value);
            }
            else {
                this.duplicates.set(existing, new Set([existing, value]));
            }
        }
        return this;
    }
};
function createSymbolTable(source) {
    return new SymbolTable(source);
}
function createBinder(program) {
    let currentFile;
    let parentNode;
    let fileNamespace;
    let scope;
    // tracks which selectors were used with which projection symbols
    // for reporting duplicates
    const projectionSymbolSelectors = new Map();
    return {
        bindSourceFile,
        bindJsSourceFile,
        bindNode,
    };
    function isFunctionName(name) {
        return DecoratorFunctionPattern.test(name);
    }
    function getFunctionName(name) {
        return name.replace(DecoratorFunctionPattern, "");
    }
    function bindJsSourceFile(sourceFile) {
        // cast because it causes TS to make the type of .symbol never other
        if (sourceFile.symbol !== undefined) {
            return;
        }
        const tracer = program.tracer.sub("bind.js");
        fileNamespace = undefined;
        mutate(sourceFile).symbol = createSymbol(sourceFile, sourceFile.file.path, 2097152 /* SymbolFlags.SourceFile */);
        const rootNs = sourceFile.esmExports["namespace"];
        for (const [key, member] of Object.entries(sourceFile.esmExports)) {
            let name;
            let kind;
            let containerSymbol = sourceFile.symbol;
            if (typeof member === "function") {
                // lots of 'any' casts here because control flow narrowing `member` to Function
                // isn't particularly useful it turns out.
                if (isFunctionName(key)) {
                    name = getFunctionName(key);
                    kind = "decorator";
                    if (name === "onValidate") {
                        const context = getLocationContext(program, sourceFile);
                        const metadata = context.type === "library"
                            ? context.metadata
                            : ({ type: "file" });
                        program.onValidate(member, metadata);
                        continue;
                    }
                    else if (name === "onEmit") {
                        // nothing to do here this is loaded as emitter.
                        continue;
                    }
                }
                else {
                    name = key;
                    kind = "function";
                }
                const nsParts = resolveJSMemberNamespaceParts(rootNs, member);
                for (const part of nsParts) {
                    const existingBinding = containerSymbol.exports.get(part);
                    const jsNamespaceNode = {
                        kind: SyntaxKind.JsNamespaceDeclaration,
                        id: {
                            kind: SyntaxKind.Identifier,
                            sv: part,
                            pos: 0,
                            end: 0,
                            flags: 0 /* NodeFlags.None */,
                            symbol: undefined,
                        },
                        pos: sourceFile.pos,
                        end: sourceFile.end,
                        parent: sourceFile,
                        flags: 0 /* NodeFlags.None */,
                        symbol: undefined,
                    };
                    const sym = createSymbol(jsNamespaceNode, part, 4096 /* SymbolFlags.Namespace */, containerSymbol);
                    mutate(jsNamespaceNode).symbol = sym;
                    if (existingBinding) {
                        if (existingBinding.flags & 4096 /* SymbolFlags.Namespace */) {
                            // since the namespace was "declared" as part of this source file,
                            // we can simply re-use it.
                            containerSymbol = existingBinding;
                        }
                        else {
                            // we have some conflict, lets report a duplicate binding error.
                            mutate(containerSymbol.exports).set(part, sym);
                        }
                    }
                    else {
                        mutate(sym).exports = createSymbolTable();
                        mutate(containerSymbol.exports).set(part, sym);
                        containerSymbol = sym;
                    }
                }
                let sym;
                if (kind === "decorator") {
                    tracer.trace("decorator", `Bound decorator "@${name}" in namespace "${nsParts.join(".")}".`);
                    sym = createSymbol(sourceFile, "@" + name, 16384 /* SymbolFlags.Decorator */ | 8388608 /* SymbolFlags.Implementation */, containerSymbol);
                }
                else {
                    tracer.trace("function", `Bound function "${name}" in namespace "${nsParts.join(".")}".`);
                    sym = createSymbol(sourceFile, name, 131072 /* SymbolFlags.Function */ | 8388608 /* SymbolFlags.Implementation */, containerSymbol);
                }
                mutate(sym).value = member;
                mutate(containerSymbol.exports).set(sym.name, sym);
            }
        }
    }
    function resolveJSMemberNamespaceParts(rootNs, member) {
        const memberNs = member.namespace;
        const nsParts = [];
        if (rootNs) {
            nsParts.push(...rootNs.split("."));
        }
        if (memberNs) {
            nsParts.push(...memberNs.split("."));
        }
        return nsParts;
    }
    function bindSourceFile(script) {
        if (script.locals !== undefined) {
            return;
        }
        mutate(script).locals = createSymbolTable();
        mutate(script).symbol = createSymbol(script, script.file.path, 2097152 /* SymbolFlags.SourceFile */);
        mutate(script.symbol).exports = createSymbolTable();
        fileNamespace = undefined;
        currentFile = script;
        scope = script;
        bindNode(script);
    }
    function bindNode(node) {
        if (!node)
            return;
        // set the node's parent since we're going for a walk anyway
        mutate(node).parent = parentNode;
        switch (node.kind) {
            case SyntaxKind.ModelStatement:
                bindModelStatement(node);
                break;
            case SyntaxKind.ModelExpression:
                bindModelExpression(node);
                break;
            case SyntaxKind.ScalarStatement:
                bindScalarStatement(node);
                break;
            case SyntaxKind.InterfaceStatement:
                bindInterfaceStatement(node);
                break;
            case SyntaxKind.UnionStatement:
                bindUnionStatement(node);
                break;
            case SyntaxKind.AliasStatement:
                bindAliasStatement(node);
                break;
            case SyntaxKind.EnumStatement:
                bindEnumStatement(node);
                break;
            case SyntaxKind.NamespaceStatement:
                bindNamespaceStatement(node);
                break;
            case SyntaxKind.OperationStatement:
                bindOperationStatement(node);
                break;
            case SyntaxKind.TemplateParameterDeclaration:
                bindTemplateParameterDeclaration(node);
                break;
            case SyntaxKind.UsingStatement:
                bindUsingStatement(node);
                break;
            case SyntaxKind.DecoratorDeclarationStatement:
                bindDecoratorDeclarationStatement(node);
                break;
            case SyntaxKind.FunctionDeclarationStatement:
                bindFunctionDeclarationStatement(node);
                break;
            case SyntaxKind.FunctionParameter:
                bindFunctionParameter(node);
                break;
            case SyntaxKind.Projection:
                bindProjection(node);
                break;
            case SyntaxKind.ProjectionStatement:
                bindProjectionStatement(node);
                break;
            case SyntaxKind.ProjectionParameterDeclaration:
                bindProjectionParameterDeclaration(node);
                break;
            case SyntaxKind.ProjectionLambdaParameterDeclaration:
                bindProjectionLambdaParameterDeclaration(node);
                break;
            case SyntaxKind.ProjectionLambdaExpression:
                bindProjectionLambdaExpression(node);
        }
        const prevParent = parentNode;
        // set parent node when we walk into children
        parentNode = node;
        if (hasScope(node)) {
            const prevScope = scope;
            scope = node;
            visitChildren(node, bindNode);
            if ("locals" in node) {
                program.reportDuplicateSymbols(node.locals);
            }
            scope = prevScope;
        }
        else {
            visitChildren(node, bindNode);
        }
        // restore parent node
        parentNode = prevParent;
    }
    function bindProjection(node) {
        mutate(node).locals = createSymbolTable();
    }
    /**
     * Binding projection statements is interesting because there may be
     * multiple declarations spread across various source files that all
     * contribute to the same symbol because they declare the same
     * projection on different selectors.
     *
     * There is presently an issue where we do not check for duplicate
     * projections when they're applied to a specific type. This could
     * be done with ease in the checker during evaluation, but could
     * probably instead be done in a post-bind phase - we just need
     * all the symbols in place so we know if a projection was declared
     * multiple times for the same symbol.
     *
     */
    function bindProjectionStatement(node) {
        const name = node.id.sv;
        const table = scope.symbol
            .exports;
        let sym;
        if (table.has(name)) {
            sym = table.get(name);
            if (!(sym.flags & 8192 /* SymbolFlags.Projection */)) {
                // clashing with some other decl, report duplicate symbol
                declareSymbol(node, 8192 /* SymbolFlags.Projection */);
                return;
            }
            mutate(sym.declarations).push(node);
        }
        else {
            sym = createSymbol(node, name, 8192 /* SymbolFlags.Projection */, scope.symbol);
            mutate(table).set(name, sym);
        }
        mutate(node).symbol = sym;
        if (node.selector.kind !== SyntaxKind.Identifier &&
            node.selector.kind !== SyntaxKind.MemberExpression) {
            let selectorString;
            switch (node.selector.kind) {
                case SyntaxKind.ProjectionModelSelector:
                    selectorString = "model";
                    break;
                case SyntaxKind.ProjectionModelPropertySelector:
                    selectorString = "modelproperty";
                    break;
                case SyntaxKind.ProjectionOperationSelector:
                    selectorString = "op";
                    break;
                case SyntaxKind.ProjectionUnionSelector:
                    selectorString = "union";
                    break;
                case SyntaxKind.ProjectionUnionVariantSelector:
                    selectorString = "unionvariant";
                    break;
                case SyntaxKind.ProjectionEnumSelector:
                    selectorString = "enum";
                    break;
                case SyntaxKind.ProjectionEnumMemberSelector:
                    selectorString = "enummember";
                    break;
                case SyntaxKind.ProjectionInterfaceSelector:
                    selectorString = "interface";
                    break;
                default:
                    node.selector;
                    compilerAssert(false, "Unreachable");
            }
            let existingSelectors = projectionSymbolSelectors.get(sym);
            if (!existingSelectors) {
                existingSelectors = new Set();
                projectionSymbolSelectors.set(sym, existingSelectors);
            }
            if (existingSelectors.has(selectorString)) {
                // clashing with a like-named decl with this selector, so throw.
                declareSymbol(node, 8192 /* SymbolFlags.Projection */);
                return;
            }
            existingSelectors.add(selectorString);
        }
    }
    function bindProjectionParameterDeclaration(node) {
        declareSymbol(node, 65536 /* SymbolFlags.ProjectionParameter */);
    }
    function bindProjectionLambdaParameterDeclaration(node) {
        declareSymbol(node, 262144 /* SymbolFlags.FunctionParameter */);
    }
    function bindProjectionLambdaExpression(node) {
        mutate(node).locals = new SymbolTable();
    }
    function bindTemplateParameterDeclaration(node) {
        declareSymbol(node, 32768 /* SymbolFlags.TemplateParameter */);
    }
    function bindModelStatement(node) {
        declareSymbol(node, 2 /* SymbolFlags.Model */);
        // Initialize locals for type parameters
        mutate(node).locals = new SymbolTable();
    }
    function bindModelExpression(node) {
        bindSymbol(node, 2 /* SymbolFlags.Model */);
    }
    function bindScalarStatement(node) {
        declareSymbol(node, 8 /* SymbolFlags.Scalar */);
        // Initialize locals for type parameters
        mutate(node).locals = new SymbolTable();
    }
    function bindInterfaceStatement(node) {
        declareSymbol(node, 128 /* SymbolFlags.Interface */);
        mutate(node).locals = new SymbolTable();
    }
    function bindUnionStatement(node) {
        declareSymbol(node, 512 /* SymbolFlags.Union */);
        mutate(node).locals = new SymbolTable();
    }
    function bindAliasStatement(node) {
        declareSymbol(node, 2048 /* SymbolFlags.Alias */);
        // Initialize locals for type parameters
        mutate(node).locals = new SymbolTable();
    }
    function bindEnumStatement(node) {
        declareSymbol(node, 32 /* SymbolFlags.Enum */);
    }
    function bindNamespaceStatement(statement) {
        // check if there's an existing symbol for this namespace
        const existingBinding = scope.symbol.exports.get(statement.id.sv);
        if (existingBinding && existingBinding.flags & 4096 /* SymbolFlags.Namespace */) {
            mutate(statement).symbol = existingBinding;
            // locals are never shared.
            mutate(statement).locals = createSymbolTable();
            mutate(existingBinding.declarations).push(statement);
        }
        else {
            // Initialize locals for non-exported symbols
            mutate(statement).locals = createSymbolTable();
            declareSymbol(statement, 4096 /* SymbolFlags.Namespace */);
        }
        currentFile.namespaces.push(statement);
        if (statement.statements === undefined) {
            fileNamespace = statement;
            let current = statement;
            while (current.kind !== SyntaxKind.TypeSpecScript) {
                currentFile.inScopeNamespaces.push(current);
                current = current.parent;
            }
        }
    }
    function bindUsingStatement(statement) {
        mutate(currentFile.usings).push(statement);
    }
    function bindOperationStatement(statement) {
        if (scope.kind !== SyntaxKind.InterfaceStatement) {
            declareSymbol(statement, 16 /* SymbolFlags.Operation */);
        }
        mutate(statement).locals = createSymbolTable();
    }
    function bindDecoratorDeclarationStatement(node) {
        declareSymbol(node, 16384 /* SymbolFlags.Decorator */ | 4194304 /* SymbolFlags.Declaration */, `@${node.id.sv}`);
    }
    function bindFunctionDeclarationStatement(node) {
        declareSymbol(node, 131072 /* SymbolFlags.Function */ | 4194304 /* SymbolFlags.Declaration */);
    }
    function bindFunctionParameter(node) {
        const symbol = createSymbol(node, node.id.sv, 262144 /* SymbolFlags.FunctionParameter */, scope.symbol);
        mutate(node).symbol = symbol;
    }
    /**
     * Declare a symbole for the given node in the current scope.
     * @param node Node
     * @param flags Symbol flags
     * @param name Optional symbol name, default to the node id.
     * @returns Created Symbol
     */
    function declareSymbol(node, flags, name) {
        switch (scope.kind) {
            case SyntaxKind.NamespaceStatement:
                return declareNamespaceMember(node, flags, name);
            case SyntaxKind.TypeSpecScript:
            case SyntaxKind.JsSourceFile:
                return declareScriptMember(node, flags, name);
            default:
                const key = name !== null && name !== void 0 ? name : node.id.sv;
                const symbol = createSymbol(node, key, flags, scope === null || scope === void 0 ? void 0 : scope.symbol);
                mutate(node).symbol = symbol;
                mutate(scope.locals).set(key, symbol);
                return symbol;
        }
    }
    function bindSymbol(node, flags) {
        const symbol = createSymbol(node, "-", flags, scope === null || scope === void 0 ? void 0 : scope.symbol);
        mutate(node).symbol = symbol;
        return symbol;
    }
    function declareNamespaceMember(node, flags, name) {
        if (flags & 4096 /* SymbolFlags.Namespace */ &&
            mergeNamespaceDeclarations(node, scope)) {
            return;
        }
        const key = name !== null && name !== void 0 ? name : node.id.sv;
        const symbol = createSymbol(node, key, flags, scope.symbol);
        mutate(node).symbol = symbol;
        mutate(scope.symbol.exports).set(key, symbol);
        return symbol;
    }
    function declareScriptMember(node, flags, name) {
        const effectiveScope = fileNamespace !== null && fileNamespace !== void 0 ? fileNamespace : scope;
        if (flags & 4096 /* SymbolFlags.Namespace */ &&
            mergeNamespaceDeclarations(node, effectiveScope)) {
            return;
        }
        const key = name !== null && name !== void 0 ? name : node.id.sv;
        const symbol = createSymbol(node, key, flags, fileNamespace === null || fileNamespace === void 0 ? void 0 : fileNamespace.symbol);
        mutate(node).symbol = symbol;
        mutate(effectiveScope.symbol.exports).set(key, symbol);
        return symbol;
    }
    function mergeNamespaceDeclarations(node, scope) {
        // we are declaring a namespace in either global scope, or a blockless namespace.
        const existingBinding = scope.symbol.exports.get(node.id.sv);
        if (existingBinding && existingBinding.flags & 4096 /* SymbolFlags.Namespace */) {
            // we have an existing binding, so just push this node to its declarations
            mutate(existingBinding.declarations).push(node);
            mutate(node).symbol = existingBinding;
            return true;
        }
        return false;
    }
}
function hasScope(node) {
    switch (node.kind) {
        case SyntaxKind.ModelStatement:
        case SyntaxKind.ScalarStatement:
        case SyntaxKind.AliasStatement:
        case SyntaxKind.TypeSpecScript:
        case SyntaxKind.InterfaceStatement:
        case SyntaxKind.OperationStatement:
        case SyntaxKind.UnionStatement:
        case SyntaxKind.Projection:
        case SyntaxKind.ProjectionLambdaExpression:
            return true;
        case SyntaxKind.NamespaceStatement:
            return node.statements !== undefined;
        default:
            return false;
    }
}
function createSymbol(node, name, flags, parent, value) {
    let exports;
    if (flags & 2101248 /* SymbolFlags.ExportContainer */) {
        exports = createSymbolTable();
    }
    let members;
    if (flags & 674 /* SymbolFlags.MemberContainer */) {
        members = createSymbolTable();
    }
    return {
        declarations: node ? [node] : [],
        name,
        exports,
        members,
        flags,
        value,
        parent,
        metatypeMembers: createSymbolTable(),
    };
}

function getDiscriminatedUnion(type, discriminator) {
    switch (type.kind) {
        case "Model":
            return getDiscriminatedUnionForModel(type, discriminator);
        case "Union":
            return getDiscriminatedUnionForUnion(type, discriminator);
    }
}
/**
 * Run the validation on all discriminated models to make sure the discriminator are valid.
 * This has to be done after the checker so we can have the full picture of all the dervied models.
 */
function validateInheritanceDiscriminatedUnions(program) {
    for (const [type, discriminator] of getDiscriminatedTypes(program)) {
        // Union would have already reported the issue.
        if (type.kind === "Model") {
            const [_, diagnostics] = getDiscriminatedUnionForModel(type, discriminator);
            program.reportDiagnostics(diagnostics);
        }
    }
}
function getDiscriminatedUnionForUnion(type, discriminator) {
    const variants = new Map();
    const diagnostics = [];
    const duplicates = new DuplicateTracker();
    for (const variant of type.variants.values()) {
        if (variant.type.kind !== "Model") {
            diagnostics.push(createDiagnostic({
                code: "invalid-discriminated-union-variant",
                format: { name: variant.name.toString() },
                target: variant,
            }));
            continue;
        }
        const prop = getDiscriminatorProperty(variant.type, discriminator, diagnostics);
        if (prop === undefined) {
            diagnostics.push(createDiagnostic({
                code: "invalid-discriminated-union-variant",
                messageId: "noDiscriminant",
                format: { name: variant.name.toString(), discriminant: discriminator.propertyName },
                target: variant,
            }));
            continue;
        }
        const key = getStringValue(prop.type);
        if (key) {
            duplicates.track(key, variant.type);
            variants.set(key, variant.type);
        }
        else {
            diagnostics.push(createDiagnostic({
                code: "invalid-discriminated-union-variant",
                messageId: "wrongDiscriminantType",
                format: { name: variant.name.toString(), discriminant: discriminator.propertyName },
                target: variant.type,
            }));
        }
    }
    reportDuplicateDiscriminatorValues(duplicates, diagnostics);
    const discriminatedUnion = {
        propertyName: discriminator.propertyName,
        variants,
    };
    return [discriminatedUnion, diagnostics];
}
function getDiscriminatedUnionForModel(type, discriminator) {
    const variants = new Map();
    const diagnostics = [];
    const duplicates = new DuplicateTracker();
    function checkForVariantsIn(current) {
        for (const derivedModel of current.derivedModels) {
            if (isTemplateDeclarationOrInstance(derivedModel)) {
                continue; // Skip template instances as they should be used with `model is`
            }
            const keys = getDiscriminatorValues(derivedModel, discriminator, diagnostics);
            if (keys === undefined) {
                if (derivedModel.derivedModels.length === 0) {
                    diagnostics.push(createDiagnostic({
                        code: "missing-discriminator-property",
                        format: { discriminator: discriminator.propertyName },
                        target: derivedModel,
                    }));
                }
                else {
                    checkForVariantsIn(derivedModel);
                }
            }
            else {
                for (const key of keys) {
                    duplicates.track(key, derivedModel);
                    variants.set(key, derivedModel);
                }
            }
        }
    }
    checkForVariantsIn(type);
    reportDuplicateDiscriminatorValues(duplicates, diagnostics);
    const discriminatedUnion = {
        propertyName: discriminator.propertyName,
        variants,
    };
    return [discriminatedUnion, diagnostics];
}
function reportDuplicateDiscriminatorValues(duplicates, diagnostics) {
    for (const [duplicateKey, models] of duplicates.entries()) {
        for (const model of models) {
            diagnostics.push(createDiagnostic({
                code: "invalid-discriminator-value",
                messageId: "duplicate",
                format: { discriminator: duplicateKey },
                target: model,
            }));
        }
    }
}
function getDiscriminatorProperty(model, discriminator, diagnostics) {
    const prop = model.properties.get(discriminator.propertyName);
    if (prop && prop.optional) {
        diagnostics.push(createDiagnostic({
            code: "invalid-discriminator-value",
            messageId: "required",
            target: prop,
        }));
    }
    return prop;
}
function getDiscriminatorValues(model, discriminator, diagnostics) {
    const prop = getDiscriminatorProperty(model, discriminator, diagnostics);
    if (!prop)
        return undefined;
    const keys = getStringValues(prop.type);
    if (keys.length === 0) {
        diagnostics.push(createDiagnostic({
            code: "invalid-discriminator-value",
            format: { kind: prop.type.kind },
            target: prop,
        }));
    }
    return keys;
}
function getStringValues(type) {
    var _a;
    switch (type.kind) {
        case "String":
            return [type.value];
        case "Union":
            return [...type.variants.values()].flatMap((x) => getStringValues(x.type)).filter(isDefined);
        case "EnumMember":
            return typeof type.value !== "number" ? [(_a = type.value) !== null && _a !== void 0 ? _a : type.name] : [];
        case "UnionVariant":
            return getStringValues(type.type);
        default:
            return [];
    }
}
function getStringValue(type) {
    var _a;
    switch (type.kind) {
        case "String":
            return type.value;
        case "EnumMember":
            return typeof type.value !== "number" ? (_a = type.value) !== null && _a !== void 0 ? _a : type.name : undefined;
        default:
            return undefined;
    }
}

function getLocationContext(program, type) {
    const sourceLocation = getSourceLocation(type);
    if (sourceLocation.isSynthetic) {
        return { type: "synthetic" };
    }
    return program.getSourceFileLocationContext(sourceLocation.file);
}

var __classPrivateFieldSet$1 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet$3 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _CustomKeyMap_items, _CustomKeyMap_keyer;
/**
 * This is a map type that allows providing a custom keyer function. The keyer
 * function returns a string that is used to look up in the map. This is useful
 * for implementing maps that look up based on an arbitrary number of keys.
 *
 * For example, to look up in a map with a [ObjA, ObjB)] tuple, such that tuples
 * with identical values (but not necessarily identical tuples!) create an
 * object keyer for each of the objects:
 *
 *     const aKeyer = CustomKeyMap.objectKeyer();
 *     const bKeyer = CUstomKeyMap.objectKeyer();
 *
 * And compose these into a tuple keyer to use when instantiating the custom key
 * map:
 *
 *     const tupleKeyer = ([a, b]) => `${aKeyer.getKey(a)}-${bKeyer.getKey(b)}`;
 *     const map = new CustomKeyMap(tupleKeyer);
 *
 */
class CustomKeyMap {
    constructor(keyer) {
        _CustomKeyMap_items.set(this, new Map());
        _CustomKeyMap_keyer.set(this, void 0);
        __classPrivateFieldSet$1(this, _CustomKeyMap_keyer, keyer, "f");
    }
    get(items) {
        return __classPrivateFieldGet$3(this, _CustomKeyMap_items, "f").get(__classPrivateFieldGet$3(this, _CustomKeyMap_keyer, "f").call(this, items));
    }
    set(items, value) {
        const key = __classPrivateFieldGet$3(this, _CustomKeyMap_keyer, "f").call(this, items);
        __classPrivateFieldGet$3(this, _CustomKeyMap_items, "f").set(key, value);
    }
    static objectKeyer() {
        const knownKeys = new WeakMap();
        let count = 0;
        return {
            getKey(o) {
                if (knownKeys.has(o)) {
                    return knownKeys.get(o);
                }
                const key = count;
                count++;
                knownKeys.set(o, key);
                return key;
            },
        };
    }
}
_CustomKeyMap_items = new WeakMap(), _CustomKeyMap_keyer = new WeakMap();

var __classPrivateFieldGet$2 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Placeholder_listeners;
/**
 * Keeps track of a value we don't know yet because of a circular reference. Use
 * the `onValue` method to provide a callback with how to handle the
 * placeholder's value becoming available. Generally the callback will replace
 * this placeholder with the value in whatever references the placeholder.
 */
class Placeholder {
    constructor() {
        _Placeholder_listeners.set(this, []);
    }
    setValue(value) {
        for (const listener of __classPrivateFieldGet$2(this, _Placeholder_listeners, "f")) {
            listener(value);
        }
    }
    onValue(cb) {
        __classPrivateFieldGet$2(this, _Placeholder_listeners, "f").push(cb);
    }
}
_Placeholder_listeners = new WeakMap();

function scopeChain(scope) {
    const chain = [];
    while (scope) {
        chain.unshift(scope);
        scope = scope.parentScope;
    }
    return chain;
}
/**
 * Resolve relative scopes between the current scope and the target declaration.
 * @param target The target declaration
 * @param currentScope Current scope
 * @returns
 */
function resolveDeclarationReferenceScope(target, currentScope) {
    var _a;
    const targetScope = target.scope;
    const targetChain = scopeChain(targetScope);
    const currentChain = scopeChain(currentScope);
    let diffStart = 0;
    while (targetChain[diffStart] &&
        currentChain[diffStart] &&
        targetChain[diffStart] === currentChain[diffStart]) {
        diffStart++;
    }
    const pathUp = currentChain.slice(diffStart);
    const pathDown = targetChain.slice(diffStart);
    const commonScope = (_a = targetChain[diffStart - 1]) !== null && _a !== void 0 ? _a : null;
    return { pathUp, pathDown, commonScope };
}

var __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet$1 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ReferenceCycle_entries;
/**
 * Represent a reference cycle.
 * The cycle entries will always start with a declaration if there is one in the cycle.
 */
class ReferenceCycle {
    constructor(entries) {
        _ReferenceCycle_entries.set(this, void 0);
        const firstDeclarationIndex = entries.findIndex((entry) => entry.entity.kind === "declaration");
        this.containsDeclaration = firstDeclarationIndex !== -1;
        __classPrivateFieldSet(this, _ReferenceCycle_entries, this.containsDeclaration
            ? [...entries.slice(firstDeclarationIndex), ...entries.slice(0, firstDeclarationIndex)]
            : entries, "f");
    }
    get first() {
        return __classPrivateFieldGet$1(this, _ReferenceCycle_entries, "f")[0];
    }
    [(_ReferenceCycle_entries = new WeakMap(), Symbol.iterator)]() {
        return __classPrivateFieldGet$1(this, _ReferenceCycle_entries, "f")[Symbol.iterator]();
    }
    [Symbol.toStringTag]() {
        return [...__classPrivateFieldGet$1(this, _ReferenceCycle_entries, "f"), __classPrivateFieldGet$1(this, _ReferenceCycle_entries, "f")[0]].map((x) => getTypeName(x.type)).join(" -> ");
    }
    toString() {
        return this[Symbol.toStringTag]();
    }
}

class EmitterResult {
}
class Declaration extends EmitterResult {
    constructor(name, scope, value) {
        if (value instanceof Placeholder) {
            value.onValue((v) => (this.value = v));
        }
        super();
        this.name = name;
        this.scope = scope;
        this.value = value;
        this.kind = "declaration";
        this.meta = {};
    }
}
class RawCode extends EmitterResult {
    constructor(value) {
        if (value instanceof Placeholder) {
            value.onValue((v) => (this.value = v));
        }
        super();
        this.value = value;
        this.kind = "code";
    }
}
class NoEmit extends EmitterResult {
    constructor() {
        super(...arguments);
        this.kind = "none";
    }
}
class CircularEmit extends EmitterResult {
    constructor(emitEntityKey) {
        super();
        this.emitEntityKey = emitEntityKey;
        this.kind = "circular";
    }
}

function createAssetEmitter(program, TypeEmitterClass, emitContext) {
    var _a;
    const sourceFiles = [];
    const options = {
        noEmit: (_a = program.compilerOptions.noEmit) !== null && _a !== void 0 ? _a : false,
        emitterOutputDir: emitContext.emitterOutputDir,
        ...emitContext.options,
    };
    const typeId = CustomKeyMap.objectKeyer();
    const contextId = CustomKeyMap.objectKeyer();
    const entryId = CustomKeyMap.objectKeyer();
    // This is effectively a seen set, ensuring that we don't emit the same
    // type with the same context twice. So the map stores a triple of:
    //
    // 1. the method of TypeEmitter we would call
    // 2. the tsp type we're emitting.
    // 3. the current context.
    //
    // Note that in order for this to work, context needs to be interned so
    // contexts with the same values inside are treated as identical in the
    // map. See createInterner for more details.
    const typeToEmitEntity = new CustomKeyMap(([method, type, context]) => {
        return `${method}-${typeId.getKey(type)}-${contextId.getKey(context)}`;
    });
    // When we encounter a circular reference, this map will hold a callback
    // that should be called when the circularly referenced type has completed
    // its emit.
    const waitingCircularRefs = new CustomKeyMap(([method, type, context]) => {
        return `${method}-${typeId.getKey(type)}-${contextId.getKey(context)}`;
    });
    // Similar to `typeToEmitEntity`, this ensures we don't recompute context
    // for types that we already have context for. Note that context is
    // dependent on the context of the context call, e.g. if a model is
    // referenced with reference context set we need to get its declaration
    // context again. So we use the context's context as a key. Context must
    // be interned, see createInterner for more details.
    const knownContexts = new CustomKeyMap(([entry, context]) => {
        return `${entryId.getKey(entry)}-${contextId.getKey(context)}`;
    });
    // The stack of types that the currently emitted type is lexically
    // contained in. This gets pushed to when we visit a type that is
    // lexically contained in the current type, and is reset when we jump via
    // reference to another type in a different lexical context. Note that
    // this does not correspond to tsp's lexical nesting, e.g. in the case of
    // an alias to a model expression, the alias is lexically outside the
    // model, but in the type graph we will consider it to be lexically inside
    // whatever references the alias.
    let lexicalTypeStack = [];
    let referenceTypeChain = [];
    // Internally, context is is split between lexicalContext and
    // referenceContext because when a reference is made, we carry over
    // referenceContext but leave lexical context behind. When context is
    // accessed by the user, they are merged by getContext().
    let context = {
        lexicalContext: {},
        referenceContext: {},
    };
    let programContext = null;
    // Incoming reference context is reference context that comes from emitting a
    // type reference. Incoming reference context is only set on the
    // incomingReferenceContextTarget and types lexically contained within it. For
    // example, when referencing a model with reference context set, we may need
    // to get context from the referenced model's namespaces, and such namespaces
    // will not see the reference context. However, the reference context will be
    // available for the model, its properties, and any types nested within it
    // (e.g. anonymous models).
    let incomingReferenceContext = null;
    let incomingReferenceContextTarget = null;
    const stateInterner = createInterner();
    const stackEntryInterner = createInterner();
    const assetEmitter = {
        getContext() {
            return {
                ...context.lexicalContext,
                ...context.referenceContext,
            };
        },
        getOptions() {
            return options;
        },
        getProgram() {
            return program;
        },
        result: {
            declaration(name, value) {
                const scope = currentScope();
                compilerAssert(scope, "Emit context must have a scope set in order to create declarations. Consider setting scope to a new source file's global scope in the `programContext` method of `TypeEmitter`.");
                return new Declaration(name, scope, value);
            },
            rawCode(value) {
                return new RawCode(value);
            },
            none() {
                return new NoEmit();
            },
        },
        createScope(block, name, parentScope = null) {
            let newScope;
            if (!parentScope) {
                // create source file scope
                newScope = {
                    kind: "sourceFile",
                    name,
                    sourceFile: block,
                    parentScope,
                    childScopes: [],
                    declarations: [],
                };
            }
            else {
                newScope = {
                    kind: "namespace",
                    name,
                    namespace: block,
                    childScopes: [],
                    declarations: [],
                    parentScope,
                };
            }
            parentScope === null || parentScope === void 0 ? void 0 : parentScope.childScopes.push(newScope);
            return newScope; // the overload of createScope causes type weirdness
        },
        createSourceFile(path) {
            const basePath = options.emitterOutputDir;
            const sourceFile = {
                globalScope: undefined,
                path: joinPaths(basePath, path),
                imports: new Map(),
                meta: {},
            };
            sourceFile.globalScope = this.createScope(sourceFile, "");
            sourceFiles.push(sourceFile);
            return sourceFile;
        },
        emitTypeReference(target, options) {
            return withPatchedReferenceContext(options === null || options === void 0 ? void 0 : options.referenceContext, () => {
                var _a;
                const oldIncomingReferenceContext = incomingReferenceContext;
                const oldIncomingReferenceContextTarget = incomingReferenceContextTarget;
                incomingReferenceContext = (_a = context.referenceContext) !== null && _a !== void 0 ? _a : null;
                incomingReferenceContextTarget = incomingReferenceContext ? target : null;
                let result;
                if (target.kind === "ModelProperty") {
                    result = invokeTypeEmitter("modelPropertyReference", target);
                }
                else if (target.kind === "EnumMember") {
                    result = invokeTypeEmitter("enumMemberReference", target);
                }
                if (result) {
                    incomingReferenceContext = oldIncomingReferenceContext;
                    incomingReferenceContextTarget = oldIncomingReferenceContextTarget;
                    return result;
                }
                const entity = this.emitType(target);
                incomingReferenceContext = oldIncomingReferenceContext;
                incomingReferenceContextTarget = oldIncomingReferenceContextTarget;
                let placeholder = null;
                if (entity.kind === "circular") {
                    let waiting = waitingCircularRefs.get(entity.emitEntityKey);
                    if (!waiting) {
                        waiting = [];
                        waitingCircularRefs.set(entity.emitEntityKey, waiting);
                    }
                    const typeChainSnapshot = referenceTypeChain;
                    waiting.push({
                        state: {
                            lexicalTypeStack,
                            context,
                        },
                        cb: (resolvedEntity) => invokeReference(this, resolvedEntity, true, resolveReferenceCycle(typeChainSnapshot, entity, typeToEmitEntity)),
                    });
                    placeholder = new Placeholder();
                    return this.result.rawCode(placeholder);
                }
                else {
                    return invokeReference(this, entity, false);
                }
                function invokeReference(assetEmitter, entity, circular, cycle) {
                    let ref;
                    const scope = currentScope();
                    if (circular) {
                        ref = typeEmitter.circularReference(entity, scope, cycle);
                    }
                    else {
                        if (entity.kind !== "declaration") {
                            return entity;
                        }
                        compilerAssert(scope, "Emit context must have a scope set in order to create references to declarations.");
                        const { pathUp, pathDown, commonScope } = resolveDeclarationReferenceScope(entity, scope);
                        ref = typeEmitter.reference(entity, pathUp, pathDown, commonScope);
                    }
                    if (!(ref instanceof EmitterResult)) {
                        ref = assetEmitter.result.rawCode(ref);
                    }
                    if (placeholder) {
                        // this should never happen as this function shouldn't be called until
                        // the target declaration is finished being emitted.
                        compilerAssert(ref.kind !== "circular", "TypeEmitter `reference` returned circular emit");
                        // this could presumably be allowed if we want.
                        compilerAssert(ref.kind === "none" || !(ref.value instanceof Placeholder), "TypeEmitter's `reference` method cannot return a placeholder.");
                        switch (ref.kind) {
                            case "code":
                            case "declaration":
                                placeholder.setValue(ref.value);
                                break;
                            case "none":
                                // this cast is incorrect, think about what should happen
                                // if reference returns noEmit...
                                placeholder.setValue("");
                                break;
                        }
                    }
                    return ref;
                }
            });
        },
        emitDeclarationName(type) {
            return typeEmitter.declarationName(type);
        },
        async writeOutput() {
            return typeEmitter.writeOutput(sourceFiles);
        },
        getSourceFiles() {
            return sourceFiles;
        },
        emitType(type, context) {
            var _a;
            if (context === null || context === void 0 ? void 0 : context.referenceContext) {
                incomingReferenceContext = (_a = context === null || context === void 0 ? void 0 : context.referenceContext) !== null && _a !== void 0 ? _a : incomingReferenceContext;
                incomingReferenceContextTarget = type !== null && type !== void 0 ? type : incomingReferenceContextTarget;
            }
            const declName = isDeclaration(type) && type.kind !== "Namespace" ? typeEmitter.declarationName(type) : null;
            const key = typeEmitterKey(type);
            let args;
            switch (key) {
                case "scalarDeclaration":
                case "scalarInstantiation":
                case "modelDeclaration":
                case "modelInstantiation":
                case "operationDeclaration":
                case "interfaceDeclaration":
                case "interfaceOperationDeclaration":
                case "enumDeclaration":
                case "unionDeclaration":
                case "unionInstantiation":
                    args = [declName];
                    break;
                case "arrayDeclaration":
                    const arrayDeclElement = type.indexer.value;
                    args = [declName, arrayDeclElement];
                    break;
                case "arrayLiteral":
                    const arrayLiteralElement = type.indexer.value;
                    args = [arrayLiteralElement];
                    break;
                case "intrinsic":
                    args = [declName];
                    break;
                default:
                    args = [];
            }
            const result = invokeTypeEmitter(key, type, ...args);
            return result;
        },
        emitProgram(options) {
            const namespace = program.getGlobalNamespaceType();
            if (options === null || options === void 0 ? void 0 : options.emitGlobalNamespace) {
                this.emitType(namespace);
                return;
            }
            for (const ns of namespace.namespaces.values()) {
                if (ns.name === "TypeSpec" && !(options === null || options === void 0 ? void 0 : options.emitTypeSpecNamespace))
                    continue;
                this.emitType(ns);
            }
            for (const model of namespace.models.values()) {
                if (!isTemplateDeclaration(model)) {
                    this.emitType(model);
                }
            }
            for (const operation of namespace.operations.values()) {
                if (!isTemplateDeclaration(operation)) {
                    this.emitType(operation);
                }
            }
            for (const enumeration of namespace.enums.values()) {
                this.emitType(enumeration);
            }
            for (const union of namespace.unions.values()) {
                if (!isTemplateDeclaration(union)) {
                    this.emitType(union);
                }
            }
            for (const iface of namespace.interfaces.values()) {
                if (!isTemplateDeclaration(iface)) {
                    this.emitType(iface);
                }
            }
            for (const scalar of namespace.scalars.values()) {
                this.emitType(scalar);
            }
        },
        emitModelProperties(model) {
            const res = invokeTypeEmitter("modelProperties", model);
            if (res instanceof EmitterResult) {
                return res;
            }
            else {
                return this.result.rawCode(res);
            }
        },
        emitModelProperty(property) {
            return invokeTypeEmitter("modelPropertyLiteral", property);
        },
        emitOperationParameters(operation) {
            return invokeTypeEmitter("operationParameters", operation, operation.parameters);
        },
        emitOperationReturnType(operation) {
            return invokeTypeEmitter("operationReturnType", operation, operation.returnType);
        },
        emitInterfaceOperations(iface) {
            return invokeTypeEmitter("interfaceDeclarationOperations", iface);
        },
        emitInterfaceOperation(operation) {
            const name = typeEmitter.declarationName(operation);
            if (name === undefined) {
                // the general approach of invoking the expression form doesn't work here
                // because typespec doesn't have operation expressions.
                compilerAssert(false, "Unnamed operations are not supported");
            }
            return invokeTypeEmitter("interfaceOperationDeclaration", operation, name);
        },
        emitEnumMembers(en) {
            return invokeTypeEmitter("enumMembers", en);
        },
        emitUnionVariants(union) {
            return invokeTypeEmitter("unionVariants", union);
        },
        emitTupleLiteralValues(tuple) {
            return invokeTypeEmitter("tupleLiteralValues", tuple);
        },
        async emitSourceFile(sourceFile) {
            return await typeEmitter.sourceFile(sourceFile);
        },
    };
    const typeEmitter = new TypeEmitterClass(assetEmitter);
    return assetEmitter;
    /**
     * This function takes care of calling a method on the TypeEmitter to
     * convert it to some emitted output. It will return a cached type if we
     * have seen it before (and the context is the same). It will establish
     * the emit context by calling the appropriate methods before getting the
     * emit result. Also if a type emitter returns just a T or a
     * Placeholder<T>, it will convert that to a RawCode result.
     */
    function invokeTypeEmitter(method, ...args) {
        const type = args[0];
        let entity;
        let emitEntityKey;
        let cached = false;
        withTypeContext(method, args, () => {
            emitEntityKey = [method, type, context];
            const seenEmitEntity = typeToEmitEntity.get(emitEntityKey);
            if (seenEmitEntity) {
                entity = seenEmitEntity;
                cached = true;
                return;
            }
            typeToEmitEntity.set(emitEntityKey, new CircularEmit(emitEntityKey));
            compilerAssert(typeEmitter[method], `TypeEmitter doesn't have a method named ${method}.`);
            entity = liftToRawCode(typeEmitter[method](...args));
        });
        if (cached) {
            return entity;
        }
        if (entity instanceof Placeholder) {
            entity.onValue((v) => handleCompletedEntity(v));
            return entity;
        }
        handleCompletedEntity(entity);
        return entity;
        function handleCompletedEntity(entity) {
            typeToEmitEntity.set(emitEntityKey, entity);
            const waitingRefCbs = waitingCircularRefs.get(emitEntityKey);
            if (waitingRefCbs) {
                for (const record of waitingRefCbs) {
                    withContext(record.state, () => {
                        record.cb(entity);
                    });
                }
                waitingCircularRefs.set(emitEntityKey, []);
            }
            if (entity.kind === "declaration") {
                entity.scope.declarations.push(entity);
            }
        }
        function liftToRawCode(value) {
            if (value instanceof EmitterResult) {
                return value;
            }
            return assetEmitter.result.rawCode(value);
        }
    }
    function isInternalMethod(method) {
        return (method === "interfaceDeclarationOperations" ||
            method === "interfaceOperationDeclaration" ||
            method === "operationParameters" ||
            method === "operationReturnType" ||
            method === "modelProperties" ||
            method === "enumMembers" ||
            method === "tupleLiteralValues" ||
            method === "unionVariants");
    }
    /**
     * This helper takes a type and sets the `context` state to what it should
     * be in order to invoke the type emitter method for that type. This needs
     * to take into account the current context and any incoming reference
     * context.
     */
    function setContextForType(method, args) {
        const type = args[0];
        let newTypeStack;
        // if we've walked into a new declaration, reset the lexical type stack
        // to the lexical containers of the current type.
        if (isDeclaration(type) && type.kind !== "Intrinsic" && !isInternalMethod(method)) {
            newTypeStack = [stackEntryInterner.intern({ method, args: stackEntryInterner.intern(args) })];
            let ns = type.namespace;
            while (ns) {
                if (ns.name === "")
                    break;
                newTypeStack.unshift(stackEntryInterner.intern({ method: "namespace", args: stackEntryInterner.intern([ns]) }));
                ns = ns.namespace;
            }
        }
        else {
            newTypeStack = [
                ...lexicalTypeStack,
                stackEntryInterner.intern({ method, args: stackEntryInterner.intern(args) }),
            ];
        }
        lexicalTypeStack = newTypeStack;
        if (!programContext) {
            programContext = stateInterner.intern({
                lexicalContext: typeEmitter.programContext(program),
                referenceContext: stateInterner.intern({}),
            });
        }
        // Establish our context by starting from program and walking up the type stack
        // and merging in context for each of the lexical containers.
        context = programContext;
        for (const entry of lexicalTypeStack) {
            if (incomingReferenceContext && entry.args[0] === incomingReferenceContextTarget) {
                // bring in any reference context so it is available for any types nested beneath this type.
                context = stateInterner.intern({
                    lexicalContext: context.lexicalContext,
                    referenceContext: stateInterner.intern({
                        ...context.referenceContext,
                        ...incomingReferenceContext,
                    }),
                });
            }
            const seenContext = knownContexts.get([entry, context]);
            if (seenContext) {
                context = seenContext;
                continue;
            }
            const lexicalKey = entry.method + "Context";
            const referenceKey = entry.method + "ReferenceContext";
            if (keyHasContext(entry.method)) {
                compilerAssert(typeEmitter[lexicalKey], `TypeEmitter doesn't have a method named ${lexicalKey}`);
            }
            if (keyHasReferenceContext(entry.method)) {
                compilerAssert(typeEmitter[referenceKey], `TypeEmitter doesn't have a method named ${referenceKey}`);
            }
            const newContext = keyHasContext(entry.method)
                ? typeEmitter[lexicalKey](...entry.args)
                : {};
            const newReferenceContext = keyHasReferenceContext(entry.method)
                ? typeEmitter[referenceKey](...entry.args)
                : {};
            // assemble our new reference and lexical contexts.
            const newContextState = stateInterner.intern({
                lexicalContext: stateInterner.intern({
                    ...context.lexicalContext,
                    ...newContext,
                }),
                referenceContext: stateInterner.intern({
                    ...context.referenceContext,
                    ...newReferenceContext,
                }),
            });
            knownContexts.set([entry, context], newContextState);
            context = newContextState;
        }
        if (!isInternalMethod(method)) {
            referenceTypeChain = [
                ...referenceTypeChain,
                stackEntryInterner.intern({
                    method,
                    type,
                    context,
                }),
            ];
        }
    }
    /**
     * Invoke the callback with the proper context for a given type.
     */
    function withTypeContext(method, args, cb) {
        const oldContext = context;
        const oldTypeStack = lexicalTypeStack;
        const oldRefTypeStack = referenceTypeChain;
        setContextForType(method, args);
        cb();
        context = oldContext;
        lexicalTypeStack = oldTypeStack;
        referenceTypeChain = oldRefTypeStack;
    }
    function withPatchedReferenceContext(referenceContext, cb) {
        if (referenceContext !== undefined) {
            const oldContext = context;
            context = stateInterner.intern({
                lexicalContext: context.lexicalContext,
                referenceContext: stateInterner.intern({
                    ...context.referenceContext,
                    ...referenceContext,
                }),
            });
            const result = cb();
            context = oldContext;
            return result;
        }
        else {
            return cb();
        }
    }
    /**
     * Invoke the callback with the given context.
     */
    function withContext(newContext, cb) {
        const oldContext = newContext.context;
        const oldTypeStack = newContext.lexicalTypeStack;
        context = newContext.context;
        lexicalTypeStack = newContext.lexicalTypeStack;
        cb();
        context = oldContext;
        lexicalTypeStack = oldTypeStack;
    }
    function typeEmitterKey(type) {
        switch (type.kind) {
            case "Model":
                if (program.checker.isStdType(type) && type.name === "Array") {
                    // likely an array literal, though could be a bare reference to Array maybe?
                    return "arrayLiteral";
                }
                if (type.name === "") {
                    return "modelLiteral";
                }
                if (type.templateMapper) {
                    return "modelInstantiation";
                }
                if (type.indexer && type.indexer.key.name === "integer") {
                    return "arrayDeclaration";
                }
                return "modelDeclaration";
            case "Namespace":
                return "namespace";
            case "ModelProperty":
                return "modelPropertyLiteral";
            case "StringTemplate":
                return "stringTemplate";
            case "Boolean":
                return "booleanLiteral";
            case "String":
                return "stringLiteral";
            case "Number":
                return "numericLiteral";
            case "Operation":
                if (type.interface) {
                    return "interfaceOperationDeclaration";
                }
                else {
                    return "operationDeclaration";
                }
            case "Interface":
                return "interfaceDeclaration";
            case "Enum":
                return "enumDeclaration";
            case "EnumMember":
                return "enumMember";
            case "Union":
                if (!type.name) {
                    return "unionLiteral";
                }
                if (type.templateMapper) {
                    return "unionInstantiation";
                }
                return "unionDeclaration";
            case "UnionVariant":
                return "unionVariant";
            case "Tuple":
                return "tupleLiteral";
            case "Scalar":
                if (type.templateMapper) {
                    return "scalarInstantiation";
                }
                else {
                    return "scalarDeclaration";
                }
            case "Intrinsic":
                return "intrinsic";
            default:
                compilerAssert(false, `Encountered type ${type.kind} which we don't know how to emit.`);
        }
    }
    function currentScope() {
        var _a, _b, _c, _d;
        return (_d = (_b = (_a = context.referenceContext) === null || _a === void 0 ? void 0 : _a.scope) !== null && _b !== void 0 ? _b : (_c = context.lexicalContext) === null || _c === void 0 ? void 0 : _c.scope) !== null && _d !== void 0 ? _d : null;
    }
}
/**
 * Returns true if the given type is a declaration or an instantiation of a declaration.
 * @param type
 * @returns
 */
function isDeclaration(type) {
    switch (type.kind) {
        case "Namespace":
        case "Interface":
        case "Enum":
        case "Operation":
        case "Scalar":
        case "Intrinsic":
            return true;
        case "Model":
            return type.name ? type.name !== "" && type.name !== "Array" : false;
        case "Union":
            return type.name ? type.name !== "" : false;
        default:
            return false;
    }
}
/**
 * An interner takes an object and returns either that same object, or a
 * previously seen object that has the identical shape.
 *
 * This implementation is EXTREMELY non-optimal (O(n*m) where n = number of unique
 * state objects and m = the number of properties a state object contains). This
 * will very quickly be a bottleneck. That said, the common case is no state at
 * all, and also this is essentially implementing records and tuples, so could
 * probably adopt those when they are released. That that said, the records and
 * tuples are presently facing headwinds due to implementations facing exactly
 * these performance characteristics. Regardless, there are optimizations we
 * could consider.
 */
function createInterner() {
    const emptyObject = {};
    const knownObjects = new Set();
    return {
        intern(object) {
            const keyLen = Object.keys(object).length;
            if (keyLen === 0)
                return emptyObject;
            for (const ko of knownObjects) {
                const entries = Object.entries(ko);
                if (entries.length !== keyLen)
                    continue;
                let found = true;
                for (const [key, value] of entries) {
                    if (object[key] !== value) {
                        found = false;
                        break;
                    }
                }
                if (found) {
                    return ko;
                }
            }
            knownObjects.add(object);
            return object;
        },
    };
}
const noContext = new Set(["modelPropertyReference", "enumMemberReference"]);
function keyHasContext(key) {
    return !noContext.has(key);
}
const noReferenceContext = new Set([
    ...noContext,
    "booleanLiteral",
    "stringTemplate",
    "stringLiteral",
    "numericLiteral",
    "scalarInstantiation",
    "enumMember",
    "enumMembers",
    "intrinsic",
]);
function keyHasReferenceContext(key) {
    return !noReferenceContext.has(key);
}
function resolveReferenceCycle(stack, entity, typeToEmitEntity) {
    for (let i = stack.length - 1; i >= 0; i--) {
        if (stack[i].type === entity.emitEntityKey[1]) {
            return new ReferenceCycle(stack.slice(i).map((x) => {
                return {
                    type: x.type,
                    entity: typeToEmitEntity.get([x.method, x.type, x.context]),
                };
            }));
        }
    }
    throw new Error(`Couldn't resolve the circular reference stack for ${getTypeName(entity.emitEntityKey[1])}`);
}

/**
 * Resolve the path to the main file
 * @param path path to the entrypoint of the program. Can be the main.tsp, folder containing main.tsp or a project/library root.
 * @returns Absolute path to the entrypoint.
 */
async function resolveTypeSpecEntrypoint(host, path, reportDiagnostic) {
    const resolvedPath = resolvePath(path);
    const mainStat = await doIO(host.stat, resolvedPath, reportDiagnostic);
    if (!mainStat) {
        return undefined;
    }
    if (mainStat.isDirectory()) {
        return resolveTypeSpecEntrypointForDir(host, resolvedPath, reportDiagnostic);
    }
    else {
        return resolvedPath;
    }
}
async function resolveTypeSpecEntrypointForDir(host, dir, reportDiagnostic) {
    const pkgJsonPath = resolvePath(dir, "package.json");
    const [pkg] = await loadFile(host, pkgJsonPath, JSON.parse, reportDiagnostic, {
        allowFileNotFound: true,
    });
    const tspMain = resolveTspMain(pkg);
    if (tspMain !== undefined) {
        return resolvePath(dir, tspMain);
    }
    // Back Compat: if main.cadl exist, return main.cadl
    let mainFile = resolvePath(dir, "main.cadl");
    const stat = await doIO(() => host.stat(mainFile), mainFile, () => { });
    // if not found, use the normal resolution.
    if ((stat === null || stat === void 0 ? void 0 : stat.isFile()) !== true) {
        mainFile = resolvePath(dir, "main.tsp");
    }
    return mainFile;
}

class ExternalError extends Error {
    constructor(info) {
        super(renderExternalErrorInfo(info));
        this.info = info;
        this.name = "ExternalError";
    }
    render(color) {
        return renderExternalErrorInfo(this.info, color);
    }
}
function renderExternalErrorInfo(info, color = (x) => x) {
    var _a, _b;
    const { metadata, kind } = info;
    const msg = [
        color(kind === "emitter"
            ? `Emitter "${metadata.name}" crashed! This is a bug.`
            : `Library "${metadata.name}" $onValidate crashed! This is a bug.`, "red"),
    ];
    if ((_a = metadata.bugs) === null || _a === void 0 ? void 0 : _a.url) {
        msg.push(`Please file an issue at ${color((_b = metadata.bugs) === null || _b === void 0 ? void 0 : _b.url, "cyan")}`);
    }
    else {
        msg.push(`Please contact library author to report this issue.`);
    }
    msg.push("");
    msg.push(color(getInnerError(info), "gray"));
    msg.push("");
    msg.push(getReportInfo(metadata, color));
    return msg.join("\n");
}
function getInnerError({ error }) {
    if (typeof error === "object" &&
        error !== null &&
        "stack" in error &&
        typeof error.stack === "string") {
        return error.stack;
    }
    else {
        return String(error);
    }
}
function getReportInfo(metadata, color) {
    var _a;
    const details = {
        "Library Version": (_a = metadata.version) !== null && _a !== void 0 ? _a : "?",
        "TypeSpec Compiler Version": MANIFEST.version,
    };
    return [
        "-".repeat(50),
        ...Object.entries(details).map(([k, v]) => `${k.padEnd(30)} ${color(v, "yellow")}`),
        "-".repeat(50),
    ].join("\n");
}

const defaultOptions$1 = {
    includeTemplateDeclaration: false,
};
/**
 * Navigate all types in the program.
 * @param program Program to navigate.
 * @param listeners Listener called when visiting types.
 * @param options Navigation options.
 */
function navigateProgram(program, listeners, options = {}) {
    const context = createNavigationContext(listeners, options);
    context.emit("root", program);
    navigateNamespaceType(program.getGlobalNamespaceType(), context);
}
/**
 * Navigate the given type and all the types that are used in it.
 * @param type Type to navigate.
 * @param listeners Listener for the types found.
 * @param options Navigation options
 */
function navigateType(type, listeners, options) {
    const context = createNavigationContext(listeners, options);
    navigateTypeInternal(type, context);
}
/**
 * Scope the current navigation to the given namespace.
 * @param namespace Namespace the traversal shouldn't leave.
 * @param listeners Type listeners.
 * @param options Scope options
 * @returns wrapped listeners that that can be used with `navigateType`
 */
function scopeNavigationToNamespace(namespace, listeners, options = {}) {
    const wrappedListeners = {};
    for (const [name, callback] of Object.entries(listeners)) {
        wrappedListeners[name] = (x) => {
            if (x !== namespace && "namespace" in x) {
                if (options.skipSubNamespaces && x.namespace !== namespace) {
                    return ListenerFlow.NoRecursion;
                }
                if (x.namespace && !isSubNamespace(x.namespace, namespace)) {
                    return ListenerFlow.NoRecursion;
                }
            }
            return callback(x);
        };
    }
    return wrappedListeners;
}
function navigateTypesInNamespace(namespace, listeners, options = {}) {
    navigateType(namespace, scopeNavigationToNamespace(namespace, listeners, options), options);
}
/**
 * Create a Semantic node listener from an event emitter.
 * @param eventEmitter Event emitter.
 * @returns Semantic node listener.
 */
function mapEventEmitterToNodeListener(eventEmitter) {
    const listener = {};
    for (const eventName of eventNames) {
        listener[eventName] = (...args) => {
            eventEmitter.emit(eventName, ...args);
        };
    }
    return listener;
}
function isSubNamespace(subNamespace, namespace) {
    let current = subNamespace;
    while (current !== undefined) {
        if (current === namespace) {
            return true;
        }
        current = current.namespace;
    }
    return false;
}
function createNavigationContext(listeners, options = {}) {
    return {
        visited: new Set(),
        emit: (key, ...args) => { var _a; return (_a = listeners[key]) === null || _a === void 0 ? void 0 : _a.call(listeners, ...args); },
        options: computeOptions(options),
    };
}
function computeOptions(options) {
    return { ...defaultOptions$1, ...options };
}
function navigateNamespaceType(namespace, context) {
    if (context.emit("namespace", namespace) === ListenerFlow.NoRecursion)
        return;
    for (const model of namespace.models.values()) {
        navigateModelType(model, context);
    }
    for (const scalar of namespace.scalars.values()) {
        navigateScalarType(scalar, context);
    }
    for (const operation of namespace.operations.values()) {
        navigateOperationType(operation, context);
    }
    for (const subNamespace of namespace.namespaces.values()) {
        navigateNamespaceType(subNamespace, context);
    }
    for (const union of namespace.unions.values()) {
        navigateUnionType(union, context);
    }
    for (const iface of namespace.interfaces.values()) {
        navigateInterfaceType(iface, context);
    }
    for (const enumType of namespace.enums.values()) {
        navigateEnumType(enumType, context);
    }
    for (const decorator of namespace.decoratorDeclarations.values()) {
        navigateDecoratorDeclaration(decorator, context);
    }
}
function checkVisited(visited, item) {
    if (visited.has(item)) {
        return true;
    }
    visited.add(item);
    return false;
}
function shouldNavigateTemplatableType(context, type) {
    if (context.options.includeTemplateDeclaration) {
        return type.isFinished || isTemplateDeclaration(type);
    }
    else {
        return type.isFinished;
    }
}
function navigateOperationType(operation, context) {
    if (checkVisited(context.visited, operation)) {
        return;
    }
    if (!shouldNavigateTemplatableType(context, operation)) {
        return;
    }
    if (context.emit("operation", operation) === ListenerFlow.NoRecursion)
        return;
    for (const parameter of operation.parameters.properties.values()) {
        navigateTypeInternal(parameter, context);
    }
    navigateTypeInternal(operation.returnType, context);
    if (operation.sourceOperation) {
        navigateTypeInternal(operation.sourceOperation, context);
    }
}
function navigateModelType(model, context) {
    if (checkVisited(context.visited, model)) {
        return;
    }
    if (!shouldNavigateTemplatableType(context, model)) {
        return;
    }
    if (context.emit("model", model) === ListenerFlow.NoRecursion)
        return;
    for (const property of model.properties.values()) {
        navigateModelTypeProperty(property, context);
    }
    if (model.baseModel) {
        navigateModelType(model.baseModel, context);
    }
    if (model.indexer && model.indexer.value) {
        navigateTypeInternal(model.indexer.value, context);
    }
    context.emit("exitModel", model);
}
function navigateModelTypeProperty(property, context) {
    if (checkVisited(context.visited, property)) {
        return;
    }
    if (context.emit("modelProperty", property) === ListenerFlow.NoRecursion)
        return;
    navigateTypeInternal(property.type, context);
}
function navigateScalarType(scalar, context) {
    if (checkVisited(context.visited, scalar)) {
        return;
    }
    if (context.emit("scalar", scalar) === ListenerFlow.NoRecursion)
        return;
    if (scalar.baseScalar) {
        navigateScalarType(scalar.baseScalar, context);
    }
    context.emit("exitScalar", scalar);
}
function navigateInterfaceType(type, context) {
    if (checkVisited(context.visited, type)) {
        return;
    }
    if (!shouldNavigateTemplatableType(context, type)) {
        return;
    }
    context.emit("interface", type);
    for (const op of type.operations.values()) {
        navigateOperationType(op, context);
    }
}
function navigateEnumType(type, context) {
    if (checkVisited(context.visited, type)) {
        return;
    }
    context.emit("enum", type);
}
function navigateUnionType(type, context) {
    if (checkVisited(context.visited, type)) {
        return;
    }
    if (!shouldNavigateTemplatableType(context, type)) {
        return;
    }
    if (context.emit("union", type) === ListenerFlow.NoRecursion)
        return;
    for (const variant of type.variants.values()) {
        navigateUnionTypeVariant(variant, context);
    }
}
function navigateUnionTypeVariant(type, context) {
    if (checkVisited(context.visited, type)) {
        return;
    }
    if (context.emit("unionVariant", type) === ListenerFlow.NoRecursion)
        return;
    navigateTypeInternal(type.type, context);
}
function navigateTupleType(type, context) {
    if (checkVisited(context.visited, type)) {
        return;
    }
    if (context.emit("tuple", type) === ListenerFlow.NoRecursion)
        return;
    for (const value of type.values) {
        navigateTypeInternal(value, context);
    }
}
function navigateStringTemplate(type, context) {
    if (checkVisited(context.visited, type)) {
        return;
    }
    if (context.emit("stringTemplate", type) === ListenerFlow.NoRecursion)
        return;
    for (const value of type.spans) {
        navigateTypeInternal(value, context);
    }
}
function navigateStringTemplateSpan(type, context) {
    if (checkVisited(context.visited, type)) {
        return;
    }
    if (context.emit("stringTemplateSpan", type) === ListenerFlow.NoRecursion)
        return;
    navigateTypeInternal(type.type, context);
}
function navigateTemplateParameter(type, context) {
    if (checkVisited(context.visited, type)) {
        return;
    }
    if (context.emit("templateParameter", type) === ListenerFlow.NoRecursion)
        return;
}
function navigateDecoratorDeclaration(type, context) {
    if (checkVisited(context.visited, type)) {
        return;
    }
    if (context.emit("decorator", type) === ListenerFlow.NoRecursion)
        return;
}
function navigateTypeInternal(type, context) {
    switch (type.kind) {
        case "Model":
            return navigateModelType(type, context);
        case "Scalar":
            return navigateScalarType(type, context);
        case "ModelProperty":
            return navigateModelTypeProperty(type, context);
        case "Namespace":
            return navigateNamespaceType(type, context);
        case "Interface":
            return navigateInterfaceType(type, context);
        case "Enum":
            return navigateEnumType(type, context);
        case "Operation":
            return navigateOperationType(type, context);
        case "Union":
            return navigateUnionType(type, context);
        case "UnionVariant":
            return navigateUnionTypeVariant(type, context);
        case "Tuple":
            return navigateTupleType(type, context);
        case "StringTemplate":
            return navigateStringTemplate(type, context);
        case "StringTemplateSpan":
            return navigateStringTemplateSpan(type, context);
        case "TemplateParameter":
            return navigateTemplateParameter(type, context);
        case "Decorator":
            return navigateDecoratorDeclaration(type, context);
        case "Object":
        case "Projection":
        case "Function":
        case "FunctionParameter":
        case "Boolean":
        case "EnumMember":
        case "Intrinsic":
        case "Number":
        case "String":
            return;
        default:
            return;
    }
}
// Return property from type, nesting into baseTypes as needed.
function getProperty(type, propertyName) {
    while (type.baseModel) {
        if (type.properties.has(propertyName)) {
            return type.properties.get(propertyName);
        }
        type = type.baseModel;
    }
    return type.properties.get(propertyName);
}
class EventEmitter {
    constructor() {
        this.listeners = new Map();
    }
    on(name, listener) {
        const array = this.listeners.get(name);
        if (array) {
            array.push(listener);
        }
        else {
            this.listeners.set(name, [listener]);
        }
    }
    emit(name, ...args) {
        const listeners = this.listeners.get(name);
        if (listeners) {
            for (const listener of listeners) {
                listener(...args);
            }
        }
    }
}
const eventNames = [
    "root",
    "templateParameter",
    "exitTemplateParameter",
    "scalar",
    "exitScalar",
    "model",
    "exitModel",
    "modelProperty",
    "exitModelProperty",
    "interface",
    "exitInterface",
    "enum",
    "exitEnum",
    "enumMember",
    "exitEnumMember",
    "namespace",
    "exitNamespace",
    "operation",
    "exitOperation",
    "string",
    "exitString",
    "number",
    "exitNumber",
    "boolean",
    "exitBoolean",
    "tuple",
    "exitTuple",
    "union",
    "exitUnion",
    "unionVariant",
    "exitUnionVariant",
    "intrinsic",
    "exitIntrinsic",
    "function",
    "exitFunction",
    "object",
    "exitObject",
    "projection",
    "exitProjection",
];

function createLinter(program, loadLibrary) {
    const tracer = program.tracer.sub("linter");
    const ruleMap = new Map();
    const enabledRules = new Map();
    const linterLibraries = new Map();
    return {
        extendRuleSet,
        lint,
    };
    async function extendRuleSet(ruleSet) {
        var _a, _b, _c;
        tracer.trace("extend-rule-set.start", JSON.stringify(ruleSet, null, 2));
        const diagnostics = createDiagnosticCollector();
        if (ruleSet.extends) {
            for (const extendingRuleSetName of ruleSet.extends) {
                const ref = diagnostics.pipe(parseRuleReference(extendingRuleSetName));
                if (ref) {
                    const library = await resolveLibrary(ref.libraryName);
                    const extendingRuleSet = (_c = (_b = (_a = library === null || library === void 0 ? void 0 : library.definition) === null || _a === void 0 ? void 0 : _a.linter) === null || _b === void 0 ? void 0 : _b.ruleSets) === null || _c === void 0 ? void 0 : _c[ref.name];
                    if (extendingRuleSet) {
                        await extendRuleSet(extendingRuleSet);
                    }
                    else {
                        diagnostics.add(createDiagnostic({
                            code: "unknown-rule-set",
                            format: { libraryName: ref.libraryName, ruleSetName: ref.name },
                            target: NoTarget,
                        }));
                    }
                }
            }
        }
        const enabledInThisRuleSet = new Set();
        if (ruleSet.enable) {
            for (const [ruleName, enable] of Object.entries(ruleSet.enable)) {
                if (enable === false) {
                    continue;
                }
                const ref = diagnostics.pipe(parseRuleReference(ruleName));
                if (ref) {
                    await resolveLibrary(ref.libraryName);
                    const rule = ruleMap.get(ruleName);
                    if (rule) {
                        enabledInThisRuleSet.add(ruleName);
                        enabledRules.set(ruleName, rule);
                    }
                    else {
                        diagnostics.add(createDiagnostic({
                            code: "unknown-rule",
                            format: { libraryName: ref.libraryName, ruleName: ref.name },
                            target: NoTarget,
                        }));
                    }
                }
            }
        }
        if (ruleSet.disable) {
            for (const ruleName of Object.keys(ruleSet.disable)) {
                if (enabledInThisRuleSet.has(ruleName)) {
                    diagnostics.add(createDiagnostic({
                        code: "rule-enabled-disabled",
                        format: { ruleName },
                        target: NoTarget,
                    }));
                }
                enabledRules.delete(ruleName);
            }
        }
        tracer.trace("extend-rule-set.end", "Rules enabled: \n" + [...enabledRules.keys()].map((x) => ` - ${x}`).join("\n"));
        return diagnostics.diagnostics;
    }
    function lint() {
        const diagnostics = createDiagnosticCollector();
        const eventEmitter = new EventEmitter();
        tracer.trace("lint", `Running linter with following rules:\n` +
            [...enabledRules.keys()].map((x) => ` - ${x}`).join("\n"));
        for (const rule of enabledRules.values()) {
            const listener = rule.create(createLinterRuleContext(program, rule, diagnostics));
            for (const [name, cb] of Object.entries(listener)) {
                eventEmitter.on(name, cb);
            }
        }
        navigateProgram(program, mapEventEmitterToNodeListener(eventEmitter));
        return diagnostics.diagnostics;
    }
    async function resolveLibrary(name) {
        const loadedLibrary = linterLibraries.get(name);
        if (loadedLibrary === undefined) {
            return registerLinterLibrary(name);
        }
        return loadedLibrary;
    }
    async function registerLinterLibrary(name) {
        var _a, _b;
        tracer.trace("register-library", name);
        const library = await loadLibrary(name);
        if ((_b = (_a = library === null || library === void 0 ? void 0 : library.definition) === null || _a === void 0 ? void 0 : _a.linter) === null || _b === void 0 ? void 0 : _b.rules) {
            for (const ruleDef of library.definition.linter.rules) {
                const ruleId = `${name}/${ruleDef.name}`;
                tracer.trace("register-library.rule", `Registering rule "${ruleId}" for library "${name}".`);
                const rule = { ...ruleDef, id: ruleId };
                if (ruleMap.has(ruleId)) {
                    compilerAssert(false, `Unexpected duplicate linter rule: "${ruleId}"`);
                }
                else {
                    ruleMap.set(ruleId, rule);
                }
            }
        }
        linterLibraries.set(name, library);
        return library;
    }
    function parseRuleReference(ref) {
        const segments = ref.split("/");
        const name = segments.pop();
        const libraryName = segments.join("/");
        if (!libraryName || !name) {
            return [
                undefined,
                [createDiagnostic({ code: "invalid-rule-ref", format: { ref }, target: NoTarget })],
            ];
        }
        return [{ libraryName, name }, []];
    }
}
function createLinterRuleContext(program, rule, diagnosticCollector) {
    return {
        program,
        reportDiagnostic,
    };
    function createDiagnostic(diag) {
        var _a;
        const message = rule.messages[(_a = diag.messageId) !== null && _a !== void 0 ? _a : "default"];
        if (!message) {
            const messageString = Object.keys(rule.messages)
                .map((x) => ` - ${x}`)
                .join("\n");
            const messageId = String(diag.messageId);
            throw new Error(`Unexpected message id '${messageId}' for rule '${rule.name}'. Defined messages:\n${messageString}`);
        }
        const messageStr = typeof message === "string" ? message : message(diag.format);
        return {
            code: rule.id,
            severity: rule.severity,
            message: messageStr,
            target: diag.target,
        };
    }
    function reportDiagnostic(diag) {
        const diagnostic = createDiagnostic(diag);
        if (diagnostic.target !== NoTarget) {
            const context = getLocationContext(program, diagnostic.target);
            // Only report diagnostic in the user project.
            // See for showing diagnostic in library at point of usage https://github.com/microsoft/typespec/issues/1997
            if (context.type === "project") {
                diagnosticCollector.add(diagnostic);
            }
        }
    }
}

function createTracer(logger, tracerOptions = {}) {
    const filters = tracerOptions.filter ? createFilterTree(tracerOptions.filter) : undefined;
    function shouldTrace(area) {
        if (!filters) {
            return false;
        }
        return filters.match(area);
    }
    function log(area, message) {
        if (shouldTrace(area)) {
            logger.log({
                level: "trace",
                code: area,
                message,
            });
        }
    }
    return createTracerInternal(log);
}
function createFilterTree(filters) {
    const tree = {
        all: false,
        children: {},
    };
    for (const filter of filters) {
        if (tree.all) {
            break;
        }
        let current = tree;
        const segments = filter.split(".");
        for (const segment of segments) {
            if (current.all) {
                break;
            }
            if (segment === "*") {
                current.all = true;
                break;
            }
            current.children[segment] = {
                all: false,
                children: {},
            };
            current = current.children[segment];
        }
        current.all = true;
    }
    return { match };
    function match(area) {
        if (tree.all) {
            return true;
        }
        const segments = area.split(".");
        let current = tree;
        for (const segment of segments) {
            if (current.all) {
                return true;
            }
            if (!current.children[segment]) {
                return false;
            }
            current = current.children[segment];
        }
        return true;
    }
}
function createTracerInternal(log) {
    return {
        trace,
        sub,
    };
    function trace(area, message) {
        log(area, message);
    }
    function sub(subArea) {
        return createTracerInternal((area, message) => {
            log(joinAreas(subArea, area), message);
        });
    }
}
function joinAreas(a, b) {
    if (a) {
        if (b) {
            return `${a}.${b}`;
        }
        return a;
    }
    else {
        return b !== null && b !== void 0 ? b : "";
    }
}

/**
 * Creates a projector which returns a projected view of either the global namespace or the
 * start node provided. Projecting a type effectively clones every type referenced underneath
 * it. This is accomplished by doing a semantic walk of each type, cloning each type we find,
 * and running projection code on the clone.
 *
 * Projectors can run multiple projections at once. In such cases, each projection is run
 * on the same clone of the unprojected type. It is up to projections and the user to ensure
 * that projections which depend on a particular shape are run when that shape is present (or
 * else to ensure that their projections are tolerant to shape changes).
 *
 * The projector maintains its own state maps and sets. If a projection is active (i.e.
 * program.currentProjector is set), then the projector's state will be returned instead
 * of the program's state. This ensures that there is no overlap between projected and
 * unprojected state. It also means that you cannot get state for nodes that are not
 * part of the active projection.
 *
 * Note that decorators are run on namespaces prior to cloning any child types to align
 * with the checker semantics, while projections are run after everything under the namespace
 * is cloned. All other run decorators and projections after all child types are cloned and
 * have their decorators run.
 */
function createProjector(program, projections, startNode) {
    const projectedTypes = new Map();
    const checker = program.checker;
    const neverType = checker.neverType;
    const scope = [];
    const projector = {
        projectedTypes,
        projections,
        projectType,
        parentProjector: isProjectedProgram(program) ? program.projector : undefined,
    };
    const projectedNamespaces = [];
    let projectingNamespaces = false;
    const projectedProgram = {
        ...program,
        getGlobalNamespaceType: () => projector.projectedGlobalNamespace,
        projector,
        ...createStateAccessors(program.stateMaps, program.stateSets, projector),
    };
    const targetGlobalNs = startNode
        ? startNode.projector
            ? startNode.projector.projectedGlobalNamespace
            : program.checker.getGlobalNamespaceType()
        : program.checker.getGlobalNamespaceType();
    projectingNamespaces = true;
    // Project the global namespace to get a reference.
    projector.projectedGlobalNamespace = projectNamespace(targetGlobalNs, false);
    // Then project the content
    projectSubNamespaces(targetGlobalNs, projector.projectedGlobalNamespace);
    projectingNamespaces = false;
    // then project all the types
    for (const ns of projectedNamespaces) {
        projectNamespaceContents(ns);
    }
    projectType(targetGlobalNs);
    projector.projectedStartNode = startNode
        ? projectedTypes.get(startNode)
        : projector.projectedGlobalNamespace;
    return projectedProgram;
    function projectType(type) {
        if (projectedTypes.has(type)) {
            return projectedTypes.get(type);
        }
        scope.push(type);
        const preProjected = applyPreProjection(type);
        if (preProjected !== type) {
            projectedTypes.set(type, preProjected);
            scope.pop();
            return preProjected;
        }
        let projected;
        switch (type.kind) {
            case "Namespace":
                compilerAssert(projectingNamespaces, `Namespace ${type.name} should have already been projected.`);
                projected = projectNamespace(type, false);
                break;
            case "Scalar":
                projected = projectScalar(type);
                break;
            case "Model":
                projected = projectModel(type);
                break;
            case "ModelProperty":
                projected = projectModelProperty(type);
                break;
            case "Operation":
                projected = projectOperation(type);
                break;
            case "Interface":
                projected = projectInterface(type);
                break;
            case "Union":
                projected = projectUnion(type);
                break;
            case "UnionVariant":
                projected = projectUnionVariant(type);
                break;
            case "Tuple":
                projected = projectTuple(type);
                break;
            case "Enum":
                projected = projectEnum(type);
                break;
            case "EnumMember":
                projected = projectEnumMember(type);
                break;
            default:
                projected = type;
        }
        scope.pop();
        return projected;
    }
    function projectSubNamespaces(ns, projectedNs) {
        if (ns.namespaces.size === projectedNs.namespaces.size) {
            // Sub namespace should already have been projected.
            return;
        }
        for (const [key, childNs] of ns.namespaces) {
            const projected = projectNamespace(childNs);
            if (projected.kind === "Namespace") {
                // todo: check for never?
                projectedNs.namespaces.set(key, projected);
            }
        }
    }
    function projectNamespace(ns, projectSubNamespace = true) {
        const alreadyProjected = projectedTypes.get(ns);
        if (alreadyProjected) {
            if (projectSubNamespace) {
                projectSubNamespaces(ns, alreadyProjected);
            }
            return alreadyProjected;
        }
        const projectedNs = shallowClone(ns, {
            namespaces: new Map(),
            scalars: new Map(),
            models: new Map(),
            operations: new Map(),
            interfaces: new Map(),
            unions: new Map(),
            enums: new Map(),
            decorators: [],
        });
        projectedNs.decorators = projectDecorators(ns.decorators);
        if (ns.namespace) {
            projectedNs.namespace = projectNamespace(ns.namespace, false);
        }
        // ns run decorators before projecting anything inside them
        finishTypeForProgram(projectedProgram, projectedNs);
        if (projectSubNamespace) {
            projectSubNamespaces(ns, projectedNs);
        }
        projectedNamespaces.push(ns);
        return applyProjection(ns, projectedNs);
    }
    /**
     * Projects the contents of a namespace, but not the namespace itself. The namespace itself
     * is projected in an earlier phase.
     */
    function projectNamespaceContents(ns) {
        const projectedNs = projectedTypes.get(ns);
        compilerAssert(projectedNs, "Should have projected namespace by now");
        if (projectedNs.kind !== "Namespace") {
            // we projected the namespace to something else so don't do any more work.
            // this might happen if a namespace itself was added/removed/etc. and is
            // projected to never.
            return neverType;
        }
        for (const childModel of ns.models.values()) {
            const projected = projectType(childModel);
            if (projected.kind === "Model") {
                projectedNs.models.set(projected.name, projected);
            }
        }
        for (const scalar of ns.scalars.values()) {
            const projected = projectType(scalar);
            if (projected.kind === "Scalar") {
                projectedNs.scalars.set(projected.name, projected);
            }
        }
        for (const childOperation of ns.operations.values()) {
            const projected = projectType(childOperation);
            if (projected.kind === "Operation") {
                projectedNs.operations.set(projected.name, projected);
            }
        }
        for (const childInterface of ns.interfaces.values()) {
            const projected = projectType(childInterface);
            if (projected.kind === "Interface") {
                projectedNs.interfaces.set(projected.name, projected);
            }
        }
        for (const childUnion of ns.unions.values()) {
            const projected = projectType(childUnion);
            if (projected.kind === "Union") {
                projectedNs.unions.set(projected.name, projected);
            }
        }
        for (const childEnum of ns.enums.values()) {
            const projected = projectType(childEnum);
            if (projected.kind === "Enum") {
                projectedNs.enums.set(projected.name, projected);
            }
        }
        return projectedNs;
    }
    function projectModel(model) {
        var _a;
        var _b;
        const properties = createRekeyableMap();
        const projectedModel = shallowClone(model, {
            properties,
            derivedModels: [],
        });
        if (model.templateMapper) {
            projectedModel.templateMapper = projectTemplateMapper(model.templateMapper);
            // eslint-disable-next-line deprecation/deprecation
            projectedModel.templateArguments = mutate(projectedModel.templateMapper.args);
        }
        if (model.baseModel) {
            projectedModel.baseModel = projectType(model.baseModel);
        }
        if (model.sourceModel) {
            projectedModel.sourceModel = projectType(model.sourceModel);
        }
        if (model.indexer) {
            projectedModel.indexer = {
                key: projectType(model.indexer.key),
                value: projectType(model.indexer.value),
            };
        }
        projectedTypes.set(model, projectedModel);
        for (const prop of model.properties.values()) {
            const projectedProp = projectType(prop);
            if (projectedProp.kind === "ModelProperty") {
                properties.set(projectedProp.name, projectedProp);
            }
        }
        projectedModel.decorators = projectDecorators(model.decorators);
        if (shouldFinishType(model)) {
            finishTypeForProgram(projectedProgram, projectedModel);
        }
        const projectedResult = applyProjection(model, projectedModel);
        if (!isNeverType(projectedResult) &&
            projectedResult.kind === "Model" &&
            projectedResult.baseModel) {
            (_a = (_b = projectedResult.baseModel).derivedModels) !== null && _a !== void 0 ? _a : (_b.derivedModels = []);
            projectedResult.baseModel.derivedModels.push(projectedModel);
        }
        return projectedResult;
    }
    function projectTemplateMapper(mapper) {
        const projectedMapper = {
            ...mapper,
            args: [],
            map: new Map(),
        };
        for (const arg of mapper.args) {
            mutate(projectedMapper.args).push(projectType(arg));
        }
        for (const [param, type] of mapper.map) {
            projectedMapper.map.set(param, projectType(type));
        }
        return projectedMapper;
    }
    function projectScalar(scalar) {
        var _a;
        var _b;
        const projectedScalar = shallowClone(scalar, {
            derivedScalars: [],
        });
        if (scalar.templateMapper) {
            projectedScalar.templateMapper = projectTemplateMapper(scalar.templateMapper);
            // eslint-disable-next-line deprecation/deprecation
            projectedScalar.templateArguments = mutate(projectedScalar.templateMapper.args);
        }
        if (scalar.baseScalar) {
            projectedScalar.baseScalar = projectType(scalar.baseScalar);
        }
        projectedTypes.set(scalar, projectedScalar);
        projectedScalar.decorators = projectDecorators(scalar.decorators);
        if (shouldFinishType(scalar)) {
            finishTypeForProgram(projectedProgram, projectedScalar);
        }
        const projectedResult = applyProjection(scalar, projectedScalar);
        if (!isNeverType(projectedResult) &&
            projectedResult.kind === "Scalar" &&
            projectedResult.baseScalar) {
            (_a = (_b = projectedResult.baseScalar).derivedScalars) !== null && _a !== void 0 ? _a : (_b.derivedScalars = []);
            projectedResult.baseScalar.derivedScalars.push(projectedScalar);
        }
        return projectedResult;
    }
    /**
     * Returns true if we should finish a type. The only time we don't finish is when it's
     * a template type, because we don't want to run decorators for templates.
     */
    function shouldFinishType(type) {
        const parentTemplate = getParentTemplateNode(type.node);
        return !parentTemplate || isTemplateInstance(type);
    }
    function projectModelProperty(prop) {
        const projectedType = projectType(prop.type);
        const projectedDecs = projectDecorators(prop.decorators);
        const projectedProp = shallowClone(prop, {
            type: projectedType,
            decorators: projectedDecs,
        });
        if (prop.sourceProperty) {
            const sourceProperty = projectType(prop.sourceProperty);
            projectedProp.sourceProperty = sourceProperty;
        }
        if (shouldFinishType(prop)) {
            finishTypeForProgram(projectedProgram, projectedProp);
        }
        if (prop.model) {
            projectedProp.model = projectType(prop.model);
        }
        return applyProjection(prop, projectedProp);
    }
    function projectOperation(op) {
        const projectedOp = shallowClone(op, {});
        projectedOp.parameters = projectType(op.parameters);
        projectedOp.returnType = projectType(op.returnType);
        projectedOp.decorators = projectDecorators(op.decorators);
        if (op.templateMapper) {
            projectedOp.templateMapper = projectTemplateMapper(op.templateMapper);
            // eslint-disable-next-line deprecation/deprecation
            projectedOp.templateArguments = mutate(projectedOp.templateMapper.args);
        }
        if (op.sourceOperation) {
            projectedOp.sourceOperation = projectType(op.sourceOperation);
        }
        if (op.namespace) {
            projectedOp.namespace = projectedNamespaceScope();
        }
        finishTypeForProgram(projectedProgram, projectedOp);
        if (op.interface) {
            projectedOp.interface = projectType(op.interface);
        }
        return applyProjection(op, projectedOp);
    }
    function projectInterface(iface) {
        const operations = createRekeyableMap();
        const sourceInterfaces = [];
        const projectedIface = shallowClone(iface, {
            operations,
            sourceInterfaces,
        });
        projectedIface.decorators = projectDecorators(iface.decorators);
        if (iface.templateMapper) {
            projectedIface.templateMapper = projectTemplateMapper(iface.templateMapper);
            // eslint-disable-next-line deprecation/deprecation
            projectedIface.templateArguments = mutate(projectedIface.templateMapper.args);
        }
        for (const op of iface.operations.values()) {
            const projectedOp = projectType(op);
            if (projectedOp.kind === "Operation") {
                operations.set(projectedOp.name, projectedOp);
            }
        }
        for (const source of iface.sourceInterfaces) {
            sourceInterfaces.push(projectType(source));
        }
        if (shouldFinishType(iface)) {
            finishTypeForProgram(projectedProgram, projectedIface);
        }
        return applyProjection(iface, projectedIface);
    }
    function projectUnion(union) {
        const variants = createRekeyableMap();
        const projectedUnion = shallowClone(union, {
            variants,
        });
        projectedUnion.decorators = projectDecorators(union.decorators);
        if (union.templateMapper) {
            projectedUnion.templateMapper = projectTemplateMapper(union.templateMapper);
            // eslint-disable-next-line deprecation/deprecation
            projectedUnion.templateArguments = mutate(projectedUnion.templateMapper.args);
        }
        for (const variant of union.variants.values()) {
            const projectedVariant = projectType(variant);
            if (projectedVariant.kind === "UnionVariant" && projectedVariant.type !== neverType) {
                variants.set(projectedVariant.name, projectedVariant);
            }
        }
        if (shouldFinishType(union)) {
            finishTypeForProgram(projectedProgram, projectedUnion);
        }
        return applyProjection(union, projectedUnion);
    }
    function projectUnionVariant(variant) {
        const projectedType = projectType(variant.type);
        const projectedDecs = projectDecorators(variant.decorators);
        const projectedVariant = shallowClone(variant, {
            type: projectedType,
            decorators: projectedDecs,
        });
        finishTypeForProgram(projectedProgram, projectedVariant);
        projectedVariant.union = projectType(variant.union);
        return applyProjection(variant, projectedVariant);
    }
    function projectTuple(tuple) {
        const values = [];
        const projectedTuple = shallowClone(tuple, {
            values,
        });
        for (const item of tuple.values) {
            values.push(projectType(item));
        }
        return projectedTuple;
    }
    function projectEnum(e) {
        const members = createRekeyableMap();
        const projectedEnum = shallowClone(e, {
            members,
        });
        projectedEnum.decorators = projectDecorators(e.decorators);
        projectedTypes.set(e, projectedEnum);
        for (const member of e.members.values()) {
            const projectedMember = projectType(member);
            if (projectedMember.kind === "EnumMember") {
                members.set(projectedMember.name, projectedMember);
            }
        }
        finishTypeForProgram(projectedProgram, projectedEnum);
        return applyProjection(e, projectedEnum);
    }
    function projectEnumMember(e) {
        const decorators = projectDecorators(e.decorators);
        const projectedMember = shallowClone(e, {
            decorators,
        });
        finishTypeForProgram(projectedProgram, projectedMember);
        projectedMember.enum = projectType(e.enum);
        return applyProjection(e, projectedMember);
    }
    function projectDecorators(decs) {
        const decorators = [];
        for (const dec of decs) {
            const args = [];
            for (const arg of dec.args) {
                const jsValue = typeof arg.jsValue === "object" ? projectType(arg.jsValue) : arg.jsValue;
                args.push({ ...arg, value: projectType(arg.value), jsValue });
            }
            decorators.push({ ...dec, args });
        }
        return decorators;
    }
    function getInScopeProjections() {
        const candidates = new Set(projections);
        const inScope = [];
        let currentScope = namespaceScope();
        outer: while (currentScope) {
            for (const candidate of candidates) {
                if (!candidate.scope || candidate.scope === currentScope) {
                    candidates.delete(candidate);
                    inScope.push(candidate);
                    if (candidates.size === 0) {
                        break outer;
                    }
                }
            }
            currentScope = currentScope.namespace;
        }
        return inScope;
    }
    function namespaceScope() {
        for (let i = scope.length - 1; i >= 0; i--) {
            if (scope[i].namespace !== undefined) {
                return scope[i].namespace;
            }
        }
        return undefined;
    }
    function projectedNamespaceScope() {
        const ns = namespaceScope();
        if (!ns)
            return ns;
        return projectType(ns);
    }
    function applyProjection(baseType, projectedType) {
        const inScopeProjections = getInScopeProjections();
        for (const projectionApplication of inScopeProjections) {
            const projectionsByName = baseType.projectionsByName(projectionApplication.projectionName);
            if (projectionsByName.length === 0)
                continue;
            const targetNode = projectionApplication.direction === "from"
                ? projectionsByName[0].from
                : projectionsByName[0].to;
            if (targetNode) {
                const projected = checker.project(projectedType, targetNode, projectionApplication.arguments);
                if (projected !== projectedType) {
                    // override the projected type cache with the returned type
                    projectedTypes.set(baseType, projected);
                    return projected;
                }
            }
        }
        return projectedType;
    }
    function applyPreProjection(type) {
        const inScopeProjections = getInScopeProjections();
        for (const projectionApplication of inScopeProjections) {
            const projectionsByName = type.projectionsByName(projectionApplication.projectionName);
            if (projectionsByName.length === 0)
                continue;
            const targetNode = projectionApplication.direction === "from"
                ? projectionsByName[0].preFrom
                : projectionsByName[0].preTo;
            if (targetNode) {
                return checker.project(type, targetNode, projectionApplication.arguments);
            }
        }
        return type;
    }
    function shallowClone(type, additionalProps) {
        var _a;
        const scopeProps = {};
        if ("namespace" in type && type.namespace !== undefined) {
            scopeProps.namespace = projectedNamespaceScope();
        }
        const clone = checker.createType({
            ...type,
            ...additionalProps,
            ...scopeProps,
            projectionSource: type,
            projectionBase: (_a = type.projectionBase) !== null && _a !== void 0 ? _a : type,
            projector,
        });
        if (type.kind === "Union") {
            // create the options getter
            Object.defineProperty(clone, "options", {
                get() {
                    return Array.from(this.variants.values()).map((v) => v.type);
                },
            });
        }
        projectedTypes.set(type, clone);
        return clone;
    }
}

var _a, _b;
function isProjectedProgram(program) {
    return "projector" in program;
}
class StateMap extends Map {
}
class StateSet extends Map {
}
class StateMapView {
    constructor(state, projector) {
        this.state = state;
        this.projector = projector;
        this[_a] = "StateMap";
    }
    has(t) {
        var _c, _d;
        return (_d = (_c = this.dispatch(t)) === null || _c === void 0 ? void 0 : _c.has(t)) !== null && _d !== void 0 ? _d : false;
    }
    set(t, v) {
        this.dispatch(t).set(t, v);
        return this;
    }
    get(t) {
        return this.dispatch(t).get(t);
    }
    delete(t) {
        return this.dispatch(t).delete(t);
    }
    forEach(cb, thisArg) {
        this.dispatch().forEach(cb, thisArg);
        return this;
    }
    get size() {
        return this.dispatch().size;
    }
    clear() {
        return this.dispatch().clear();
    }
    entries() {
        return this.dispatch().entries();
    }
    values() {
        return this.dispatch().values();
    }
    keys() {
        return this.dispatch().keys();
    }
    [Symbol.iterator]() {
        return this.entries();
    }
    dispatch(keyType) {
        const key = keyType ? keyType.projector : this.projector;
        if (!this.state.has(key)) {
            this.state.set(key, new Map());
        }
        return this.state.get(key);
    }
}
_a = Symbol.toStringTag;
class StateSetView {
    constructor(state, projector) {
        this.state = state;
        this.projector = projector;
        this[_b] = "StateSet";
    }
    has(t) {
        var _c, _d;
        return (_d = (_c = this.dispatch(t)) === null || _c === void 0 ? void 0 : _c.has(t)) !== null && _d !== void 0 ? _d : false;
    }
    add(t) {
        this.dispatch(t).add(t);
        return this;
    }
    delete(t) {
        return this.dispatch(t).delete(t);
    }
    forEach(cb, thisArg) {
        this.dispatch().forEach(cb, thisArg);
        return this;
    }
    get size() {
        return this.dispatch().size;
    }
    clear() {
        return this.dispatch().clear();
    }
    values() {
        return this.dispatch().values();
    }
    keys() {
        return this.dispatch().keys();
    }
    entries() {
        return this.dispatch().entries();
    }
    [Symbol.iterator]() {
        return this.values();
    }
    dispatch(keyType) {
        const key = keyType ? keyType.projector : this.projector;
        if (!this.state.has(key)) {
            this.state.set(key, new Set());
        }
        return this.state.get(key);
    }
}
_b = Symbol.toStringTag;
function projectProgram(program, projections, startNode) {
    return createProjector(program, projections, startNode);
}
async function compile(host, mainFile, options = {}, oldProgram // NOTE: deliberately separate from options to avoid memory leak by chaining all old programs together.
) {
    var _c, _d;
    const validateCbs = [];
    const stateMaps = new Map();
    const stateSets = new Map();
    const diagnostics = [];
    const seenSourceFiles = new Set();
    const duplicateSymbols = new Set();
    const emitters = [];
    const requireImports = new Map();
    const loadedLibraries = new Map();
    const sourceFileLocationContexts = new WeakMap();
    let error = false;
    const logger = createLogger({ sink: host.logSink });
    const tracer = createTracer(logger, { filter: options.trace });
    const resolvedMain = await resolveTypeSpecEntrypoint(host, mainFile, reportDiagnostic);
    const program = {
        checker: undefined,
        compilerOptions: resolveOptions(options),
        sourceFiles: new Map(),
        jsSourceFiles: new Map(),
        literalTypes: new Map(),
        host,
        diagnostics,
        emitters,
        loadTypeSpecScript,
        getOption,
        stateMaps,
        stateSets,
        tracer,
        trace,
        ...createStateAccessors(stateMaps, stateSets),
        reportDiagnostic,
        reportDiagnostics,
        reportDuplicateSymbols,
        hasError() {
            return error;
        },
        onValidate(cb, metadata) {
            validateCbs.push({ callback: cb, metadata });
        },
        getGlobalNamespaceType,
        resolveTypeReference,
        getSourceFileLocationContext,
        projectRoot: getDirectoryPath((_d = (_c = options.config) !== null && _c !== void 0 ? _c : resolvedMain) !== null && _d !== void 0 ? _d : ""),
    };
    trace("compiler.options", JSON.stringify(options, null, 2));
    function trace(area, message) {
        tracer.trace(area, message);
    }
    const binder = createBinder(program);
    if (!(options === null || options === void 0 ? void 0 : options.nostdlib)) {
        await loadStandardLibrary();
    }
    // Load additional imports prior to compilation
    if (resolvedMain && options.additionalImports) {
        const importScript = options.additionalImports.map((i) => `import "${i}";`).join("\n");
        const sourceFile = createSourceFile(importScript, joinPaths(getDirectoryPath(resolvedMain), `__additional_imports`));
        sourceFileLocationContexts.set(sourceFile, { type: "project" });
        await loadTypeSpecScript(sourceFile);
    }
    if (resolvedMain) {
        await loadMain(resolvedMain);
    }
    else {
        return program;
    }
    const basedir = getDirectoryPath(resolvedMain);
    let emit = options.emit;
    let emitterOptions = options.options;
    /* eslint-disable deprecation/deprecation */
    if (options.emitters) {
        emit !== null && emit !== void 0 ? emit : (emit = Object.keys(options.emitters));
        emitterOptions !== null && emitterOptions !== void 0 ? emitterOptions : (emitterOptions = options.emitters);
    }
    /* eslint-enable deprecation/deprecation */
    await loadEmitters(basedir, emit !== null && emit !== void 0 ? emit : [], emitterOptions !== null && emitterOptions !== void 0 ? emitterOptions : {});
    if (oldProgram &&
        mapEquals(oldProgram.sourceFiles, program.sourceFiles) &&
        deepEquals(oldProgram.compilerOptions, program.compilerOptions)) {
        return oldProgram;
    }
    // let GC reclaim old program, we do not reuse it beyond this point.
    oldProgram = undefined;
    const linter = createLinter(program, (name) => loadLibrary(basedir, name));
    if (options.linterRuleSet) {
        program.reportDiagnostics(await linter.extendRuleSet(options.linterRuleSet));
    }
    program.checker = createChecker(program);
    program.checker.checkProgram();
    if (program.hasError()) {
        return program;
    }
    // onValidate stage
    await runValidators();
    for (const [requiredImport, emitterName] of requireImports) {
        if (!loadedLibraries.has(requiredImport)) {
            program.reportDiagnostic(createDiagnostic({
                code: "missing-import",
                format: { requiredImport, emitterName },
                target: NoTarget,
            }));
        }
    }
    await validateLoadedLibraries();
    if (program.hasError()) {
        return program;
    }
    // Linter stage
    program.reportDiagnostics(linter.lint());
    // Emitter stage
    for (const instance of emitters) {
        await runEmitter(instance);
    }
    return program;
    /**
     * Validate the libraries loaded during the compilation process are compatible.
     */
    async function validateLoadedLibraries() {
        const loadedRoots = new Set();
        // Check all the files that were loaded
        for (const fileUrl of getLibraryUrlsLoaded()) {
            const root = await findProjectRoot(host, host.fileURLToPath(fileUrl));
            if (root) {
                loadedRoots.add(root);
            }
        }
        const libraries = new Map([...loadedLibraries.entries()]);
        const incompatibleLibraries = new Map();
        for (const root of loadedRoots) {
            const packageJsonPath = joinPaths(root, "package.json");
            try {
                const packageJson = JSON.parse((await host.readFile(packageJsonPath)).text);
                const found = libraries.get(packageJson.name);
                if (found && found.path !== root && found.manifest.version !== packageJson.version) {
                    let incompatibleIndex = incompatibleLibraries.get(packageJson.name);
                    if (incompatibleIndex === undefined) {
                        incompatibleIndex = [found];
                        incompatibleLibraries.set(packageJson.name, incompatibleIndex);
                    }
                    incompatibleIndex.push({ path: root, manifest: packageJson });
                }
            }
            catch { }
        }
        for (const [name, incompatibleLibs] of incompatibleLibraries) {
            reportDiagnostic(createDiagnostic({
                code: "incompatible-library",
                format: {
                    name: name,
                    versionMap: incompatibleLibs
                        .map((x) => `  - Version: "${x.manifest.version}" installed at "${x.path}"`)
                        .join("\n"),
                },
                target: NoTarget,
            }));
        }
    }
    async function loadStandardLibrary(program) {
        const locationContext = { type: "compiler" };
        for (const dir of host.getLibDirs()) {
            await loadDirectory(dir, locationContext, NoTarget);
        }
    }
    async function loadDirectory(dir, locationContext, diagnosticTarget) {
        const mainFile = await resolveTypeSpecEntrypointForDir(host, dir, reportDiagnostic);
        await loadTypeSpecFile(mainFile, locationContext, diagnosticTarget);
        return mainFile;
    }
    async function loadTypeSpecFile(path, locationContext, diagnosticTarget) {
        if (seenSourceFiles.has(path)) {
            return;
        }
        seenSourceFiles.add(path);
        const file = await doIO(host.readFile, path, program.reportDiagnostic, {
            diagnosticTarget,
        });
        if (file) {
            sourceFileLocationContexts.set(file, locationContext);
            await loadTypeSpecScript(file);
        }
    }
    async function loadJsFile(path, locationContext, diagnosticTarget) {
        const sourceFile = program.jsSourceFiles.get(path);
        if (sourceFile !== undefined) {
            return sourceFile;
        }
        const file = createSourceFile("", path);
        sourceFileLocationContexts.set(file, locationContext);
        const exports = await doIO(host.getJsImport, path, program.reportDiagnostic, {
            diagnosticTarget,
            jsDiagnosticTarget: { file, pos: 0, end: 0 },
        });
        if (!exports) {
            return undefined;
        }
        return {
            kind: SyntaxKind.JsSourceFile,
            id: {
                kind: SyntaxKind.Identifier,
                sv: "",
                pos: 0,
                end: 0,
                symbol: undefined,
                flags: 8 /* NodeFlags.Synthetic */,
            },
            esmExports: exports,
            file,
            namespaceSymbols: [],
            symbol: undefined,
            pos: 0,
            end: 0,
            flags: 0 /* NodeFlags.None */,
        };
    }
    /**
     * Import the Javascript files decorator and lifecycle hooks.
     */
    async function importJsFile(path, locationContext, diagnosticTarget) {
        const file = await loadJsFile(path, locationContext, diagnosticTarget);
        if (file !== undefined) {
            program.jsSourceFiles.set(path, file);
            binder.bindJsSourceFile(file);
        }
    }
    async function loadTypeSpecScript(file) {
        // This is not a diagnostic because the compiler should never reuse the same path.
        // It's the caller's responsibility to use unique paths.
        if (program.sourceFiles.has(file.path)) {
            throw new RangeError("Duplicate script path: " + file.path);
        }
        const script = parseOrReuse(file);
        program.reportDiagnostics(script.parseDiagnostics);
        program.sourceFiles.set(file.path, script);
        binder.bindSourceFile(script);
        await loadScriptImports(script);
        return script;
    }
    function parseOrReuse(file) {
        var _c, _d, _e;
        const old = (_c = oldProgram === null || oldProgram === void 0 ? void 0 : oldProgram.sourceFiles.get(file.path)) !== null && _c !== void 0 ? _c : (_d = host === null || host === void 0 ? void 0 : host.parseCache) === null || _d === void 0 ? void 0 : _d.get(file);
        if ((old === null || old === void 0 ? void 0 : old.file) === file && deepEquals(old.parseOptions, options.parseOptions)) {
            return old;
        }
        const script = parse$2(file, options.parseOptions);
        (_e = host.parseCache) === null || _e === void 0 ? void 0 : _e.set(file, script);
        return script;
    }
    async function loadScriptImports(file) {
        // collect imports
        const basedir = getDirectoryPath(file.file.path);
        await loadImports(file.statements.filter(isImportStatement).map((x) => ({ path: x.path.value, target: x })), basedir, getSourceFileLocationContext(file.file));
    }
    function getSourceFileLocationContext(sourcefile) {
        const locationContext = sourceFileLocationContexts.get(sourcefile);
        compilerAssert(locationContext, "SourceFile should have a declaration locationContext.");
        return locationContext;
    }
    async function loadImports(imports, relativeTo, locationContext) {
        // collect imports
        for (const { path, target } of imports) {
            await loadImport(path, target, relativeTo, locationContext);
        }
    }
    async function loadImport(path, target, relativeTo, locationContext) {
        const library = await resolveTypeSpecLibrary(path, relativeTo, target);
        if (library === undefined) {
            return;
        }
        if (library.type === "module") {
            loadedLibraries.set(library.manifest.name, {
                path: library.path,
                manifest: library.manifest,
            });
            trace("import-resolution.library", `Loading library "${path}" from "${library.mainFile}"`);
            const metadata = computeModuleMetadata(library);
            locationContext = {
                type: "library",
                metadata,
            };
        }
        const importFilePath = library.type === "module" ? library.mainFile : library.path;
        const isDirectory = (await host.stat(importFilePath)).isDirectory();
        if (isDirectory) {
            return await loadDirectory(importFilePath, locationContext, target);
        }
        const sourceFileKind = host.getSourceFileKind(importFilePath);
        switch (sourceFileKind) {
            case "js":
                return await importJsFile(importFilePath, locationContext, target);
            case "typespec":
                return await loadTypeSpecFile(importFilePath, locationContext, target);
            default:
                program.reportDiagnostic(createDiagnostic({ code: "invalid-import", target }));
        }
    }
    async function loadEmitters(basedir, emitterNameOrPaths, emitterOptions) {
        for (const emitterNameOrPath of emitterNameOrPaths) {
            const emitter = await loadEmitter(basedir, emitterNameOrPath, emitterOptions);
            if (emitter) {
                emitters.push(emitter);
            }
        }
    }
    async function resolveEmitterModuleAndEntrypoint(basedir, emitterNameOrPath) {
        const locationContext = { type: "project" };
        // attempt to resolve a node module with this name
        const [module, diagnostics] = await resolveJSLibrary(emitterNameOrPath, basedir);
        if (!module) {
            return [undefined, diagnostics];
        }
        const entrypoint = module.type === "file" ? module.path : module.mainFile;
        const file = await loadJsFile(entrypoint, locationContext, NoTarget);
        return [{ module, entrypoint: file }, []];
    }
    async function loadLibrary(basedir, libraryNameOrPath) {
        const [resolution, diagnostics] = await resolveEmitterModuleAndEntrypoint(basedir, libraryNameOrPath);
        if (resolution === undefined) {
            program.reportDiagnostics(diagnostics);
            return undefined;
        }
        const { module, entrypoint } = resolution;
        const libDefinition = entrypoint === null || entrypoint === void 0 ? void 0 : entrypoint.esmExports.$lib;
        const metadata = computeLibraryMetadata(module, libDefinition);
        return {
            ...resolution,
            metadata,
            definition: libDefinition,
        };
    }
    async function loadEmitter(basedir, emitterNameOrPath, emittersOptions) {
        var _c, _d, _e, _f, _g;
        const library = await loadLibrary(basedir, emitterNameOrPath);
        if (library === undefined) {
            return undefined;
        }
        const { entrypoint, metadata } = library;
        if (entrypoint === undefined) {
            program.reportDiagnostic(createDiagnostic({
                code: "invalid-emitter",
                format: { emitterPackage: emitterNameOrPath },
                target: NoTarget,
            }));
            return undefined;
        }
        const emitFunction = entrypoint.esmExports.$onEmit;
        const libDefinition = library.definition;
        let { "emitter-output-dir": emitterOutputDir, ...emitterOptions } = (_d = emittersOptions[(_c = metadata.name) !== null && _c !== void 0 ? _c : emitterNameOrPath]) !== null && _d !== void 0 ? _d : {};
        if (emitterOutputDir === undefined) {
            emitterOutputDir = [options.outputDir, metadata.name].filter(isDefined).join("/");
        }
        if (libDefinition === null || libDefinition === void 0 ? void 0 : libDefinition.requireImports) {
            for (const lib of libDefinition.requireImports) {
                requireImports.set(lib, libDefinition.name);
            }
        }
        if (emitFunction !== undefined) {
            if ((_e = libDefinition === null || libDefinition === void 0 ? void 0 : libDefinition.emitter) === null || _e === void 0 ? void 0 : _e.options) {
                const diagnostics = (_f = libDefinition === null || libDefinition === void 0 ? void 0 : libDefinition.emitterOptionValidator) === null || _f === void 0 ? void 0 : _f.validate(emitterOptions, ((_g = options.configFile) === null || _g === void 0 ? void 0 : _g.file)
                    ? {
                        kind: "path-target",
                        path: ["options", emitterNameOrPath],
                        script: options.configFile.file,
                    }
                    : NoTarget);
                if (diagnostics && diagnostics.length > 0) {
                    program.reportDiagnostics(diagnostics);
                    return;
                }
            }
            return {
                main: entrypoint.file.path,
                emitFunction,
                metadata,
                emitterOutputDir,
                options: emitterOptions,
            };
        }
        else {
            program.reportDiagnostic(createDiagnostic({
                code: "invalid-emitter",
                format: { emitterPackage: emitterNameOrPath },
                target: NoTarget,
            }));
            return undefined;
        }
    }
    function computeLibraryMetadata(module, libDefinition) {
        if (module.type === "file") {
            return {
                type: "file",
                name: libDefinition === null || libDefinition === void 0 ? void 0 : libDefinition.name,
            };
        }
        return computeModuleMetadata(module);
    }
    function computeModuleMetadata(module) {
        var _c, _d;
        const metadata = {
            type: "module",
            name: module.manifest.name,
        };
        if (module.manifest.homepage) {
            metadata.homepage = module.manifest.homepage;
        }
        if ((_c = module.manifest.bugs) === null || _c === void 0 ? void 0 : _c.url) {
            metadata.bugs = { url: (_d = module.manifest.bugs) === null || _d === void 0 ? void 0 : _d.url };
        }
        if (module.manifest.version) {
            metadata.version = module.manifest.version;
        }
        return metadata;
    }
    /**
     * @param emitter Emitter ref to run
     */
    async function runEmitter(emitter) {
        const context = {
            program,
            emitterOutputDir: emitter.emitterOutputDir,
            options: emitter.options,
            getAssetEmitter(TypeEmitterClass) {
                return createAssetEmitter(program, TypeEmitterClass, this);
            },
        };
        try {
            await emitter.emitFunction(context);
        }
        catch (error) {
            throw new ExternalError({ kind: "emitter", metadata: emitter.metadata, error });
        }
    }
    async function runValidators() {
        for (const validator of validateCbs) {
            await runValidator(validator);
        }
    }
    async function runValidator(validator) {
        try {
            await validator.callback(program);
        }
        catch (error) {
            if (options.designTimeBuild) {
                program.reportDiagnostic(createDiagnostic({
                    code: "on-validate-fail",
                    format: { error: error.stack },
                    target: NoTarget,
                }));
            }
            else {
                throw new ExternalError({ kind: "validator", metadata: validator.metadata, error });
            }
        }
    }
    /**
     * resolves a module specifier like "myLib" to an absolute path where we can find the main of
     * that module, e.g. "/typespec/node_modules/myLib/main.tsp".
     */
    async function resolveTypeSpecLibrary(specifier, baseDir, target) {
        try {
            return await resolveModule(getResolveModuleHost(), specifier, {
                baseDir,
                directoryIndexFiles: ["main.tsp", "index.mjs", "index.js"],
                resolveMain(pkg) {
                    var _c;
                    // this lets us follow node resolve semantics more-or-less exactly
                    // but using tspMain instead of main.
                    return (_c = resolveTspMain(pkg)) !== null && _c !== void 0 ? _c : pkg.main;
                },
            });
        }
        catch (e) {
            if (e.code === "MODULE_NOT_FOUND") {
                program.reportDiagnostic(createDiagnostic({ code: "import-not-found", format: { path: specifier }, target }));
                return undefined;
            }
            else if (e.code === "INVALID_MAIN") {
                program.reportDiagnostic(createDiagnostic({
                    code: "library-invalid",
                    format: { path: specifier },
                    messageId: "tspMain",
                    target,
                }));
                return undefined;
            }
            else {
                throw e;
            }
        }
    }
    /**
     * resolves a module specifier like "myLib" to an absolute path where we can find the main of
     * that module, e.g. "/typespec/node_modules/myLib/dist/lib.js".
     */
    async function resolveJSLibrary(specifier, baseDir, locationContext) {
        try {
            return [await resolveModule(getResolveModuleHost(), specifier, { baseDir }), []];
        }
        catch (e) {
            if (e.code === "MODULE_NOT_FOUND") {
                return [
                    undefined,
                    [
                        createDiagnostic({
                            code: "import-not-found",
                            format: { path: specifier },
                            target: NoTarget,
                        }),
                    ],
                ];
            }
            else if (e.code === "INVALID_MAIN") {
                return [
                    undefined,
                    [
                        createDiagnostic({
                            code: "library-invalid",
                            format: { path: specifier },
                            target: NoTarget,
                        }),
                    ],
                ];
            }
            else {
                throw e;
            }
        }
    }
    function getResolveModuleHost() {
        return {
            realpath: host.realpath,
            stat: host.stat,
            readFile: async (path) => {
                const file = await host.readFile(path);
                return file.text;
            },
        };
    }
    /**
     * Load the main file from the given path
     * @param mainPath Absolute path to the main file.
     */
    async function loadMain(mainPath) {
        await checkForCompilerVersionMismatch(mainPath);
        const sourceFileKind = host.getSourceFileKind(mainPath);
        const locationContext = { type: "project" };
        switch (sourceFileKind) {
            case "js":
                return await importJsFile(mainPath, locationContext, NoTarget);
            case "typespec":
                return await loadTypeSpecFile(mainPath, locationContext, NoTarget);
            default:
                program.reportDiagnostic(createDiagnostic({ code: "invalid-main", target: NoTarget }));
        }
    }
    // It's important that we use the compiler version that resolves locally
    // from the input TypeSpec source location. Otherwise, there will be undefined
    // runtime behavior when decorators and handlers expect a
    // different version of typespec than the current one. Abort the compilation
    // with an error if the TypeSpec entry point resolves to a different local
    // compiler.
    async function checkForCompilerVersionMismatch(mainPath) {
        const baseDir = getDirectoryPath(mainPath);
        let actual;
        try {
            const resolved = await resolveModule({
                realpath: host.realpath,
                stat: host.stat,
                readFile: async (path) => {
                    const file = await host.readFile(path);
                    return file.text;
                },
            }, "@typespec/compiler", { baseDir });
            compilerAssert(resolved.type === "module", `Expected to have resolved "@typespec/compiler" to a node module.`);
            actual = resolved;
        }
        catch (err) {
            if (err.code === "MODULE_NOT_FOUND" || err.code === "INVALID_MAIN") {
                return true; // no local typespec, ok to use any compiler
            }
            throw err;
        }
        const expected = resolvePath(await host.realpath(host.fileURLToPath(import.meta.url)), "../../../..");
        if (actual.path !== expected && MANIFEST.version !== actual.manifest.version) {
            const betterTypeSpecServerPath = actual.path;
            program.reportDiagnostic(createDiagnostic({
                code: "compiler-version-mismatch",
                format: { basedir: baseDir, betterTypeSpecServerPath, actual: actual.path, expected },
                target: NoTarget,
            }));
            return false;
        }
        return true;
    }
    function getOption(key) {
        return (options.miscOptions || {})[key];
    }
    function reportDiagnostic(diagnostic) {
        if (shouldSuppress(diagnostic)) {
            return;
        }
        if (options.warningAsError && diagnostic.severity === "warning") {
            diagnostic = { ...diagnostic, severity: "error" };
        }
        if (diagnostic.severity === "error") {
            error = true;
        }
        diagnostics.push(diagnostic);
    }
    function reportDiagnostics(newDiagnostics) {
        for (const diagnostic of newDiagnostics) {
            reportDiagnostic(diagnostic);
        }
    }
    function shouldSuppress(diagnostic) {
        const { target } = diagnostic;
        if (diagnostic.code === "error") {
            diagnostics.push(diagnostic);
            return false;
        }
        if (target === NoTarget || target === undefined) {
            return false;
        }
        if ("file" in target) {
            return false; // No global file suppress yet.
        }
        const node = getNode(target);
        if (node === undefined) {
            return false; // Can't find target cannot be suppressed.
        }
        const suppressing = findDirectiveSuppressingOnNode(diagnostic.code, node);
        if (suppressing) {
            if (diagnostic.severity === "error") {
                // Cannot suppress errors.
                diagnostics.push({
                    severity: "error",
                    code: "suppress-error",
                    message: "Errors cannot be suppressed.",
                    target: suppressing.node,
                });
                return false;
            }
            else {
                return true;
            }
        }
        return false;
    }
    function findDirectiveSuppressingOnNode(code, node) {
        let current = node;
        do {
            if (current.directives) {
                const directive = findDirectiveSuppressingCode(code, current.directives);
                if (directive) {
                    return directive;
                }
            }
        } while ((current = current.parent));
        return undefined;
    }
    /**
     * Returns the directive node that is suppressing this code.
     * @param code Code to check for suppression.
     * @param directives List of directives.
     * @returns Directive suppressing this code if found, `undefined` otherwise
     */
    function findDirectiveSuppressingCode(code, directives) {
        for (const directive of directives.map((x) => parseDirective(x))) {
            if (directive.name === "suppress") {
                if (directive.code === code) {
                    return directive;
                }
            }
        }
        return undefined;
    }
    function parseDirective(node) {
        const args = node.arguments.map((x) => {
            return x.kind === SyntaxKind.Identifier ? x.sv : x.value;
        });
        switch (node.target.sv) {
            case "suppress":
                return { name: "suppress", code: args[0], message: args[1], node };
            case "deprecated":
                return { name: "deprecated", message: args[0], node };
            default:
                throw new Error("Unexpected directive name.");
        }
    }
    function getNode(target) {
        if (!("kind" in target)) {
            // symbol
            if (target.flags & 524288 /* SymbolFlags.Using */) {
                return target.symbolSource.declarations[0];
            }
            return target.declarations[0]; // handle multiple decls
        }
        else if (typeof target.kind === "number") {
            // node
            return target;
        }
        else {
            // type
            return target.node;
        }
    }
    function reportDuplicateSymbols(symbols) {
        if (!symbols) {
            return;
        }
        for (const set of symbols.duplicates.values()) {
            for (const symbol of set) {
                if (!duplicateSymbols.has(symbol)) {
                    duplicateSymbols.add(symbol);
                    const name = symbol.flags & 524288 /* SymbolFlags.Using */ ? symbol.symbolSource.name : symbol.name;
                    reportDiagnostic(createDiagnostic({
                        code: "duplicate-symbol",
                        format: { name },
                        target: symbol,
                    }));
                }
            }
        }
    }
    function getGlobalNamespaceType() {
        return program.checker.getGlobalNamespaceType();
    }
    function resolveTypeReference(reference) {
        const [node, parseDiagnostics] = parseStandaloneTypeReference(reference);
        if (parseDiagnostics.length > 0) {
            return [undefined, parseDiagnostics];
        }
        const binder = createBinder(program);
        binder.bindNode(node);
        mutate(node).parent = program.checker.getGlobalNamespaceNode();
        return program.checker.resolveTypeReference(node);
    }
}
function createStateAccessors(stateMaps, stateSets, projector) {
    function stateMap(key) {
        let m = stateMaps.get(key);
        if (!m) {
            m = new StateMap();
            stateMaps.set(key, m);
        }
        return new StateMapView(m, projector);
    }
    function stateSet(key) {
        let s = stateSets.get(key);
        if (!s) {
            s = new StateSet();
            stateSets.set(key, s);
        }
        return new StateSetView(s, projector);
    }
    return { stateMap, stateSet };
}
/**
 * Resolve compiler options from input options.
 */
function resolveOptions(options) {
    var _c;
    // eslint-disable-next-line deprecation/deprecation
    const outputDir = (_c = options.outputDir) !== null && _c !== void 0 ? _c : options.outputPath;
    return {
        ...options,
        outputDir,
        outputPath: outputDir,
    };
}

/**
 * Convert a string template to a string value.
 * Only literal interpolated can be converted to string.
 * Otherwise diagnostics will be reported.
 *
 * @param stringTemplate String template to convert.
 */
function stringTemplateToString(stringTemplate) {
    const diagnostics = createDiagnosticCollector();
    const result = stringTemplate.spans
        .map((x) => {
        if (x.isInterpolated) {
            switch (x.type.kind) {
                case "String":
                case "Number":
                case "Boolean":
                    return String(x.type.value);
                case "StringTemplate":
                    return diagnostics.pipe(stringTemplateToString(x.type));
                default:
                    diagnostics.add(createDiagnostic({
                        code: "non-literal-string-template",
                        target: x.node,
                    }));
                    return getTypeName(x.type);
            }
        }
        else {
            return x.type.value;
        }
    })
        .join("");
    return diagnostics.wrap(result);
}
function isStringTemplateSerializable(stringTemplate) {
    const diagnostics = createDiagnosticCollector();
    for (const span of stringTemplate.spans) {
        if (span.isInterpolated) {
            switch (span.type.kind) {
                case "String":
                case "Number":
                case "Boolean":
                    break;
                case "StringTemplate":
                    diagnostics.pipe(isStringTemplateSerializable(span.type));
                    break;
                case "TemplateParameter":
                    if (span.type.constraint && span.type.constraint.kind === "Value") {
                        break; // Value types will be serializable in the template instance.
                    }
                // eslint-disable-next-line no-fallthrough
                default:
                    diagnostics.add(createDiagnostic({
                        code: "non-literal-string-template",
                        target: span.node,
                    }));
            }
        }
    }
    return [diagnostics.diagnostics.length === 0, diagnostics.diagnostics];
}

// prettier-ignore
var UsageFlags;
(function (UsageFlags) {
    UsageFlags[UsageFlags["None"] = 0] = "None";
    UsageFlags[UsageFlags["Input"] = 2] = "Input";
    UsageFlags[UsageFlags["Output"] = 4] = "Output";
})(UsageFlags || (UsageFlags = {}));
/**
 * Resolve usage(input, output or both) of various types in the given namespace.
 * Will recursively scan all namespace, interfaces and operations contained inside the namespace.
 * @param types Entrypoint(s) namespace, interface or operations to get usage from.
 * @returns Map of types to usage.
 */
function resolveUsages(types) {
    const usages = new Map();
    if (isArray(types)) {
        for (const item of types) {
            addUsagesInContainer(item, usages);
        }
    }
    else {
        addUsagesInContainer(types, usages);
    }
    return {
        types: [...usages.keys()],
        isUsedAs: (type, usage) => {
            const used = usages.get(type);
            if (used === undefined) {
                return false;
            }
            return Boolean(used & usage);
        },
    };
}
function addUsagesInContainer(type, usages) {
    switch (type.kind) {
        case "Namespace":
            addUsagesInNamespace(type, usages);
            break;
        case "Interface":
            addUsagesInInterface(type, usages);
            break;
        case "Operation":
            addUsagesInOperation(type, usages);
            break;
    }
}
function trackUsage(usages, type, usage) {
    var _a;
    const existingFlag = (_a = usages.get(type)) !== null && _a !== void 0 ? _a : UsageFlags.None;
    usages.set(type, existingFlag | usage);
}
function addUsagesInNamespace(namespace, usages) {
    for (const subNamespace of namespace.namespaces.values()) {
        addUsagesInNamespace(subNamespace, usages);
    }
    for (const Interface of namespace.interfaces.values()) {
        addUsagesInInterface(Interface, usages);
    }
    for (const operation of namespace.operations.values()) {
        addUsagesInOperation(operation, usages);
    }
}
function addUsagesInInterface(Interface, usages) {
    for (const operation of Interface.operations.values()) {
        addUsagesInOperation(operation, usages);
    }
}
function addUsagesInOperation(operation, usages) {
    navigateReferencedTypes(operation.parameters, (type) => trackUsage(usages, type, UsageFlags.Input));
    navigateReferencedTypes(operation.returnType, (type) => trackUsage(usages, type, UsageFlags.Output));
}
function navigateReferencedTypes(type, callback, visited = new Set()) {
    var _a;
    if (visited.has(type)) {
        return;
    }
    visited.add(type);
    switch (type.kind) {
        case "Model":
            callback(type);
            navigateIterable(type.properties, callback, visited);
            navigateIterable(type.derivedModels, callback, visited);
            ((_a = type.indexer) === null || _a === void 0 ? void 0 : _a.value) && navigateReferencedTypes(type.indexer.value, callback, visited);
            break;
        case "ModelProperty":
            navigateReferencedTypes(type.type, callback, visited);
            break;
        case "Union":
            callback(type);
            navigateIterable(type.variants, callback, visited);
            break;
        case "UnionVariant":
            navigateReferencedTypes(type.type, callback, visited);
            break;
        case "Enum":
        case "Tuple":
            callback(type);
            break;
    }
}
function navigateIterable(map, callback, visited = new Set()) {
    for (const type of map.values()) {
        navigateReferencedTypes(type, callback, visited);
    }
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */


var __assign = function() {
  __assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
      return t;
  };
  return __assign.apply(this, arguments);
};

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

/**
 * Source: ftp://ftp.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt
 */
/**
 * Lower case as a function.
 */
function lowerCase(str) {
    return str.toLowerCase();
}

// Support camel case ("camelCase" -> "camel Case" and "CAMELCase" -> "CAMEL Case").
var DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];
// Remove all non-word characters.
var DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;
/**
 * Normalize the string into something other libraries can manipulate easier.
 */
function noCase(input, options) {
    if (options === void 0) { options = {}; }
    var _a = options.splitRegexp, splitRegexp = _a === void 0 ? DEFAULT_SPLIT_REGEXP : _a, _b = options.stripRegexp, stripRegexp = _b === void 0 ? DEFAULT_STRIP_REGEXP : _b, _c = options.transform, transform = _c === void 0 ? lowerCase : _c, _d = options.delimiter, delimiter = _d === void 0 ? " " : _d;
    var result = replace(replace(input, splitRegexp, "$1\0$2"), stripRegexp, "\0");
    var start = 0;
    var end = result.length;
    // Trim the delimiter from around the output string.
    while (result.charAt(start) === "\0")
        start++;
    while (result.charAt(end - 1) === "\0")
        end--;
    // Transform each token independently.
    return result.slice(start, end).split("\0").map(transform).join(delimiter);
}
/**
 * Replace `re` in the input string with the replacement value.
 */
function replace(input, re, value) {
    if (re instanceof RegExp)
        return input.replace(re, value);
    return re.reduce(function (input, re) { return input.replace(re, value); }, input);
}

function pascalCaseTransform(input, index) {
    var firstChar = input.charAt(0);
    var lowerChars = input.substr(1).toLowerCase();
    if (index > 0 && firstChar >= "0" && firstChar <= "9") {
        return "_" + firstChar + lowerChars;
    }
    return "" + firstChar.toUpperCase() + lowerChars;
}
function pascalCase(input, options) {
    if (options === void 0) { options = {}; }
    return noCase(input, __assign({ delimiter: "", transform: pascalCaseTransform }, options));
}

function camelCaseTransform(input, index) {
    if (index === 0)
        return input.toLowerCase();
    return pascalCaseTransform(input, index);
}
function camelCase(input, options) {
    if (options === void 0) { options = {}; }
    return pascalCase(input, __assign({ transform: camelCaseTransform }, options));
}

function dotCase(input, options) {
    if (options === void 0) { options = {}; }
    return noCase(input, __assign({ delimiter: "." }, options));
}

function paramCase(input, options) {
    if (options === void 0) { options = {}; }
    return dotCase(input, __assign({ delimiter: "-" }, options));
}

function snakeCase(input, options) {
    if (options === void 0) { options = {}; }
    return dotCase(input, __assign({ delimiter: "_" }, options));
}

function createProjectionMembers(checker) {
    const { voidType, neverType, createType, createFunctionType, createLiteralType } = checker;
    function createBaseMembers() {
        return {
            projectionSource: (base) => { var _a; return (_a = base.projectionSource) !== null && _a !== void 0 ? _a : voidType; },
            projectionBase: (base) => { var _a; return (_a = base.projectionBase) !== null && _a !== void 0 ? _a : voidType; },
        };
    }
    function createNameableMembers() {
        return {
            name: (base) => (base.name ? createLiteralType(base.name) : voidType),
            rename: (base) => {
                return createFunctionType((newName) => {
                    assertType("new name", newName, "String");
                    base.name = newName.value;
                    return voidType;
                });
            },
        };
    }
    return {
        Model: {
            ...createBaseMembers(),
            ...createNameableMembers(),
            properties(base) {
                return createType({
                    kind: "Object",
                    properties: {
                        forEach: createFunctionType((block) => {
                            assertType("block", block, "Function");
                            const props = Array.from(base.properties.values());
                            props.forEach((p) => block.implementation(p));
                            return voidType;
                        }),
                    },
                });
            },
            renameProperty(base) {
                return createFunctionType((oldNameT, newNameT) => {
                    assertType("current property name", oldNameT, "String");
                    assertType("new property name", newNameT, "String");
                    const oldName = oldNameT.value;
                    const newName = newNameT.value;
                    const prop = base.properties.get(oldName);
                    if (!prop) {
                        throw new ProjectionError(`Property ${oldName} not found`);
                    }
                    prop.name = newName;
                    base.properties.rekey(oldName, newName);
                    return voidType;
                });
            },
            changePropertyType(base) {
                return createFunctionType((nameT, newType) => {
                    assertType("property name", nameT, "String");
                    const propertyName = nameT.value;
                    const prop = base.properties.get(propertyName);
                    if (!prop) {
                        throw new ProjectionError(`Property ${propertyName} not found`);
                    }
                    prop.type = newType;
                    return voidType;
                });
            },
            addProperty(base) {
                return createFunctionType((nameT, type, defaultT) => {
                    assertType("property", nameT, "String");
                    const name = nameT.value;
                    const prop = base.properties.get(name);
                    if (prop) {
                        throw new ProjectionError(`Property ${name} already exists`);
                    }
                    base.properties.set(name, createType({
                        kind: "ModelProperty",
                        name,
                        optional: false,
                        decorators: [],
                        node: undefined,
                        default: defaultT,
                        type,
                    }));
                    return voidType;
                });
            },
            deleteProperty(base) {
                return createFunctionType((nameT) => {
                    assertType("property", nameT, "String");
                    const name = nameT.value;
                    const prop = base.properties.get(name);
                    if (!prop) {
                        return voidType;
                    }
                    base.properties.delete(name);
                    return voidType;
                });
            },
        },
        ModelProperty: {
            ...createBaseMembers(),
            name(base) {
                return createLiteralType(base.name);
            },
            type(base) {
                return base.type;
            },
            setType(base) {
                return createFunctionType((t) => {
                    base.type = t;
                    return voidType;
                });
            },
            setOptional(base) {
                return createFunctionType((optional) => {
                    assertType("Optional", optional, "Boolean");
                    base.optional = optional.value;
                    return voidType;
                });
            },
        },
        Union: {
            ...createBaseMembers(),
            ...createNameableMembers(),
            variants(base) {
                return createType({
                    kind: "Object",
                    properties: {
                        forEach: createFunctionType((block) => {
                            assertType("block", block, "Function");
                            const variants = Array.from(base.variants.values());
                            variants.forEach((p) => block.implementation(p));
                            return voidType;
                        }),
                    },
                });
            },
            renameVariant(base) {
                return createFunctionType((oldNameT, newNameT) => {
                    assertType("old variant name", oldNameT, "String");
                    assertType("new variant name", newNameT, "String");
                    const oldName = oldNameT.value;
                    const newName = newNameT.value;
                    const variant = base.variants.get(oldName);
                    if (!variant) {
                        throw new ProjectionError(`Couldn't find variant ${variant}`);
                    }
                    base.variants.rekey(oldName, newName);
                    variant.name = newName;
                    return voidType;
                });
            },
            addVariant(base) {
                return createFunctionType((nameT, type) => {
                    assertType("Variant name", nameT, "String");
                    const name = nameT.value;
                    const variantType = createType({
                        kind: "UnionVariant",
                        decorators: [],
                        name,
                        node: undefined,
                        type,
                        union: base,
                    });
                    base.variants.set(name, variantType);
                    return voidType;
                });
            },
            deleteVariant(base) {
                return createFunctionType((nameT) => {
                    assertType("Name", nameT, "String");
                    const name = nameT.value;
                    base.variants.delete(name);
                    return voidType;
                });
            },
        },
        UnionVariant: {
            ...createBaseMembers(),
            name(base) {
                if (typeof base.name === "string") {
                    return createLiteralType(base.name);
                }
                else {
                    throw new ProjectionError("Can't refer to name of anonymous union variant");
                }
            },
            setType(base) {
                return createFunctionType((type) => {
                    base.type = type;
                    return voidType;
                });
            },
            type(base) {
                return base.type;
            },
        },
        Operation: {
            ...createBaseMembers(),
            ...createNameableMembers(),
            parameters(base) {
                return base.parameters;
            },
            returnType(base) {
                return base.returnType;
            },
            changeReturnType(base) {
                return createFunctionType((newType) => {
                    base.returnType = newType;
                    return voidType;
                });
            },
        },
        Interface: {
            ...createBaseMembers(),
            ...createNameableMembers(),
            operations(base) {
                return createType({
                    kind: "Object",
                    properties: {
                        forEach: createFunctionType((block) => {
                            assertType("block", block, "Function");
                            const props = Array.from(base.operations.values());
                            props.forEach((p) => block.implementation(p));
                            return voidType;
                        }),
                    },
                });
            },
            renameOperation(base) {
                return createFunctionType((oldNameT, newNameT) => {
                    assertType("operation name", oldNameT, "String");
                    assertType("operation name", newNameT, "String");
                    const oldName = oldNameT.value;
                    const newName = newNameT.value;
                    const op = base.operations.get(oldName);
                    if (!op) {
                        throw new ProjectionError(`Couldn't find operation named ${oldName}`);
                    }
                    op.name = newName;
                    base.operations.rekey(oldName, newName);
                    return voidType;
                });
            },
            addOperation(base) {
                return createFunctionType((nameT, parameters, returnType) => {
                    assertType("operation name", nameT, "String");
                    assertType("parameters", parameters, "Model");
                    const name = nameT.value;
                    const prop = base.operations.get(name);
                    if (prop) {
                        throw new ProjectionError(`Operation named ${name} already exists`);
                    }
                    base.operations.set(name, createType({
                        kind: "Operation",
                        name,
                        node: undefined,
                        parameters,
                        returnType,
                        decorators: [],
                    }));
                    return voidType;
                });
            },
            deleteOperation(base) {
                return createFunctionType((nameT) => {
                    assertType("operation name", nameT, "String");
                    const name = nameT.value;
                    const prop = base.operations.get(name);
                    if (!prop) {
                        return voidType;
                    }
                    base.operations.delete(name);
                    return voidType;
                });
            },
        },
        Enum: {
            ...createBaseMembers(),
            ...createNameableMembers(),
            members(base) {
                return createType({
                    kind: "Object",
                    properties: {
                        forEach: createFunctionType((block) => {
                            assertType("parameter", block, "Function");
                            const props = Array.from(base.members.values());
                            props.forEach((p) => block.implementation(p));
                            return voidType;
                        }),
                    },
                });
            },
            name(base) {
                return createLiteralType(base.name);
            },
            addMember(base) {
                return createFunctionType((nameT, type) => {
                    assertType("enum member", nameT, "String");
                    type && assertType("enum type", type, "String", "Number");
                    const name = nameT.value;
                    const member = base.members.get(name);
                    if (member) {
                        throw new ProjectionError(`Enum already has a member named ${name}`);
                    }
                    if (type !== undefined && type.kind !== "Number" && type.kind !== "String") {
                        throw new ProjectionError(`Enum member types must be string or number`);
                    }
                    base.members.set(name, createType({
                        kind: "EnumMember",
                        enum: base,
                        name,
                        decorators: [],
                        node: undefined,
                        value: type ? type.value : undefined,
                    }));
                    return voidType;
                });
            },
            deleteMember(base) {
                return createFunctionType((nameT) => {
                    assertType("enum member", nameT, "String");
                    const name = nameT.value;
                    base.members.delete(name);
                    return voidType;
                });
            },
            renameMember(base) {
                return createFunctionType((oldNameT, newNameT) => {
                    assertType("enum member", oldNameT, "String");
                    assertType("enum member", newNameT, "String");
                    const oldName = oldNameT.value;
                    const newName = newNameT.value;
                    const member = base.members.get(oldName);
                    if (!member) {
                        throw new ProjectionError(`Enum doesn't have member ${oldName}`);
                    }
                    member.name = newName;
                    base.members.rekey(oldName, newName);
                    return voidType;
                });
            },
        },
        EnumMember: {
            ...createBaseMembers(),
            name(base) {
                return createLiteralType(base.name);
            },
            type(base) {
                return base.value ? createLiteralType(base.value) : neverType;
            },
        },
        String: {
            toCamelCase(base) {
                return createFunctionType(() => {
                    return createLiteralType(camelCase(base.value));
                });
            },
            toPascalCase(base) {
                return createFunctionType(() => {
                    return createLiteralType(pascalCase(base.value));
                });
            },
            toSnakeCase(base) {
                return createFunctionType(() => {
                    return createLiteralType(snakeCase(base.value));
                });
            },
            toKebabCase(base) {
                return createFunctionType(() => {
                    return createLiteralType(paramCase(base.value));
                });
            },
        },
    };
}

var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _PendingResolutions_data;
/**
 * Maps type arguments to type instantiation.
 */
const TypeInstantiationMap = class extends MultiKeyMap {
};
let currentSymbolId = 0;
function createChecker(program) {
    const stdTypes = {};
    const symbolLinks = new Map();
    const mergedSymbols = new Map();
    const augmentDecoratorsForSym = new Map();
    const augmentedSymbolTables = new Map();
    const referenceSymCache = new WeakMap();
    let onCheckerDiagnostic = (x) => {
        program.reportDiagnostic(x);
    };
    const typePrototype = {
        get projections() {
            return (projectionsByTypeKind.get(this.kind) || []).concat(projectionsByType.get(this) || []);
        },
        projectionsByName(name) {
            return this.projections.filter((p) => p.id.sv === name);
        },
    };
    const globalNamespaceNode = createGlobalNamespaceNode();
    const globalNamespaceType = createGlobalNamespaceType();
    // Caches the deprecation test of nodes in the program
    const nodeDeprecationMap = new Map();
    const errorType = createType({ kind: "Intrinsic", name: "ErrorType" });
    const voidType = createType({ kind: "Intrinsic", name: "void" });
    const neverType = createType({ kind: "Intrinsic", name: "never" });
    const unknownType = createType({ kind: "Intrinsic", name: "unknown" });
    const nullType = createType({ kind: "Intrinsic", name: "null" });
    const nullSym = createSymbol(undefined, "null", 0 /* SymbolFlags.None */);
    const projectionsByTypeKind = new Map([
        ["Model", []],
        ["ModelProperty", []],
        ["Union", []],
        ["UnionVariant", []],
        ["Operation", []],
        ["Interface", []],
        ["Enum", []],
        ["EnumMember", []],
    ]);
    const projectionsByType = new Map();
    // whether we've checked this specific projection statement before
    // and added it to the various projection maps.
    const processedProjections = new Set();
    // interpreter state
    let currentProjectionDirection;
    /**
     * Set keeping track of node pending type resolution.
     * Key is the SymId of a node. It can be retrieved with getNodeSymId(node)
     */
    const pendingResolutions = new PendingResolutions();
    for (const file of program.jsSourceFiles.values()) {
        mergeSourceFile(file);
    }
    for (const file of program.sourceFiles.values()) {
        mergeSourceFile(file);
    }
    const typespecNamespaceBinding = globalNamespaceNode.symbol.exports.get("TypeSpec");
    if (typespecNamespaceBinding) {
        // the typespec namespace binding will be absent if we've passed
        // the no-std-lib option.
        // the first declaration here is the JS file for the typespec script.
        initializeTypeSpecIntrinsics();
        for (const file of program.sourceFiles.values()) {
            addUsingSymbols(typespecNamespaceBinding.exports, file.locals);
        }
    }
    for (const file of program.sourceFiles.values()) {
        setUsingsForFile(file);
    }
    let evalContext = undefined;
    const checker = {
        getTypeForNode,
        checkProgram,
        checkSourceFile,
        getLiteralType,
        getTypeName,
        getNamespaceString: getNamespaceFullName,
        getGlobalNamespaceType,
        getGlobalNamespaceNode,
        setUsingsForFile,
        getMergedSymbol,
        mergeSourceFile,
        cloneType,
        resolveIdentifier,
        resolveCompletions,
        evalProjection,
        project,
        neverType,
        errorType,
        anyType: unknownType,
        voidType,
        typePrototype,
        createType,
        createAndFinishType,
        createFunctionType,
        createLiteralType,
        finishType,
        isTypeAssignableTo,
        isStdType,
        getStdType,
        resolveTypeReference,
    };
    const projectionMembers = createProjectionMembers(checker);
    return checker;
    function reportCheckerDiagnostic(diagnostic) {
        onCheckerDiagnostic(diagnostic);
    }
    function reportCheckerDiagnostics(diagnostics) {
        diagnostics.forEach((x) => reportCheckerDiagnostic(x));
    }
    function initializeTypeSpecIntrinsics() {
        // a utility function to log strings or numbers
        mutate(typespecNamespaceBinding.exports).set("log", {
            flags: 131072 /* SymbolFlags.Function */,
            name: "log",
            value(p, ...strs) {
                program.trace("projection.log", strs.join(" "));
                return voidType;
            },
            declarations: [],
        });
        // Until we have an `unit` type for `null`
        mutate(typespecNamespaceBinding.exports).set("null", nullSym);
        mutate(nullSym).type = nullType;
        getSymbolLinks(nullSym).type = nullType;
    }
    function getStdType(name) {
        var _a;
        const type = stdTypes[name];
        if (type !== undefined) {
            return type;
        }
        const sym = (_a = typespecNamespaceBinding === null || typespecNamespaceBinding === void 0 ? void 0 : typespecNamespaceBinding.exports) === null || _a === void 0 ? void 0 : _a.get(name);
        if (sym && sym.flags & 2 /* SymbolFlags.Model */) {
            checkModelStatement(sym.declarations[0], undefined);
        }
        else {
            checkScalar(sym.declarations[0], undefined);
        }
        const loadedType = stdTypes[name];
        compilerAssert(loadedType, `TypeSpec std type "${name}" should have been initalized before using array syntax.`);
        return loadedType;
    }
    function mergeSourceFile(file) {
        mergeSymbolTable(file.symbol.exports, mutate(globalNamespaceNode.symbol.exports));
    }
    function setUsingsForFile(file) {
        const usedUsing = new Set();
        for (const using of file.usings) {
            const parentNs = using.parent;
            const sym = resolveTypeReferenceSym(using.name, undefined);
            if (!sym) {
                continue;
            }
            if (!(sym.flags & 4096 /* SymbolFlags.Namespace */)) {
                reportCheckerDiagnostic(createDiagnostic({ code: "using-invalid-ref", target: using }));
                continue;
            }
            const namespaceSym = getMergedSymbol(sym);
            if (usedUsing.has(namespaceSym)) {
                reportCheckerDiagnostic(createDiagnostic({
                    code: "duplicate-using",
                    format: { usingName: memberExpressionToString(using.name) },
                    target: using,
                }));
                continue;
            }
            usedUsing.add(namespaceSym);
            addUsingSymbols(sym.exports, parentNs.locals);
        }
    }
    function applyAugmentDecorators(node) {
        if (!node.statements || !isArray(node.statements)) {
            return;
        }
        const augmentDecorators = node.statements.filter((x) => x.kind === SyntaxKind.AugmentDecoratorStatement);
        for (const decNode of augmentDecorators) {
            const ref = resolveTypeReferenceSym(decNode.targetType, undefined);
            if (ref) {
                let args = [];
                if (ref.declarations[0].kind === SyntaxKind.AliasStatement) {
                    const aliasNode = ref.declarations[0];
                    if (aliasNode.value.kind === SyntaxKind.TypeReference) {
                        args = aliasNode.value.arguments;
                    }
                }
                else {
                    args = decNode.targetType.arguments;
                }
                if (ref.flags & 4096 /* SymbolFlags.Namespace */) {
                    const links = getSymbolLinks(getMergedSymbol(ref));
                    const type = links.type;
                    const decApp = checkDecorator(type, decNode, undefined);
                    if (decApp) {
                        type.decorators.push(decApp);
                        applyDecoratorToType(program, decApp, type);
                    }
                }
                else if (args.length > 0 || ref.flags & 16777216 /* SymbolFlags.LateBound */) {
                    reportCheckerDiagnostic(createDiagnostic({
                        code: "augment-decorator-target",
                        messageId: "noInstance",
                        target: decNode.target,
                    }));
                }
                else {
                    let list = augmentDecoratorsForSym.get(ref);
                    if (list === undefined) {
                        list = [];
                        augmentDecoratorsForSym.set(ref, list);
                    }
                    list.unshift(decNode);
                }
            }
        }
    }
    function addUsingSymbols(source, destination) {
        const augmented = getOrCreateAugmentedSymbolTable(destination);
        for (const symbolSource of source.values()) {
            const sym = {
                flags: 524288 /* SymbolFlags.Using */,
                declarations: [],
                name: symbolSource.name,
                symbolSource: symbolSource,
            };
            augmented.set(sym.name, sym);
        }
    }
    /**
     * We cannot inject symbols into the symbol tables hanging off syntax tree nodes as
     * syntax tree nodes can be shared by other programs. This is called as a copy-on-write
     * to inject using and late-bound symbols, and then we use the copy when resolving
     * in the table.
     */
    function getOrCreateAugmentedSymbolTable(table) {
        let augmented = augmentedSymbolTables.get(table);
        if (!augmented) {
            augmented = createSymbolTable(table);
            augmentedSymbolTables.set(table, augmented);
        }
        return mutate(augmented);
    }
    /**
     * Create the link for the given type to the symbol links.
     * If currently instantiating a template it will link to the instantiations.
     * Else will link to the declaredType.
     * @param links Symbol link
     * @param type Type
     * @param mapper Type mapper if in an template instantiation
     */
    function linkType(links, type, mapper) {
        if (mapper === undefined) {
            links.declaredType = type;
            links.instantiations = new TypeInstantiationMap();
        }
        else if (links.instantiations) {
            links.instantiations.set(mapper.args, type);
        }
    }
    function linkMemberType(links, type, mapper) {
        if (mapper === undefined) {
            links.declaredType = type;
        }
    }
    /**
     * Check a member symbol.
     * @param sym Symbol binding a member node.
     * @param mapper Type mapper.
     * @returns Checked type for the given member symbol.
     */
    function checkMemberSym(sym, mapper) {
        var _a;
        const symbolLinks = getSymbolLinks(sym);
        const memberContainer = getTypeForNode(sym.parent.declarations[0], mapper);
        const type = (_a = symbolLinks.declaredType) !== null && _a !== void 0 ? _a : symbolLinks.type;
        if (type) {
            return type;
        }
        else {
            return checkMember(sym.declarations[0], mapper, memberContainer);
        }
    }
    /**
     * Check a member node
     * @param node Member node to check
     * @param mapper Type mapper
     * @param containerType Member node container type(Interface, Model, Union, etc.)
     * @returns Checked member
     */
    function checkMember(node, mapper, containerType) {
        switch (node.kind) {
            case SyntaxKind.ModelProperty:
                return checkModelProperty(node, mapper);
            case SyntaxKind.EnumMember:
                return checkEnumMember(node, mapper, containerType);
            case SyntaxKind.OperationStatement:
                return checkOperation(node, mapper, containerType);
            case SyntaxKind.UnionVariant:
                return checkUnionVariant(node, mapper);
        }
    }
    function getTypeForNode(node, mapper) {
        switch (node.kind) {
            case SyntaxKind.ModelExpression:
                return checkModel(node, mapper);
            case SyntaxKind.ModelStatement:
                return checkModel(node, mapper);
            case SyntaxKind.ModelProperty:
                return checkModelProperty(node, mapper);
            case SyntaxKind.ScalarStatement:
                return checkScalar(node, mapper);
            case SyntaxKind.AliasStatement:
                return checkAlias(node, mapper);
            case SyntaxKind.EnumStatement:
                return checkEnum(node, mapper);
            case SyntaxKind.EnumMember:
                return checkEnumMember(node, mapper);
            case SyntaxKind.InterfaceStatement:
                return checkInterface(node, mapper);
            case SyntaxKind.UnionStatement:
                return checkUnion(node, mapper);
            case SyntaxKind.UnionVariant:
                return checkUnionVariant(node, mapper);
            case SyntaxKind.NamespaceStatement:
            case SyntaxKind.JsNamespaceDeclaration:
                return checkNamespace(node);
            case SyntaxKind.OperationStatement:
                return checkOperation(node, mapper);
            case SyntaxKind.NumericLiteral:
                return checkNumericLiteral(node);
            case SyntaxKind.BooleanLiteral:
                return checkBooleanLiteral(node);
            case SyntaxKind.TupleExpression:
                return checkTupleExpression(node, mapper);
            case SyntaxKind.StringLiteral:
                return checkStringLiteral(node);
            case SyntaxKind.StringTemplateExpression:
                return checkStringTemplateExpresion(node, mapper);
            case SyntaxKind.ArrayExpression:
                return checkArrayExpression(node, mapper);
            case SyntaxKind.UnionExpression:
                return checkUnionExpression(node, mapper);
            case SyntaxKind.IntersectionExpression:
                return checkIntersectionExpression(node, mapper);
            case SyntaxKind.DecoratorDeclarationStatement:
                return checkDecoratorDeclaration(node, mapper);
            case SyntaxKind.FunctionDeclarationStatement:
                return checkFunctionDeclaration(node, mapper);
            case SyntaxKind.TypeReference:
                return checkTypeReference(node, mapper);
            case SyntaxKind.TemplateParameterDeclaration:
                return checkTemplateParameterDeclaration(node, mapper);
            case SyntaxKind.ProjectionStatement:
                return checkProjectionDeclaration(node);
            case SyntaxKind.VoidKeyword:
                return voidType;
            case SyntaxKind.NeverKeyword:
                return neverType;
            case SyntaxKind.UnknownKeyword:
                return unknownType;
        }
        // we don't emit an error here as we blindly call this function
        // with any node type, but some nodes don't produce a type
        // (e.g. imports). errorType should result in an error if it
        // bubbles out somewhere its not supposed to be.
        return errorType;
    }
    /**
     * Return a fully qualified id of node
     */
    function getNodeSymId(node) {
        var _a;
        const symbol = node.kind === SyntaxKind.OperationStatement &&
            ((_a = node.parent) === null || _a === void 0 ? void 0 : _a.kind) === SyntaxKind.InterfaceStatement
            ? getSymbolForMember(node)
            : node.symbol;
        // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain
        return symbol === null || symbol === void 0 ? void 0 : symbol.id;
    }
    /**
     * Check if the given namespace is the standard library `TypeSpec` namespace.
     */
    function isTypeSpecNamespace(namespace) {
        var _a;
        return (namespace.name === "TypeSpec" &&
            (namespace.namespace === globalNamespaceType ||
                ((_a = namespace.namespace) === null || _a === void 0 ? void 0 : _a.projectionBase) === globalNamespaceType));
    }
    /**
     * Check if the given type is defined right in the TypeSpec namespace.
     */
    function isInTypeSpecNamespace(type) {
        return Boolean(type.namespace && isTypeSpecNamespace(type.namespace));
    }
    function checkTemplateParameterDeclaration(node, mapper) {
        var _a;
        const parentNode = node.parent;
        const grandParentNode = parentNode.parent;
        const links = getSymbolLinks(node.symbol);
        let type = links.declaredType;
        if (type === undefined) {
            if (grandParentNode) {
                if ((_a = grandParentNode.locals) === null || _a === void 0 ? void 0 : _a.has(node.id.sv)) {
                    reportCheckerDiagnostic(createDiagnostic({
                        code: "shadow",
                        format: { name: node.id.sv },
                        target: node,
                    }));
                }
            }
            const index = parentNode.templateParameters.findIndex((v) => v === node);
            type = links.declaredType = createAndFinishType({
                kind: "TemplateParameter",
                node: node,
            });
            if (node.constraint) {
                type.constraint = getTypeOrValueTypeForNode(node.constraint);
            }
            if (node.default) {
                type.default = checkTemplateParameterDefault(node.default, parentNode.templateParameters, index, type.constraint);
            }
        }
        return mapper ? mapper.getMappedType(type) : type;
    }
    function getResolvedTypeParameterDefault(declaredType, node, mapper) {
        if (declaredType.default === undefined) {
            return undefined;
        }
        if (isErrorType(declaredType.default)) {
            return declaredType.default;
        }
        return getTypeForNode(node.default, mapper);
    }
    function checkTemplateParameterDefault(nodeDefault, templateParameters, index, constraint) {
        var _a;
        function visit(node) {
            const type = getTypeForNode(node);
            let hasError = false;
            if (type.kind === "TemplateParameter") {
                for (let i = index; i < templateParameters.length; i++) {
                    if (type.node.symbol === templateParameters[i].symbol) {
                        reportCheckerDiagnostic(createDiagnostic({ code: "invalid-template-default", target: node }));
                        return undefined;
                    }
                }
                return type;
            }
            visitChildren(node, (x) => {
                const visited = visit(x);
                if (visited === undefined) {
                    hasError = true;
                }
            });
            return hasError ? undefined : type;
        }
        const type = (_a = visit(nodeDefault)) !== null && _a !== void 0 ? _a : errorType;
        if (!isErrorType(type) && constraint) {
            checkTypeAssignable(type, constraint, nodeDefault);
        }
        return type;
    }
    /**
     * Check and resolve a type for the given type reference node.
     * @param node Node.
     * @param mapper Type mapper for template instantiation context.
     * @param instantiateTemplate If templated type should be instantiated if they haven't yet.
     * @returns Resolved type.
     */
    function checkTypeReference(node, mapper, instantiateTemplate = true) {
        const sym = resolveTypeReferenceSym(node, mapper);
        if (!sym) {
            return errorType;
        }
        const type = checkTypeReferenceSymbol(sym, node, mapper, instantiateTemplate);
        return type;
    }
    function resolveTypeReference(node) {
        const oldDiagnosticHook = onCheckerDiagnostic;
        const diagnostics = [];
        onCheckerDiagnostic = (x) => diagnostics.push(x);
        const type = checkTypeReference(node, undefined, false);
        onCheckerDiagnostic = oldDiagnosticHook;
        return [type === errorType ? undefined : type, diagnostics];
    }
    function copyDeprecation(sourceType, destType) {
        const deprecationDetails = getDeprecationDetails(program, sourceType);
        if (deprecationDetails) {
            markDeprecated(program, destType, deprecationDetails);
        }
    }
    function checkDeprecated(type, node, target) {
        if (node) {
            const deprecationDetails = getDeprecationDetails(program, node);
            if (deprecationDetails) {
                reportDeprecation(program, target, deprecationDetails.message, reportCheckerDiagnostic);
                return;
            }
        }
        const deprecationDetails = getDeprecationDetails(program, type);
        if (deprecationDetails) {
            reportDeprecation(program, target, deprecationDetails.message, reportCheckerDiagnostic);
        }
    }
    function isTypeReferenceContextDeprecated(node) {
        function checkDeprecatedNode(node) {
            var _a;
            // Perform a simple check if the parent node is deprecated.  We do this
            // out of band because `checkDirectives` usually gets called on the parent
            // type after child types have already been checked (including their
            // deprecations).
            if (!nodeDeprecationMap.has(node)) {
                nodeDeprecationMap.set(node, ((_a = node.directives) !== null && _a !== void 0 ? _a : []).findIndex((d) => d.target.sv === "deprecated") >= 0);
            }
            return nodeDeprecationMap.get(node);
        }
        // Walk the parent hierarchy up to a node which might have a
        // deprecation which would mitigate the deprecation warning of the original
        // type reference. This is done to prevent multiple deprecation notices from
        // being raised when a parent context is already being deprecated.
        switch (node.kind) {
            case SyntaxKind.ModelStatement:
                return checkDeprecatedNode(node);
            case SyntaxKind.OperationStatement:
                return (checkDeprecatedNode(node) ||
                    (node.parent.kind === SyntaxKind.InterfaceStatement &&
                        isTypeReferenceContextDeprecated(node.parent)));
            case SyntaxKind.InterfaceStatement:
                return checkDeprecatedNode(node);
            case SyntaxKind.IntersectionExpression:
            case SyntaxKind.UnionExpression:
            case SyntaxKind.ModelProperty:
            case SyntaxKind.OperationSignatureDeclaration:
            case SyntaxKind.OperationSignatureReference:
                return isTypeReferenceContextDeprecated(node.parent);
            default:
                return false;
        }
    }
    function checkTypeReferenceArgs(node, mapper) {
        const args = [];
        if (node.kind !== SyntaxKind.TypeReference) {
            return args;
        }
        for (const arg of node.arguments) {
            const value = getTypeForNode(arg, mapper);
            args.push([arg, value]);
        }
        return args;
    }
    function checkTemplateInstantiationArgs(node, args, declarations) {
        var _a, _b, _c;
        if (args.length > declarations.length) {
            reportCheckerDiagnostic(createDiagnostic({
                code: "invalid-template-args",
                messageId: "tooMany",
                target: node,
            }));
            // Too many args shouldn't matter for instantiating we can still go ahead
        }
        const values = [];
        const params = [];
        let tooFew = false;
        for (let i = 0; i < declarations.length; i++) {
            const declaration = declarations[i];
            const declaredType = getTypeForNode(declaration);
            params.push(declaredType);
            if (i < args.length) {
                let [valueNode, value] = args[i];
                if (declaredType.constraint) {
                    if (!checkTypeAssignable(value, declaredType.constraint, valueNode)) {
                        // TODO-TIM check if we expose this below
                        value =
                            ((_a = declaredType.constraint) === null || _a === void 0 ? void 0 : _a.kind) === "Value" ? unknownType : declaredType.constraint;
                    }
                }
                values.push(value);
            }
            else {
                const mapper = createTypeMapper(params, values);
                const defaultValue = getResolvedTypeParameterDefault(declaredType, declaration, mapper);
                if (defaultValue) {
                    values.push(defaultValue);
                }
                else {
                    tooFew = true;
                    values.push(
                    // TODO-TIM check if we expose this below
                    ((_b = declaredType.constraint) === null || _b === void 0 ? void 0 : _b.kind) === "Value"
                        ? unknownType
                        : (_c = declaredType.constraint) !== null && _c !== void 0 ? _c : unknownType);
                }
            }
        }
        if (tooFew) {
            reportCheckerDiagnostic(createDiagnostic({
                code: "invalid-template-args",
                messageId: "tooFew",
                target: node,
            }));
        }
        return [params, values];
    }
    /**
     * Check and resolve the type for the given symbol + node.
     * @param sym Symbol
     * @param node Node
     * @param mapper Type mapper for template instantiation context.
     * @param instantiateTemplates If a templated type should be instantiated if not yet @default true
     * @returns resolved type.
     */
    function checkTypeReferenceSymbol(sym, node, mapper, instantiateTemplates = true) {
        if (sym.flags & 16384 /* SymbolFlags.Decorator */) {
            reportCheckerDiagnostic(createDiagnostic({ code: "invalid-type-ref", messageId: "decorator", target: sym }));
            return errorType;
        }
        if (sym.flags & 131072 /* SymbolFlags.Function */) {
            reportCheckerDiagnostic(createDiagnostic({ code: "invalid-type-ref", messageId: "function", target: sym }));
            return errorType;
        }
        const symbolLinks = getSymbolLinks(sym);
        let baseType;
        const args = checkTypeReferenceArgs(node, mapper);
        if (sym.flags &
            (2 /* SymbolFlags.Model */ |
                8 /* SymbolFlags.Scalar */ |
                2048 /* SymbolFlags.Alias */ |
                128 /* SymbolFlags.Interface */ |
                16 /* SymbolFlags.Operation */ |
                512 /* SymbolFlags.Union */)) {
            const decl = sym.declarations[0];
            if (!isTemplatedNode(decl)) {
                if (args.length > 0) {
                    reportCheckerDiagnostic(createDiagnostic({
                        code: "invalid-template-args",
                        messageId: "notTemplate",
                        target: node,
                    }));
                }
                if (sym.flags & 16777216 /* SymbolFlags.LateBound */) {
                    compilerAssert(sym.type, "Expected late bound symbol to have type");
                    return sym.type;
                }
                else if (symbolLinks.declaredType) {
                    baseType = symbolLinks.declaredType;
                }
                else if (sym.flags & 1348 /* SymbolFlags.Member */) {
                    baseType = checkMemberSym(sym, mapper);
                }
                else {
                    baseType = checkDeclaredType(sym, decl, mapper);
                }
            }
            else {
                const declaredType = getOrCheckDeclaredType(sym, decl, mapper);
                const templateParameters = decl.templateParameters;
                const [params, instantiationArgs] = checkTemplateInstantiationArgs(node, args, templateParameters);
                baseType = getOrInstantiateTemplate(decl, params, instantiationArgs, declaredType.templateMapper, instantiateTemplates);
            }
        }
        else {
            // some other kind of reference
            if (args.length > 0) {
                reportCheckerDiagnostic(createDiagnostic({
                    code: "invalid-template-args",
                    messageId: "notTemplate",
                    target: node,
                }));
            }
            if (sym.flags & 16777216 /* SymbolFlags.LateBound */) {
                compilerAssert(sym.type, "Expected late bound symbol to have type");
                return sym.type;
            }
            else if (sym.flags & 32768 /* SymbolFlags.TemplateParameter */) {
                baseType = checkTemplateParameterDeclaration(sym.declarations[0], mapper);
            }
            else if (symbolLinks.type) {
                // Have a cached type for non-declarations
                baseType = symbolLinks.type;
            }
            else if (symbolLinks.declaredType) {
                baseType = symbolLinks.declaredType;
            }
            else {
                if (sym.flags & 1348 /* SymbolFlags.Member */) {
                    baseType = checkMemberSym(sym, mapper);
                }
                else {
                    // don't have a cached type for this symbol, so go grab it and cache it
                    baseType = getTypeForNode(sym.declarations[0], mapper);
                    symbolLinks.type = baseType;
                }
            }
        }
        // Check for deprecations here, first on symbol, then on type.  However,
        // don't raise deprecation when the usage site is also a deprecated
        // declaration.
        const declarationNode = sym === null || sym === void 0 ? void 0 : sym.declarations[0];
        if (declarationNode && mapper === undefined) {
            if (!isTypeReferenceContextDeprecated(node.parent)) {
                checkDeprecated(baseType, declarationNode, node);
            }
        }
        return baseType;
    }
    /**
     * Get or check the declared type of a templatable node.
     * @param node Declaration node
     * @param sym Node Symbol
     * @param mapper Type mapper for template resolution
     * @returns The declared type for the given node.
     */
    function getOrCheckDeclaredType(sym, decl, mapper) {
        const symbolLinks = getSymbolLinks(sym);
        if (symbolLinks.declaredType) {
            return symbolLinks.declaredType;
        }
        if (sym.flags & 16777216 /* SymbolFlags.LateBound */) {
            compilerAssert(sym.type, "Expected late bound symbol to have type");
            return sym.type;
        }
        if (sym.flags & 1348 /* SymbolFlags.Member */) {
            return checkMemberSym(sym, mapper);
        }
        else {
            return checkDeclaredType(sym, decl, mapper);
        }
    }
    /**
     * Check the declared type of a templatable node.
     * @param node Declaration node
     * @param sym Node Symbol
     * @param mapper Type mapper for template resolution
     * @returns The declared type for the given node.
     */
    function checkDeclaredType(sym, node, mapper) {
        return sym.flags & 2 /* SymbolFlags.Model */
            ? checkModelStatement(node, mapper)
            : sym.flags & 8 /* SymbolFlags.Scalar */
                ? checkScalar(node, mapper)
                : sym.flags & 2048 /* SymbolFlags.Alias */
                    ? checkAlias(node, mapper)
                    : sym.flags & 128 /* SymbolFlags.Interface */
                        ? checkInterface(node, mapper)
                        : sym.flags & 16 /* SymbolFlags.Operation */
                            ? checkOperation(node, mapper)
                            : checkUnion(node, mapper);
    }
    function getOrInstantiateTemplate(templateNode, params, args, parentMapper, instantiateTempalates = true) {
        var _a;
        const symbolLinks = templateNode.kind === SyntaxKind.OperationStatement &&
            templateNode.parent.kind === SyntaxKind.InterfaceStatement
            ? getSymbolLinksForMember(templateNode)
            : getSymbolLinks(templateNode.symbol);
        compilerAssert(symbolLinks, `Unexpected checker error. symbolLinks was not defined for ${SyntaxKind[templateNode.kind]}`);
        if (symbolLinks.instantiations === undefined) {
            const type = getTypeForNode(templateNode);
            if (isErrorType(type)) {
                return errorType;
            }
            else {
                compilerAssert(false, `Unexpected checker error. symbolLinks.instantiations was not defined for ${SyntaxKind[templateNode.kind]}`);
            }
        }
        const mapper = createTypeMapper(params, args, parentMapper);
        const cached = (_a = symbolLinks.instantiations) === null || _a === void 0 ? void 0 : _a.get(mapper.args);
        if (cached) {
            return cached;
        }
        if (instantiateTempalates) {
            return instantiateTemplate(symbolLinks.instantiations, templateNode, params, mapper);
        }
        else {
            return errorType;
        }
    }
    /**
     * Builds a model type from a template and its template arguments.
     * Adds the template node to a set we can check when we bind template
     * parameters to access type type arguments.
     *
     * This will fall over if the same template is ever being instantiated
     * twice at the same time, or if template parameters from more than one template
     * are ever in scope at once.
     */
    function instantiateTemplate(instantiations, templateNode, params, mapper) {
        const type = getTypeForNode(templateNode, mapper);
        if (!instantiations.get(mapper.args)) {
            instantiations.set(mapper.args, type);
        }
        if (type.kind === "Model") {
            type.templateNode = templateNode;
        }
        return type;
    }
    function checkUnionExpression(node, mapper) {
        const unionType = createAndFinishType({
            kind: "Union",
            node,
            get options() {
                return Array.from(this.variants.values()).map((v) => v.type);
            },
            expression: true,
            variants: createRekeyableMap(),
            decorators: [],
        });
        for (const o of node.options) {
            const type = getTypeForNode(o, mapper);
            // The type `A | never` is just `A`
            if (type === neverType) {
                continue;
            }
            if (type.kind === "Union" && type.expression) {
                for (const [name, variant] of type.variants) {
                    unionType.variants.set(name, variant);
                }
            }
            else {
                const variant = createType({
                    kind: "UnionVariant",
                    type,
                    name: Symbol("name"),
                    decorators: [],
                    node: undefined,
                    union: unionType,
                });
                unionType.variants.set(variant.name, variant);
            }
        }
        return unionType;
    }
    function checkValueOfExpression(node, mapper) {
        const target = getTypeForNode(node.target, mapper);
        return {
            kind: "Value",
            target,
        };
    }
    /**
     * Intersection produces a model type from the properties of its operands.
     * So this doesn't work if we don't have a known set of properties (e.g.
     * with unions). The resulting model is anonymous.
     */
    function checkIntersectionExpression(node, mapper) {
        const options = node.options.map((o) => [o, getTypeForNode(o, mapper)]);
        return mergeModelTypes(node, options, mapper);
    }
    function checkDecoratorDeclaration(node, mapper) {
        const symbol = getMergedSymbol(node.symbol);
        const links = getSymbolLinks(symbol);
        if (links.declaredType && mapper === undefined) {
            // we're not instantiating this operation and we've already checked it
            return links.declaredType;
        }
        const namespace = getParentNamespaceType(node);
        compilerAssert(namespace, `Decorator ${node.id.sv} should have resolved a namespace or found the global namespace.`);
        const name = node.id.sv;
        if (!(node.modifierFlags & 2 /* ModifierFlags.Extern */)) {
            reportCheckerDiagnostic(createDiagnostic({ code: "decorator-extern", target: node }));
        }
        const implementation = symbol.value;
        if (implementation === undefined) {
            reportCheckerDiagnostic(createDiagnostic({ code: "missing-implementation", target: node }));
        }
        const decoratorType = createType({
            kind: "Decorator",
            name: `@${name}`,
            namespace,
            node,
            target: checkFunctionParameter(node.target, mapper),
            parameters: node.parameters.map((x) => checkFunctionParameter(x, mapper)),
            implementation: implementation !== null && implementation !== void 0 ? implementation : (() => { }),
        });
        namespace.decoratorDeclarations.set(name, decoratorType);
        linkType(links, decoratorType, mapper);
        return decoratorType;
    }
    function checkFunctionDeclaration(node, mapper) {
        const symbol = getMergedSymbol(node.symbol);
        const links = getSymbolLinks(symbol);
        if (links.declaredType && mapper === undefined) {
            // we're not instantiating this operation and we've already checked it
            return links.declaredType;
        }
        const namespace = getParentNamespaceType(node);
        compilerAssert(namespace, `Decorator ${node.id.sv} should have resolved a namespace or found the global namespace.`);
        const name = node.id.sv;
        if (!(node.modifierFlags & 2 /* ModifierFlags.Extern */)) {
            reportCheckerDiagnostic(createDiagnostic({ code: "function-extern", target: node }));
        }
        const implementation = symbol.value;
        if (implementation === undefined) {
            reportCheckerDiagnostic(createDiagnostic({ code: "missing-implementation", target: node }));
        }
        const functionType = createType({
            kind: "Function",
            name,
            namespace,
            node,
            parameters: node.parameters.map((x) => checkFunctionParameter(x, mapper)),
            returnType: node.returnType ? getTypeForNode(node.returnType, mapper) : unknownType,
            implementation: implementation !== null && implementation !== void 0 ? implementation : (() => { }),
        });
        namespace.functionDeclarations.set(name, functionType);
        linkType(links, functionType, mapper);
        return functionType;
    }
    function checkFunctionParameter(node, mapper) {
        const links = getSymbolLinks(node.symbol);
        if (links.declaredType) {
            return links.declaredType;
        }
        if (node.rest &&
            node.type &&
            !(node.type.kind === SyntaxKind.ArrayExpression ||
                (node.type.kind === SyntaxKind.ValueOfExpression &&
                    node.type.target.kind === SyntaxKind.ArrayExpression))) {
            reportCheckerDiagnostic(createDiagnostic({ code: "rest-parameter-array", target: node.type }));
        }
        const type = node.type ? getTypeOrValueTypeForNode(node.type) : unknownType;
        const parameterType = createType({
            kind: "FunctionParameter",
            node,
            name: node.id.sv,
            optional: node.optional,
            rest: node.rest,
            type,
            implementation: node.symbol.value,
        });
        linkType(links, parameterType, mapper);
        return parameterType;
    }
    function getTypeOrValueTypeForNode(node, mapper) {
        if (node.kind === SyntaxKind.ValueOfExpression) {
            return checkValueOfExpression(node, mapper);
        }
        return getTypeForNode(node, mapper);
    }
    function mergeModelTypes(node, options, mapper) {
        const properties = createRekeyableMap();
        const intersection = createType({
            kind: "Model",
            node,
            name: "",
            namespace: getParentNamespaceType(node),
            properties: properties,
            decorators: [],
            derivedModels: [],
        });
        const indexers = [];
        for (const [optionNode, option] of options) {
            if (option.kind === "TemplateParameter") {
                continue;
            }
            if (option.kind !== "Model") {
                reportCheckerDiagnostic(createDiagnostic({ code: "intersect-non-model", target: optionNode }));
                continue;
            }
            if (option.indexer) {
                if (option.indexer.key.name === "integer") {
                    reportCheckerDiagnostic(createDiagnostic({
                        code: "intersect-invalid-index",
                        messageId: "array",
                        target: optionNode,
                    }));
                }
                else {
                    indexers.push(option.indexer);
                }
            }
            if (indexers.length === 1) {
                intersection.indexer = indexers[0];
            }
            else if (indexers.length > 1) {
                intersection.indexer = {
                    key: indexers[0].key,
                    value: mergeModelTypes(node, indexers.map((x) => [x.value.node, x.value]), mapper),
                };
            }
            const allProps = walkPropertiesInherited(option);
            for (const prop of allProps) {
                if (properties.has(prop.name)) {
                    reportCheckerDiagnostic(createDiagnostic({
                        code: "intersect-duplicate-property",
                        format: { propName: prop.name },
                        target: node,
                    }));
                    continue;
                }
                const newPropType = cloneType(prop, {
                    sourceProperty: prop,
                    model: intersection,
                });
                properties.set(prop.name, newPropType);
            }
        }
        linkMapper(intersection, mapper);
        return finishType(intersection);
    }
    function checkArrayExpression(node, mapper) {
        const elementType = getTypeForNode(node.elementType, mapper);
        const arrayType = getStdType("Array");
        const arrayNode = arrayType.node;
        const param = getTypeForNode(arrayNode.templateParameters[0]);
        return getOrInstantiateTemplate(arrayNode, [param], [elementType], undefined);
    }
    function checkNamespace(node) {
        const links = getSymbolLinks(getMergedSymbol(node.symbol));
        let type = links.type;
        if (!type) {
            type = initializeTypeForNamespace(node);
        }
        if (node.kind === SyntaxKind.NamespaceStatement) {
            if (isArray(node.statements)) {
                node.statements.forEach((x) => getTypeForNode(x));
            }
            else if (node.statements) {
                const subNs = checkNamespace(node.statements);
                type.namespaces.set(subNs.name, subNs);
            }
        }
        return type;
    }
    function initializeTypeForNamespace(node) {
        compilerAssert(node.symbol, "Namespace is unbound.", node);
        const mergedSymbol = getMergedSymbol(node.symbol);
        const symbolLinks = getSymbolLinks(mergedSymbol);
        if (!symbolLinks.type) {
            // haven't seen this namespace before
            const namespace = getParentNamespaceType(node);
            const name = node.id.sv;
            const type = createType({
                kind: "Namespace",
                name,
                namespace,
                node: node,
                models: new Map(),
                scalars: new Map(),
                operations: new Map(),
                namespaces: new Map(),
                interfaces: new Map(),
                unions: new Map(),
                enums: new Map(),
                decoratorDeclarations: new Map(),
                functionDeclarations: new Map(),
                decorators: [],
            });
            symbolLinks.type = type;
            for (const sourceNode of mergedSymbol.declarations) {
                // namespaces created from typespec scripts don't have decorators
                if (sourceNode.kind !== SyntaxKind.NamespaceStatement)
                    continue;
                type.decorators = type.decorators.concat(checkDecorators(type, sourceNode, undefined));
            }
            finishType(type);
            namespace === null || namespace === void 0 ? void 0 : namespace.namespaces.set(name, type);
        }
        return symbolLinks.type;
    }
    function getParentNamespaceType(node) {
        if (node === globalNamespaceType.node)
            return undefined;
        if (node.kind === SyntaxKind.ModelExpression ||
            node.kind === SyntaxKind.IntersectionExpression) {
            let parent = node.parent;
            while (parent !== undefined) {
                if (parent.kind === SyntaxKind.ModelStatement ||
                    parent.kind === SyntaxKind.ScalarStatement ||
                    parent.kind === SyntaxKind.OperationStatement ||
                    parent.kind === SyntaxKind.EnumStatement ||
                    parent.kind === SyntaxKind.InterfaceStatement ||
                    parent.kind === SyntaxKind.UnionStatement ||
                    parent.kind === SyntaxKind.ModelExpression ||
                    parent.kind === SyntaxKind.IntersectionExpression) {
                    return getParentNamespaceType(parent);
                }
                else {
                    parent = parent.parent;
                }
            }
            return undefined;
        }
        if (node.kind === SyntaxKind.OperationStatement &&
            node.parent &&
            node.parent.kind === SyntaxKind.InterfaceStatement) {
            return getParentNamespaceType(node.parent);
        }
        if (!node.symbol.parent) {
            return globalNamespaceType;
        }
        if (node.symbol.parent.declarations[0].kind === SyntaxKind.TypeSpecScript ||
            node.symbol.parent.declarations[0].kind === SyntaxKind.JsSourceFile) {
            return globalNamespaceType;
        }
        const mergedSymbol = getMergedSymbol(node.symbol.parent);
        const symbolLinks = getSymbolLinks(mergedSymbol);
        if (!symbolLinks.type) {
            // in general namespaces should be typed before anything calls this function.
            // However, one case where this is not true is when a decorator on a namespace
            // refers to a model in another namespace. In this case, we need to evaluate
            // the namespace here.
            const namespaceNode = mergedSymbol.declarations.find((x) => x.kind === SyntaxKind.NamespaceStatement || x.kind === SyntaxKind.JsNamespaceDeclaration);
            compilerAssert(namespaceNode, "Can't find namespace declaration node.", node);
            symbolLinks.type = initializeTypeForNamespace(namespaceNode);
        }
        return symbolLinks.type;
    }
    function checkOperation(node, mapper, parentInterface) {
        var _a;
        const inInterface = ((_a = node.parent) === null || _a === void 0 ? void 0 : _a.kind) === SyntaxKind.InterfaceStatement;
        const symbol = inInterface ? getSymbolForMember(node) : node.symbol;
        const links = symbol && getSymbolLinks(symbol);
        if (links) {
            if (links.declaredType && mapper === undefined) {
                // we're not instantiating this operation and we've already checked it
                return links.declaredType;
            }
        }
        if (mapper === undefined && inInterface) {
            compilerAssert(parentInterface, "Operation in interface should already have been checked.");
        }
        checkTemplateDeclaration(node, mapper);
        // If we are instantating operation inside of interface
        if (isTemplatedNode(node) && mapper !== undefined && parentInterface) {
            mapper = { ...mapper, partial: true };
        }
        const namespace = getParentNamespaceType(node);
        const name = node.id.sv;
        let decorators = [];
        // Is this a definition or reference?
        let parameters, returnType, sourceOperation;
        if (node.signature.kind === SyntaxKind.OperationSignatureReference) {
            // Attempt to resolve the operation
            const baseOperation = checkOperationIs(node, node.signature.baseOperation, mapper);
            if (!baseOperation) {
                return errorType;
            }
            sourceOperation = baseOperation;
            const parameterModelSym = getOrCreateAugmentedSymbolTable(symbol.metatypeMembers).get("parameters");
            // Reference the same return type and create the parameters type
            const clone = initializeClone(baseOperation.parameters, {
                properties: createRekeyableMap(),
            });
            clone.properties = createRekeyableMap(Array.from(baseOperation.parameters.properties.entries()).map(([key, prop]) => [
                key,
                cloneTypeForSymbol(getMemberSymbol(parameterModelSym, prop.name), prop, {
                    model: clone,
                    sourceProperty: prop,
                }),
            ]));
            parameters = finishType(clone);
            returnType = baseOperation.returnType;
            // Copy decorators from the base operation, inserting the base decorators first
            decorators = [...baseOperation.decorators];
        }
        else {
            parameters = getTypeForNode(node.signature.parameters, mapper);
            returnType = getTypeForNode(node.signature.returnType, mapper);
        }
        const operationType = createType({
            kind: "Operation",
            name,
            namespace,
            node,
            parameters,
            returnType,
            decorators,
            sourceOperation,
            interface: parentInterface,
        });
        if (links) {
            linkType(links, operationType, mapper);
        }
        decorators.push(...checkDecorators(operationType, node, mapper));
        operationType.parameters.namespace = namespace;
        const parent = node.parent;
        linkMapper(operationType, mapper);
        if (parent.kind === SyntaxKind.InterfaceStatement) {
            if (shouldCreateTypeForTemplate(parent, mapper) &&
                shouldCreateTypeForTemplate(node, mapper)) {
                finishType(operationType);
            }
        }
        else {
            if (shouldCreateTypeForTemplate(node, mapper)) {
                finishType(operationType);
            }
            if (mapper === undefined) {
                namespace === null || namespace === void 0 ? void 0 : namespace.operations.set(name, operationType);
            }
        }
        return operationType;
    }
    function checkOperationIs(operation, opReference, mapper) {
        if (!opReference)
            return undefined;
        // Ensure that we don't end up with a circular reference to the same operation
        const opSymId = getNodeSymId(operation);
        if (opSymId) {
            pendingResolutions.start(opSymId, ResolutionKind.BaseType);
        }
        const target = resolveTypeReferenceSym(opReference, mapper);
        if (target === undefined) {
            return undefined;
        }
        // Did we encounter a circular operation reference?
        if (pendingResolutions.has(getNodeSymId(target.declarations[0]), ResolutionKind.BaseType)) {
            if (mapper === undefined) {
                reportCheckerDiagnostic(createDiagnostic({
                    code: "circular-op-signature",
                    format: { typeName: target.declarations[0].id.sv },
                    target: opReference,
                }));
            }
            return undefined;
        }
        // Resolve the base operation type
        const baseOperation = checkTypeReferenceSymbol(target, opReference, mapper);
        if (opSymId) {
            pendingResolutions.finish(opSymId, ResolutionKind.BaseType);
        }
        if (isErrorType(baseOperation)) {
            return undefined;
        }
        // Was the wrong type referenced?
        if (baseOperation.kind !== "Operation") {
            reportCheckerDiagnostic(createDiagnostic({ code: "is-operation", target: opReference }));
            return;
        }
        return baseOperation;
    }
    function getGlobalNamespaceType() {
        return globalNamespaceType;
    }
    function getGlobalNamespaceNode() {
        return globalNamespaceNode;
    }
    function checkTupleExpression(node, mapper) {
        return createAndFinishType({
            kind: "Tuple",
            node: node,
            values: node.values.map((v) => getTypeForNode(v, mapper)),
        });
    }
    function getSymbolLinks(s) {
        const id = getSymbolId(s);
        if (symbolLinks.has(id)) {
            return symbolLinks.get(id);
        }
        const links = {};
        symbolLinks.set(id, links);
        return links;
    }
    function getSymbolId(s) {
        if (s.id === undefined) {
            mutate(s).id = currentSymbolId++;
        }
        return s.id;
    }
    function resolveIdentifierInTable(node, table, options) {
        var _a, _b;
        if (!table) {
            return undefined;
        }
        table = (_a = augmentedSymbolTables.get(table)) !== null && _a !== void 0 ? _a : table;
        let sym;
        if (options.resolveDecorators) {
            sym = table.get("@" + node.sv);
        }
        else {
            sym = table.get(node.sv);
        }
        if (!sym)
            return sym;
        if (sym.flags & 1048576 /* SymbolFlags.DuplicateUsing */) {
            reportAmbiguousIdentifier(node, [...((_b = table.duplicates.get(sym)) !== null && _b !== void 0 ? _b : [])]);
            return sym;
        }
        return getMergedSymbol(sym);
    }
    function reportAmbiguousIdentifier(node, symbols) {
        const duplicateNames = symbols.map((s) => getFullyQualifiedSymbolName(s, { useGlobalPrefixAtTopLevel: true }));
        reportCheckerDiagnostic(createDiagnostic({
            code: "ambiguous-symbol",
            format: { name: node.sv, duplicateNames: duplicateNames.join(", ") },
            target: node,
        }));
    }
    function resolveIdentifier(id, mapper) {
        var _a, _b, _c;
        let sym;
        const { node, kind } = getIdentifierContext(id);
        switch (kind) {
            case IdentifierKind.Declaration:
                if (node.symbol && (!isTemplatedNode(node) || mapper === undefined)) {
                    sym = getMergedSymbol(node.symbol);
                    break;
                }
                compilerAssert(node.parent, "Parent expected.");
                const containerType = getTypeForNode(node.parent, mapper);
                if (isAnonymous(containerType)) {
                    return undefined; // member of anonymous type cannot be referenced.
                }
                lateBindMemberContainer(containerType);
                let container = node.parent.symbol;
                if (!container && "symbol" in containerType && containerType.symbol) {
                    container = containerType.symbol;
                }
                if (!container) {
                    return undefined;
                }
                lateBindMembers(containerType, container);
                sym = resolveIdentifierInTable(id, (_a = container.exports) !== null && _a !== void 0 ? _a : container.members, defaultSymbolResolutionOptions);
                break;
            case IdentifierKind.Other:
                return undefined;
            case IdentifierKind.Decorator:
            case IdentifierKind.Function:
            case IdentifierKind.Using:
            case IdentifierKind.TypeReference:
                let ref = id;
                let resolveDecorator = kind === IdentifierKind.Decorator;
                if (((_b = id.parent) === null || _b === void 0 ? void 0 : _b.kind) === SyntaxKind.MemberExpression) {
                    if (id.parent.id === id) {
                        // If the identifier is Y in X.Y, then resolve (X.Y).
                        ref = id.parent;
                    }
                    else {
                        // If the identifier is X in X.Y then we are resolving a
                        // namespace, which is never a decorator.
                        resolveDecorator = false;
                    }
                }
                sym = resolveTypeReferenceSym(ref, mapper, resolveDecorator);
                break;
            default:
                compilerAssert(false, "Unreachable");
        }
        return (_c = sym === null || sym === void 0 ? void 0 : sym.symbolSource) !== null && _c !== void 0 ? _c : sym;
    }
    function resolveCompletions(identifier) {
        var _a, _b;
        const completions = new Map();
        const { kind } = getIdentifierContext(identifier);
        switch (kind) {
            case IdentifierKind.Using:
            case IdentifierKind.Decorator:
            case IdentifierKind.Function:
            case IdentifierKind.TypeReference:
                break; // supported
            case IdentifierKind.Other:
                return completions; // not implemented
            case IdentifierKind.Declaration:
                return completions; // cannot complete, name can be chosen arbitrarily
            default:
                compilerAssert(false, "Unreachable");
        }
        if (identifier.parent && identifier.parent.kind === SyntaxKind.MemberExpression) {
            let base = resolveTypeReferenceSym(identifier.parent.base, undefined, false);
            if (base) {
                if (base.flags & 2048 /* SymbolFlags.Alias */) {
                    base = getAliasedSymbol(base, undefined, defaultSymbolResolutionOptions);
                }
                if (base) {
                    if (isTemplatedNode(base.declarations[0])) {
                        const type = (_a = base.type) !== null && _a !== void 0 ? _a : getTypeForNode(base.declarations[0], undefined);
                        if (isTemplateInstance(type)) {
                            lateBindMemberContainer(type);
                            lateBindMembers(type, base);
                        }
                    }
                    addCompletions((_b = base.exports) !== null && _b !== void 0 ? _b : base.members);
                }
            }
        }
        else {
            let scope = identifier.parent;
            while (scope && scope.kind !== SyntaxKind.TypeSpecScript) {
                if (scope.symbol && scope.symbol.exports) {
                    const mergedSymbol = getMergedSymbol(scope.symbol);
                    addCompletions(mergedSymbol.exports);
                }
                if ("locals" in scope) {
                    addCompletions(scope.locals);
                }
                scope = scope.parent;
            }
            if (scope && scope.kind === SyntaxKind.TypeSpecScript) {
                // check any blockless namespace decls
                for (const ns of scope.inScopeNamespaces) {
                    const mergedSymbol = getMergedSymbol(ns.symbol);
                    addCompletions(mergedSymbol.exports);
                }
                // check "global scope" declarations
                addCompletions(globalNamespaceNode.symbol.exports);
                // check "global scope" usings
                addCompletions(scope.locals);
            }
        }
        return completions;
        function addCompletions(table) {
            var _a;
            if (!table) {
                return;
            }
            table = (_a = augmentedSymbolTables.get(table)) !== null && _a !== void 0 ? _a : table;
            for (const [key, sym] of table) {
                if (sym.flags & 1048576 /* SymbolFlags.DuplicateUsing */) {
                    const duplicates = table.duplicates.get(sym);
                    for (const duplicate of duplicates) {
                        if (duplicate.flags & 524288 /* SymbolFlags.Using */) {
                            const fqn = getFullyQualifiedSymbolName(duplicate.symbolSource);
                            addCompletion(fqn, duplicate);
                        }
                    }
                }
                else {
                    addCompletion(key, sym);
                }
            }
        }
        function addCompletion(key, sym) {
            if (sym.symbolSource) {
                sym = sym.symbolSource;
            }
            if (!shouldAddCompletion(sym)) {
                return;
            }
            if (key.startsWith("@")) {
                key = key.slice(1);
            }
            if (!completions.has(key)) {
                completions.set(key, { sym });
            }
        }
        function shouldAddCompletion(sym) {
            switch (kind) {
                case IdentifierKind.Decorator:
                    // Only return decorators and namespaces when completing decorator
                    return !!(sym.flags & (16384 /* SymbolFlags.Decorator */ | 4096 /* SymbolFlags.Namespace */));
                case IdentifierKind.Using:
                    // Only return namespaces when completing using
                    return !!(sym.flags & 4096 /* SymbolFlags.Namespace */);
                case IdentifierKind.TypeReference:
                    // Do not return functions or decorators when completing types
                    return !(sym.flags & (131072 /* SymbolFlags.Function */ | 16384 /* SymbolFlags.Decorator */));
                default:
                    compilerAssert(false, "We should have bailed up-front on other kinds.");
            }
        }
    }
    function resolveIdentifierInScope(node, mapper, options) {
        var _a;
        compilerAssert(((_a = node.parent) === null || _a === void 0 ? void 0 : _a.kind) !== SyntaxKind.MemberExpression || node.parent.id !== node, "This function should not be used to resolve Y in member expression X.Y. Use resolveIdentifier() to resolve an arbitrary identifier.");
        if (hasParseError(node)) {
            // Don't report synthetic identifiers used for parser error recovery.
            // The parse error is the root cause and will already have been logged.
            return undefined;
        }
        let scope = node.parent;
        let binding;
        while (scope && scope.kind !== SyntaxKind.TypeSpecScript) {
            if (scope.symbol && "exports" in scope.symbol) {
                const mergedSymbol = getMergedSymbol(scope.symbol);
                binding = resolveIdentifierInTable(node, mergedSymbol.exports, options);
                if (binding)
                    return binding;
            }
            if ("locals" in scope) {
                binding = resolveIdentifierInTable(node, scope.locals, options);
                if (binding)
                    return binding;
            }
            scope = scope.parent;
        }
        if (!binding && scope && scope.kind === SyntaxKind.TypeSpecScript) {
            // check any blockless namespace decls
            for (const ns of scope.inScopeNamespaces) {
                const mergedSymbol = getMergedSymbol(ns.symbol);
                binding = resolveIdentifierInTable(node, mergedSymbol.exports, options);
                if (binding)
                    return binding;
            }
            // check "global scope" declarations
            const globalBinding = resolveIdentifierInTable(node, globalNamespaceNode.symbol.exports, options);
            // check using types
            const usingBinding = resolveIdentifierInTable(node, scope.locals, options);
            if (globalBinding && usingBinding) {
                reportAmbiguousIdentifier(node, [globalBinding, usingBinding]);
                return globalBinding;
            }
            else if (globalBinding) {
                return globalBinding;
            }
            else if (usingBinding) {
                return usingBinding.flags & 1048576 /* SymbolFlags.DuplicateUsing */ ? undefined : usingBinding;
            }
        }
        if (mapper === undefined) {
            reportCheckerDiagnostic(createDiagnostic({ code: "unknown-identifier", format: { id: node.sv }, target: node }));
        }
        return undefined;
    }
    function resolveTypeReferenceSym(node, mapper, options) {
        const resolvedOptions = typeof options === "boolean"
            ? { ...defaultSymbolResolutionOptions, resolveDecorators: options }
            : { ...defaultSymbolResolutionOptions, ...(options !== null && options !== void 0 ? options : {}) };
        if (mapper === undefined && resolvedOptions.checkTemplateTypes && referenceSymCache.has(node)) {
            return referenceSymCache.get(node);
        }
        const sym = resolveTypeReferenceSymInternal(node, mapper, resolvedOptions);
        if (resolvedOptions.checkTemplateTypes) {
            referenceSymCache.set(node, sym);
        }
        return sym;
    }
    function resolveTypeReferenceSymInternal(node, mapper, options) {
        if (hasParseError(node)) {
            // Don't report synthetic identifiers used for parser error recovery.
            // The parse error is the root cause and will already have been logged.
            return undefined;
        }
        if (node.kind === SyntaxKind.TypeReference) {
            return resolveTypeReferenceSym(node.target, mapper, options);
        }
        if (node.kind === SyntaxKind.MemberExpression) {
            let base = resolveTypeReferenceSym(node.base, mapper);
            if (!base) {
                return undefined;
            }
            // when resolving a type reference based on an alias, unwrap the alias.
            if (base.flags & 2048 /* SymbolFlags.Alias */) {
                base = getAliasedSymbol(base, mapper, options);
                if (!base) {
                    return undefined;
                }
            }
            if (node.selector === ".") {
                return resolveMemberInContainer(node, base, mapper, options);
            }
            else {
                return resolveMetaProperty(node, base);
            }
        }
        if (node.kind === SyntaxKind.Identifier) {
            const sym = resolveIdentifierInScope(node, mapper, options);
            if (!sym)
                return undefined;
            return sym.flags & 524288 /* SymbolFlags.Using */ ? sym.symbolSource : sym;
        }
        compilerAssert(false, `Unknown type reference kind "${SyntaxKind[node.kind]}"`, node);
    }
    function resolveMemberInContainer(node, base, mapper, options) {
        if (base.flags & 4096 /* SymbolFlags.Namespace */) {
            const symbol = resolveIdentifierInTable(node.id, base.exports, options);
            if (!symbol) {
                reportCheckerDiagnostic(createDiagnostic({
                    code: "invalid-ref",
                    messageId: "underNamespace",
                    format: {
                        namespace: getFullyQualifiedSymbolName(base),
                        id: node.id.sv,
                    },
                    target: node,
                }));
                return undefined;
            }
            return symbol;
        }
        else if (base.flags & 16384 /* SymbolFlags.Decorator */) {
            reportCheckerDiagnostic(createDiagnostic({
                code: "invalid-ref",
                messageId: "inDecorator",
                format: { id: node.id.sv },
                target: node,
            }));
            return undefined;
        }
        else if (base.flags & 131072 /* SymbolFlags.Function */) {
            reportCheckerDiagnostic(createDiagnostic({
                code: "invalid-ref",
                messageId: "node",
                format: { id: node.id.sv, nodeName: "function" },
                target: node,
            }));
            return undefined;
        }
        else if (base.flags & 674 /* SymbolFlags.MemberContainer */) {
            if (options.checkTemplateTypes && isTemplatedNode(base.declarations[0])) {
                const type = base.flags & 16777216 /* SymbolFlags.LateBound */
                    ? base.type
                    : getTypeForNode(base.declarations[0], mapper);
                if (isTemplateInstance(type)) {
                    lateBindMembers(type, base);
                }
            }
            const sym = resolveIdentifierInTable(node.id, base.members, options);
            if (!sym) {
                reportCheckerDiagnostic(createDiagnostic({
                    code: "invalid-ref",
                    messageId: "underContainer",
                    format: { kind: getMemberKindName(base.declarations[0]), id: node.id.sv },
                    target: node,
                }));
                return undefined;
            }
            return sym;
        }
        else {
            reportCheckerDiagnostic(createDiagnostic({
                code: "invalid-ref",
                messageId: "node",
                format: {
                    id: node.id.sv,
                    nodeName: base.declarations[0] ? SyntaxKind[base.declarations[0].kind] : "Unknown node",
                },
                target: node,
            }));
            return undefined;
        }
    }
    function resolveMetaProperty(node, base) {
        const resolved = resolveIdentifierInTable(node.id, base.metatypeMembers, {
            resolveDecorators: false,
            checkTemplateTypes: false,
        });
        if (!resolved) {
            reportCheckerDiagnostic(createDiagnostic({
                code: "invalid-ref",
                messageId: "metaProperty",
                format: { kind: getMemberKindName(base.declarations[0]), id: node.id.sv },
                target: node,
            }));
        }
        return resolved;
    }
    function getMemberKindName(node) {
        switch (node.kind) {
            case SyntaxKind.ModelStatement:
            case SyntaxKind.ModelExpression:
                return "Model";
            case SyntaxKind.ModelProperty:
                return "ModelProperty";
            case SyntaxKind.EnumStatement:
                return "Enum";
            case SyntaxKind.InterfaceStatement:
                return "Interface";
            case SyntaxKind.UnionStatement:
                return "Union";
            default:
                return "Type";
        }
    }
    /**
     * Return the symbol that is aliased by this alias declaration. If no such symbol is aliased,
     * return the symbol for the alias instead. For member containers which need to be late bound
     * (i.e. they contain symbols we don't know until we've instantiated the type and the type is an
     * instantiation) we late bind the container which creates the symbol that will hold its members.
     */
    function getAliasedSymbol(aliasSymbol, mapper, options) {
        var _a;
        let current = aliasSymbol;
        while (current.flags & 2048 /* SymbolFlags.Alias */) {
            const node = current.declarations[0];
            const targetNode = node.kind === SyntaxKind.AliasStatement ? node.value : node;
            const sym = resolveTypeReferenceSymInternal(targetNode, mapper, options);
            if (sym === undefined) {
                return undefined;
            }
            current = sym;
        }
        const sym = current;
        const node = aliasSymbol.declarations[0];
        const resolvedTargetNode = sym.declarations[0];
        if (!options.checkTemplateTypes || !isTemplatedNode(resolvedTargetNode)) {
            return sym;
        }
        const aliasType = getTypeForNode(node, mapper);
        if (isErrorType(aliasType)) {
            return undefined;
        }
        switch (aliasType.kind) {
            case "Model":
            case "Interface":
            case "Union":
                if (isTemplateInstance(aliasType)) {
                    // this is an alias for some instantiation, so late-bind the instantiation
                    lateBindMemberContainer(aliasType);
                    return aliasType.symbol;
                }
            // fallthrough
            default:
                // get the symbol from the node aliased type's node, or just return the base
                // if it doesn't have a symbol (which will likely result in an error later on)
                return (_a = getMergedSymbol(aliasType.node.symbol)) !== null && _a !== void 0 ? _a : aliasSymbol;
        }
    }
    function checkStringTemplateExpresion(node, mapper) {
        const spans = [createTemplateSpanLiteral(node.head)];
        for (const span of node.spans) {
            spans.push(createTemplateSpanValue(span.expression, mapper));
            spans.push(createTemplateSpanLiteral(span.literal));
        }
        const type = createType({
            kind: "StringTemplate",
            node,
            spans,
        });
        return type;
    }
    function createTemplateSpanLiteral(node) {
        return createType({
            kind: "StringTemplateSpan",
            node: node,
            isInterpolated: false,
            type: getLiteralType(node),
        });
    }
    function createTemplateSpanValue(node, mapper) {
        return createType({
            kind: "StringTemplateSpan",
            node: node,
            isInterpolated: true,
            type: getTypeForNode(node, mapper),
        });
    }
    function checkStringLiteral(str) {
        return getLiteralType(str);
    }
    function checkNumericLiteral(num) {
        return getLiteralType(num);
    }
    function checkBooleanLiteral(bool) {
        return getLiteralType(bool);
    }
    function checkProgram() {
        var _a, _b;
        program.reportDuplicateSymbols(globalNamespaceNode.symbol.exports);
        for (const file of program.sourceFiles.values()) {
            bindAllMembers(file);
        }
        for (const file of program.sourceFiles.values()) {
            bindMetaTypes(file);
        }
        for (const file of program.sourceFiles.values()) {
            for (const ns of file.namespaces) {
                const exports = (_b = (_a = mergedSymbols.get(ns.symbol)) === null || _a === void 0 ? void 0 : _a.exports) !== null && _b !== void 0 ? _b : ns.symbol.exports;
                program.reportDuplicateSymbols(exports);
                initializeTypeForNamespace(ns);
            }
        }
        for (const file of program.sourceFiles.values()) {
            applyAugmentDecoratorsInScope(file);
        }
        for (const file of program.sourceFiles.values()) {
            checkSourceFile(file);
        }
        internalDecoratorValidation();
    }
    /**
     * Post checking validation for internal decorators.
     */
    function internalDecoratorValidation() {
        validateInheritanceDiscriminatedUnions(program);
    }
    function applyAugmentDecoratorsInScope(scope) {
        applyAugmentDecorators(scope);
        if (scope.statements === undefined) {
            return;
        }
        if (isArray(scope.statements)) {
            for (const statement of scope.statements) {
                if (statement.kind === SyntaxKind.NamespaceStatement) {
                    applyAugmentDecoratorsInScope(statement);
                }
            }
        }
        else {
            applyAugmentDecoratorsInScope(scope.statements);
        }
    }
    function checkSourceFile(file) {
        for (const statement of file.statements) {
            getTypeForNode(statement, undefined);
        }
    }
    /**
     * Check that the given node template parameters are valid if applicable.
     * @param node Node with template parameters
     * @param mapper Type mapper, set if instantiating the template, undefined otherwise.
     */
    function checkTemplateDeclaration(node, mapper) {
        // If mapper is undefined it means we are checking the declaration of the template.
        if (mapper === undefined) {
            for (const templateParameter of node.templateParameters) {
                checkTemplateParameterDeclaration(templateParameter, undefined);
            }
        }
    }
    function checkModel(node, mapper) {
        if (node.kind === SyntaxKind.ModelStatement) {
            return checkModelStatement(node, mapper);
        }
        else {
            return checkModelExpression(node, mapper);
        }
    }
    function checkModelStatement(node, mapper) {
        var _a;
        const links = getSymbolLinks(node.symbol);
        if (links.declaredType && mapper === undefined) {
            // we're not instantiating this model and we've already checked it
            return links.declaredType;
        }
        checkTemplateDeclaration(node, mapper);
        const decorators = [];
        const type = createType({
            kind: "Model",
            name: node.id.sv,
            node: node,
            properties: createRekeyableMap(),
            namespace: getParentNamespaceType(node),
            decorators,
            derivedModels: [],
        });
        linkType(links, type, mapper);
        const isBase = checkModelIs(node, node.is, mapper);
        if (isBase) {
            type.sourceModel = isBase;
            // copy decorators
            decorators.push(...isBase.decorators);
            if (isBase.indexer) {
                type.indexer = isBase.indexer;
            }
        }
        decorators.push(...checkDecorators(type, node, mapper));
        if (isBase) {
            for (const prop of isBase.properties.values()) {
                const newProp = cloneType(prop, {
                    sourceProperty: prop,
                    model: type,
                });
                linkIndirectMember(node, newProp, mapper);
                type.properties.set(prop.name, newProp);
            }
        }
        if (isBase) {
            type.baseModel = isBase.baseModel;
        }
        else if (node.extends) {
            type.baseModel = checkClassHeritage(node, node.extends, mapper);
            if (type.baseModel) {
                copyDeprecation(type.baseModel, type);
            }
        }
        if (type.baseModel) {
            type.baseModel.derivedModels.push(type);
        }
        // Hold on to the model type that's being defined so that it
        // can be referenced
        if (mapper === undefined) {
            (_a = type.namespace) === null || _a === void 0 ? void 0 : _a.models.set(type.name, type);
        }
        // Evaluate the properties after
        checkModelProperties(node, type.properties, type, mapper);
        linkMapper(type, mapper);
        if (shouldCreateTypeForTemplate(node, mapper)) {
            finishType(type);
        }
        const indexer = getIndexer(program, type);
        if (type.name === "Array" && isInTypeSpecNamespace(type)) {
            stdTypes.Array = type;
        }
        else if (type.name === "Record" && isInTypeSpecNamespace(type)) {
            stdTypes.Record = type;
        }
        if (indexer) {
            type.indexer = indexer;
        }
        return type;
    }
    function shouldCreateTypeForTemplate(node, mapper) {
        // Node is not a template we should create the type.
        if (node.templateParameters.length === 0) {
            return true;
        }
        // There is no mapper so we shouldn't be instantiating the template.
        if (mapper === undefined) {
            return false;
        }
        // Some of the mapper args are still template parameter so we shouldn't create the type.
        return mapper.args.every((t) => t.kind !== "TemplateParameter");
    }
    function checkModelExpression(node, mapper) {
        const properties = createRekeyableMap();
        const type = createType({
            kind: "Model",
            name: "",
            node: node,
            properties,
            indexer: undefined,
            namespace: getParentNamespaceType(node),
            decorators: [],
            derivedModels: [],
        });
        checkModelProperties(node, properties, type, mapper);
        return finishType(type);
    }
    /** Find the indexer that applies to this model. Either defined on itself or from a base model */
    function findIndexer(model) {
        let current = model;
        while (current) {
            if (current.indexer) {
                return current.indexer;
            }
            current = current.baseModel;
        }
        return undefined;
    }
    function checkPropertyCompatibleWithIndexer(parentModel, property, diagnosticTarget) {
        const indexer = findIndexer(parentModel);
        if (indexer === undefined) {
            return;
        }
        const [valid, diagnostics] = isTypeAssignableTo(property.type, indexer.value, diagnosticTarget.kind === SyntaxKind.ModelSpreadProperty
            ? diagnosticTarget
            : diagnosticTarget.value);
        if (!valid)
            reportCheckerDiagnostics(diagnostics);
    }
    function checkModelProperties(node, properties, parentModel, mapper) {
        for (const prop of node.properties) {
            if ("id" in prop) {
                const newProp = checkModelProperty(prop, mapper);
                newProp.model = parentModel;
                checkPropertyCompatibleWithIndexer(parentModel, newProp, prop);
                defineProperty(properties, newProp);
            }
            else {
                // spread property
                const newProperties = checkSpreadProperty(node.symbol, prop.target, parentModel, mapper);
                for (const newProp of newProperties) {
                    linkIndirectMember(node, newProp, mapper);
                    checkPropertyCompatibleWithIndexer(parentModel, newProp, prop);
                    defineProperty(properties, newProp, prop);
                }
            }
        }
    }
    function defineProperty(properties, newProp, diagnosticTarget) {
        if (properties.has(newProp.name)) {
            reportCheckerDiagnostic(createDiagnostic({
                code: "duplicate-property",
                format: { propName: newProp.name },
                target: diagnosticTarget !== null && diagnosticTarget !== void 0 ? diagnosticTarget : newProp,
            }));
            return;
        }
        const overriddenProp = getOverriddenProperty(newProp);
        if (overriddenProp) {
            const [isAssignable, _] = isTypeAssignableTo(newProp.type, overriddenProp.type, newProp);
            const parentType = getTypeName(overriddenProp.type);
            const newPropType = getTypeName(newProp.type);
            if (!isAssignable) {
                reportCheckerDiagnostic(createDiagnostic({
                    code: "override-property-mismatch",
                    format: { propName: newProp.name, propType: newPropType, parentType: parentType },
                    target: diagnosticTarget !== null && diagnosticTarget !== void 0 ? diagnosticTarget : newProp,
                }));
                return;
            }
        }
        properties.set(newProp.name, newProp);
    }
    function bindAllMembers(node) {
        const bound = new Set();
        if (node.symbol) {
            bindMembers(node, node.symbol);
        }
        visitChildren(node, (child) => {
            bindAllMembers(child);
        });
        function bindMembers(node, containerSym) {
            if (bound.has(containerSym)) {
                return;
            }
            bound.add(containerSym);
            let containerMembers;
            switch (node.kind) {
                case SyntaxKind.ModelStatement:
                    if (node.extends && node.extends.kind === SyntaxKind.TypeReference) {
                        resolveAndCopyMembers(node.extends);
                    }
                    if (node.is && node.is.kind === SyntaxKind.TypeReference) {
                        resolveAndCopyMembers(node.is);
                    }
                    for (const prop of node.properties) {
                        if (prop.kind === SyntaxKind.ModelSpreadProperty) {
                            resolveAndCopyMembers(prop.target);
                        }
                        else {
                            const name = prop.id.sv;
                            bindMember(name, prop, 4 /* SymbolFlags.ModelProperty */);
                        }
                    }
                    break;
                case SyntaxKind.ModelExpression:
                    for (const prop of node.properties) {
                        if (prop.kind === SyntaxKind.ModelSpreadProperty) {
                            resolveAndCopyMembers(prop.target);
                        }
                        else {
                            const name = prop.id.sv;
                            bindMember(name, prop, 4 /* SymbolFlags.ModelProperty */);
                        }
                    }
                    break;
                case SyntaxKind.EnumStatement:
                    for (const member of node.members.values()) {
                        if (member.kind === SyntaxKind.EnumSpreadMember) {
                            resolveAndCopyMembers(member.target);
                        }
                        else {
                            const name = member.id.sv;
                            bindMember(name, member, 64 /* SymbolFlags.EnumMember */);
                        }
                    }
                    break;
                case SyntaxKind.InterfaceStatement:
                    for (const member of node.operations.values()) {
                        bindMember(member.id.sv, member, 256 /* SymbolFlags.InterfaceMember */ | 16 /* SymbolFlags.Operation */);
                    }
                    if (node.extends) {
                        for (const ext of node.extends) {
                            resolveAndCopyMembers(ext);
                        }
                    }
                    break;
                case SyntaxKind.UnionStatement:
                    for (const variant of node.options.values()) {
                        if (!variant.id) {
                            continue;
                        }
                        const name = variant.id.sv;
                        bindMember(name, variant, 1024 /* SymbolFlags.UnionVariant */);
                    }
                    break;
            }
            function resolveAndCopyMembers(node) {
                let ref = resolveTypeReferenceSym(node, undefined);
                if (ref && ref.flags & 2048 /* SymbolFlags.Alias */) {
                    ref = resolveAliasedSymbol(ref);
                }
                if (ref && ref.members) {
                    bindMembers(ref.declarations[0], ref);
                    copyMembers(ref.members);
                }
            }
            function resolveAliasedSymbol(ref) {
                const node = ref.declarations[0];
                switch (node.value.kind) {
                    case SyntaxKind.MemberExpression:
                    case SyntaxKind.TypeReference:
                    case SyntaxKind.Identifier:
                        const resolvedSym = resolveTypeReferenceSym(node.value, undefined);
                        if (resolvedSym && resolvedSym.flags & 2048 /* SymbolFlags.Alias */) {
                            return resolveAliasedSymbol(resolvedSym);
                        }
                        return resolvedSym;
                    default:
                        return undefined;
                }
            }
            function copyMembers(table) {
                var _a;
                const members = (_a = augmentedSymbolTables.get(table)) !== null && _a !== void 0 ? _a : table;
                for (const member of members.values()) {
                    bindMember(member.name, member.declarations[0], member.flags);
                }
            }
            function bindMember(name, node, kind) {
                const sym = createSymbol(node, name, kind, containerSym);
                compilerAssert(containerSym.members, "containerSym.members is undefined");
                containerMembers !== null && containerMembers !== void 0 ? containerMembers : (containerMembers = getOrCreateAugmentedSymbolTable(containerSym.members));
                containerMembers.set(name, sym);
            }
        }
    }
    function copyMembersToContainer(targetContainerSym, table) {
        var _a;
        const members = (_a = augmentedSymbolTables.get(table)) !== null && _a !== void 0 ? _a : table;
        compilerAssert(targetContainerSym.members, "containerSym.members is undefined");
        const containerMembers = getOrCreateAugmentedSymbolTable(targetContainerSym.members);
        for (const member of members.values()) {
            bindMemberToContainer(targetContainerSym, containerMembers, member.name, member.declarations[0], member.flags);
        }
    }
    function bindMemberToContainer(containerSym, containerMembers, name, node, kind) {
        const sym = createSymbol(node, name, kind, containerSym);
        compilerAssert(containerSym.members, "containerSym.members is undefined");
        containerMembers.set(name, sym);
    }
    function bindMetaTypes(node) {
        const visited = new Set();
        function visit(node, symbol) {
            var _a;
            if (visited.has(node)) {
                return;
            }
            visited.add(node);
            switch (node.kind) {
                case SyntaxKind.ModelProperty: {
                    const sym = getSymbolForMember(node);
                    if (sym) {
                        const table = getOrCreateAugmentedSymbolTable(sym.metatypeMembers);
                        table.set("type", node.value.kind === SyntaxKind.TypeReference
                            ? createSymbol(node.value, "", 2048 /* SymbolFlags.Alias */)
                            : node.value.symbol);
                    }
                    break;
                }
                case SyntaxKind.OperationStatement: {
                    const sym = (_a = symbol !== null && symbol !== void 0 ? symbol : node.symbol) !== null && _a !== void 0 ? _a : getSymbolForMember(node);
                    const table = getOrCreateAugmentedSymbolTable(sym.metatypeMembers);
                    if (node.signature.kind === SyntaxKind.OperationSignatureDeclaration) {
                        table.set("parameters", node.signature.parameters.symbol);
                        table.set("returnType", node.signature.returnType.symbol);
                    }
                    else {
                        const sig = resolveTypeReferenceSym(node.signature.baseOperation, undefined, {
                            checkTemplateTypes: false,
                        });
                        if (sig) {
                            visit(sig.declarations[0], sig);
                            const sigTable = getOrCreateAugmentedSymbolTable(sig.metatypeMembers);
                            const sigParameterSym = sigTable.get("parameters");
                            if (sigParameterSym !== undefined) {
                                const parametersSym = createSymbol(sigParameterSym.declarations[0], "parameters", 2 /* SymbolFlags.Model */ & 674 /* SymbolFlags.MemberContainer */);
                                copyMembersToContainer(parametersSym, sigParameterSym.members);
                                table.set("parameters", parametersSym);
                                table.set("returnType", sigTable.get("returnType"));
                            }
                        }
                    }
                    break;
                }
            }
            visitChildren(node, (child) => {
                bindMetaTypes(child);
            });
        }
        visit(node);
    }
    /**
     * Initializes a late bound symbol for the type. This is generally necessary when attempting to
     * access a symbol for a type that is created during the check phase.
     */
    function lateBindMemberContainer(type) {
        if (type.symbol)
            return;
        switch (type.kind) {
            case "Model":
                type.symbol = createSymbol(type.node, type.name, 2 /* SymbolFlags.Model */ | 16777216 /* SymbolFlags.LateBound */);
                mutate(type.symbol).type = type;
                break;
            case "Interface":
                type.symbol = createSymbol(type.node, type.name, 128 /* SymbolFlags.Interface */ | 16777216 /* SymbolFlags.LateBound */);
                mutate(type.symbol).type = type;
                break;
            case "Union":
                if (!type.name)
                    return; // don't make a symbol for anonymous unions
                type.symbol = createSymbol(type.node, type.name, 512 /* SymbolFlags.Union */ | 16777216 /* SymbolFlags.LateBound */);
                mutate(type.symbol).type = type;
                break;
        }
    }
    function lateBindMembers(type, containerSym) {
        let containerMembers;
        switch (type.kind) {
            case "Model":
                for (const prop of walkPropertiesInherited(type)) {
                    lateBindMember(prop, 4 /* SymbolFlags.ModelProperty */);
                }
                break;
            case "Enum":
                for (const member of type.members.values()) {
                    lateBindMember(member, 64 /* SymbolFlags.EnumMember */);
                }
                break;
            case "Interface":
                for (const member of type.operations.values()) {
                    lateBindMember(member, 256 /* SymbolFlags.InterfaceMember */ | 16 /* SymbolFlags.Operation */);
                }
                break;
            case "Union":
                for (const variant of type.variants.values()) {
                    lateBindMember(variant, 1024 /* SymbolFlags.UnionVariant */);
                }
                break;
        }
        function lateBindMember(member, kind) {
            if (!member.node || typeof member.name !== "string") {
                // don't bind anything for union expressions
                return;
            }
            const sym = createSymbol(member.node, member.name, kind | 16777216 /* SymbolFlags.LateBound */, containerSym);
            mutate(sym).type = member;
            compilerAssert(containerSym.members, "containerSym.members is undefined");
            containerMembers !== null && containerMembers !== void 0 ? containerMembers : (containerMembers = getOrCreateAugmentedSymbolTable(containerSym.members));
            containerMembers.set(member.name, sym);
        }
    }
    function checkClassHeritage(model, heritageRef, mapper) {
        if (heritageRef.kind === SyntaxKind.ModelExpression) {
            reportCheckerDiagnostic(createDiagnostic({
                code: "extend-model",
                messageId: "modelExpression",
                target: heritageRef,
            }));
            return undefined;
        }
        if (heritageRef.kind !== SyntaxKind.TypeReference) {
            reportCheckerDiagnostic(createDiagnostic({
                code: "extend-model",
                target: heritageRef,
            }));
            return undefined;
        }
        const modelSymId = getNodeSymId(model);
        pendingResolutions.start(modelSymId, ResolutionKind.BaseType);
        const target = resolveTypeReferenceSym(heritageRef, mapper);
        if (target === undefined) {
            return undefined;
        }
        if (pendingResolutions.has(getNodeSymId(target.declarations[0]), ResolutionKind.BaseType)) {
            if (mapper === undefined) {
                reportCheckerDiagnostic(createDiagnostic({
                    code: "circular-base-type",
                    format: { typeName: target.declarations[0].id.sv },
                    target: target,
                }));
            }
            return undefined;
        }
        const heritageType = checkTypeReferenceSymbol(target, heritageRef, mapper);
        pendingResolutions.finish(modelSymId, ResolutionKind.BaseType);
        if (isErrorType(heritageType)) {
            compilerAssert(program.hasError(), "Should already have reported an error.", heritageRef);
            return undefined;
        }
        if (heritageType.kind !== "Model") {
            reportCheckerDiagnostic(createDiagnostic({ code: "extend-model", target: heritageRef }));
            return undefined;
        }
        if (heritageType.name === "") {
            reportCheckerDiagnostic(createDiagnostic({
                code: "extend-model",
                messageId: "modelExpression",
                target: heritageRef,
            }));
        }
        return heritageType;
    }
    function checkModelIs(model, isExpr, mapper) {
        if (!isExpr)
            return undefined;
        const modelSymId = getNodeSymId(model);
        pendingResolutions.start(modelSymId, ResolutionKind.BaseType);
        let isType;
        if (isExpr.kind === SyntaxKind.ModelExpression) {
            reportCheckerDiagnostic(createDiagnostic({
                code: "is-model",
                messageId: "modelExpression",
                target: isExpr,
            }));
            return undefined;
        }
        else if (isExpr.kind === SyntaxKind.ArrayExpression) {
            isType = checkArrayExpression(isExpr, mapper);
        }
        else if (isExpr.kind === SyntaxKind.TypeReference) {
            const target = resolveTypeReferenceSym(isExpr, mapper);
            if (target === undefined) {
                return undefined;
            }
            if (pendingResolutions.has(getNodeSymId(target.declarations[0]), ResolutionKind.BaseType)) {
                if (mapper === undefined) {
                    reportCheckerDiagnostic(createDiagnostic({
                        code: "circular-base-type",
                        format: { typeName: target.declarations[0].id.sv },
                        target: target,
                    }));
                }
                return undefined;
            }
            isType = checkTypeReferenceSymbol(target, isExpr, mapper);
        }
        else {
            reportCheckerDiagnostic(createDiagnostic({ code: "is-model", target: isExpr }));
            return undefined;
        }
        pendingResolutions.finish(modelSymId, ResolutionKind.BaseType);
        if (isType.kind !== "Model") {
            reportCheckerDiagnostic(createDiagnostic({ code: "is-model", target: isExpr }));
            return;
        }
        if (isType.name === "") {
            reportCheckerDiagnostic(createDiagnostic({ code: "is-model", messageId: "modelExpression", target: isExpr }));
            return undefined;
        }
        return isType;
    }
    function checkSpreadProperty(parentModelSym, targetNode, parentModel, mapper) {
        const targetType = getTypeForNode(targetNode, mapper);
        if (targetType.kind === "TemplateParameter" || isErrorType(targetType)) {
            return [];
        }
        if (targetType.kind !== "Model") {
            reportCheckerDiagnostic(createDiagnostic({ code: "spread-model", target: targetNode }));
            return [];
        }
        if (parentModel === targetType) {
            reportCheckerDiagnostic(createDiagnostic({
                code: "spread-model",
                messageId: "selfSpread",
                target: targetNode,
            }));
        }
        const props = [];
        // copy each property
        for (const prop of walkPropertiesInherited(targetType)) {
            const memberSym = getMemberSymbol(parentModelSym, prop.name);
            props.push(cloneTypeForSymbol(memberSym, prop, {
                sourceProperty: prop,
                model: parentModel,
            }));
        }
        return props;
    }
    /**
     * Link an indirect model property(included via spread or model is) to its model member symbols.
     * @param containerNode Model Node
     * @param member New Property
     * @param mapper Type Mapper.
     */
    function linkIndirectMember(containerNode, member, mapper) {
        if (mapper !== undefined) {
            return;
        }
        compilerAssert(typeof member.name === "string", "Cannot link unmapped unions");
        if (containerNode.symbol === undefined) {
            return;
        }
        compilerAssert(containerNode.symbol.members, `Expected container node ${SyntaxKind[containerNode.kind]} to have members.`);
        const memberSym = getOrCreateAugmentedSymbolTable(containerNode.symbol.members).get(member.name);
        if (memberSym) {
            const links = getSymbolLinks(memberSym);
            linkMemberType(links, member, mapper);
        }
    }
    function checkModelProperty(prop, mapper) {
        var _a, _b, _c;
        const symId = getSymbolId(getSymbolForMember(prop));
        const links = getSymbolLinksForMember(prop);
        if (links && links.declaredType && mapper === undefined) {
            return links.declaredType;
        }
        const name = prop.id.sv;
        const type = createType({
            kind: "ModelProperty",
            name,
            node: prop,
            optional: prop.optional,
            type: undefined,
            decorators: [],
        });
        if (pendingResolutions.has(symId, ResolutionKind.Type) && mapper === undefined) {
            reportCheckerDiagnostic(createDiagnostic({
                code: "circular-prop",
                format: { propName: name },
                target: prop,
            }));
            type.type = errorType;
        }
        else {
            pendingResolutions.start(symId, ResolutionKind.Type);
            type.type = getTypeForNode(prop.value, mapper);
            type.default = prop.default && checkDefault(prop.default, type.type);
            if (links) {
                linkType(links, type, mapper);
            }
        }
        type.decorators = checkDecorators(type, prop, mapper);
        const parentTemplate = getParentTemplateNode(prop);
        linkMapper(type, mapper);
        if (!parentTemplate || shouldCreateTypeForTemplate(parentTemplate, mapper)) {
            if (((_b = (_a = prop.parent) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.kind) === SyntaxKind.OperationSignatureDeclaration &&
                ((_c = prop.parent.parent.parent) === null || _c === void 0 ? void 0 : _c.kind) === SyntaxKind.OperationStatement) {
                const doc = extractParamDoc(prop.parent.parent.parent, type.name);
                if (doc) {
                    type.decorators.unshift(createDocFromCommentDecorator("self", doc));
                }
            }
            finishType(type);
        }
        pendingResolutions.finish(symId, ResolutionKind.Type);
        return type;
    }
    function createDocFromCommentDecorator(key, doc) {
        return {
            decorator: $docFromComment,
            args: [
                { value: createLiteralType(key), jsValue: key },
                { value: createLiteralType(doc), jsValue: doc },
            ],
        };
    }
    function isValueType(type) {
        if (type === nullType) {
            return true;
        }
        if (type.kind === "StringTemplate") {
            const [valid] = isStringTemplateSerializable(type);
            return valid;
        }
        const valueTypes = new Set(["String", "Number", "Boolean", "EnumMember", "Tuple"]);
        return valueTypes.has(type.kind);
    }
    function checkDefault(defaultNode, type) {
        const defaultType = getTypeForNode(defaultNode, undefined);
        if (isErrorType(type)) {
            return errorType;
        }
        if (!isValueType(defaultType)) {
            reportCheckerDiagnostic(createDiagnostic({
                code: "unsupported-default",
                format: { type: defaultType.kind },
                target: defaultNode,
            }));
            return errorType;
        }
        const [related, diagnostics] = isTypeAssignableTo(defaultType, type, defaultNode);
        if (!related) {
            reportCheckerDiagnostics(diagnostics);
            return errorType;
        }
        else {
            return defaultType;
        }
    }
    function checkDecorator(targetType, decNode, mapper) {
        var _a;
        const sym = resolveTypeReferenceSym(decNode.target, undefined, true);
        if (!sym) {
            reportCheckerDiagnostic(createDiagnostic({
                code: "unknown-decorator",
                target: decNode,
            }));
            return undefined;
        }
        if (!(sym.flags & 16384 /* SymbolFlags.Decorator */)) {
            reportCheckerDiagnostic(createDiagnostic({
                code: "invalid-decorator",
                format: { id: sym.name },
                target: decNode,
            }));
            return undefined;
        }
        const symbolLinks = getSymbolLinks(sym);
        let args = checkDecoratorArguments(decNode, mapper);
        let hasError = false;
        if (symbolLinks.declaredType === undefined) {
            const decoratorDeclNode = sym.declarations.find((x) => x.kind === SyntaxKind.DecoratorDeclarationStatement);
            if (decoratorDeclNode) {
                checkDecoratorDeclaration(decoratorDeclNode, mapper);
            }
        }
        if (symbolLinks.declaredType) {
            compilerAssert(symbolLinks.declaredType.kind === "Decorator", "Expected to find a decorator type.");
            // Means we have a decorator declaration.
            [hasError, args] = checkDecoratorUsage(targetType, symbolLinks.declaredType, args, decNode);
        }
        if (hasError) {
            return undefined;
        }
        return {
            definition: symbolLinks.declaredType,
            decorator: (_a = sym.value) !== null && _a !== void 0 ? _a : ((...args) => { }),
            node: decNode,
            args,
        };
    }
    function checkDecoratorUsage(targetType, declaration, args, decoratorNode) {
        var _a;
        let hasError = false;
        const [targetValid] = isTypeAssignableTo(targetType, declaration.target.type, decoratorNode);
        if (!targetValid) {
            hasError = true;
            reportCheckerDiagnostic(createDiagnostic({
                code: "decorator-wrong-target",
                messageId: "withExpected",
                format: {
                    decorator: declaration.name,
                    to: getTypeName(targetType),
                    expected: getTypeName(declaration.target.type),
                },
                target: decoratorNode,
            }));
        }
        const minArgs = declaration.parameters.filter((x) => !x.optional && !x.rest).length;
        const maxArgs = ((_a = declaration.parameters[declaration.parameters.length - 1]) === null || _a === void 0 ? void 0 : _a.rest)
            ? undefined
            : declaration.parameters.length;
        if (args.length < minArgs || (maxArgs !== undefined && args.length > maxArgs)) {
            if (maxArgs === undefined) {
                reportCheckerDiagnostic(createDiagnostic({
                    code: "invalid-argument-count",
                    messageId: "atLeast",
                    format: { actual: args.length.toString(), expected: minArgs.toString() },
                    target: decoratorNode,
                }));
            }
            else {
                const expected = minArgs === maxArgs ? minArgs.toString() : `${minArgs}-${maxArgs}`;
                reportCheckerDiagnostic(createDiagnostic({
                    code: "invalid-argument-count",
                    format: { actual: args.length.toString(), expected },
                    target: decoratorNode,
                }));
            }
        }
        const resolvedArgs = [];
        for (const [index, parameter] of declaration.parameters.entries()) {
            if (parameter.rest) {
                const restType = getIndexType(parameter.type.kind === "Value" ? parameter.type.target : parameter.type);
                if (restType) {
                    for (let i = index; i < args.length; i++) {
                        const arg = args[i];
                        if (arg && arg.value) {
                            resolvedArgs.push({
                                ...arg,
                                jsValue: resolveDecoratorArgJsValue(arg.value, parameter.type.kind === "Value"),
                            });
                            if (!checkArgumentAssignable(arg.value, restType, arg.node)) {
                                hasError = true;
                            }
                        }
                    }
                }
                break;
            }
            const arg = args[index];
            if (arg && arg.value) {
                resolvedArgs.push({
                    ...arg,
                    jsValue: resolveDecoratorArgJsValue(arg.value, parameter.type.kind === "Value"),
                });
                if (!checkArgumentAssignable(arg.value, parameter.type, arg.node)) {
                    hasError = true;
                }
            }
        }
        return [hasError, resolvedArgs];
    }
    function getIndexType(type) {
        var _a;
        return type.kind === "Model" ? (_a = type.indexer) === null || _a === void 0 ? void 0 : _a.value : undefined;
    }
    function resolveDecoratorArgJsValue(value, valueOf) {
        if (valueOf) {
            if (value.kind === "Boolean" || value.kind === "String" || value.kind === "Number") {
                return literalTypeToValue(value);
            }
            else if (value.kind === "StringTemplate") {
                return stringTemplateToString(value)[0];
            }
        }
        return value;
    }
    function checkArgumentAssignable(argumentType, parameterType, diagnosticTarget) {
        const [valid] = isTypeAssignableTo(argumentType, parameterType, diagnosticTarget);
        if (!valid) {
            reportCheckerDiagnostic(createDiagnostic({
                code: "invalid-argument",
                format: {
                    value: getTypeName(argumentType),
                    expected: getTypeName(parameterType),
                },
                target: diagnosticTarget,
            }));
        }
        return valid;
    }
    function checkAugmentDecorators(sym, targetType, mapper) {
        var _a;
        const augmentDecoratorNodes = (_a = augmentDecoratorsForSym.get(sym)) !== null && _a !== void 0 ? _a : [];
        const decorators = [];
        for (const decNode of augmentDecoratorNodes) {
            const decorator = checkDecorator(targetType, decNode, mapper);
            if (decorator) {
                decorators.unshift(decorator);
            }
        }
        return decorators;
    }
    function checkDecorators(targetType, node, mapper) {
        var _a, _b;
        const sym = isMemberNode(node) ? (_a = getSymbolForMember(node)) !== null && _a !== void 0 ? _a : node.symbol : node.symbol;
        const decorators = [];
        const augmentDecoratorNodes = (_b = augmentDecoratorsForSym.get(sym)) !== null && _b !== void 0 ? _b : [];
        const decoratorNodes = [
            ...augmentDecoratorNodes,
            ...node.decorators,
        ];
        for (const decNode of decoratorNodes) {
            const decorator = checkDecorator(targetType, decNode, mapper);
            if (decorator) {
                decorators.unshift(decorator);
            }
        }
        // Doc comment should always be the first decorator in case an explicit @doc must override it.
        const docComment = extractMainDoc(targetType);
        if (docComment) {
            decorators.unshift(createDocFromCommentDecorator("self", docComment));
        }
        if (targetType.kind === "Operation") {
            const returnTypesDocs = extractReturnsDocs(targetType);
            if (returnTypesDocs.returns) {
                decorators.unshift(createDocFromCommentDecorator("returns", returnTypesDocs.returns));
            }
            if (returnTypesDocs.errors) {
                decorators.unshift(createDocFromCommentDecorator("errors", returnTypesDocs.errors));
            }
        }
        return decorators;
    }
    function checkDecoratorArguments(decorator, mapper) {
        return decorator.arguments.map((argNode) => {
            const type = getTypeForNode(argNode, mapper);
            return {
                value: type,
                jsValue: type,
                node: argNode,
            };
        });
    }
    function checkScalar(node, mapper) {
        var _a;
        const links = getSymbolLinks(node.symbol);
        if (links.declaredType && mapper === undefined) {
            // we're not instantiating this model and we've already checked it
            return links.declaredType;
        }
        checkTemplateDeclaration(node, mapper);
        const decorators = [];
        const type = createType({
            kind: "Scalar",
            name: node.id.sv,
            node: node,
            namespace: getParentNamespaceType(node),
            decorators,
            derivedScalars: [],
        });
        linkType(links, type, mapper);
        if (node.extends) {
            type.baseScalar = checkScalarExtends(node, node.extends, mapper);
            if (type.baseScalar) {
                copyDeprecation(type.baseScalar, type);
                type.baseScalar.derivedScalars.push(type);
            }
        }
        decorators.push(...checkDecorators(type, node, mapper));
        if (mapper === undefined) {
            (_a = type.namespace) === null || _a === void 0 ? void 0 : _a.scalars.set(type.name, type);
        }
        linkMapper(type, mapper);
        if (shouldCreateTypeForTemplate(node, mapper)) {
            finishType(type);
        }
        if (isInTypeSpecNamespace(type)) {
            stdTypes[type.name] = type;
        }
        return type;
    }
    function checkScalarExtends(scalar, extendsRef, mapper) {
        const symId = getNodeSymId(scalar);
        pendingResolutions.start(symId, ResolutionKind.BaseType);
        const target = resolveTypeReferenceSym(extendsRef, mapper);
        if (target === undefined) {
            return undefined;
        }
        if (pendingResolutions.has(getNodeSymId(target.declarations[0]), ResolutionKind.BaseType)) {
            if (mapper === undefined) {
                reportCheckerDiagnostic(createDiagnostic({
                    code: "circular-base-type",
                    format: { typeName: target.declarations[0].id.sv },
                    target: target,
                }));
            }
            return undefined;
        }
        const extendsType = checkTypeReferenceSymbol(target, extendsRef, mapper);
        pendingResolutions.finish(symId, ResolutionKind.BaseType);
        if (isErrorType(extendsType)) {
            compilerAssert(program.hasError(), "Should already have reported an error.", extendsRef);
            return undefined;
        }
        if (extendsType.kind !== "Scalar") {
            reportCheckerDiagnostic(createDiagnostic({ code: "extend-model", target: extendsRef }));
            return undefined;
        }
        return extendsType;
    }
    function checkAlias(node, mapper) {
        const links = getSymbolLinks(node.symbol);
        if (links.declaredType && mapper === undefined) {
            return links.declaredType;
        }
        checkTemplateDeclaration(node, mapper);
        const aliasSymId = getNodeSymId(node);
        if (pendingResolutions.has(aliasSymId, ResolutionKind.Type)) {
            if (mapper === undefined) {
                reportCheckerDiagnostic(createDiagnostic({
                    code: "circular-alias-type",
                    format: { typeName: node.id.sv },
                    target: node,
                }));
            }
            links.declaredType = errorType;
            return errorType;
        }
        pendingResolutions.start(aliasSymId, ResolutionKind.Type);
        const type = getTypeForNode(node.value, mapper);
        linkType(links, type, mapper);
        pendingResolutions.finish(aliasSymId, ResolutionKind.Type);
        return type;
    }
    function checkEnum(node, mapper) {
        var _a;
        const links = getSymbolLinks(node.symbol);
        if (!links.type) {
            const enumType = (links.type = createType({
                kind: "Enum",
                name: node.id.sv,
                node,
                members: createRekeyableMap(),
                decorators: [],
            }));
            const memberNames = new Set();
            for (const member of node.members) {
                if (member.kind === SyntaxKind.EnumMember) {
                    const memberType = checkEnumMember(member, mapper, enumType);
                    if (memberNames.has(memberType.name)) {
                        reportCheckerDiagnostic(createDiagnostic({
                            code: "enum-member-duplicate",
                            format: { name: memberType.name },
                            target: node,
                        }));
                        continue;
                    }
                    memberNames.add(memberType.name);
                    enumType.members.set(memberType.name, memberType);
                }
                else {
                    const members = checkEnumSpreadMember(node.symbol, enumType, member.target, mapper, memberNames);
                    for (const memberType of members) {
                        linkIndirectMember(node, memberType, mapper);
                        enumType.members.set(memberType.name, memberType);
                    }
                }
            }
            const namespace = getParentNamespaceType(node);
            enumType.namespace = namespace;
            (_a = enumType.namespace) === null || _a === void 0 ? void 0 : _a.enums.set(enumType.name, enumType);
            enumType.decorators = checkDecorators(enumType, node, mapper);
            linkMapper(enumType, mapper);
            finishType(enumType);
        }
        return links.type;
    }
    function checkInterface(node, mapper) {
        var _a;
        const links = getSymbolLinks(node.symbol);
        if (links.declaredType && mapper === undefined) {
            // we're not instantiating this interface and we've already checked it
            return links.declaredType;
        }
        checkTemplateDeclaration(node, mapper);
        const interfaceType = createType({
            kind: "Interface",
            decorators: [],
            node,
            namespace: getParentNamespaceType(node),
            sourceInterfaces: [],
            operations: createRekeyableMap(),
            name: node.id.sv,
        });
        linkType(links, interfaceType, mapper);
        interfaceType.decorators = checkDecorators(interfaceType, node, mapper);
        const ownMembers = checkInterfaceMembers(node, mapper, interfaceType);
        for (const extendsNode of node.extends) {
            const extendsType = getTypeForNode(extendsNode, mapper);
            if (extendsType.kind !== "Interface") {
                reportCheckerDiagnostic(createDiagnostic({ code: "extends-interface", target: extendsNode }));
                continue;
            }
            for (const member of extendsType.operations.values()) {
                if (interfaceType.operations.has(member.name)) {
                    reportCheckerDiagnostic(createDiagnostic({
                        code: "extends-interface-duplicate",
                        format: { name: member.name },
                        target: extendsNode,
                    }));
                }
                const newMember = cloneTypeForSymbol(getMemberSymbol(node.symbol, member.name), member, {
                    interface: interfaceType,
                });
                // Don't link it it is overritten
                if (!ownMembers.has(member.name)) {
                    linkIndirectMember(node, newMember, mapper);
                }
                // Clone deprecation information
                copyDeprecation(member, newMember);
                interfaceType.operations.set(newMember.name, newMember);
            }
            interfaceType.sourceInterfaces.push(extendsType);
        }
        for (const [key, value] of ownMembers) {
            interfaceType.operations.set(key, value);
        }
        linkMapper(interfaceType, mapper);
        if (shouldCreateTypeForTemplate(node, mapper)) {
            finishType(interfaceType);
        }
        if (mapper === undefined) {
            (_a = interfaceType.namespace) === null || _a === void 0 ? void 0 : _a.interfaces.set(interfaceType.name, interfaceType);
        }
        return interfaceType;
    }
    function checkInterfaceMembers(node, mapper, interfaceType) {
        const ownMembers = new Map();
        for (const opNode of node.operations) {
            const opType = checkOperation(opNode, mapper, interfaceType);
            if (opType.kind === "Operation") {
                if (ownMembers.has(opType.name)) {
                    reportCheckerDiagnostic(createDiagnostic({
                        code: "interface-duplicate",
                        format: { name: opType.name },
                        target: opNode,
                    }));
                    continue;
                }
                ownMembers.set(opType.name, opType);
            }
        }
        return ownMembers;
    }
    function checkUnion(node, mapper) {
        var _a;
        const links = getSymbolLinks(node.symbol);
        if (links.declaredType && mapper === undefined) {
            // we're not instantiating this union and we've already checked it
            return links.declaredType;
        }
        checkTemplateDeclaration(node, mapper);
        const variants = createRekeyableMap();
        const unionType = createType({
            kind: "Union",
            decorators: [],
            node,
            namespace: getParentNamespaceType(node),
            name: node.id.sv,
            variants,
            get options() {
                return Array.from(this.variants.values()).map((v) => v.type);
            },
            expression: false,
        });
        linkType(links, unionType, mapper);
        unionType.decorators = checkDecorators(unionType, node, mapper);
        checkUnionVariants(unionType, node, variants, mapper);
        linkMapper(unionType, mapper);
        if (shouldCreateTypeForTemplate(node, mapper)) {
            finishType(unionType);
        }
        if (mapper === undefined) {
            (_a = unionType.namespace) === null || _a === void 0 ? void 0 : _a.unions.set(unionType.name, unionType);
        }
        return unionType;
    }
    function checkUnionVariants(parentUnion, node, variants, mapper) {
        for (const variantNode of node.options) {
            const variantType = checkUnionVariant(variantNode, mapper);
            variantType.union = parentUnion;
            if (variants.has(variantType.name)) {
                reportCheckerDiagnostic(createDiagnostic({
                    code: "union-duplicate",
                    format: { name: variantType.name.toString() },
                    target: variantNode,
                }));
                continue;
            }
            variants.set(variantType.name, variantType);
        }
    }
    function checkUnionVariant(variantNode, mapper) {
        const links = getSymbolLinksForMember(variantNode);
        if (links && links.declaredType && mapper === undefined) {
            // we're not instantiating this union variant and we've already checked it
            return links.declaredType;
        }
        const name = variantNode.id ? variantNode.id.sv : Symbol("name");
        const type = getTypeForNode(variantNode.value, mapper);
        const variantType = createType({
            kind: "UnionVariant",
            name,
            node: variantNode,
            decorators: [],
            type,
            union: undefined,
        });
        variantType.decorators = checkDecorators(variantType, variantNode, mapper);
        linkMapper(variantType, mapper);
        if (shouldCreateTypeForTemplate(variantNode.parent, mapper)) {
            finishType(variantType);
        }
        if (links) {
            linkType(links, variantType, mapper);
        }
        return variantType;
    }
    function isMemberNode(node) {
        return (node.kind === SyntaxKind.ModelProperty ||
            node.kind === SyntaxKind.EnumMember ||
            node.kind === SyntaxKind.OperationStatement ||
            node.kind === SyntaxKind.UnionVariant);
    }
    function getMemberSymbol(parentSym, name) {
        return parentSym ? getOrCreateAugmentedSymbolTable(parentSym.members).get(name) : undefined;
    }
    function getSymbolForMember(node) {
        var _a;
        if (!node.id) {
            return undefined;
        }
        const name = node.id.sv;
        const parentSym = (_a = node.parent) === null || _a === void 0 ? void 0 : _a.symbol;
        return parentSym ? getOrCreateAugmentedSymbolTable(parentSym.members).get(name) : undefined;
    }
    function getSymbolLinksForMember(node) {
        const sym = getSymbolForMember(node);
        return sym ? (sym.declarations[0] === node ? getSymbolLinks(sym) : undefined) : undefined;
    }
    function checkEnumMember(node, mapper, parentEnum) {
        const name = node.id.sv;
        const links = getSymbolLinksForMember(node);
        if (links === null || links === void 0 ? void 0 : links.type) {
            return links.type;
        }
        compilerAssert(parentEnum, "Enum member should already have been checked.");
        const value = node.value ? node.value.value : undefined;
        const member = createType({
            kind: "EnumMember",
            enum: parentEnum,
            name,
            node,
            value,
            decorators: [],
        });
        if (links) {
            links.type = member;
        }
        member.decorators = checkDecorators(member, node, mapper);
        return finishType(member);
    }
    function checkEnumSpreadMember(parentEnumSym, parentEnum, targetNode, mapper, existingMemberNames) {
        const members = [];
        const targetType = getTypeForNode(targetNode, mapper);
        if (!isErrorType(targetType)) {
            if (targetType.kind !== "Enum") {
                reportCheckerDiagnostic(createDiagnostic({ code: "spread-enum", target: targetNode }));
                return members;
            }
            for (const member of targetType.members.values()) {
                if (existingMemberNames.has(member.name)) {
                    reportCheckerDiagnostic(createDiagnostic({
                        code: "enum-member-duplicate",
                        format: { name: member.name },
                        target: targetNode,
                    }));
                }
                else {
                    existingMemberNames.add(member.name);
                    const memberSym = getMemberSymbol(parentEnumSym, member.name);
                    const clonedMember = cloneTypeForSymbol(memberSym, member, {
                        enum: parentEnum,
                        sourceMember: member,
                    });
                    if (clonedMember) {
                        members.push(clonedMember);
                    }
                }
            }
        }
        return members;
    }
    function checkDirectives(node, type) {
        var _a;
        let hasDeprecation = false;
        for (const directive of (_a = node.directives) !== null && _a !== void 0 ? _a : []) {
            if (directive.target.sv === "deprecated") {
                const message = directive.arguments[0];
                if (message === undefined) {
                    reportCheckerDiagnostic(createDiagnostic({
                        code: "invalid-deprecation-argument",
                        messageId: "missing",
                        target: directive,
                    }));
                    continue;
                }
                let messageStr;
                if (message.kind !== SyntaxKind.StringLiteral) {
                    reportCheckerDiagnostic(createDiagnostic({
                        code: "invalid-deprecation-argument",
                        format: { kind: SyntaxKind[message.kind] },
                        target: directive.arguments[0],
                    }));
                    messageStr = "<missing message>";
                }
                else {
                    messageStr = message.value;
                }
                if (hasDeprecation === true) {
                    reportCheckerDiagnostic(createDiagnostic({ code: "duplicate-deprecation", target: node }));
                }
                else {
                    hasDeprecation = true;
                    markDeprecated(program, type, {
                        message: messageStr,
                    });
                }
            }
        }
    }
    // the types here aren't ideal and could probably be refactored.
    function createAndFinishType(typeDef) {
        createType(typeDef);
        return finishType(typeDef);
    }
    /**
     * Given the own-properties of a type, returns a fully-initialized type.
     * So far, that amounts to setting the prototype to typePrototype which
     * contains the `projections` getter.
     */
    function createType(typeDef) {
        Object.setPrototypeOf(typeDef, typePrototype);
        typeDef.isFinished = false;
        // If the type has an associated syntax node, check any directives that
        // might be attached.
        const createdType = typeDef;
        if (createdType.node) {
            checkDirectives(createdType.node, createdType);
        }
        return createdType;
    }
    function finishType(typeDef) {
        return finishTypeForProgramAndChecker(program, typePrototype, typeDef);
    }
    function getLiteralType(node) {
        return createLiteralType(node.value, node);
    }
    function mergeSymbolTable(source, target) {
        for (const [sym, duplicates] of source.duplicates) {
            const targetSet = target.duplicates.get(sym);
            if (targetSet === undefined) {
                mutate(target.duplicates).set(sym, new Set([...duplicates]));
            }
            else {
                for (const duplicate of duplicates) {
                    mutate(targetSet).add(duplicate);
                }
            }
        }
        for (const [key, sourceBinding] of source) {
            if (sourceBinding.flags & 4096 /* SymbolFlags.Namespace */) {
                let targetBinding = target.get(key);
                if (!targetBinding) {
                    targetBinding = {
                        ...sourceBinding,
                        declarations: [],
                        exports: createSymbolTable(),
                    };
                    target.set(key, targetBinding);
                }
                if (targetBinding.flags & 4096 /* SymbolFlags.Namespace */) {
                    mergedSymbols.set(sourceBinding, targetBinding);
                    mutate(targetBinding.declarations).push(...sourceBinding.declarations);
                    mergeSymbolTable(sourceBinding.exports, mutate(targetBinding.exports));
                }
                else {
                    // this will set a duplicate error
                    target.set(key, sourceBinding);
                }
            }
            else if (sourceBinding.flags & 4194304 /* SymbolFlags.Declaration */ ||
                sourceBinding.flags & 8388608 /* SymbolFlags.Implementation */) {
                if (sourceBinding.flags & 16384 /* SymbolFlags.Decorator */) {
                    mergeDeclarationOrImplementation(key, sourceBinding, target, 16384 /* SymbolFlags.Decorator */);
                }
                else if (sourceBinding.flags & 131072 /* SymbolFlags.Function */) {
                    mergeDeclarationOrImplementation(key, sourceBinding, target, 131072 /* SymbolFlags.Function */);
                }
                else {
                    target.set(key, sourceBinding);
                }
            }
            else {
                target.set(key, sourceBinding);
            }
        }
    }
    function mergeDeclarationOrImplementation(key, sourceBinding, target, expectTargetFlags) {
        const targetBinding = target.get(key);
        if (!targetBinding || !(targetBinding.flags & expectTargetFlags)) {
            target.set(key, sourceBinding);
            return;
        }
        const isSourceDeclaration = sourceBinding.flags & 4194304 /* SymbolFlags.Declaration */;
        const isSourceImplementation = sourceBinding.flags & 8388608 /* SymbolFlags.Implementation */;
        const isTargetDeclaration = targetBinding.flags & 4194304 /* SymbolFlags.Declaration */;
        const isTargetImplementation = targetBinding.flags & 8388608 /* SymbolFlags.Implementation */;
        if (isTargetDeclaration && isTargetImplementation) {
            // If the target already has both a declration and implementation set the symbol which will mark it as duplicate
            target.set(key, sourceBinding);
        }
        else if (isTargetDeclaration && isSourceImplementation) {
            mergedSymbols.set(sourceBinding, targetBinding);
            mutate(targetBinding).value = sourceBinding.value;
            mutate(targetBinding).flags |= sourceBinding.flags;
            mutate(targetBinding.declarations).push(...sourceBinding.declarations);
        }
        else if (isTargetImplementation && isSourceDeclaration) {
            mergedSymbols.set(sourceBinding, targetBinding);
            mutate(targetBinding).flags |= sourceBinding.flags;
            mutate(targetBinding.declarations).unshift(...sourceBinding.declarations);
        }
        else {
            // this will set a duplicate error
            target.set(key, sourceBinding);
        }
    }
    function getMergedSymbol(sym) {
        if (!sym)
            return sym;
        return mergedSymbols.get(sym) || sym;
    }
    function createGlobalNamespaceNode() {
        const nsId = {
            kind: SyntaxKind.Identifier,
            pos: 0,
            end: 0,
            sv: "global",
            symbol: undefined,
            flags: 8 /* NodeFlags.Synthetic */,
        };
        const nsNode = {
            kind: SyntaxKind.NamespaceStatement,
            decorators: [],
            pos: 0,
            end: 0,
            id: nsId,
            symbol: undefined,
            locals: createSymbolTable(),
            flags: 8 /* NodeFlags.Synthetic */,
        };
        mutate(nsNode).symbol = createSymbol(nsNode, nsId.sv, 4096 /* SymbolFlags.Namespace */);
        mutate(nsNode.symbol.exports).set(nsId.sv, nsNode.symbol);
        return nsNode;
    }
    function createGlobalNamespaceType() {
        const type = createAndFinishType({
            kind: "Namespace",
            name: "",
            node: globalNamespaceNode,
            models: new Map(),
            scalars: new Map(),
            operations: new Map(),
            namespaces: new Map(),
            interfaces: new Map(),
            unions: new Map(),
            enums: new Map(),
            decoratorDeclarations: new Map(),
            functionDeclarations: new Map(),
            decorators: [],
        });
        getSymbolLinks(globalNamespaceNode.symbol).type = type;
        return type;
    }
    function initializeClone(type, additionalProps) {
        let clone;
        switch (type.kind) {
            case "Model":
                const newModel = createType({
                    ...type,
                    decorators: [...type.decorators],
                    properties: undefined,
                    ...additionalProps,
                });
                if (!("properties" in additionalProps)) {
                    newModel.properties = createRekeyableMap(Array.from(type.properties.entries()).map(([key, prop]) => [
                        key,
                        cloneType(prop, { model: newModel }),
                    ]));
                }
                clone = newModel;
                break;
            case "Union":
                const newUnion = createType({
                    ...type,
                    decorators: [...type.decorators],
                    variants: undefined,
                    get options() {
                        return Array.from(this.variants.values()).map((v) => v.type);
                    },
                    ...additionalProps,
                });
                if (!("variants" in additionalProps)) {
                    newUnion.variants = createRekeyableMap(Array.from(type.variants.entries()).map(([key, prop]) => [
                        key,
                        cloneType(prop, { union: newUnion }),
                    ]));
                }
                clone = newUnion;
                break;
            case "Interface":
                const newInterface = createType({
                    ...type,
                    decorators: [...type.decorators],
                    operations: undefined,
                    ...additionalProps,
                });
                if (!("operations" in additionalProps)) {
                    newInterface.operations = createRekeyableMap(Array.from(type.operations.entries()).map(([key, prop]) => [
                        key,
                        cloneType(prop, { interface: newInterface }),
                    ]));
                }
                clone = newInterface;
                break;
            case "Enum":
                const newEnum = createType({
                    ...type,
                    decorators: [...type.decorators],
                    members: undefined,
                    ...additionalProps,
                });
                if (!("members" in additionalProps)) {
                    newEnum.members = createRekeyableMap(Array.from(type.members.entries()).map(([key, prop]) => [
                        key,
                        cloneType(prop, { enum: newEnum }),
                    ]));
                }
                clone = newEnum;
                break;
            default:
                clone = createType({
                    ...type,
                    ...("decorators" in type ? { decorators: [...type.decorators] } : {}),
                    ...additionalProps,
                });
                break;
        }
        return clone;
    }
    /**
     * Clone a type, resulting in an identical type with all the same decorators
     * applied. Decorators are re-run on the clone to achieve this.
     *
     * Care is taken to clone nested data structures that are part of the type.
     * Any type with e.g. a map or an array property must recreate the map or array
     * so that clones don't share the same object.
     *
     * For types which have sub-types that are part of it, e.g. enums with members,
     * unions with variants, or models with properties, the sub-types are cloned
     * as well.
     *
     * If the entire type graph needs to be cloned, then cloneType must be called
     * recursively by the caller.
     */
    function cloneType(type, additionalProps = {}) {
        const clone = finishType(initializeClone(type, additionalProps));
        const projection = projectionsByType.get(type);
        if (projection) {
            projectionsByType.set(clone, projection);
        }
        compilerAssert(clone.kind === type.kind, "cloneType must not change type kind");
        return clone;
    }
    /**
     * Clone a type linking to the given symbol.
     * @param sym Symbol which to associate the clone
     * @param type Type to clone
     * @param additionalProps Additional properties to set/override on the clone
     * @returns cloned type
     */
    function cloneTypeForSymbol(sym, type, additionalProps = {}) {
        let clone = initializeClone(type, additionalProps);
        if ("decorators" in clone) {
            for (const dec of checkAugmentDecorators(sym, clone, undefined)) {
                clone.decorators.push(dec);
            }
        }
        clone = finishType(clone);
        compilerAssert(clone.kind === type.kind, "cloneType must not change type kind");
        return clone;
    }
    function checkProjectionDeclaration(node) {
        // todo: check for duplicate projection decls on individual types
        // right now you can declare the same projection on a specific type
        // this could maybe go in the binder? But right now we don't know
        // what an identifier resolves to until check time.
        const links = getSymbolLinks(node.symbol);
        if (processedProjections.has(node)) {
            return links.declaredType;
        }
        processedProjections.add(node);
        reportCheckerDiagnostic(createDiagnostic({ code: "projections-are-experimental", target: node }));
        let type;
        if (links.declaredType) {
            type = links.declaredType;
        }
        else {
            type = links.declaredType = createType({
                kind: "Projection",
                node: undefined,
                nodeByKind: new Map(),
                nodeByType: new Map(),
            });
        }
        switch (node.selector.kind) {
            case SyntaxKind.ProjectionModelSelector:
                projectionsByTypeKind.get("Model").push(node);
                type.nodeByKind.set("Model", node);
                break;
            case SyntaxKind.ProjectionModelPropertySelector:
                projectionsByTypeKind.get("ModelProperty").push(node);
                type.nodeByKind.set("ModelProperty", node);
                break;
            case SyntaxKind.ProjectionOperationSelector:
                projectionsByTypeKind.get("Operation").push(node);
                type.nodeByKind.set("Operation", node);
                break;
            case SyntaxKind.ProjectionUnionSelector:
                projectionsByTypeKind.get("Union").push(node);
                type.nodeByKind.set("Union", node);
                break;
            case SyntaxKind.ProjectionUnionVariantSelector:
                projectionsByTypeKind.get("UnionVariant").push(node);
                type.nodeByKind.set("UnionVariant", node);
                break;
            case SyntaxKind.ProjectionInterfaceSelector:
                projectionsByTypeKind.get("Interface").push(node);
                type.nodeByKind.set("Interface", node);
                break;
            case SyntaxKind.ProjectionEnumSelector:
                projectionsByTypeKind.get("Enum").push(node);
                type.nodeByKind.set("Enum", node);
                break;
            case SyntaxKind.ProjectionEnumMemberSelector:
                projectionsByTypeKind.get("EnumMember").push(node);
                type.nodeByKind.set("EnumMember", node);
                break;
            default:
                const projected = checkTypeReference(node.selector, undefined);
                let current = projectionsByType.get(projected);
                if (!current) {
                    current = [];
                    projectionsByType.set(projected, current);
                }
                current.push(node);
                type.nodeByType.set(projected, node);
                break;
        }
        return type;
    }
    function evalProjectionNode(node) {
        switch (node.kind) {
            case SyntaxKind.ProjectionExpressionStatement:
                return evalProjectionExpressionStatement(node);
            case SyntaxKind.ProjectionCallExpression:
                return evalProjectionCallExpression(node);
            case SyntaxKind.ProjectionMemberExpression:
                return evalProjectionMemberExpression(node);
            case SyntaxKind.ProjectionDecoratorReferenceExpression:
                return evalProjectionDecoratorReference(node);
            case SyntaxKind.Identifier:
                return evalProjectionIdentifier(node);
            case SyntaxKind.ProjectionLambdaExpression:
                return evalProjectionLambdaExpression(node);
            case SyntaxKind.StringLiteral:
                return evalStringLiteral(node);
            case SyntaxKind.NumericLiteral:
                return evalNumericLiteral(node);
            case SyntaxKind.BooleanLiteral:
                return evalBooleanLiteral(node);
            case SyntaxKind.ProjectionBlockExpression:
                return evalProjectionBlockExpression(node);
            case SyntaxKind.ProjectionArithmeticExpression:
                return evalProjectionArithmeticExpression(node);
            case SyntaxKind.ProjectionIfExpression:
                return evalProjectionIfExpression(node);
            case SyntaxKind.ProjectionEqualityExpression:
                return evalProjectionEqualityExpression(node);
            case SyntaxKind.ProjectionUnaryExpression:
                return evalProjectionUnaryExpression(node);
            case SyntaxKind.ProjectionRelationalExpression:
                return evalProjectionRelationalExpression(node);
            case SyntaxKind.ProjectionModelExpression:
                return evalProjectionModelExpression(node);
            case SyntaxKind.VoidKeyword:
                return voidType;
            case SyntaxKind.NeverKeyword:
                return neverType;
            case SyntaxKind.UnknownKeyword:
                return unknownType;
            case SyntaxKind.Return:
                return evalReturnKeyword(node);
            default:
                compilerAssert(false, `Can't eval the node ${SyntaxKind[node.kind]}`);
        }
    }
    function evalReturnKeyword(node) {
        const value = evalProjectionNode(node.value);
        if (value.kind === "Return") {
            return value;
        }
        return {
            kind: "Return",
            value,
        };
    }
    function evalProjectionModelExpression(node) {
        const modelType = createType({
            kind: "Model",
            name: "",
            node: node,
            decorators: [],
            properties: createRekeyableMap(),
            derivedModels: [],
        });
        for (const propNode of node.properties) {
            if (propNode.kind === SyntaxKind.ProjectionModelProperty) {
                const prop = evalProjectionModelProperty(propNode, modelType);
                if (prop.kind === "Return") {
                    return prop;
                }
                modelType.properties.set(prop.name, prop);
            }
            else {
                const props = evalProjectionModelSpreadProperty(propNode);
                if (!Array.isArray(props)) {
                    // return record
                    return props;
                }
                for (const newProp of props) {
                    modelType.properties.set(newProp.name, newProp);
                }
            }
        }
        return modelType;
    }
    function evalProjectionModelProperty(node, model) {
        const type = evalProjectionNode(node.value);
        if (type.kind === "Return") {
            return type;
        }
        return createType({
            kind: "ModelProperty",
            name: node.id.sv,
            node: node,
            decorators: [],
            optional: node.optional,
            type,
            model,
        });
    }
    function evalProjectionModelSpreadProperty(node) {
        const target = evalProjectionNode(node.target);
        if (target.kind === "Return") {
            return target;
        }
        if (target.kind !== "Model") {
            throw new ProjectionError(`Can only spread models`);
        }
        const props = [];
        // copy each property
        for (const prop of walkPropertiesInherited(target)) {
            const newProp = cloneType(prop, { sourceProperty: prop });
            props.push(newProp);
        }
        return props;
    }
    function evalProjectionRelationalExpression(node) {
        const left = evalProjectionNode(node.left);
        if (left.kind === "Return") {
            return left;
        }
        else if (left.kind !== "Number" && left.kind !== "String") {
            throw new ProjectionError("Can only compare numbers or strings");
        }
        const right = evalProjectionNode(node.right);
        if (right.kind === "Return") {
            return right;
        }
        else if (right.kind !== "Number" && right.kind !== "String") {
            throw new ProjectionError("Can only compare numbers or strings");
        }
        if (left.kind !== right.kind) {
            throw new ProjectionError("Can't compare numbers and strings");
        }
        switch (node.op) {
            case "<":
                return createLiteralType(left.value < right.value);
            case "<=":
                return createLiteralType(left.value <= right.value);
            case ">":
                return createLiteralType(left.value > right.value);
            case ">=":
                return createLiteralType(left.value >= right.value);
        }
    }
    function evalProjectionUnaryExpression(node) {
        const target = evalProjectionNode(node.target);
        if (target.kind !== "Boolean") {
            throw new ProjectionError("Can't negate a non-boolean");
        }
        switch (node.op) {
            case "!":
                return createLiteralType(!target.value);
        }
    }
    function evalProjectionEqualityExpression(node) {
        const left = evalProjectionNode(node.left);
        if (left.kind === "Return") {
            return left;
        }
        else if (left.kind !== "Number" && left.kind !== "String") {
            throw new ProjectionError("Comparisons must be strings or numbers");
        }
        const right = evalProjectionNode(node.right);
        if (right.kind === "Return") {
            return right;
        }
        else if (right.kind !== "Number" && right.kind !== "String") {
            throw new ProjectionError("Comparisons must be strings or numbers");
        }
        if (right.kind !== left.kind) {
            throw new ProjectionError("Can't compare number and string");
        }
        switch (node.op) {
            case "==":
                return createLiteralType(left.value === right.value);
            case "!=":
                return createLiteralType(left.value !== right.value);
        }
    }
    function evalProjectionIfExpression(node) {
        let ifExpr = node;
        while (ifExpr) {
            const test = evalProjectionNode(ifExpr.test);
            if (test.kind === "Return") {
                return test;
            }
            if (typeIsTruthy(test)) {
                return evalProjectionBlockExpression(ifExpr.consequent);
            }
            else if (ifExpr.alternate &&
                ifExpr.alternate.kind === SyntaxKind.ProjectionBlockExpression) {
                return evalProjectionBlockExpression(ifExpr.alternate);
            }
            else {
                ifExpr = ifExpr.alternate;
            }
        }
        return voidType;
    }
    function typeIsTruthy(t) {
        switch (t.kind) {
            case "Boolean":
                return t.value;
            case "Number":
                return !!t.value;
            case "String":
                return !!t.value;
            default:
                return true;
        }
    }
    function createEvalContext(node, parent) {
        return {
            node,
            locals: new Map(),
            parent,
        };
    }
    function evalProjectionBlockExpression(node) {
        let lastVal = voidType;
        for (const stmt of node.statements) {
            const stmtValue = evalProjectionNode(stmt);
            if (stmtValue.kind === "Return") {
                return stmtValue;
            }
            lastVal = stmtValue;
        }
        return lastVal;
    }
    function evalProjectionArithmeticExpression(node) {
        const lhs = evalProjectionNode(node.left);
        if (lhs.kind === "Return") {
            return lhs;
        }
        if (lhs.kind !== "Number" && lhs.kind !== "String") {
            throw new ProjectionError(`Operator ${node.op} can only apply to strings or numbers`);
        }
        const rhs = evalProjectionNode(node.right);
        if (rhs.kind === "Return") {
            return rhs;
        }
        if (rhs.kind !== "Number" && rhs.kind !== "String") {
            throw new ProjectionError(`Operator ${node.op} can only apply to strings or numbers`);
        }
        if (rhs.kind !== lhs.kind) {
            throw new ProjectionError(`Operator ${node.op}'s operands need to be the same type`);
        }
        if (lhs.kind === "String") {
            return createLiteralType(lhs.value + rhs.value);
        }
        else {
            return createLiteralType(lhs.value + rhs.value);
        }
    }
    function evalProjection(node, target, args) {
        if (node.direction === "<error>") {
            throw new ProjectionError("Cannot evaluate projection with invalid direction.");
        }
        let topLevelProjection = false;
        if (!currentProjectionDirection) {
            topLevelProjection = true;
            currentProjectionDirection = node.direction;
        }
        if (currentProjectionDirection === "from" && !target.projectionSource) {
            // this model wasn't projected, so we'll just return the target
            return target;
        }
        const originalContext = evalContext;
        evalContext = createEvalContext(node);
        for (const [i, param] of node.parameters.entries()) {
            if (!args[i]) {
                throw new ProjectionError("need argument for parameter " + SyntaxKind[node.parameters[i].kind]);
            }
            const argVal = args[i];
            let typeVal;
            if (typeof argVal === "number" || typeof argVal === "string" || typeof argVal === "boolean") {
                typeVal = createLiteralType(argVal);
            }
            else {
                typeVal = argVal;
            }
            evalContext.locals.set(param.id.sv, typeVal);
        }
        evalContext.locals.set("self", target);
        let lastVal = voidType;
        for (const item of node.body) {
            lastVal = evalProjectionNode(item);
            if (lastVal.kind === "Return") {
                break;
            }
        }
        if (topLevelProjection) {
            currentProjectionDirection = undefined;
        }
        const selfResult = evalContext.locals.get("self");
        evalContext = originalContext;
        if (lastVal.kind === "Return") {
            return lastVal.value;
        }
        else {
            return selfResult;
        }
    }
    function evalProjectionExpressionStatement(node) {
        return evalProjectionNode(node.expr);
    }
    function evalProjectionCallExpression(node) {
        const target = evalProjectionNode(node.target);
        if (!target)
            throw new ProjectionError("target undefined");
        const args = [];
        for (const arg of node.arguments) {
            args.push(evalProjectionNode(arg));
        }
        if (target.kind !== "Function") {
            throw new ProjectionError("Can't call non-function, got type " + target.kind);
        }
        return target.implementation(...args);
    }
    function evalProjectionMemberExpression(node) {
        const base = evalProjectionNode(node.base);
        if (base.kind === "Return") {
            return base;
        }
        const member = node.id.sv;
        const selector = node.selector;
        if (selector === ".") {
            switch (base.kind) {
                case "Namespace":
                    const sym = base.node.symbol.exports.get(member);
                    if (sym) {
                        const links = getSymbolLinks(sym);
                        return links.declaredType || links.type || errorType;
                    }
                    else {
                        throw new ProjectionError(`Namespace doesn't have member ${member}`);
                    }
                case "Model":
                    const prop = base.properties.get(member);
                    if (!prop) {
                        throw new ProjectionError(`Model doesn't have property ${member}`);
                    }
                    return prop;
                case "Enum":
                    const enumMember = base.members.get(member);
                    if (!enumMember) {
                        throw new ProjectionError(`Enum doesn't have member ${member}`);
                    }
                    return enumMember;
                case "Union":
                    const variant = base.variants.get(member);
                    if (!variant) {
                        throw new ProjectionError(`Union doesn't have variant ${member}`);
                    }
                    return variant;
                default:
                    throw new ProjectionError(`Can't get member "${member}" of type ${base.kind} because it has no members. Did you mean to use "::" instead of "."?`);
            }
        }
        switch (base.kind) {
            case "Object":
                return base.properties[member] || errorType;
            default:
                const typeOps = projectionMembers[base.kind];
                if (!typeOps) {
                    throw new ProjectionError(`${base.kind} doesn't have an object model member named ${member}`);
                }
                // any cast needed to ensure we don't get a too complex union error on the call
                // to op further down.
                const op = typeOps[member];
                if (!op) {
                    throw new ProjectionError(`${base.kind} doesn't have an object model member named ${member}`);
                }
                return op(base);
        }
    }
    function createFunctionType(fn) {
        const parameters = [];
        return createType({
            kind: "Function",
            name: "",
            parameters,
            returnType: unknownType,
            implementation: fn,
        });
    }
    function createLiteralType(value, node) {
        if (program.literalTypes.has(value)) {
            return program.literalTypes.get(value);
        }
        let type;
        switch (typeof value) {
            case "string":
                type = createType({ kind: "String", value });
                break;
            case "boolean":
                type = createType({ kind: "Boolean", value });
                break;
            case "number":
                let valueAsString;
                if (node) {
                    compilerAssert(node.kind === SyntaxKind.NumericLiteral, "Must pass numeric literal node or undefined when creating a numeric literal type");
                    valueAsString = node.valueAsString;
                }
                else {
                    valueAsString = String(value);
                }
                type = createType({
                    kind: "Number",
                    value,
                    valueAsString,
                });
                break;
        }
        program.literalTypes.set(value, type);
        return type;
    }
    function evalProjectionDecoratorReference(node) {
        const ref = resolveTypeReferenceSym(node.target, undefined, true);
        if (!ref)
            throw new ProjectionError("Can't find decorator.");
        compilerAssert(ref.flags & 16384 /* SymbolFlags.Decorator */, "should only resolve decorator symbols");
        return createFunctionType((...args) => {
            ref.value({ program }, ...marshalArgumentsForJS(args));
            return voidType;
        });
    }
    function evalProjectionIdentifier(node) {
        // first check the eval context
        let currentContext = evalContext;
        while (currentContext) {
            if (currentContext.locals.has(node.sv)) {
                return currentContext.locals.get(node.sv);
            }
            currentContext = currentContext.parent;
        }
        // next, resolve outside
        const ref = resolveTypeReferenceSym(node, undefined);
        if (!ref)
            throw new ProjectionError("Unknown identifier " + node.sv);
        if (ref.flags & 16384 /* SymbolFlags.Decorator */) {
            // shouldn't ever resolve a decorator symbol here (without passing
            // true to resolveTypeReference)
            return errorType;
        }
        else if (ref.flags & 131072 /* SymbolFlags.Function */) {
            // TODO: store this in a symbol link probably?
            const t = createFunctionType((...args) => {
                const retval = ref.value(program, ...marshalArgumentsForJS(args));
                return marshalProjectionReturn(retval, { functionName: node.sv });
            });
            return t;
        }
        else {
            const links = getSymbolLinks(ref);
            compilerAssert(links.declaredType, "Should have checked all types by now");
            return links.declaredType;
        }
    }
    function marshalProjectionReturn(value, options = {}) {
        if (typeof value === "boolean" || typeof value === "string" || typeof value === "number") {
            return createLiteralType(value);
        }
        if (typeof value === "object" && value !== null) {
            if ("kind" in value) {
                return value;
            }
            else {
                // this could probably be more robust
                return createType({
                    kind: "Object",
                    properties: value,
                });
            }
        }
        if (options.functionName) {
            throw new ProjectionError(`Can't marshal value "${value}" returned from JS function "${options.functionName}" into typespec`);
        }
        else {
            throw new ProjectionError(`Can't marshal value "${value}" into typespec`);
        }
    }
    function evalProjectionLambdaExpression(node) {
        return createFunctionType((...args) => {
            return callLambdaExpression(node, args);
        });
    }
    function callLambdaExpression(node, args) {
        const originalContext = evalContext;
        evalContext = createEvalContext(node, originalContext);
        for (const [i, param] of node.parameters.entries()) {
            evalContext.locals.set(param.id.sv, args[i]);
        }
        const retval = evalProjectionBlockExpression(node.body);
        evalContext = originalContext;
        if (retval.kind === "Return") {
            return retval.value;
        }
        return retval;
    }
    function evalStringLiteral(node) {
        return createLiteralType(node.value, node);
    }
    function evalNumericLiteral(node) {
        return createLiteralType(node.value, node);
    }
    function evalBooleanLiteral(node) {
        return createLiteralType(node.value, node);
    }
    function project(target, projection, args = []) {
        return evalProjection(projection, target, args.map((x) => marshalProjectionReturn(x)));
    }
    function memberExpressionToString(expr) {
        let current = expr;
        const parts = [];
        while (current.kind === SyntaxKind.MemberExpression) {
            parts.push(current.id.sv);
            current = current.base;
        }
        parts.push(current.sv);
        return parts.reverse().join(".");
    }
    /**
     * Check if the source type can be assigned to the target type and emit diagnostics
     * @param source Source type
     * @param target Target type
     * @param diagnosticTarget Target for the diagnostic, unless something better can be inferred.
     */
    function checkTypeAssignable(source, target, diagnosticTarget) {
        const [related, diagnostics] = isTypeAssignableTo(source, target, diagnosticTarget);
        if (!related) {
            reportCheckerDiagnostics(diagnostics);
        }
        return related;
    }
    /**
     * Check if the source type can be assigned to the target type.
     * @param source Source type
     * @param target Target type
     * @param diagnosticTarget Target for the diagnostic, unless something better can be inferred.
     */
    function isTypeAssignableTo(source, target, diagnosticTarget) {
        const [related, diagnostics] = isTypeAssignableToInternal(source, target, diagnosticTarget, new MultiKeyMap());
        return [related === Related.true, diagnostics];
    }
    function isTypeAssignableToInternal(source, target, diagnosticTarget, relationCache) {
        const cached = relationCache.get([source, target]);
        if (cached !== undefined) {
            return [cached, []];
        }
        const [result, diagnostics] = isTypeAssignableToWorker(source, target, diagnosticTarget, new MultiKeyMap());
        relationCache.set([source, target], result);
        return [result, diagnostics];
    }
    function isTypeAssignableToWorker(source, target, diagnosticTarget, relationCache) {
        var _a;
        // BACKCOMPAT: Added May 2023 sprint, to be removed by June 2023 sprint
        if (source.kind === "TemplateParameter" && source.constraint && target.kind === "Value") {
            const [assignable] = isTypeAssignableToInternal(source.constraint, target.target, diagnosticTarget, relationCache);
            if (assignable) {
                const constraint = getTypeName(source.constraint);
                reportDeprecated(program, `Template constrainted to '${constraint}' will not be assignable to '${getTypeName(target)}' in the future. Update the constraint to be 'valueof ${constraint}'`, diagnosticTarget);
                return [Related.true, []];
            }
        }
        if (source.kind === "TemplateParameter") {
            source = (_a = source.constraint) !== null && _a !== void 0 ? _a : unknownType;
        }
        if (source === target)
            return [Related.true, []];
        if (target.kind === "Value") {
            return isAssignableToValueType(source, target, diagnosticTarget, relationCache);
        }
        if (source.kind === "Value") {
            return [Related.false, [createUnassignableDiagnostic(source, target, diagnosticTarget)]];
        }
        const isSimpleTypeRelated = isSimpleTypeAssignableTo(source, target);
        if (isSimpleTypeRelated === true) {
            return [Related.true, []];
        }
        else if (isSimpleTypeRelated === false) {
            return [Related.false, [createUnassignableDiagnostic(source, target, diagnosticTarget)]];
        }
        if (source.kind === "Union") {
            for (const variant of source.variants.values()) {
                const [variantAssignable] = isTypeAssignableToInternal(variant.type, target, diagnosticTarget, relationCache);
                if (!variantAssignable) {
                    return [Related.false, [createUnassignableDiagnostic(source, target, diagnosticTarget)]];
                }
            }
            return [Related.true, []];
        }
        if (target.kind === "Model" &&
            source.kind === "Model" &&
            target.name !== "object" &&
            target.indexer === undefined &&
            source.indexer &&
            source.indexer.key.name === "integer") {
            return [
                Related.false,
                [
                    createDiagnostic({
                        code: "missing-index",
                        format: {
                            indexType: getTypeName(source.indexer.key),
                            sourceType: getTypeName(target),
                        },
                        target: diagnosticTarget,
                    }),
                ],
            ];
        }
        else if (target.kind === "Model" && target.indexer !== undefined && source.kind === "Model") {
            return isIndexerValid(source, target, diagnosticTarget, relationCache);
        }
        else if (target.kind === "Model" && source.kind === "Model") {
            return isModelRelatedTo(source, target, diagnosticTarget, relationCache);
        }
        else if (target.kind === "Model" && target.indexer && source.kind === "Tuple") {
            for (const item of source.values) {
                const [related, diagnostics] = isTypeAssignableToInternal(item, target.indexer.value, diagnosticTarget, relationCache);
                if (!related) {
                    return [Related.false, diagnostics];
                }
            }
            return [Related.true, []];
        }
        else if (target.kind === "Tuple" && source.kind === "Tuple") {
            return isTupleAssignableToTuple(source, target, diagnosticTarget, relationCache);
        }
        else if (target.kind === "Union") {
            return isAssignableToUnion(source, target, diagnosticTarget, relationCache);
        }
        else if (target.kind === "Enum") {
            return isAssignableToEnum(source, target, diagnosticTarget);
        }
        return [Related.false, [createUnassignableDiagnostic(source, target, diagnosticTarget)]];
    }
    function isAssignableToValueType(source, target, diagnosticTarget, relationCache) {
        if (source.kind === "Value") {
            return isTypeAssignableToInternal(source.target, target.target, diagnosticTarget, relationCache);
        }
        const [assignable, diagnostics] = isTypeAssignableToInternal(source, target.target, diagnosticTarget, relationCache);
        if (!assignable) {
            return [assignable, diagnostics];
        }
        if (!isValueType(source)) {
            return [Related.false, [createUnassignableDiagnostic(source, target, diagnosticTarget)]];
        }
        return [Related.true, []];
    }
    function isReflectionType(type) {
        var _a, _b, _c;
        return (type.kind === "Model" &&
            ((_a = type.namespace) === null || _a === void 0 ? void 0 : _a.name) === "Reflection" &&
            ((_c = (_b = type.namespace) === null || _b === void 0 ? void 0 : _b.namespace) === null || _c === void 0 ? void 0 : _c.name) === "TypeSpec");
    }
    function isRelatedToScalar(source, target) {
        switch (source.kind) {
            case "Number":
                return isNumericLiteralRelatedTo(source, target);
            case "String":
            case "StringTemplate":
                return areScalarsRelated(target, getStdType("string"));
            case "Boolean":
                return areScalarsRelated(target, getStdType("boolean"));
            case "Scalar":
                return areScalarsRelated(source, target);
            case "Union":
                return undefined;
            default:
                return false;
        }
    }
    function areScalarsRelated(source, target) {
        let current = source;
        while (current) {
            if (current === target) {
                return true;
            }
            current = current.baseScalar;
        }
        return false;
    }
    function isSimpleTypeAssignableTo(source, target) {
        if (isNeverType(source))
            return true;
        if (isVoidType(target))
            return false;
        if (isUnknownType(target))
            return true;
        if (isReflectionType(target)) {
            return source.kind === ReflectionNameToKind[target.name];
        }
        if (target.kind === "Scalar") {
            return isRelatedToScalar(source, target);
        }
        if (source.kind === "Scalar" && target.kind === "Model") {
            return false;
        }
        if (target.kind === "String") {
            return source.kind === "String" && target.value === source.value;
        }
        if (target.kind === "Number") {
            return source.kind === "Number" && target.value === source.value;
        }
        return undefined;
    }
    function isNumericLiteralRelatedTo(source, target) {
        // if the target does not derive from numeric, then it can't be assigned a numeric literal
        if (!areScalarsRelated(target, getStdType("numeric"))) {
            return false;
        }
        // With respect to literal assignability a custom numeric scalar is
        // equivalent to its nearest TypeSpec.* base. Adjust target accordingly.
        while (!target.namespace || !isTypeSpecNamespace(target.namespace)) {
            compilerAssert(target.baseScalar, "Should not be possible to be derived from TypeSpec.numeric and not have a base when not in TypeSpec namespace.");
            target = target.baseScalar;
        }
        if (target.name === "numeric")
            return true;
        if (target.name === "decimal")
            return true;
        if (target.name === "decimal128")
            return true;
        const isInt = Number.isInteger(source.value);
        if (target.name === "integer")
            return isInt;
        if (target.name === "float")
            return true;
        if (!(target.name in numericRanges))
            return false;
        const [low, high, options] = numericRanges[target.name];
        return source.value >= low && source.value <= high && (!options.int || isInt);
    }
    function isModelRelatedTo(source, target, diagnosticTarget, relationCache) {
        relationCache.set([source, target], Related.maybe);
        const diagnostics = [];
        for (const prop of walkPropertiesInherited(target)) {
            const sourceProperty = getProperty(source, prop.name);
            if (sourceProperty === undefined) {
                if (!prop.optional) {
                    diagnostics.push(createDiagnostic({
                        code: "missing-property",
                        format: {
                            propertyName: prop.name,
                            sourceType: getTypeName(source),
                            targetType: getTypeName(target),
                        },
                        target: source,
                    }));
                }
            }
            else {
                const [related, propDiagnostics] = isTypeAssignableToInternal(sourceProperty.type, prop.type, diagnosticTarget, relationCache);
                if (!related) {
                    diagnostics.push(...propDiagnostics);
                }
            }
        }
        return [diagnostics.length === 0 ? Related.true : Related.false, diagnostics];
    }
    function getProperty(model, name) {
        var _a;
        return ((_a = model.properties.get(name)) !== null && _a !== void 0 ? _a : (model.baseModel !== undefined ? getProperty(model.baseModel, name) : undefined));
    }
    function isIndexerValid(source, target, diagnosticTarget, relationCache) {
        // Model expressions should be able to be assigned.
        if (source.name === "" && target.indexer.key.name !== "integer") {
            return isIndexConstraintValid(target.indexer.value, source, diagnosticTarget);
        }
        else {
            if (source.indexer === undefined || source.indexer.key !== target.indexer.key) {
                return [
                    Related.false,
                    [
                        createDiagnostic({
                            code: "missing-index",
                            format: {
                                indexType: getTypeName(target.indexer.key),
                                sourceType: getTypeName(source),
                            },
                            target: diagnosticTarget,
                        }),
                    ],
                ];
            }
            return isTypeAssignableToInternal(source.indexer.value, target.indexer.value, diagnosticTarget, relationCache);
        }
    }
    /**
     * @param constraintType Type of the constraints(All properties must have this type).
     * @param type Type of the model that should be respecting the constraint.
     * @param diagnosticTarget Diagnostic target unless something better can be inferred.
     */
    function isIndexConstraintValid(constraintType, type, diagnosticTarget, relationCache) {
        for (const prop of type.properties.values()) {
            const [related, diagnostics] = isTypeAssignableTo(prop.type, constraintType, diagnosticTarget);
            if (!related) {
                return [Related.false, diagnostics];
            }
        }
        if (type.baseModel) {
            const [related, diagnostics] = isIndexConstraintValid(constraintType, type.baseModel, diagnosticTarget);
            if (!related) {
                return [Related.false, diagnostics];
            }
        }
        return [Related.true, []];
    }
    function isTupleAssignableToTuple(source, target, diagnosticTarget, relationCache) {
        if (source.values.length !== target.values.length) {
            return [
                Related.false,
                [
                    createDiagnostic({
                        code: "unassignable",
                        messageId: "withDetails",
                        format: {
                            sourceType: getTypeName(source),
                            targetType: getTypeName(target),
                            details: `Source has ${source.values.length} element(s) but target requires ${target.values.length}.`,
                        },
                        target: diagnosticTarget,
                    }),
                ],
            ];
        }
        for (const [index, sourceItem] of source.values.entries()) {
            const targetItem = target.values[index];
            const [related, diagnostics] = isTypeAssignableToInternal(sourceItem, targetItem, diagnosticTarget, relationCache);
            if (!related) {
                return [Related.false, diagnostics];
            }
        }
        return [Related.true, []];
    }
    function isAssignableToUnion(source, target, diagnosticTarget, relationCache) {
        if (source.kind === "UnionVariant" && source.union === target) {
            return [Related.true, []];
        }
        for (const option of target.variants.values()) {
            const [related] = isTypeAssignableToInternal(source, option.type, diagnosticTarget, relationCache);
            if (related) {
                return [Related.true, []];
            }
        }
        return [Related.false, [createUnassignableDiagnostic(source, target, diagnosticTarget)]];
    }
    function isAssignableToEnum(source, target, diagnosticTarget) {
        switch (source.kind) {
            case "Enum":
                if (source === target) {
                    return [Related.true, []];
                }
                else {
                    return [Related.false, [createUnassignableDiagnostic(source, target, diagnosticTarget)]];
                }
            case "EnumMember":
                if (source.enum === target) {
                    return [Related.true, []];
                }
                else {
                    return [Related.false, [createUnassignableDiagnostic(source, target, diagnosticTarget)]];
                }
            default:
                return [Related.false, [createUnassignableDiagnostic(source, target, diagnosticTarget)]];
        }
    }
    function createUnassignableDiagnostic(source, target, diagnosticTarget) {
        return createDiagnostic({
            code: "unassignable",
            format: { targetType: getTypeName(target), value: getTypeName(source) },
            target: diagnosticTarget,
        });
    }
    function isStdType(type, stdType) {
        var _a;
        type = (_a = type.projectionBase) !== null && _a !== void 0 ? _a : type;
        if ((type.kind !== "Model" && type.kind !== "Scalar") ||
            type.namespace === undefined ||
            !isTypeSpecNamespace(type.namespace))
            return false;
        if (type.kind === "Scalar")
            return stdType === undefined || stdType === type.name;
        if (stdType === "Array" && type === stdTypes["Array"])
            return true;
        if (stdType === "Record" && type === stdTypes["Record"])
            return true;
        if (type.kind === "Model")
            return stdType === undefined || stdType === type.name;
        return false;
    }
}
function isAnonymous(type) {
    return !("name" in type) || typeof type.name !== "string" || !type.name;
}
function isErrorType(type) {
    return type.kind === "Intrinsic" && type.name === "ErrorType";
}
const numericRanges = {
    int64: [BigInt("-9223372036854775807"), BigInt("9223372036854775808"), { int: true }],
    int32: [-2147483648, 2147483647, { int: true }],
    int16: [-32768, 32767, { int: true }],
    int8: [-128, 127, { int: true }],
    uint64: [0, BigInt("18446744073709551615"), { int: true }],
    uint32: [0, 4294967295, { int: true }],
    uint16: [0, 65535, { int: true }],
    uint8: [0, 255, { int: true }],
    safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, { int: true }],
    float32: [-3.4e38, 3.4e38, { int: false }],
    float64: [-Number.MAX_VALUE, Number.MAX_VALUE, { int: false }],
};
/**
 * Find all named models that could have been the source of the given
 * property. This includes the named parents of all property sources in a
 * chain.
 */
function getNamedSourceModels(property) {
    var _a;
    if (!property.sourceProperty) {
        return undefined;
    }
    const set = new Set();
    for (let p = property; p; p = p.sourceProperty) {
        if ((_a = p.model) === null || _a === void 0 ? void 0 : _a.name) {
            set.add(p.model);
        }
    }
    return set;
}
/**
 * Find derived types of `models` in `possiblyDerivedModels` and add them to
 * `models`.
 */
function addDerivedModels(models, possiblyDerivedModels) {
    for (const element of possiblyDerivedModels) {
        if (!models.has(element)) {
            for (let t = element.baseModel; t; t = t.baseModel) {
                if (models.has(t)) {
                    models.add(element);
                    break;
                }
            }
        }
    }
}
function createTypeMapper(parameters, args, parentMapper) {
    var _a, _b;
    const map = new Map((_a = parentMapper === null || parentMapper === void 0 ? void 0 : parentMapper.map) !== null && _a !== void 0 ? _a : []);
    for (const [index, param] of parameters.entries()) {
        map.set(param, args[index]);
    }
    return {
        partial: false,
        args: [...((_b = parentMapper === null || parentMapper === void 0 ? void 0 : parentMapper.args) !== null && _b !== void 0 ? _b : []), ...args],
        getMappedType: (type) => {
            var _a;
            return (_a = map.get(type)) !== null && _a !== void 0 ? _a : type;
        },
        map,
    };
}
/**
 * If the input is anonymous (or the provided filter removes properties)
 * and there exists a named model with the same set of properties
 * (ignoring filtered properties), then return that named model.
 * Otherwise, return the input unchanged.
 *
 * This can be used by emitters to find a better name for a set of
 * properties after filtering. For example, given `{ @metadata prop:
 * string} & SomeName`, and an emitter that wishes to discard properties
 * marked with `@metadata`, the emitter can use this to recover that the
 * best name for the remaining properties is `SomeName`.
 *
 * @param model The input model
 * @param filter An optional filter to apply to the input model's
 * properties.
 */
function getEffectiveModelType(program, model, filter) {
    if (filter) {
        model = filterModelProperties(program, model, filter);
    }
    if (model.name) {
        // named model
        return model;
    }
    // We would need to change the algorithm if this doesn't hold. We
    // assume model has no inherited properties below.
    compilerAssert(!model.baseModel, "Anonymous model with base model.");
    if (model.properties.size === 0) {
        // empty model
        return model;
    }
    // Find the candidate set of named model types that could have been the
    // source of every property in the model.
    let candidates;
    for (const property of model.properties.values()) {
        const sources = getNamedSourceModels(property);
        if (!sources) {
            // unsourced property: no possible match
            return model;
        }
        if (!candidates) {
            // first sourced property: initialize candidates to its sources
            candidates = sources;
            continue;
        }
        // Add derived sources as we encounter them. If a model is sourced from
        // a base property, then it can also be sourced from a derived model.
        //
        // (Unless it is overridden, but then the presence of the overridden
        // property will still cause the the base model to be excluded from the
        // candidates.)
        //
        // Note: We depend on the order of that spread and intersect source
        // properties here, which is that we see properties sourced from derived
        // types before properties sourced from their base types.
        addDerivedModels(sources, candidates);
        // remove candidates that are not common to this property.
        for (const candidate of candidates) {
            if (!sources.has(candidate)) {
                candidates.delete(candidate);
            }
        }
    }
    // Search for a candidate that has no additional properties (ignoring
    // filtered properties). If so, it is effectively the same type as the
    // input model. Consider a candidate that meets this test without
    // ignoring filtering as a better match than one that requires filtering
    // to meet this test.
    let match;
    for (const candidate of candidates !== null && candidates !== void 0 ? candidates : []) {
        if (model.properties.size === countPropertiesInherited(candidate)) {
            match = candidate;
            break; // exact match
        }
        if (filter && !match && model.properties.size === countPropertiesInherited(candidate, filter)) {
            match = candidate;
            continue; // match with filter: keep searching for exact match
        }
    }
    return match !== null && match !== void 0 ? match : model;
}
/**
 * Applies a filter to the properties of a given type. If no properties
 * are filtered out, then return the input unchanged. Otherwise, return
 * a new anonymous model with only the filtered properties.
 *
 * @param model The input model to filter.
 * @param filter The filter to apply. Properties are kept when this returns true.
 */
function filterModelProperties(program, model, filter) {
    let filtered = false;
    for (const property of walkPropertiesInherited(model)) {
        if (!filter(property)) {
            filtered = true;
            break;
        }
    }
    if (!filtered) {
        return model;
    }
    const properties = createRekeyableMap();
    const newModel = program.checker.createType({
        kind: "Model",
        node: undefined,
        name: "",
        indexer: undefined,
        properties,
        decorators: [],
        derivedModels: [],
    });
    for (const property of walkPropertiesInherited(model)) {
        if (filter(property)) {
            const newProperty = program.checker.cloneType(property, {
                sourceProperty: property,
                model: newModel,
            });
            properties.set(property.name, newProperty);
        }
    }
    return finishTypeForProgram(program, newModel);
}
/**
 * Gets the property from the nearest base type that is overridden by the
 * given property, if any.
 */
function getOverriddenProperty(property) {
    compilerAssert(property.model, "Parent model must be set before overridden property can be found.");
    for (let current = property.model.baseModel; current; current = current.baseModel) {
        const overridden = current.properties.get(property.name);
        if (overridden) {
            return overridden;
        }
    }
    return undefined;
}
/**
 * Enumerates the properties declared by model or inherited from its base.
 *
 * Properties declared by more derived types are enumerated before properties
 * of less derived types.
 *
 * Properties that are overridden are not enumerated.
 */
function* walkPropertiesInherited(model) {
    const returned = new Set();
    for (let current = model; current; current = current.baseModel) {
        for (const property of current.properties.values()) {
            if (returned.has(property.name)) {
                // skip properties that have been overridden
                continue;
            }
            returned.add(property.name);
            yield property;
        }
    }
}
function countPropertiesInherited(model, filter) {
    let count = 0;
    for (const property of walkPropertiesInherited(model)) {
        if (!filter || filter(property)) {
            count++;
        }
    }
    return count;
}
function finishTypeForProgram(program, typeDef) {
    return finishTypeForProgramAndChecker(program, program.checker.typePrototype, typeDef);
}
function linkMapper(typeDef, mapper) {
    if (mapper) {
        compilerAssert(!typeDef.templateArguments, "Mapper provided but template arguments already set.");
        typeDef.templateMapper = mapper;
        typeDef.templateArguments = mapper.args;
    }
}
function extractMainDoc(type) {
    var _a;
    if (((_a = type.node) === null || _a === void 0 ? void 0 : _a.docs) === undefined) {
        return undefined;
    }
    let mainDoc = "";
    for (const doc of type.node.docs) {
        mainDoc += getDocContent$1(doc.content);
    }
    const trimmed = mainDoc.trim();
    return trimmed === "" ? undefined : trimmed;
}
function extractReturnsDocs(type) {
    var _a;
    const result = {
        returns: undefined,
        errors: undefined,
    };
    if (((_a = type.node) === null || _a === void 0 ? void 0 : _a.docs) === undefined) {
        return result;
    }
    for (const doc of type.node.docs) {
        for (const tag of doc.tags) {
            if (tag.kind === SyntaxKind.DocReturnsTag) {
                result.returns = getDocContent$1(tag.content);
            }
            if (tag.kind === SyntaxKind.DocErrorsTag) {
                result.errors = getDocContent$1(tag.content);
            }
        }
    }
    return result;
}
function extractParamDoc(node, paramName) {
    if (node.docs === undefined) {
        return undefined;
    }
    for (const doc of node.docs) {
        for (const tag of doc.tags) {
            if (tag.kind === SyntaxKind.DocParamTag && tag.paramName.sv === paramName) {
                return getDocContent$1(tag.content);
            }
        }
    }
    return undefined;
}
function getDocContent$1(content) {
    const docs = [];
    for (const node of content) {
        compilerAssert(node.kind === SyntaxKind.DocText, "No other doc content node kinds exist yet. Update this code appropriately when more are added.");
        docs.push(node.text);
    }
    return docs.join("");
}
function finishTypeForProgramAndChecker(program, typePrototype, typeDef) {
    if ("decorators" in typeDef) {
        for (const decApp of typeDef.decorators) {
            applyDecoratorToType(program, decApp, typeDef);
        }
    }
    Object.setPrototypeOf(typeDef, typePrototype);
    typeDef.isFinished = true;
    return typeDef;
}
function reportDeprecation(program, target, message, reportFunc) {
    if (program.compilerOptions.ignoreDeprecated !== true) {
        reportFunc(createDiagnostic({
            code: "deprecated",
            format: {
                message,
            },
            target,
        }));
    }
}
function applyDecoratorToType(program, decApp, target) {
    var _a, _b;
    compilerAssert("decorators" in target, "Cannot apply decorator to non-decoratable type", target);
    for (const arg of decApp.args) {
        if (isErrorType(arg.value)) {
            // If one of the decorator argument is an error don't run it.
            return;
        }
    }
    // Is the decorator definition deprecated?
    if (decApp.definition) {
        const deprecation = getDeprecationDetails(program, decApp.definition);
        if (deprecation !== undefined) {
            reportDeprecation(program, (_a = decApp.node) !== null && _a !== void 0 ? _a : target, deprecation.message, program.reportDiagnostic);
        }
    }
    // peel `fn` off to avoid setting `this`.
    try {
        const args = decApp.args.map((x) => x.jsValue);
        const fn = decApp.decorator;
        const context = createDecoratorContext(program, decApp);
        fn(context, target, ...args);
    }
    catch (error) {
        // do not fail the language server for exceptions in decorators
        if (program.compilerOptions.designTimeBuild) {
            program.reportDiagnostic(createDiagnostic({
                code: "decorator-fail",
                format: { decoratorName: decApp.decorator.name, error: error.stack },
                target: (_b = decApp.node) !== null && _b !== void 0 ? _b : target,
            }));
        }
        else {
            throw error;
        }
    }
}
function createDecoratorContext(program, decApp) {
    function createPassThruContext(program, decApp) {
        return {
            program,
            decoratorTarget: decApp.node,
            getArgumentTarget: () => decApp.node,
            call: (decorator, target, ...args) => {
                return decorator(createPassThruContext(program, decApp), target, ...args);
            },
        };
    }
    return {
        program,
        decoratorTarget: decApp.node,
        getArgumentTarget: (index) => {
            var _a;
            return (_a = decApp.args[index]) === null || _a === void 0 ? void 0 : _a.node;
        },
        call: (decorator, target, ...args) => {
            return decorator(createPassThruContext(program, decApp), target, ...args);
        },
    };
}
/**
 * Convert typespec argument to JS argument.
 */
function marshalArgumentsForJS(args) {
    return args.map((arg) => {
        if (arg.kind === "Boolean" || arg.kind === "String" || arg.kind === "Number") {
            return literalTypeToValue(arg);
        }
        else if (arg.kind === "StringTemplate") {
            return stringTemplateToString(arg)[0];
        }
        return arg;
    });
}
function literalTypeToValue(type) {
    return type.value;
}
function isTemplatedNode(node) {
    return "templateParameters" in node && node.templateParameters.length > 0;
}
/**
 * Mapping from the reflection models to Type["kind"] value
 */
const ReflectionNameToKind = {
    Enum: "Enum",
    EnumMember: "EnumMember",
    Interface: "Interface",
    Model: "Model",
    ModelProperty: "ModelProperty",
    Namespace: "Namespace",
    Operation: "Operation",
    Scalar: "Scalar",
    TemplateParameter: "TemplateParameter",
    Tuple: "Tuple",
    Union: "Union",
    UnionVariant: "UnionVariant",
};
var ResolutionKind;
(function (ResolutionKind) {
    ResolutionKind[ResolutionKind["Type"] = 0] = "Type";
    ResolutionKind[ResolutionKind["BaseType"] = 1] = "BaseType";
})(ResolutionKind || (ResolutionKind = {}));
class PendingResolutions {
    constructor() {
        _PendingResolutions_data.set(this, new Map());
    }
    start(symId, kind) {
        let existing = __classPrivateFieldGet(this, _PendingResolutions_data, "f").get(symId);
        if (existing === undefined) {
            existing = new Set();
            __classPrivateFieldGet(this, _PendingResolutions_data, "f").set(symId, existing);
        }
        existing.add(kind);
    }
    has(symId, kind) {
        var _a, _b;
        return (_b = (_a = __classPrivateFieldGet(this, _PendingResolutions_data, "f").get(symId)) === null || _a === void 0 ? void 0 : _a.has(kind)) !== null && _b !== void 0 ? _b : false;
    }
    finish(symId, kind) {
        const existing = __classPrivateFieldGet(this, _PendingResolutions_data, "f").get(symId);
        if (existing === undefined) {
            return;
        }
        existing === null || existing === void 0 ? void 0 : existing.delete(kind);
        if (existing.size === 0) {
            __classPrivateFieldGet(this, _PendingResolutions_data, "f").delete(symId);
        }
    }
}
_PendingResolutions_data = new WeakMap();
var Related;
(function (Related) {
    Related[Related["false"] = 0] = "false";
    Related[Related["true"] = 1] = "true";
    Related[Related["maybe"] = 2] = "maybe";
})(Related || (Related = {}));
const defaultSymbolResolutionOptions = {
    resolveDecorators: false,
    checkTemplateTypes: true,
};

/**
 * Helper to emit a file.
 * @param program TypeSpec Program
 * @param options File Emitter options
 */
async function emitFile(program, options) {
    // ensure path exists
    const outputFolder = getDirectoryPath(options.path);
    await program.host.mkdirp(outputFolder);
    const content = options.newLine && options.newLine === "crlf"
        ? options.content.replace(/(\r\n|\n|\r)/gm, "\r\n")
        : options.content;
    return await program.host.writeFile(options.path, content);
}

function parse$1(text, options) {
    const result = parse$2(text, { comments: true, docs: true });
    flattenNamespaces(result);
    const errors = result.parseDiagnostics.filter((x) => x.severity === "error");
    if (errors.length > 0 && !result.printable) {
        throw new PrettierParserError(errors[0]);
    }
    // Remove doc comments as those are handled directly.
    mutate(result).comments = result.comments.filter((x) => !(x.kind === SyntaxKind.BlockComment && x.parsedAsDocs));
    return result;
}
/**
 * We are patching the syntax tree to flatten the namespace nodes that are created from namespace Foo.Bar; which have the same pos, end
 * This causes prettier to not know where comments belong.
 * https://github.com/microsoft/typespec/pull/2061
 */
function flattenNamespaces(base) {
    visitChildren(base, (node) => {
        if (node.kind === SyntaxKind.NamespaceStatement) {
            let current = node;
            const ids = [node.id];
            while (current.statements && "kind" in current.statements) {
                current = current.statements;
                ids.push(current.id);
            }
            Object.assign(node, current, {
                ids,
            });
            flattenNamespaces(current);
        }
    });
}
class PrettierParserError extends Error {
    constructor(error) {
        var _a, _b;
        super(error.message);
        this.error = error;
        const location = getSourceLocation(error.target);
        this.loc = {
            start: (_a = location === null || location === void 0 ? void 0 : location.pos) !== null && _a !== void 0 ? _a : 0,
            end: (_b = location === null || location === void 0 ? void 0 : location.end) !== null && _b !== void 0 ? _b : 0,
        };
    }
}

const defaultOptions = {};
const languages = [
    {
        name: "TypeSpec",
        parsers: ["typespec"],
        extensions: [".tsp", ".cadl"],
        vscodeLanguageIds: ["typespec"],
    },
];
const TypeSpecParser = {
    parse: parse$1,
    astFormat: "typespec-format",
    locStart(node) {
        return node.pos;
    },
    locEnd(node) {
        return node.end;
    },
};
const parsers = {
    typespec: TypeSpecParser,
};
const printers = {
    "typespec-format": typespecPrinter,
};

var formatter = /*#__PURE__*/Object.freeze({
    __proto__: null,
    defaultOptions: defaultOptions,
    languages: languages,
    parsers: parsers,
    printers: printers
});

async function formatTypeSpec(code, prettierConfig) {
    const output = await cu(code, {
        ...prettierConfig,
        parser: "typespec",
        plugins: [formatter],
    });
    return output;
}
/** @deprecated use checkFormatTypeSpec */
const checkFormatCadl = checkFormatTypeSpec;
/**
 * Check the given is correctly formatted.
 * @returns true if code is formatted correctly.
 */
async function checkFormatTypeSpec(code, prettierConfig) {
    return ei(code, {
        ...prettierConfig,
        parser: "typespec",
        plugins: [formatter],
    });
}

function expandConfigVariables(config, expandOptions) {
    var _a;
    const diagnostics = createDiagnosticCollector();
    const builtInVars = {
        "project-root": config.projectRoot,
        cwd: expandOptions.cwd,
    };
    const commonVars = {
        ...builtInVars,
        ...diagnostics.pipe(resolveArgs(config.parameters, expandOptions.args, builtInVars)),
        env: diagnostics.pipe(resolveArgs(config.environmentVariables, expandOptions.env, builtInVars, true)),
    };
    const outputDir = diagnostics.pipe(resolveValue((_a = expandOptions.outputDir) !== null && _a !== void 0 ? _a : config.outputDir, commonVars));
    const result = { ...config, outputDir };
    if (config.options) {
        const options = {};
        for (const [name, emitterOptions] of Object.entries(config.options)) {
            const emitterVars = { ...commonVars, "output-dir": outputDir, "emitter-name": name };
            options[name] = diagnostics.pipe(resolveValues(emitterOptions, emitterVars));
        }
        result.options = options;
    }
    return diagnostics.wrap(result);
}
function resolveArgs(declarations, args, predefinedVariables, allowUnspecified = false) {
    var _a;
    const unmatchedArgs = new Set(Object.keys(args !== null && args !== void 0 ? args : {}));
    const result = {};
    if (declarations !== undefined) {
        for (const [name, definition] of Object.entries(declarations)) {
            unmatchedArgs.delete(name);
            result[name] = ignoreDiagnostics(resolveValue((_a = args === null || args === void 0 ? void 0 : args[name]) !== null && _a !== void 0 ? _a : definition.default, predefinedVariables));
        }
    }
    if (!allowUnspecified) {
        const diagnostics = [...unmatchedArgs].map((unmatchedArg) => {
            return createDiagnostic({
                code: "config-invalid-argument",
                format: { name: unmatchedArg },
                target: NoTarget,
            });
        });
        return [result, diagnostics];
    }
    return [result, []];
}
const VariableInterpolationRegex = /{([a-zA-Z-_.]+)}/g;
function resolveValue(value, predefinedVariables) {
    const [result, diagnostics] = resolveValues({ value }, predefinedVariables);
    return [result.value, diagnostics];
}
function resolveValues(values, predefinedVariables = {}) {
    const diagnostics = [];
    const resolvedValues = {};
    const resolvingValues = new Set();
    function resolveValue(key) {
        resolvingValues.add(key);
        const value = values[key];
        if (!(typeof value === "string")) {
            return value;
        }
        return value.replace(VariableInterpolationRegex, (match, expression) => {
            var _a;
            return (_a = resolveExpression(expression)) !== null && _a !== void 0 ? _a : `{${expression}}`;
        });
    }
    function resolveExpression(expression) {
        if (expression in resolvedValues) {
            return resolvedValues[expression];
        }
        if (resolvingValues.has(expression)) {
            diagnostics.push(createDiagnostic({
                code: "config-circular-variable",
                target: NoTarget,
                format: { name: expression },
            }));
            return undefined;
        }
        if (expression in values) {
            return resolveValue(expression);
        }
        const segments = expression.split(".");
        let resolved = predefinedVariables;
        for (const segment of segments) {
            resolved = resolved[segment];
            if (resolved === undefined) {
                return undefined;
            }
        }
        if (typeof resolved === "string") {
            return resolved;
        }
        else {
            return undefined;
        }
    }
    for (const key of Object.keys(values)) {
        resolvingValues.clear();
        if (key in resolvedValues) {
            continue;
        }
        resolvedValues[key] = resolveValue(key);
    }
    return [resolvedValues, diagnostics];
}

/**
 * Resolve the compiler options for the given entrypoint by resolving the tspconfig.yaml.
 * @param host Compiler host
 * @param compilerOptions
 */
async function resolveCompilerOptions(host, options) {
    var _a;
    const diagnostics = createDiagnosticCollector();
    const entrypointStat = await doIO(host.stat, options.entrypoint, (diag) => diagnostics.add(diag), { allowFileNotFound: true });
    const configPath = (_a = options.configPath) !== null && _a !== void 0 ? _a : ((entrypointStat === null || entrypointStat === void 0 ? void 0 : entrypointStat.isDirectory()) ? options.entrypoint : getDirectoryPath(options.entrypoint));
    const config = await loadTypeSpecConfigForPath(host, configPath, options.configPath !== undefined, options.configPath === undefined);
    config.diagnostics.forEach((x) => diagnostics.add(x));
    const compilerOptions = diagnostics.pipe(resolveOptionsFromConfig(config, options));
    return diagnostics.wrap(compilerOptions);
}
/**
 * Resolve the compiler options from the given raw TypeSpec config
 * @param config TypeSpec config.
 * @param options Options for interpolation in the config.
 * @returns
 */
function resolveOptionsFromConfig(config, options) {
    var _a, _b, _c;
    const cwd = normalizePath(options.cwd);
    const diagnostics = createDiagnosticCollector();
    const configWithOverrides = {
        ...config,
        ...options.overrides,
        options: mergeOptions(config.options, (_a = options.overrides) === null || _a === void 0 ? void 0 : _a.options),
    };
    const expandedConfig = diagnostics.pipe(expandConfigVariables(configWithOverrides, {
        cwd,
        outputDir: (_b = options.overrides) === null || _b === void 0 ? void 0 : _b.outputDir,
        env: (_c = options.env) !== null && _c !== void 0 ? _c : {},
        args: options.args,
    }));
    validateConfigPathsAbsolute(expandedConfig).forEach((x) => diagnostics.add(x));
    const resolvedOptions = omitUndefined({
        outputDir: expandedConfig.outputDir,
        config: config.filename,
        configFile: config,
        additionalImports: expandedConfig["imports"],
        warningAsError: expandedConfig.warnAsError,
        trace: expandedConfig.trace,
        emit: expandedConfig.emit,
        options: expandedConfig.options,
        linterRuleSet: expandedConfig.linter,
    });
    return diagnostics.wrap(resolvedOptions);
}
function mergeOptions(base, overrides) {
    var _a;
    const configuredEmitters = deepClone(base !== null && base !== void 0 ? base : {});
    for (const [emitterName, cliOptionOverride] of Object.entries(overrides !== null && overrides !== void 0 ? overrides : {})) {
        configuredEmitters[emitterName] = {
            ...((_a = configuredEmitters[emitterName]) !== null && _a !== void 0 ? _a : {}),
            ...cliOptionOverride,
        };
    }
    return configuredEmitters;
}

var main$3 = {};

var api$2 = {};

var semanticTokens = {};

var main$2 = {};

var main$1 = {};

var ril = {};

var api$1 = {};

var messages$1 = {};

var is$2 = {};

var hasRequiredIs;

function requireIs () {
	if (hasRequiredIs) return is$2;
	hasRequiredIs = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(is$2, "__esModule", { value: true });
	is$2.stringArray = is$2.array = is$2.func = is$2.error = is$2.number = is$2.string = is$2.boolean = void 0;
	function boolean(value) {
	    return value === true || value === false;
	}
	is$2.boolean = boolean;
	function string(value) {
	    return typeof value === 'string' || value instanceof String;
	}
	is$2.string = string;
	function number(value) {
	    return typeof value === 'number' || value instanceof Number;
	}
	is$2.number = number;
	function error(value) {
	    return value instanceof Error;
	}
	is$2.error = error;
	function func(value) {
	    return typeof value === 'function';
	}
	is$2.func = func;
	function array(value) {
	    return Array.isArray(value);
	}
	is$2.array = array;
	function stringArray(value) {
	    return array(value) && value.every(elem => string(elem));
	}
	is$2.stringArray = stringArray;
	return is$2;
}

var hasRequiredMessages;

function requireMessages () {
	if (hasRequiredMessages) return messages$1;
	hasRequiredMessages = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(messages$1, "__esModule", { value: true });
	messages$1.Message = messages$1.NotificationType9 = messages$1.NotificationType8 = messages$1.NotificationType7 = messages$1.NotificationType6 = messages$1.NotificationType5 = messages$1.NotificationType4 = messages$1.NotificationType3 = messages$1.NotificationType2 = messages$1.NotificationType1 = messages$1.NotificationType0 = messages$1.NotificationType = messages$1.RequestType9 = messages$1.RequestType8 = messages$1.RequestType7 = messages$1.RequestType6 = messages$1.RequestType5 = messages$1.RequestType4 = messages$1.RequestType3 = messages$1.RequestType2 = messages$1.RequestType1 = messages$1.RequestType = messages$1.RequestType0 = messages$1.AbstractMessageSignature = messages$1.ParameterStructures = messages$1.ResponseError = messages$1.ErrorCodes = void 0;
	const is = requireIs();
	/**
	 * Predefined error codes.
	 */
	var ErrorCodes;
	(function (ErrorCodes) {
	    // Defined by JSON RPC
	    ErrorCodes.ParseError = -32700;
	    ErrorCodes.InvalidRequest = -32600;
	    ErrorCodes.MethodNotFound = -32601;
	    ErrorCodes.InvalidParams = -32602;
	    ErrorCodes.InternalError = -32603;
	    /**
	     * This is the start range of JSON RPC reserved error codes.
	     * It doesn't denote a real error code. No application error codes should
	     * be defined between the start and end range. For backwards
	     * compatibility the `ServerNotInitialized` and the `UnknownErrorCode`
	     * are left in the range.
	     *
	     * @since 3.16.0
	    */
	    ErrorCodes.jsonrpcReservedErrorRangeStart = -32099;
	    /** @deprecated use  jsonrpcReservedErrorRangeStart */
	    ErrorCodes.serverErrorStart = -32099;
	    /**
	     * An error occurred when write a message to the transport layer.
	     */
	    ErrorCodes.MessageWriteError = -32099;
	    /**
	     * An error occurred when reading a message from the transport layer.
	     */
	    ErrorCodes.MessageReadError = -32098;
	    /**
	     * The connection got disposed or lost and all pending responses got
	     * rejected.
	     */
	    ErrorCodes.PendingResponseRejected = -32097;
	    /**
	     * The connection is inactive and a use of it failed.
	     */
	    ErrorCodes.ConnectionInactive = -32096;
	    /**
	     * Error code indicating that a server received a notification or
	     * request before the server has received the `initialize` request.
	     */
	    ErrorCodes.ServerNotInitialized = -32002;
	    ErrorCodes.UnknownErrorCode = -32001;
	    /**
	     * This is the end range of JSON RPC reserved error codes.
	     * It doesn't denote a real error code.
	     *
	     * @since 3.16.0
	    */
	    ErrorCodes.jsonrpcReservedErrorRangeEnd = -32000;
	    /** @deprecated use  jsonrpcReservedErrorRangeEnd */
	    ErrorCodes.serverErrorEnd = -32000;
	})(ErrorCodes || (messages$1.ErrorCodes = ErrorCodes = {}));
	/**
	 * An error object return in a response in case a request
	 * has failed.
	 */
	class ResponseError extends Error {
	    constructor(code, message, data) {
	        super(message);
	        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
	        this.data = data;
	        Object.setPrototypeOf(this, ResponseError.prototype);
	    }
	    toJson() {
	        const result = {
	            code: this.code,
	            message: this.message
	        };
	        if (this.data !== undefined) {
	            result.data = this.data;
	        }
	        return result;
	    }
	}
	messages$1.ResponseError = ResponseError;
	class ParameterStructures {
	    constructor(kind) {
	        this.kind = kind;
	    }
	    static is(value) {
	        return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;
	    }
	    toString() {
	        return this.kind;
	    }
	}
	messages$1.ParameterStructures = ParameterStructures;
	/**
	 * The parameter structure is automatically inferred on the number of parameters
	 * and the parameter type in case of a single param.
	 */
	ParameterStructures.auto = new ParameterStructures('auto');
	/**
	 * Forces `byPosition` parameter structure. This is useful if you have a single
	 * parameter which has a literal type.
	 */
	ParameterStructures.byPosition = new ParameterStructures('byPosition');
	/**
	 * Forces `byName` parameter structure. This is only useful when having a single
	 * parameter. The library will report errors if used with a different number of
	 * parameters.
	 */
	ParameterStructures.byName = new ParameterStructures('byName');
	/**
	 * An abstract implementation of a MessageType.
	 */
	class AbstractMessageSignature {
	    constructor(method, numberOfParams) {
	        this.method = method;
	        this.numberOfParams = numberOfParams;
	    }
	    get parameterStructures() {
	        return ParameterStructures.auto;
	    }
	}
	messages$1.AbstractMessageSignature = AbstractMessageSignature;
	/**
	 * Classes to type request response pairs
	 */
	class RequestType0 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 0);
	    }
	}
	messages$1.RequestType0 = RequestType0;
	class RequestType extends AbstractMessageSignature {
	    constructor(method, _parameterStructures = ParameterStructures.auto) {
	        super(method, 1);
	        this._parameterStructures = _parameterStructures;
	    }
	    get parameterStructures() {
	        return this._parameterStructures;
	    }
	}
	messages$1.RequestType = RequestType;
	class RequestType1 extends AbstractMessageSignature {
	    constructor(method, _parameterStructures = ParameterStructures.auto) {
	        super(method, 1);
	        this._parameterStructures = _parameterStructures;
	    }
	    get parameterStructures() {
	        return this._parameterStructures;
	    }
	}
	messages$1.RequestType1 = RequestType1;
	class RequestType2 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 2);
	    }
	}
	messages$1.RequestType2 = RequestType2;
	class RequestType3 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 3);
	    }
	}
	messages$1.RequestType3 = RequestType3;
	class RequestType4 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 4);
	    }
	}
	messages$1.RequestType4 = RequestType4;
	class RequestType5 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 5);
	    }
	}
	messages$1.RequestType5 = RequestType5;
	class RequestType6 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 6);
	    }
	}
	messages$1.RequestType6 = RequestType6;
	class RequestType7 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 7);
	    }
	}
	messages$1.RequestType7 = RequestType7;
	class RequestType8 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 8);
	    }
	}
	messages$1.RequestType8 = RequestType8;
	class RequestType9 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 9);
	    }
	}
	messages$1.RequestType9 = RequestType9;
	class NotificationType extends AbstractMessageSignature {
	    constructor(method, _parameterStructures = ParameterStructures.auto) {
	        super(method, 1);
	        this._parameterStructures = _parameterStructures;
	    }
	    get parameterStructures() {
	        return this._parameterStructures;
	    }
	}
	messages$1.NotificationType = NotificationType;
	class NotificationType0 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 0);
	    }
	}
	messages$1.NotificationType0 = NotificationType0;
	class NotificationType1 extends AbstractMessageSignature {
	    constructor(method, _parameterStructures = ParameterStructures.auto) {
	        super(method, 1);
	        this._parameterStructures = _parameterStructures;
	    }
	    get parameterStructures() {
	        return this._parameterStructures;
	    }
	}
	messages$1.NotificationType1 = NotificationType1;
	class NotificationType2 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 2);
	    }
	}
	messages$1.NotificationType2 = NotificationType2;
	class NotificationType3 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 3);
	    }
	}
	messages$1.NotificationType3 = NotificationType3;
	class NotificationType4 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 4);
	    }
	}
	messages$1.NotificationType4 = NotificationType4;
	class NotificationType5 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 5);
	    }
	}
	messages$1.NotificationType5 = NotificationType5;
	class NotificationType6 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 6);
	    }
	}
	messages$1.NotificationType6 = NotificationType6;
	class NotificationType7 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 7);
	    }
	}
	messages$1.NotificationType7 = NotificationType7;
	class NotificationType8 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 8);
	    }
	}
	messages$1.NotificationType8 = NotificationType8;
	class NotificationType9 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 9);
	    }
	}
	messages$1.NotificationType9 = NotificationType9;
	var Message;
	(function (Message) {
	    /**
	     * Tests if the given message is a request message
	     */
	    function isRequest(message) {
	        const candidate = message;
	        return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
	    }
	    Message.isRequest = isRequest;
	    /**
	     * Tests if the given message is a notification message
	     */
	    function isNotification(message) {
	        const candidate = message;
	        return candidate && is.string(candidate.method) && message.id === void 0;
	    }
	    Message.isNotification = isNotification;
	    /**
	     * Tests if the given message is a response message
	     */
	    function isResponse(message) {
	        const candidate = message;
	        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
	    }
	    Message.isResponse = isResponse;
	})(Message || (messages$1.Message = Message = {}));
	return messages$1;
}

var linkedMap = {};

var hasRequiredLinkedMap;

function requireLinkedMap () {
	if (hasRequiredLinkedMap) return linkedMap;
	hasRequiredLinkedMap = 1;
	/*---------------------------------------------------------------------------------------------
	 *  Copyright (c) Microsoft Corporation. All rights reserved.
	 *  Licensed under the MIT License. See License.txt in the project root for license information.
	 *--------------------------------------------------------------------------------------------*/
	var _a;
	Object.defineProperty(linkedMap, "__esModule", { value: true });
	linkedMap.LRUCache = linkedMap.LinkedMap = linkedMap.Touch = void 0;
	var Touch;
	(function (Touch) {
	    Touch.None = 0;
	    Touch.First = 1;
	    Touch.AsOld = Touch.First;
	    Touch.Last = 2;
	    Touch.AsNew = Touch.Last;
	})(Touch || (linkedMap.Touch = Touch = {}));
	class LinkedMap {
	    constructor() {
	        this[_a] = 'LinkedMap';
	        this._map = new Map();
	        this._head = undefined;
	        this._tail = undefined;
	        this._size = 0;
	        this._state = 0;
	    }
	    clear() {
	        this._map.clear();
	        this._head = undefined;
	        this._tail = undefined;
	        this._size = 0;
	        this._state++;
	    }
	    isEmpty() {
	        return !this._head && !this._tail;
	    }
	    get size() {
	        return this._size;
	    }
	    get first() {
	        return this._head?.value;
	    }
	    get last() {
	        return this._tail?.value;
	    }
	    has(key) {
	        return this._map.has(key);
	    }
	    get(key, touch = Touch.None) {
	        const item = this._map.get(key);
	        if (!item) {
	            return undefined;
	        }
	        if (touch !== Touch.None) {
	            this.touch(item, touch);
	        }
	        return item.value;
	    }
	    set(key, value, touch = Touch.None) {
	        let item = this._map.get(key);
	        if (item) {
	            item.value = value;
	            if (touch !== Touch.None) {
	                this.touch(item, touch);
	            }
	        }
	        else {
	            item = { key, value, next: undefined, previous: undefined };
	            switch (touch) {
	                case Touch.None:
	                    this.addItemLast(item);
	                    break;
	                case Touch.First:
	                    this.addItemFirst(item);
	                    break;
	                case Touch.Last:
	                    this.addItemLast(item);
	                    break;
	                default:
	                    this.addItemLast(item);
	                    break;
	            }
	            this._map.set(key, item);
	            this._size++;
	        }
	        return this;
	    }
	    delete(key) {
	        return !!this.remove(key);
	    }
	    remove(key) {
	        const item = this._map.get(key);
	        if (!item) {
	            return undefined;
	        }
	        this._map.delete(key);
	        this.removeItem(item);
	        this._size--;
	        return item.value;
	    }
	    shift() {
	        if (!this._head && !this._tail) {
	            return undefined;
	        }
	        if (!this._head || !this._tail) {
	            throw new Error('Invalid list');
	        }
	        const item = this._head;
	        this._map.delete(item.key);
	        this.removeItem(item);
	        this._size--;
	        return item.value;
	    }
	    forEach(callbackfn, thisArg) {
	        const state = this._state;
	        let current = this._head;
	        while (current) {
	            if (thisArg) {
	                callbackfn.bind(thisArg)(current.value, current.key, this);
	            }
	            else {
	                callbackfn(current.value, current.key, this);
	            }
	            if (this._state !== state) {
	                throw new Error(`LinkedMap got modified during iteration.`);
	            }
	            current = current.next;
	        }
	    }
	    keys() {
	        const state = this._state;
	        let current = this._head;
	        const iterator = {
	            [Symbol.iterator]: () => {
	                return iterator;
	            },
	            next: () => {
	                if (this._state !== state) {
	                    throw new Error(`LinkedMap got modified during iteration.`);
	                }
	                if (current) {
	                    const result = { value: current.key, done: false };
	                    current = current.next;
	                    return result;
	                }
	                else {
	                    return { value: undefined, done: true };
	                }
	            }
	        };
	        return iterator;
	    }
	    values() {
	        const state = this._state;
	        let current = this._head;
	        const iterator = {
	            [Symbol.iterator]: () => {
	                return iterator;
	            },
	            next: () => {
	                if (this._state !== state) {
	                    throw new Error(`LinkedMap got modified during iteration.`);
	                }
	                if (current) {
	                    const result = { value: current.value, done: false };
	                    current = current.next;
	                    return result;
	                }
	                else {
	                    return { value: undefined, done: true };
	                }
	            }
	        };
	        return iterator;
	    }
	    entries() {
	        const state = this._state;
	        let current = this._head;
	        const iterator = {
	            [Symbol.iterator]: () => {
	                return iterator;
	            },
	            next: () => {
	                if (this._state !== state) {
	                    throw new Error(`LinkedMap got modified during iteration.`);
	                }
	                if (current) {
	                    const result = { value: [current.key, current.value], done: false };
	                    current = current.next;
	                    return result;
	                }
	                else {
	                    return { value: undefined, done: true };
	                }
	            }
	        };
	        return iterator;
	    }
	    [(_a = Symbol.toStringTag, Symbol.iterator)]() {
	        return this.entries();
	    }
	    trimOld(newSize) {
	        if (newSize >= this.size) {
	            return;
	        }
	        if (newSize === 0) {
	            this.clear();
	            return;
	        }
	        let current = this._head;
	        let currentSize = this.size;
	        while (current && currentSize > newSize) {
	            this._map.delete(current.key);
	            current = current.next;
	            currentSize--;
	        }
	        this._head = current;
	        this._size = currentSize;
	        if (current) {
	            current.previous = undefined;
	        }
	        this._state++;
	    }
	    addItemFirst(item) {
	        // First time Insert
	        if (!this._head && !this._tail) {
	            this._tail = item;
	        }
	        else if (!this._head) {
	            throw new Error('Invalid list');
	        }
	        else {
	            item.next = this._head;
	            this._head.previous = item;
	        }
	        this._head = item;
	        this._state++;
	    }
	    addItemLast(item) {
	        // First time Insert
	        if (!this._head && !this._tail) {
	            this._head = item;
	        }
	        else if (!this._tail) {
	            throw new Error('Invalid list');
	        }
	        else {
	            item.previous = this._tail;
	            this._tail.next = item;
	        }
	        this._tail = item;
	        this._state++;
	    }
	    removeItem(item) {
	        if (item === this._head && item === this._tail) {
	            this._head = undefined;
	            this._tail = undefined;
	        }
	        else if (item === this._head) {
	            // This can only happened if size === 1 which is handle
	            // by the case above.
	            if (!item.next) {
	                throw new Error('Invalid list');
	            }
	            item.next.previous = undefined;
	            this._head = item.next;
	        }
	        else if (item === this._tail) {
	            // This can only happened if size === 1 which is handle
	            // by the case above.
	            if (!item.previous) {
	                throw new Error('Invalid list');
	            }
	            item.previous.next = undefined;
	            this._tail = item.previous;
	        }
	        else {
	            const next = item.next;
	            const previous = item.previous;
	            if (!next || !previous) {
	                throw new Error('Invalid list');
	            }
	            next.previous = previous;
	            previous.next = next;
	        }
	        item.next = undefined;
	        item.previous = undefined;
	        this._state++;
	    }
	    touch(item, touch) {
	        if (!this._head || !this._tail) {
	            throw new Error('Invalid list');
	        }
	        if ((touch !== Touch.First && touch !== Touch.Last)) {
	            return;
	        }
	        if (touch === Touch.First) {
	            if (item === this._head) {
	                return;
	            }
	            const next = item.next;
	            const previous = item.previous;
	            // Unlink the item
	            if (item === this._tail) {
	                // previous must be defined since item was not head but is tail
	                // So there are more than on item in the map
	                previous.next = undefined;
	                this._tail = previous;
	            }
	            else {
	                // Both next and previous are not undefined since item was neither head nor tail.
	                next.previous = previous;
	                previous.next = next;
	            }
	            // Insert the node at head
	            item.previous = undefined;
	            item.next = this._head;
	            this._head.previous = item;
	            this._head = item;
	            this._state++;
	        }
	        else if (touch === Touch.Last) {
	            if (item === this._tail) {
	                return;
	            }
	            const next = item.next;
	            const previous = item.previous;
	            // Unlink the item.
	            if (item === this._head) {
	                // next must be defined since item was not tail but is head
	                // So there are more than on item in the map
	                next.previous = undefined;
	                this._head = next;
	            }
	            else {
	                // Both next and previous are not undefined since item was neither head nor tail.
	                next.previous = previous;
	                previous.next = next;
	            }
	            item.next = undefined;
	            item.previous = this._tail;
	            this._tail.next = item;
	            this._tail = item;
	            this._state++;
	        }
	    }
	    toJSON() {
	        const data = [];
	        this.forEach((value, key) => {
	            data.push([key, value]);
	        });
	        return data;
	    }
	    fromJSON(data) {
	        this.clear();
	        for (const [key, value] of data) {
	            this.set(key, value);
	        }
	    }
	}
	linkedMap.LinkedMap = LinkedMap;
	class LRUCache extends LinkedMap {
	    constructor(limit, ratio = 1) {
	        super();
	        this._limit = limit;
	        this._ratio = Math.min(Math.max(0, ratio), 1);
	    }
	    get limit() {
	        return this._limit;
	    }
	    set limit(limit) {
	        this._limit = limit;
	        this.checkTrim();
	    }
	    get ratio() {
	        return this._ratio;
	    }
	    set ratio(ratio) {
	        this._ratio = Math.min(Math.max(0, ratio), 1);
	        this.checkTrim();
	    }
	    get(key, touch = Touch.AsNew) {
	        return super.get(key, touch);
	    }
	    peek(key) {
	        return super.get(key, Touch.None);
	    }
	    set(key, value) {
	        super.set(key, value, Touch.Last);
	        this.checkTrim();
	        return this;
	    }
	    checkTrim() {
	        if (this.size > this._limit) {
	            this.trimOld(Math.round(this._limit * this._ratio));
	        }
	    }
	}
	linkedMap.LRUCache = LRUCache;
	return linkedMap;
}

var disposable = {};

var hasRequiredDisposable;

function requireDisposable () {
	if (hasRequiredDisposable) return disposable;
	hasRequiredDisposable = 1;
	/*---------------------------------------------------------------------------------------------
	 *  Copyright (c) Microsoft Corporation. All rights reserved.
	 *  Licensed under the MIT License. See License.txt in the project root for license information.
	 *--------------------------------------------------------------------------------------------*/
	Object.defineProperty(disposable, "__esModule", { value: true });
	disposable.Disposable = void 0;
	var Disposable;
	(function (Disposable) {
	    function create(func) {
	        return {
	            dispose: func
	        };
	    }
	    Disposable.create = create;
	})(Disposable || (disposable.Disposable = Disposable = {}));
	return disposable;
}

var events = {};

var ral = {};

var hasRequiredRal;

function requireRal () {
	if (hasRequiredRal) return ral;
	hasRequiredRal = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(ral, "__esModule", { value: true });
	let _ral;
	function RAL() {
	    if (_ral === undefined) {
	        throw new Error(`No runtime abstraction layer installed`);
	    }
	    return _ral;
	}
	(function (RAL) {
	    function install(ral) {
	        if (ral === undefined) {
	            throw new Error(`No runtime abstraction layer provided`);
	        }
	        _ral = ral;
	    }
	    RAL.install = install;
	})(RAL || (RAL = {}));
	ral.default = RAL;
	return ral;
}

var hasRequiredEvents;

function requireEvents () {
	if (hasRequiredEvents) return events;
	hasRequiredEvents = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(events, "__esModule", { value: true });
	events.Emitter = events.Event = void 0;
	const ral_1 = requireRal();
	var Event;
	(function (Event) {
	    const _disposable = { dispose() { } };
	    Event.None = function () { return _disposable; };
	})(Event || (events.Event = Event = {}));
	class CallbackList {
	    add(callback, context = null, bucket) {
	        if (!this._callbacks) {
	            this._callbacks = [];
	            this._contexts = [];
	        }
	        this._callbacks.push(callback);
	        this._contexts.push(context);
	        if (Array.isArray(bucket)) {
	            bucket.push({ dispose: () => this.remove(callback, context) });
	        }
	    }
	    remove(callback, context = null) {
	        if (!this._callbacks) {
	            return;
	        }
	        let foundCallbackWithDifferentContext = false;
	        for (let i = 0, len = this._callbacks.length; i < len; i++) {
	            if (this._callbacks[i] === callback) {
	                if (this._contexts[i] === context) {
	                    // callback & context match => remove it
	                    this._callbacks.splice(i, 1);
	                    this._contexts.splice(i, 1);
	                    return;
	                }
	                else {
	                    foundCallbackWithDifferentContext = true;
	                }
	            }
	        }
	        if (foundCallbackWithDifferentContext) {
	            throw new Error('When adding a listener with a context, you should remove it with the same context');
	        }
	    }
	    invoke(...args) {
	        if (!this._callbacks) {
	            return [];
	        }
	        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
	        for (let i = 0, len = callbacks.length; i < len; i++) {
	            try {
	                ret.push(callbacks[i].apply(contexts[i], args));
	            }
	            catch (e) {
	                // eslint-disable-next-line no-console
	                (0, ral_1.default)().console.error(e);
	            }
	        }
	        return ret;
	    }
	    isEmpty() {
	        return !this._callbacks || this._callbacks.length === 0;
	    }
	    dispose() {
	        this._callbacks = undefined;
	        this._contexts = undefined;
	    }
	}
	class Emitter {
	    constructor(_options) {
	        this._options = _options;
	    }
	    /**
	     * For the public to allow to subscribe
	     * to events from this Emitter
	     */
	    get event() {
	        if (!this._event) {
	            this._event = (listener, thisArgs, disposables) => {
	                if (!this._callbacks) {
	                    this._callbacks = new CallbackList();
	                }
	                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
	                    this._options.onFirstListenerAdd(this);
	                }
	                this._callbacks.add(listener, thisArgs);
	                const result = {
	                    dispose: () => {
	                        if (!this._callbacks) {
	                            // disposable is disposed after emitter is disposed.
	                            return;
	                        }
	                        this._callbacks.remove(listener, thisArgs);
	                        result.dispose = Emitter._noop;
	                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
	                            this._options.onLastListenerRemove(this);
	                        }
	                    }
	                };
	                if (Array.isArray(disposables)) {
	                    disposables.push(result);
	                }
	                return result;
	            };
	        }
	        return this._event;
	    }
	    /**
	     * To be kept private to fire an event to
	     * subscribers
	     */
	    fire(event) {
	        if (this._callbacks) {
	            this._callbacks.invoke.call(this._callbacks, event);
	        }
	    }
	    dispose() {
	        if (this._callbacks) {
	            this._callbacks.dispose();
	            this._callbacks = undefined;
	        }
	    }
	}
	events.Emitter = Emitter;
	Emitter._noop = function () { };
	return events;
}

var cancellation = {};

var hasRequiredCancellation;

function requireCancellation () {
	if (hasRequiredCancellation) return cancellation;
	hasRequiredCancellation = 1;
	/*---------------------------------------------------------------------------------------------
	 *  Copyright (c) Microsoft Corporation. All rights reserved.
	 *  Licensed under the MIT License. See License.txt in the project root for license information.
	 *--------------------------------------------------------------------------------------------*/
	Object.defineProperty(cancellation, "__esModule", { value: true });
	cancellation.CancellationTokenSource = cancellation.CancellationToken = void 0;
	const ral_1 = requireRal();
	const Is = requireIs();
	const events_1 = requireEvents();
	var CancellationToken;
	(function (CancellationToken) {
	    CancellationToken.None = Object.freeze({
	        isCancellationRequested: false,
	        onCancellationRequested: events_1.Event.None
	    });
	    CancellationToken.Cancelled = Object.freeze({
	        isCancellationRequested: true,
	        onCancellationRequested: events_1.Event.None
	    });
	    function is(value) {
	        const candidate = value;
	        return candidate && (candidate === CancellationToken.None
	            || candidate === CancellationToken.Cancelled
	            || (Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested));
	    }
	    CancellationToken.is = is;
	})(CancellationToken || (cancellation.CancellationToken = CancellationToken = {}));
	const shortcutEvent = Object.freeze(function (callback, context) {
	    const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
	    return { dispose() { handle.dispose(); } };
	});
	class MutableToken {
	    constructor() {
	        this._isCancelled = false;
	    }
	    cancel() {
	        if (!this._isCancelled) {
	            this._isCancelled = true;
	            if (this._emitter) {
	                this._emitter.fire(undefined);
	                this.dispose();
	            }
	        }
	    }
	    get isCancellationRequested() {
	        return this._isCancelled;
	    }
	    get onCancellationRequested() {
	        if (this._isCancelled) {
	            return shortcutEvent;
	        }
	        if (!this._emitter) {
	            this._emitter = new events_1.Emitter();
	        }
	        return this._emitter.event;
	    }
	    dispose() {
	        if (this._emitter) {
	            this._emitter.dispose();
	            this._emitter = undefined;
	        }
	    }
	}
	class CancellationTokenSource {
	    get token() {
	        if (!this._token) {
	            // be lazy and create the token only when
	            // actually needed
	            this._token = new MutableToken();
	        }
	        return this._token;
	    }
	    cancel() {
	        if (!this._token) {
	            // save an object by returning the default
	            // cancelled token when cancellation happens
	            // before someone asks for the token
	            this._token = CancellationToken.Cancelled;
	        }
	        else {
	            this._token.cancel();
	        }
	    }
	    dispose() {
	        if (!this._token) {
	            // ensure to initialize with an empty token if we had none
	            this._token = CancellationToken.None;
	        }
	        else if (this._token instanceof MutableToken) {
	            // actually dispose
	            this._token.dispose();
	        }
	    }
	}
	cancellation.CancellationTokenSource = CancellationTokenSource;
	return cancellation;
}

var sharedArrayCancellation = {};

var hasRequiredSharedArrayCancellation;

function requireSharedArrayCancellation () {
	if (hasRequiredSharedArrayCancellation) return sharedArrayCancellation;
	hasRequiredSharedArrayCancellation = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(sharedArrayCancellation, "__esModule", { value: true });
	sharedArrayCancellation.SharedArrayReceiverStrategy = sharedArrayCancellation.SharedArraySenderStrategy = void 0;
	const cancellation_1 = requireCancellation();
	var CancellationState;
	(function (CancellationState) {
	    CancellationState.Continue = 0;
	    CancellationState.Cancelled = 1;
	})(CancellationState || (CancellationState = {}));
	class SharedArraySenderStrategy {
	    constructor() {
	        this.buffers = new Map();
	    }
	    enableCancellation(request) {
	        if (request.id === null) {
	            return;
	        }
	        const buffer = new SharedArrayBuffer(4);
	        const data = new Int32Array(buffer, 0, 1);
	        data[0] = CancellationState.Continue;
	        this.buffers.set(request.id, buffer);
	        request.$cancellationData = buffer;
	    }
	    async sendCancellation(_conn, id) {
	        const buffer = this.buffers.get(id);
	        if (buffer === undefined) {
	            return;
	        }
	        const data = new Int32Array(buffer, 0, 1);
	        Atomics.store(data, 0, CancellationState.Cancelled);
	    }
	    cleanup(id) {
	        this.buffers.delete(id);
	    }
	    dispose() {
	        this.buffers.clear();
	    }
	}
	sharedArrayCancellation.SharedArraySenderStrategy = SharedArraySenderStrategy;
	class SharedArrayBufferCancellationToken {
	    constructor(buffer) {
	        this.data = new Int32Array(buffer, 0, 1);
	    }
	    get isCancellationRequested() {
	        return Atomics.load(this.data, 0) === CancellationState.Cancelled;
	    }
	    get onCancellationRequested() {
	        throw new Error(`Cancellation over SharedArrayBuffer doesn't support cancellation events`);
	    }
	}
	class SharedArrayBufferCancellationTokenSource {
	    constructor(buffer) {
	        this.token = new SharedArrayBufferCancellationToken(buffer);
	    }
	    cancel() {
	    }
	    dispose() {
	    }
	}
	class SharedArrayReceiverStrategy {
	    constructor() {
	        this.kind = 'request';
	    }
	    createCancellationTokenSource(request) {
	        const buffer = request.$cancellationData;
	        if (buffer === undefined) {
	            return new cancellation_1.CancellationTokenSource();
	        }
	        return new SharedArrayBufferCancellationTokenSource(buffer);
	    }
	}
	sharedArrayCancellation.SharedArrayReceiverStrategy = SharedArrayReceiverStrategy;
	return sharedArrayCancellation;
}

var messageReader = {};

var semaphore = {};

var hasRequiredSemaphore;

function requireSemaphore () {
	if (hasRequiredSemaphore) return semaphore;
	hasRequiredSemaphore = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(semaphore, "__esModule", { value: true });
	semaphore.Semaphore = void 0;
	const ral_1 = requireRal();
	class Semaphore {
	    constructor(capacity = 1) {
	        if (capacity <= 0) {
	            throw new Error('Capacity must be greater than 0');
	        }
	        this._capacity = capacity;
	        this._active = 0;
	        this._waiting = [];
	    }
	    lock(thunk) {
	        return new Promise((resolve, reject) => {
	            this._waiting.push({ thunk, resolve, reject });
	            this.runNext();
	        });
	    }
	    get active() {
	        return this._active;
	    }
	    runNext() {
	        if (this._waiting.length === 0 || this._active === this._capacity) {
	            return;
	        }
	        (0, ral_1.default)().timer.setImmediate(() => this.doRunNext());
	    }
	    doRunNext() {
	        if (this._waiting.length === 0 || this._active === this._capacity) {
	            return;
	        }
	        const next = this._waiting.shift();
	        this._active++;
	        if (this._active > this._capacity) {
	            throw new Error(`To many thunks active`);
	        }
	        try {
	            const result = next.thunk();
	            if (result instanceof Promise) {
	                result.then((value) => {
	                    this._active--;
	                    next.resolve(value);
	                    this.runNext();
	                }, (err) => {
	                    this._active--;
	                    next.reject(err);
	                    this.runNext();
	                });
	            }
	            else {
	                this._active--;
	                next.resolve(result);
	                this.runNext();
	            }
	        }
	        catch (err) {
	            this._active--;
	            next.reject(err);
	            this.runNext();
	        }
	    }
	}
	semaphore.Semaphore = Semaphore;
	return semaphore;
}

var hasRequiredMessageReader;

function requireMessageReader () {
	if (hasRequiredMessageReader) return messageReader;
	hasRequiredMessageReader = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(messageReader, "__esModule", { value: true });
	messageReader.ReadableStreamMessageReader = messageReader.AbstractMessageReader = messageReader.MessageReader = void 0;
	const ral_1 = requireRal();
	const Is = requireIs();
	const events_1 = requireEvents();
	const semaphore_1 = requireSemaphore();
	var MessageReader;
	(function (MessageReader) {
	    function is(value) {
	        let candidate = value;
	        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) &&
	            Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
	    }
	    MessageReader.is = is;
	})(MessageReader || (messageReader.MessageReader = MessageReader = {}));
	class AbstractMessageReader {
	    constructor() {
	        this.errorEmitter = new events_1.Emitter();
	        this.closeEmitter = new events_1.Emitter();
	        this.partialMessageEmitter = new events_1.Emitter();
	    }
	    dispose() {
	        this.errorEmitter.dispose();
	        this.closeEmitter.dispose();
	    }
	    get onError() {
	        return this.errorEmitter.event;
	    }
	    fireError(error) {
	        this.errorEmitter.fire(this.asError(error));
	    }
	    get onClose() {
	        return this.closeEmitter.event;
	    }
	    fireClose() {
	        this.closeEmitter.fire(undefined);
	    }
	    get onPartialMessage() {
	        return this.partialMessageEmitter.event;
	    }
	    firePartialMessage(info) {
	        this.partialMessageEmitter.fire(info);
	    }
	    asError(error) {
	        if (error instanceof Error) {
	            return error;
	        }
	        else {
	            return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
	        }
	    }
	}
	messageReader.AbstractMessageReader = AbstractMessageReader;
	var ResolvedMessageReaderOptions;
	(function (ResolvedMessageReaderOptions) {
	    function fromOptions(options) {
	        let charset;
	        let contentDecoder;
	        const contentDecoders = new Map();
	        let contentTypeDecoder;
	        const contentTypeDecoders = new Map();
	        if (options === undefined || typeof options === 'string') {
	            charset = options ?? 'utf-8';
	        }
	        else {
	            charset = options.charset ?? 'utf-8';
	            if (options.contentDecoder !== undefined) {
	                contentDecoder = options.contentDecoder;
	                contentDecoders.set(contentDecoder.name, contentDecoder);
	            }
	            if (options.contentDecoders !== undefined) {
	                for (const decoder of options.contentDecoders) {
	                    contentDecoders.set(decoder.name, decoder);
	                }
	            }
	            if (options.contentTypeDecoder !== undefined) {
	                contentTypeDecoder = options.contentTypeDecoder;
	                contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
	            }
	            if (options.contentTypeDecoders !== undefined) {
	                for (const decoder of options.contentTypeDecoders) {
	                    contentTypeDecoders.set(decoder.name, decoder);
	                }
	            }
	        }
	        if (contentTypeDecoder === undefined) {
	            contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
	            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
	        }
	        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
	    }
	    ResolvedMessageReaderOptions.fromOptions = fromOptions;
	})(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
	class ReadableStreamMessageReader extends AbstractMessageReader {
	    constructor(readable, options) {
	        super();
	        this.readable = readable;
	        this.options = ResolvedMessageReaderOptions.fromOptions(options);
	        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
	        this._partialMessageTimeout = 10000;
	        this.nextMessageLength = -1;
	        this.messageToken = 0;
	        this.readSemaphore = new semaphore_1.Semaphore(1);
	    }
	    set partialMessageTimeout(timeout) {
	        this._partialMessageTimeout = timeout;
	    }
	    get partialMessageTimeout() {
	        return this._partialMessageTimeout;
	    }
	    listen(callback) {
	        this.nextMessageLength = -1;
	        this.messageToken = 0;
	        this.partialMessageTimer = undefined;
	        this.callback = callback;
	        const result = this.readable.onData((data) => {
	            this.onData(data);
	        });
	        this.readable.onError((error) => this.fireError(error));
	        this.readable.onClose(() => this.fireClose());
	        return result;
	    }
	    onData(data) {
	        try {
	            this.buffer.append(data);
	            while (true) {
	                if (this.nextMessageLength === -1) {
	                    const headers = this.buffer.tryReadHeaders(true);
	                    if (!headers) {
	                        return;
	                    }
	                    const contentLength = headers.get('content-length');
	                    if (!contentLength) {
	                        this.fireError(new Error(`Header must provide a Content-Length property.\n${JSON.stringify(Object.fromEntries(headers))}`));
	                        return;
	                    }
	                    const length = parseInt(contentLength);
	                    if (isNaN(length)) {
	                        this.fireError(new Error(`Content-Length value must be a number. Got ${contentLength}`));
	                        return;
	                    }
	                    this.nextMessageLength = length;
	                }
	                const body = this.buffer.tryReadBody(this.nextMessageLength);
	                if (body === undefined) {
	                    /** We haven't received the full message yet. */
	                    this.setPartialMessageTimer();
	                    return;
	                }
	                this.clearPartialMessageTimer();
	                this.nextMessageLength = -1;
	                // Make sure that we convert one received message after the
	                // other. Otherwise it could happen that a decoding of a second
	                // smaller message finished before the decoding of a first larger
	                // message and then we would deliver the second message first.
	                this.readSemaphore.lock(async () => {
	                    const bytes = this.options.contentDecoder !== undefined
	                        ? await this.options.contentDecoder.decode(body)
	                        : body;
	                    const message = await this.options.contentTypeDecoder.decode(bytes, this.options);
	                    this.callback(message);
	                }).catch((error) => {
	                    this.fireError(error);
	                });
	            }
	        }
	        catch (error) {
	            this.fireError(error);
	        }
	    }
	    clearPartialMessageTimer() {
	        if (this.partialMessageTimer) {
	            this.partialMessageTimer.dispose();
	            this.partialMessageTimer = undefined;
	        }
	    }
	    setPartialMessageTimer() {
	        this.clearPartialMessageTimer();
	        if (this._partialMessageTimeout <= 0) {
	            return;
	        }
	        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout) => {
	            this.partialMessageTimer = undefined;
	            if (token === this.messageToken) {
	                this.firePartialMessage({ messageToken: token, waitingTime: timeout });
	                this.setPartialMessageTimer();
	            }
	        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
	    }
	}
	messageReader.ReadableStreamMessageReader = ReadableStreamMessageReader;
	return messageReader;
}

var messageWriter = {};

var hasRequiredMessageWriter;

function requireMessageWriter () {
	if (hasRequiredMessageWriter) return messageWriter;
	hasRequiredMessageWriter = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(messageWriter, "__esModule", { value: true });
	messageWriter.WriteableStreamMessageWriter = messageWriter.AbstractMessageWriter = messageWriter.MessageWriter = void 0;
	const ral_1 = requireRal();
	const Is = requireIs();
	const semaphore_1 = requireSemaphore();
	const events_1 = requireEvents();
	const ContentLength = 'Content-Length: ';
	const CRLF = '\r\n';
	var MessageWriter;
	(function (MessageWriter) {
	    function is(value) {
	        let candidate = value;
	        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) &&
	            Is.func(candidate.onError) && Is.func(candidate.write);
	    }
	    MessageWriter.is = is;
	})(MessageWriter || (messageWriter.MessageWriter = MessageWriter = {}));
	class AbstractMessageWriter {
	    constructor() {
	        this.errorEmitter = new events_1.Emitter();
	        this.closeEmitter = new events_1.Emitter();
	    }
	    dispose() {
	        this.errorEmitter.dispose();
	        this.closeEmitter.dispose();
	    }
	    get onError() {
	        return this.errorEmitter.event;
	    }
	    fireError(error, message, count) {
	        this.errorEmitter.fire([this.asError(error), message, count]);
	    }
	    get onClose() {
	        return this.closeEmitter.event;
	    }
	    fireClose() {
	        this.closeEmitter.fire(undefined);
	    }
	    asError(error) {
	        if (error instanceof Error) {
	            return error;
	        }
	        else {
	            return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
	        }
	    }
	}
	messageWriter.AbstractMessageWriter = AbstractMessageWriter;
	var ResolvedMessageWriterOptions;
	(function (ResolvedMessageWriterOptions) {
	    function fromOptions(options) {
	        if (options === undefined || typeof options === 'string') {
	            return { charset: options ?? 'utf-8', contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder };
	        }
	        else {
	            return { charset: options.charset ?? 'utf-8', contentEncoder: options.contentEncoder, contentTypeEncoder: options.contentTypeEncoder ?? (0, ral_1.default)().applicationJson.encoder };
	        }
	    }
	    ResolvedMessageWriterOptions.fromOptions = fromOptions;
	})(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
	class WriteableStreamMessageWriter extends AbstractMessageWriter {
	    constructor(writable, options) {
	        super();
	        this.writable = writable;
	        this.options = ResolvedMessageWriterOptions.fromOptions(options);
	        this.errorCount = 0;
	        this.writeSemaphore = new semaphore_1.Semaphore(1);
	        this.writable.onError((error) => this.fireError(error));
	        this.writable.onClose(() => this.fireClose());
	    }
	    async write(msg) {
	        return this.writeSemaphore.lock(async () => {
	            const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
	                if (this.options.contentEncoder !== undefined) {
	                    return this.options.contentEncoder.encode(buffer);
	                }
	                else {
	                    return buffer;
	                }
	            });
	            return payload.then((buffer) => {
	                const headers = [];
	                headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
	                headers.push(CRLF);
	                return this.doWrite(msg, headers, buffer);
	            }, (error) => {
	                this.fireError(error);
	                throw error;
	            });
	        });
	    }
	    async doWrite(msg, headers, data) {
	        try {
	            await this.writable.write(headers.join(''), 'ascii');
	            return this.writable.write(data);
	        }
	        catch (error) {
	            this.handleError(error, msg);
	            return Promise.reject(error);
	        }
	    }
	    handleError(error, msg) {
	        this.errorCount++;
	        this.fireError(error, msg, this.errorCount);
	    }
	    end() {
	        this.writable.end();
	    }
	}
	messageWriter.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
	return messageWriter;
}

var messageBuffer = {};

var hasRequiredMessageBuffer;

function requireMessageBuffer () {
	if (hasRequiredMessageBuffer) return messageBuffer;
	hasRequiredMessageBuffer = 1;
	/*---------------------------------------------------------------------------------------------
	 *  Copyright (c) Microsoft Corporation. All rights reserved.
	 *  Licensed under the MIT License. See License.txt in the project root for license information.
	 *--------------------------------------------------------------------------------------------*/
	Object.defineProperty(messageBuffer, "__esModule", { value: true });
	messageBuffer.AbstractMessageBuffer = void 0;
	const CR = 13;
	const LF = 10;
	const CRLF = '\r\n';
	class AbstractMessageBuffer {
	    constructor(encoding = 'utf-8') {
	        this._encoding = encoding;
	        this._chunks = [];
	        this._totalLength = 0;
	    }
	    get encoding() {
	        return this._encoding;
	    }
	    append(chunk) {
	        const toAppend = typeof chunk === 'string' ? this.fromString(chunk, this._encoding) : chunk;
	        this._chunks.push(toAppend);
	        this._totalLength += toAppend.byteLength;
	    }
	    tryReadHeaders(lowerCaseKeys = false) {
	        if (this._chunks.length === 0) {
	            return undefined;
	        }
	        let state = 0;
	        let chunkIndex = 0;
	        let offset = 0;
	        let chunkBytesRead = 0;
	        row: while (chunkIndex < this._chunks.length) {
	            const chunk = this._chunks[chunkIndex];
	            offset = 0;
	            while (offset < chunk.length) {
	                const value = chunk[offset];
	                switch (value) {
	                    case CR:
	                        switch (state) {
	                            case 0:
	                                state = 1;
	                                break;
	                            case 2:
	                                state = 3;
	                                break;
	                            default:
	                                state = 0;
	                        }
	                        break;
	                    case LF:
	                        switch (state) {
	                            case 1:
	                                state = 2;
	                                break;
	                            case 3:
	                                state = 4;
	                                offset++;
	                                break row;
	                            default:
	                                state = 0;
	                        }
	                        break;
	                    default:
	                        state = 0;
	                }
	                offset++;
	            }
	            chunkBytesRead += chunk.byteLength;
	            chunkIndex++;
	        }
	        if (state !== 4) {
	            return undefined;
	        }
	        // The buffer contains the two CRLF at the end. So we will
	        // have two empty lines after the split at the end as well.
	        const buffer = this._read(chunkBytesRead + offset);
	        const result = new Map();
	        const headers = this.toString(buffer, 'ascii').split(CRLF);
	        if (headers.length < 2) {
	            return result;
	        }
	        for (let i = 0; i < headers.length - 2; i++) {
	            const header = headers[i];
	            const index = header.indexOf(':');
	            if (index === -1) {
	                throw new Error(`Message header must separate key and value using ':'\n${header}`);
	            }
	            const key = header.substr(0, index);
	            const value = header.substr(index + 1).trim();
	            result.set(lowerCaseKeys ? key.toLowerCase() : key, value);
	        }
	        return result;
	    }
	    tryReadBody(length) {
	        if (this._totalLength < length) {
	            return undefined;
	        }
	        return this._read(length);
	    }
	    get numberOfBytes() {
	        return this._totalLength;
	    }
	    _read(byteCount) {
	        if (byteCount === 0) {
	            return this.emptyBuffer();
	        }
	        if (byteCount > this._totalLength) {
	            throw new Error(`Cannot read so many bytes!`);
	        }
	        if (this._chunks[0].byteLength === byteCount) {
	            // super fast path, precisely first chunk must be returned
	            const chunk = this._chunks[0];
	            this._chunks.shift();
	            this._totalLength -= byteCount;
	            return this.asNative(chunk);
	        }
	        if (this._chunks[0].byteLength > byteCount) {
	            // fast path, the reading is entirely within the first chunk
	            const chunk = this._chunks[0];
	            const result = this.asNative(chunk, byteCount);
	            this._chunks[0] = chunk.slice(byteCount);
	            this._totalLength -= byteCount;
	            return result;
	        }
	        const result = this.allocNative(byteCount);
	        let resultOffset = 0;
	        let chunkIndex = 0;
	        while (byteCount > 0) {
	            const chunk = this._chunks[chunkIndex];
	            if (chunk.byteLength > byteCount) {
	                // this chunk will survive
	                const chunkPart = chunk.slice(0, byteCount);
	                result.set(chunkPart, resultOffset);
	                resultOffset += byteCount;
	                this._chunks[chunkIndex] = chunk.slice(byteCount);
	                this._totalLength -= byteCount;
	                byteCount -= byteCount;
	            }
	            else {
	                // this chunk will be entirely read
	                result.set(chunk, resultOffset);
	                resultOffset += chunk.byteLength;
	                this._chunks.shift();
	                this._totalLength -= chunk.byteLength;
	                byteCount -= chunk.byteLength;
	            }
	        }
	        return result;
	    }
	}
	messageBuffer.AbstractMessageBuffer = AbstractMessageBuffer;
	return messageBuffer;
}

var connection$1 = {};

var hasRequiredConnection;

function requireConnection () {
	if (hasRequiredConnection) return connection$1;
	hasRequiredConnection = 1;
	(function (exports) {
		/* --------------------------------------------------------------------------------------------
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License. See License.txt in the project root for license information.
		 * ------------------------------------------------------------------------------------------ */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.createMessageConnection = exports.ConnectionOptions = exports.MessageStrategy = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.RequestCancellationReceiverStrategy = exports.IdCancellationReceiverStrategy = exports.ConnectionStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = exports.NullLogger = exports.ProgressType = exports.ProgressToken = void 0;
		const ral_1 = requireRal();
		const Is = requireIs();
		const messages_1 = requireMessages();
		const linkedMap_1 = requireLinkedMap();
		const events_1 = requireEvents();
		const cancellation_1 = requireCancellation();
		var CancelNotification;
		(function (CancelNotification) {
		    CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');
		})(CancelNotification || (CancelNotification = {}));
		var ProgressToken;
		(function (ProgressToken) {
		    function is(value) {
		        return typeof value === 'string' || typeof value === 'number';
		    }
		    ProgressToken.is = is;
		})(ProgressToken || (exports.ProgressToken = ProgressToken = {}));
		var ProgressNotification;
		(function (ProgressNotification) {
		    ProgressNotification.type = new messages_1.NotificationType('$/progress');
		})(ProgressNotification || (ProgressNotification = {}));
		class ProgressType {
		    constructor() {
		    }
		}
		exports.ProgressType = ProgressType;
		var StarRequestHandler;
		(function (StarRequestHandler) {
		    function is(value) {
		        return Is.func(value);
		    }
		    StarRequestHandler.is = is;
		})(StarRequestHandler || (StarRequestHandler = {}));
		exports.NullLogger = Object.freeze({
		    error: () => { },
		    warn: () => { },
		    info: () => { },
		    log: () => { }
		});
		var Trace;
		(function (Trace) {
		    Trace[Trace["Off"] = 0] = "Off";
		    Trace[Trace["Messages"] = 1] = "Messages";
		    Trace[Trace["Compact"] = 2] = "Compact";
		    Trace[Trace["Verbose"] = 3] = "Verbose";
		})(Trace || (exports.Trace = Trace = {}));
		var TraceValues;
		(function (TraceValues) {
		    /**
		     * Turn tracing off.
		     */
		    TraceValues.Off = 'off';
		    /**
		     * Trace messages only.
		     */
		    TraceValues.Messages = 'messages';
		    /**
		     * Compact message tracing.
		     */
		    TraceValues.Compact = 'compact';
		    /**
		     * Verbose message tracing.
		     */
		    TraceValues.Verbose = 'verbose';
		})(TraceValues || (exports.TraceValues = TraceValues = {}));
		(function (Trace) {
		    function fromString(value) {
		        if (!Is.string(value)) {
		            return Trace.Off;
		        }
		        value = value.toLowerCase();
		        switch (value) {
		            case 'off':
		                return Trace.Off;
		            case 'messages':
		                return Trace.Messages;
		            case 'compact':
		                return Trace.Compact;
		            case 'verbose':
		                return Trace.Verbose;
		            default:
		                return Trace.Off;
		        }
		    }
		    Trace.fromString = fromString;
		    function toString(value) {
		        switch (value) {
		            case Trace.Off:
		                return 'off';
		            case Trace.Messages:
		                return 'messages';
		            case Trace.Compact:
		                return 'compact';
		            case Trace.Verbose:
		                return 'verbose';
		            default:
		                return 'off';
		        }
		    }
		    Trace.toString = toString;
		})(Trace || (exports.Trace = Trace = {}));
		var TraceFormat;
		(function (TraceFormat) {
		    TraceFormat["Text"] = "text";
		    TraceFormat["JSON"] = "json";
		})(TraceFormat || (exports.TraceFormat = TraceFormat = {}));
		(function (TraceFormat) {
		    function fromString(value) {
		        if (!Is.string(value)) {
		            return TraceFormat.Text;
		        }
		        value = value.toLowerCase();
		        if (value === 'json') {
		            return TraceFormat.JSON;
		        }
		        else {
		            return TraceFormat.Text;
		        }
		    }
		    TraceFormat.fromString = fromString;
		})(TraceFormat || (exports.TraceFormat = TraceFormat = {}));
		var SetTraceNotification;
		(function (SetTraceNotification) {
		    SetTraceNotification.type = new messages_1.NotificationType('$/setTrace');
		})(SetTraceNotification || (exports.SetTraceNotification = SetTraceNotification = {}));
		var LogTraceNotification;
		(function (LogTraceNotification) {
		    LogTraceNotification.type = new messages_1.NotificationType('$/logTrace');
		})(LogTraceNotification || (exports.LogTraceNotification = LogTraceNotification = {}));
		var ConnectionErrors;
		(function (ConnectionErrors) {
		    /**
		     * The connection is closed.
		     */
		    ConnectionErrors[ConnectionErrors["Closed"] = 1] = "Closed";
		    /**
		     * The connection got disposed.
		     */
		    ConnectionErrors[ConnectionErrors["Disposed"] = 2] = "Disposed";
		    /**
		     * The connection is already in listening mode.
		     */
		    ConnectionErrors[ConnectionErrors["AlreadyListening"] = 3] = "AlreadyListening";
		})(ConnectionErrors || (exports.ConnectionErrors = ConnectionErrors = {}));
		class ConnectionError extends Error {
		    constructor(code, message) {
		        super(message);
		        this.code = code;
		        Object.setPrototypeOf(this, ConnectionError.prototype);
		    }
		}
		exports.ConnectionError = ConnectionError;
		var ConnectionStrategy;
		(function (ConnectionStrategy) {
		    function is(value) {
		        const candidate = value;
		        return candidate && Is.func(candidate.cancelUndispatched);
		    }
		    ConnectionStrategy.is = is;
		})(ConnectionStrategy || (exports.ConnectionStrategy = ConnectionStrategy = {}));
		var IdCancellationReceiverStrategy;
		(function (IdCancellationReceiverStrategy) {
		    function is(value) {
		        const candidate = value;
		        return candidate && (candidate.kind === undefined || candidate.kind === 'id') && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === undefined || Is.func(candidate.dispose));
		    }
		    IdCancellationReceiverStrategy.is = is;
		})(IdCancellationReceiverStrategy || (exports.IdCancellationReceiverStrategy = IdCancellationReceiverStrategy = {}));
		var RequestCancellationReceiverStrategy;
		(function (RequestCancellationReceiverStrategy) {
		    function is(value) {
		        const candidate = value;
		        return candidate && candidate.kind === 'request' && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === undefined || Is.func(candidate.dispose));
		    }
		    RequestCancellationReceiverStrategy.is = is;
		})(RequestCancellationReceiverStrategy || (exports.RequestCancellationReceiverStrategy = RequestCancellationReceiverStrategy = {}));
		var CancellationReceiverStrategy;
		(function (CancellationReceiverStrategy) {
		    CancellationReceiverStrategy.Message = Object.freeze({
		        createCancellationTokenSource(_) {
		            return new cancellation_1.CancellationTokenSource();
		        }
		    });
		    function is(value) {
		        return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);
		    }
		    CancellationReceiverStrategy.is = is;
		})(CancellationReceiverStrategy || (exports.CancellationReceiverStrategy = CancellationReceiverStrategy = {}));
		var CancellationSenderStrategy;
		(function (CancellationSenderStrategy) {
		    CancellationSenderStrategy.Message = Object.freeze({
		        sendCancellation(conn, id) {
		            return conn.sendNotification(CancelNotification.type, { id });
		        },
		        cleanup(_) { }
		    });
		    function is(value) {
		        const candidate = value;
		        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
		    }
		    CancellationSenderStrategy.is = is;
		})(CancellationSenderStrategy || (exports.CancellationSenderStrategy = CancellationSenderStrategy = {}));
		var CancellationStrategy;
		(function (CancellationStrategy) {
		    CancellationStrategy.Message = Object.freeze({
		        receiver: CancellationReceiverStrategy.Message,
		        sender: CancellationSenderStrategy.Message
		    });
		    function is(value) {
		        const candidate = value;
		        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
		    }
		    CancellationStrategy.is = is;
		})(CancellationStrategy || (exports.CancellationStrategy = CancellationStrategy = {}));
		var MessageStrategy;
		(function (MessageStrategy) {
		    function is(value) {
		        const candidate = value;
		        return candidate && Is.func(candidate.handleMessage);
		    }
		    MessageStrategy.is = is;
		})(MessageStrategy || (exports.MessageStrategy = MessageStrategy = {}));
		var ConnectionOptions;
		(function (ConnectionOptions) {
		    function is(value) {
		        const candidate = value;
		        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));
		    }
		    ConnectionOptions.is = is;
		})(ConnectionOptions || (exports.ConnectionOptions = ConnectionOptions = {}));
		var ConnectionState;
		(function (ConnectionState) {
		    ConnectionState[ConnectionState["New"] = 1] = "New";
		    ConnectionState[ConnectionState["Listening"] = 2] = "Listening";
		    ConnectionState[ConnectionState["Closed"] = 3] = "Closed";
		    ConnectionState[ConnectionState["Disposed"] = 4] = "Disposed";
		})(ConnectionState || (ConnectionState = {}));
		function createMessageConnection(messageReader, messageWriter, _logger, options) {
		    const logger = _logger !== undefined ? _logger : exports.NullLogger;
		    let sequenceNumber = 0;
		    let notificationSequenceNumber = 0;
		    let unknownResponseSequenceNumber = 0;
		    const version = '2.0';
		    let starRequestHandler = undefined;
		    const requestHandlers = new Map();
		    let starNotificationHandler = undefined;
		    const notificationHandlers = new Map();
		    const progressHandlers = new Map();
		    let timer;
		    let messageQueue = new linkedMap_1.LinkedMap();
		    let responsePromises = new Map();
		    let knownCanceledRequests = new Set();
		    let requestTokens = new Map();
		    let trace = Trace.Off;
		    let traceFormat = TraceFormat.Text;
		    let tracer;
		    let state = ConnectionState.New;
		    const errorEmitter = new events_1.Emitter();
		    const closeEmitter = new events_1.Emitter();
		    const unhandledNotificationEmitter = new events_1.Emitter();
		    const unhandledProgressEmitter = new events_1.Emitter();
		    const disposeEmitter = new events_1.Emitter();
		    const cancellationStrategy = (options && options.cancellationStrategy) ? options.cancellationStrategy : CancellationStrategy.Message;
		    function createRequestQueueKey(id) {
		        if (id === null) {
		            throw new Error(`Can't send requests with id null since the response can't be correlated.`);
		        }
		        return 'req-' + id.toString();
		    }
		    function createResponseQueueKey(id) {
		        if (id === null) {
		            return 'res-unknown-' + (++unknownResponseSequenceNumber).toString();
		        }
		        else {
		            return 'res-' + id.toString();
		        }
		    }
		    function createNotificationQueueKey() {
		        return 'not-' + (++notificationSequenceNumber).toString();
		    }
		    function addMessageToQueue(queue, message) {
		        if (messages_1.Message.isRequest(message)) {
		            queue.set(createRequestQueueKey(message.id), message);
		        }
		        else if (messages_1.Message.isResponse(message)) {
		            queue.set(createResponseQueueKey(message.id), message);
		        }
		        else {
		            queue.set(createNotificationQueueKey(), message);
		        }
		    }
		    function cancelUndispatched(_message) {
		        return undefined;
		    }
		    function isListening() {
		        return state === ConnectionState.Listening;
		    }
		    function isClosed() {
		        return state === ConnectionState.Closed;
		    }
		    function isDisposed() {
		        return state === ConnectionState.Disposed;
		    }
		    function closeHandler() {
		        if (state === ConnectionState.New || state === ConnectionState.Listening) {
		            state = ConnectionState.Closed;
		            closeEmitter.fire(undefined);
		        }
		        // If the connection is disposed don't sent close events.
		    }
		    function readErrorHandler(error) {
		        errorEmitter.fire([error, undefined, undefined]);
		    }
		    function writeErrorHandler(data) {
		        errorEmitter.fire(data);
		    }
		    messageReader.onClose(closeHandler);
		    messageReader.onError(readErrorHandler);
		    messageWriter.onClose(closeHandler);
		    messageWriter.onError(writeErrorHandler);
		    function triggerMessageQueue() {
		        if (timer || messageQueue.size === 0) {
		            return;
		        }
		        timer = (0, ral_1.default)().timer.setImmediate(() => {
		            timer = undefined;
		            processMessageQueue();
		        });
		    }
		    function handleMessage(message) {
		        if (messages_1.Message.isRequest(message)) {
		            handleRequest(message);
		        }
		        else if (messages_1.Message.isNotification(message)) {
		            handleNotification(message);
		        }
		        else if (messages_1.Message.isResponse(message)) {
		            handleResponse(message);
		        }
		        else {
		            handleInvalidMessage(message);
		        }
		    }
		    function processMessageQueue() {
		        if (messageQueue.size === 0) {
		            return;
		        }
		        const message = messageQueue.shift();
		        try {
		            const messageStrategy = options?.messageStrategy;
		            if (MessageStrategy.is(messageStrategy)) {
		                messageStrategy.handleMessage(message, handleMessage);
		            }
		            else {
		                handleMessage(message);
		            }
		        }
		        finally {
		            triggerMessageQueue();
		        }
		    }
		    const callback = (message) => {
		        try {
		            // We have received a cancellation message. Check if the message is still in the queue
		            // and cancel it if allowed to do so.
		            if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
		                const cancelId = message.params.id;
		                const key = createRequestQueueKey(cancelId);
		                const toCancel = messageQueue.get(key);
		                if (messages_1.Message.isRequest(toCancel)) {
		                    const strategy = options?.connectionStrategy;
		                    const response = (strategy && strategy.cancelUndispatched) ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
		                    if (response && (response.error !== undefined || response.result !== undefined)) {
		                        messageQueue.delete(key);
		                        requestTokens.delete(cancelId);
		                        response.id = toCancel.id;
		                        traceSendingResponse(response, message.method, Date.now());
		                        messageWriter.write(response).catch(() => logger.error(`Sending response for canceled message failed.`));
		                        return;
		                    }
		                }
		                const cancellationToken = requestTokens.get(cancelId);
		                // The request is already running. Cancel the token
		                if (cancellationToken !== undefined) {
		                    cancellationToken.cancel();
		                    traceReceivedNotification(message);
		                    return;
		                }
		                else {
		                    // Remember the cancel but still queue the message to
		                    // clean up state in process message.
		                    knownCanceledRequests.add(cancelId);
		                }
		            }
		            addMessageToQueue(messageQueue, message);
		        }
		        finally {
		            triggerMessageQueue();
		        }
		    };
		    function handleRequest(requestMessage) {
		        if (isDisposed()) {
		            // we return here silently since we fired an event when the
		            // connection got disposed.
		            return;
		        }
		        function reply(resultOrError, method, startTime) {
		            const message = {
		                jsonrpc: version,
		                id: requestMessage.id
		            };
		            if (resultOrError instanceof messages_1.ResponseError) {
		                message.error = resultOrError.toJson();
		            }
		            else {
		                message.result = resultOrError === undefined ? null : resultOrError;
		            }
		            traceSendingResponse(message, method, startTime);
		            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
		        }
		        function replyError(error, method, startTime) {
		            const message = {
		                jsonrpc: version,
		                id: requestMessage.id,
		                error: error.toJson()
		            };
		            traceSendingResponse(message, method, startTime);
		            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
		        }
		        function replySuccess(result, method, startTime) {
		            // The JSON RPC defines that a response must either have a result or an error
		            // So we can't treat undefined as a valid response result.
		            if (result === undefined) {
		                result = null;
		            }
		            const message = {
		                jsonrpc: version,
		                id: requestMessage.id,
		                result: result
		            };
		            traceSendingResponse(message, method, startTime);
		            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
		        }
		        traceReceivedRequest(requestMessage);
		        const element = requestHandlers.get(requestMessage.method);
		        let type;
		        let requestHandler;
		        if (element) {
		            type = element.type;
		            requestHandler = element.handler;
		        }
		        const startTime = Date.now();
		        if (requestHandler || starRequestHandler) {
		            const tokenKey = requestMessage.id ?? String(Date.now()); //
		            const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver)
		                ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey)
		                : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);
		            if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
		                cancellationSource.cancel();
		            }
		            if (requestMessage.id !== null) {
		                requestTokens.set(tokenKey, cancellationSource);
		            }
		            try {
		                let handlerResult;
		                if (requestHandler) {
		                    if (requestMessage.params === undefined) {
		                        if (type !== undefined && type.numberOfParams !== 0) {
		                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
		                            return;
		                        }
		                        handlerResult = requestHandler(cancellationSource.token);
		                    }
		                    else if (Array.isArray(requestMessage.params)) {
		                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byName) {
		                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
		                            return;
		                        }
		                        handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
		                    }
		                    else {
		                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
		                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
		                            return;
		                        }
		                        handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
		                    }
		                }
		                else if (starRequestHandler) {
		                    handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
		                }
		                const promise = handlerResult;
		                if (!handlerResult) {
		                    requestTokens.delete(tokenKey);
		                    replySuccess(handlerResult, requestMessage.method, startTime);
		                }
		                else if (promise.then) {
		                    promise.then((resultOrError) => {
		                        requestTokens.delete(tokenKey);
		                        reply(resultOrError, requestMessage.method, startTime);
		                    }, error => {
		                        requestTokens.delete(tokenKey);
		                        if (error instanceof messages_1.ResponseError) {
		                            replyError(error, requestMessage.method, startTime);
		                        }
		                        else if (error && Is.string(error.message)) {
		                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
		                        }
		                        else {
		                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
		                        }
		                    });
		                }
		                else {
		                    requestTokens.delete(tokenKey);
		                    reply(handlerResult, requestMessage.method, startTime);
		                }
		            }
		            catch (error) {
		                requestTokens.delete(tokenKey);
		                if (error instanceof messages_1.ResponseError) {
		                    reply(error, requestMessage.method, startTime);
		                }
		                else if (error && Is.string(error.message)) {
		                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
		                }
		                else {
		                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
		                }
		            }
		        }
		        else {
		            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
		        }
		    }
		    function handleResponse(responseMessage) {
		        if (isDisposed()) {
		            // See handle request.
		            return;
		        }
		        if (responseMessage.id === null) {
		            if (responseMessage.error) {
		                logger.error(`Received response message without id: Error is: \n${JSON.stringify(responseMessage.error, undefined, 4)}`);
		            }
		            else {
		                logger.error(`Received response message without id. No further error information provided.`);
		            }
		        }
		        else {
		            const key = responseMessage.id;
		            const responsePromise = responsePromises.get(key);
		            traceReceivedResponse(responseMessage, responsePromise);
		            if (responsePromise !== undefined) {
		                responsePromises.delete(key);
		                try {
		                    if (responseMessage.error) {
		                        const error = responseMessage.error;
		                        responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
		                    }
		                    else if (responseMessage.result !== undefined) {
		                        responsePromise.resolve(responseMessage.result);
		                    }
		                    else {
		                        throw new Error('Should never happen.');
		                    }
		                }
		                catch (error) {
		                    if (error.message) {
		                        logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
		                    }
		                    else {
		                        logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
		                    }
		                }
		            }
		        }
		    }
		    function handleNotification(message) {
		        if (isDisposed()) {
		            // See handle request.
		            return;
		        }
		        let type = undefined;
		        let notificationHandler;
		        if (message.method === CancelNotification.type.method) {
		            const cancelId = message.params.id;
		            knownCanceledRequests.delete(cancelId);
		            traceReceivedNotification(message);
		            return;
		        }
		        else {
		            const element = notificationHandlers.get(message.method);
		            if (element) {
		                notificationHandler = element.handler;
		                type = element.type;
		            }
		        }
		        if (notificationHandler || starNotificationHandler) {
		            try {
		                traceReceivedNotification(message);
		                if (notificationHandler) {
		                    if (message.params === undefined) {
		                        if (type !== undefined) {
		                            if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
		                                logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
		                            }
		                        }
		                        notificationHandler();
		                    }
		                    else if (Array.isArray(message.params)) {
		                        // There are JSON-RPC libraries that send progress message as positional params although
		                        // specified as named. So convert them if this is the case.
		                        const params = message.params;
		                        if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
		                            notificationHandler({ token: params[0], value: params[1] });
		                        }
		                        else {
		                            if (type !== undefined) {
		                                if (type.parameterStructures === messages_1.ParameterStructures.byName) {
		                                    logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
		                                }
		                                if (type.numberOfParams !== message.params.length) {
		                                    logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
		                                }
		                            }
		                            notificationHandler(...params);
		                        }
		                    }
		                    else {
		                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
		                            logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
		                        }
		                        notificationHandler(message.params);
		                    }
		                }
		                else if (starNotificationHandler) {
		                    starNotificationHandler(message.method, message.params);
		                }
		            }
		            catch (error) {
		                if (error.message) {
		                    logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
		                }
		                else {
		                    logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
		                }
		            }
		        }
		        else {
		            unhandledNotificationEmitter.fire(message);
		        }
		    }
		    function handleInvalidMessage(message) {
		        if (!message) {
		            logger.error('Received empty message.');
		            return;
		        }
		        logger.error(`Received message which is neither a response nor a notification message:\n${JSON.stringify(message, null, 4)}`);
		        // Test whether we find an id to reject the promise
		        const responseMessage = message;
		        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
		            const key = responseMessage.id;
		            const responseHandler = responsePromises.get(key);
		            if (responseHandler) {
		                responseHandler.reject(new Error('The received response has neither a result nor an error property.'));
		            }
		        }
		    }
		    function stringifyTrace(params) {
		        if (params === undefined || params === null) {
		            return undefined;
		        }
		        switch (trace) {
		            case Trace.Verbose:
		                return JSON.stringify(params, null, 4);
		            case Trace.Compact:
		                return JSON.stringify(params);
		            default:
		                return undefined;
		        }
		    }
		    function traceSendingRequest(message) {
		        if (trace === Trace.Off || !tracer) {
		            return;
		        }
		        if (traceFormat === TraceFormat.Text) {
		            let data = undefined;
		            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
		                data = `Params: ${stringifyTrace(message.params)}\n\n`;
		            }
		            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
		        }
		        else {
		            logLSPMessage('send-request', message);
		        }
		    }
		    function traceSendingNotification(message) {
		        if (trace === Trace.Off || !tracer) {
		            return;
		        }
		        if (traceFormat === TraceFormat.Text) {
		            let data = undefined;
		            if (trace === Trace.Verbose || trace === Trace.Compact) {
		                if (message.params) {
		                    data = `Params: ${stringifyTrace(message.params)}\n\n`;
		                }
		                else {
		                    data = 'No parameters provided.\n\n';
		                }
		            }
		            tracer.log(`Sending notification '${message.method}'.`, data);
		        }
		        else {
		            logLSPMessage('send-notification', message);
		        }
		    }
		    function traceSendingResponse(message, method, startTime) {
		        if (trace === Trace.Off || !tracer) {
		            return;
		        }
		        if (traceFormat === TraceFormat.Text) {
		            let data = undefined;
		            if (trace === Trace.Verbose || trace === Trace.Compact) {
		                if (message.error && message.error.data) {
		                    data = `Error data: ${stringifyTrace(message.error.data)}\n\n`;
		                }
		                else {
		                    if (message.result) {
		                        data = `Result: ${stringifyTrace(message.result)}\n\n`;
		                    }
		                    else if (message.error === undefined) {
		                        data = 'No result returned.\n\n';
		                    }
		                }
		            }
		            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
		        }
		        else {
		            logLSPMessage('send-response', message);
		        }
		    }
		    function traceReceivedRequest(message) {
		        if (trace === Trace.Off || !tracer) {
		            return;
		        }
		        if (traceFormat === TraceFormat.Text) {
		            let data = undefined;
		            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
		                data = `Params: ${stringifyTrace(message.params)}\n\n`;
		            }
		            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
		        }
		        else {
		            logLSPMessage('receive-request', message);
		        }
		    }
		    function traceReceivedNotification(message) {
		        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
		            return;
		        }
		        if (traceFormat === TraceFormat.Text) {
		            let data = undefined;
		            if (trace === Trace.Verbose || trace === Trace.Compact) {
		                if (message.params) {
		                    data = `Params: ${stringifyTrace(message.params)}\n\n`;
		                }
		                else {
		                    data = 'No parameters provided.\n\n';
		                }
		            }
		            tracer.log(`Received notification '${message.method}'.`, data);
		        }
		        else {
		            logLSPMessage('receive-notification', message);
		        }
		    }
		    function traceReceivedResponse(message, responsePromise) {
		        if (trace === Trace.Off || !tracer) {
		            return;
		        }
		        if (traceFormat === TraceFormat.Text) {
		            let data = undefined;
		            if (trace === Trace.Verbose || trace === Trace.Compact) {
		                if (message.error && message.error.data) {
		                    data = `Error data: ${stringifyTrace(message.error.data)}\n\n`;
		                }
		                else {
		                    if (message.result) {
		                        data = `Result: ${stringifyTrace(message.result)}\n\n`;
		                    }
		                    else if (message.error === undefined) {
		                        data = 'No result returned.\n\n';
		                    }
		                }
		            }
		            if (responsePromise) {
		                const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';
		                tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
		            }
		            else {
		                tracer.log(`Received response ${message.id} without active response promise.`, data);
		            }
		        }
		        else {
		            logLSPMessage('receive-response', message);
		        }
		    }
		    function logLSPMessage(type, message) {
		        if (!tracer || trace === Trace.Off) {
		            return;
		        }
		        const lspMessage = {
		            isLSPMessage: true,
		            type,
		            message,
		            timestamp: Date.now()
		        };
		        tracer.log(lspMessage);
		    }
		    function throwIfClosedOrDisposed() {
		        if (isClosed()) {
		            throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');
		        }
		        if (isDisposed()) {
		            throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');
		        }
		    }
		    function throwIfListening() {
		        if (isListening()) {
		            throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');
		        }
		    }
		    function throwIfNotListening() {
		        if (!isListening()) {
		            throw new Error('Call listen() first.');
		        }
		    }
		    function undefinedToNull(param) {
		        if (param === undefined) {
		            return null;
		        }
		        else {
		            return param;
		        }
		    }
		    function nullToUndefined(param) {
		        if (param === null) {
		            return undefined;
		        }
		        else {
		            return param;
		        }
		    }
		    function isNamedParam(param) {
		        return param !== undefined && param !== null && !Array.isArray(param) && typeof param === 'object';
		    }
		    function computeSingleParam(parameterStructures, param) {
		        switch (parameterStructures) {
		            case messages_1.ParameterStructures.auto:
		                if (isNamedParam(param)) {
		                    return nullToUndefined(param);
		                }
		                else {
		                    return [undefinedToNull(param)];
		                }
		            case messages_1.ParameterStructures.byName:
		                if (!isNamedParam(param)) {
		                    throw new Error(`Received parameters by name but param is not an object literal.`);
		                }
		                return nullToUndefined(param);
		            case messages_1.ParameterStructures.byPosition:
		                return [undefinedToNull(param)];
		            default:
		                throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
		        }
		    }
		    function computeMessageParams(type, params) {
		        let result;
		        const numberOfParams = type.numberOfParams;
		        switch (numberOfParams) {
		            case 0:
		                result = undefined;
		                break;
		            case 1:
		                result = computeSingleParam(type.parameterStructures, params[0]);
		                break;
		            default:
		                result = [];
		                for (let i = 0; i < params.length && i < numberOfParams; i++) {
		                    result.push(undefinedToNull(params[i]));
		                }
		                if (params.length < numberOfParams) {
		                    for (let i = params.length; i < numberOfParams; i++) {
		                        result.push(null);
		                    }
		                }
		                break;
		        }
		        return result;
		    }
		    const connection = {
		        sendNotification: (type, ...args) => {
		            throwIfClosedOrDisposed();
		            let method;
		            let messageParams;
		            if (Is.string(type)) {
		                method = type;
		                const first = args[0];
		                let paramStart = 0;
		                let parameterStructures = messages_1.ParameterStructures.auto;
		                if (messages_1.ParameterStructures.is(first)) {
		                    paramStart = 1;
		                    parameterStructures = first;
		                }
		                let paramEnd = args.length;
		                const numberOfParams = paramEnd - paramStart;
		                switch (numberOfParams) {
		                    case 0:
		                        messageParams = undefined;
		                        break;
		                    case 1:
		                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
		                        break;
		                    default:
		                        if (parameterStructures === messages_1.ParameterStructures.byName) {
		                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
		                        }
		                        messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));
		                        break;
		                }
		            }
		            else {
		                const params = args;
		                method = type.method;
		                messageParams = computeMessageParams(type, params);
		            }
		            const notificationMessage = {
		                jsonrpc: version,
		                method: method,
		                params: messageParams
		            };
		            traceSendingNotification(notificationMessage);
		            return messageWriter.write(notificationMessage).catch((error) => {
		                logger.error(`Sending notification failed.`);
		                throw error;
		            });
		        },
		        onNotification: (type, handler) => {
		            throwIfClosedOrDisposed();
		            let method;
		            if (Is.func(type)) {
		                starNotificationHandler = type;
		            }
		            else if (handler) {
		                if (Is.string(type)) {
		                    method = type;
		                    notificationHandlers.set(type, { type: undefined, handler });
		                }
		                else {
		                    method = type.method;
		                    notificationHandlers.set(type.method, { type, handler });
		                }
		            }
		            return {
		                dispose: () => {
		                    if (method !== undefined) {
		                        notificationHandlers.delete(method);
		                    }
		                    else {
		                        starNotificationHandler = undefined;
		                    }
		                }
		            };
		        },
		        onProgress: (_type, token, handler) => {
		            if (progressHandlers.has(token)) {
		                throw new Error(`Progress handler for token ${token} already registered`);
		            }
		            progressHandlers.set(token, handler);
		            return {
		                dispose: () => {
		                    progressHandlers.delete(token);
		                }
		            };
		        },
		        sendProgress: (_type, token, value) => {
		            // This should not await but simple return to ensure that we don't have another
		            // async scheduling. Otherwise one send could overtake another send.
		            return connection.sendNotification(ProgressNotification.type, { token, value });
		        },
		        onUnhandledProgress: unhandledProgressEmitter.event,
		        sendRequest: (type, ...args) => {
		            throwIfClosedOrDisposed();
		            throwIfNotListening();
		            let method;
		            let messageParams;
		            let token = undefined;
		            if (Is.string(type)) {
		                method = type;
		                const first = args[0];
		                const last = args[args.length - 1];
		                let paramStart = 0;
		                let parameterStructures = messages_1.ParameterStructures.auto;
		                if (messages_1.ParameterStructures.is(first)) {
		                    paramStart = 1;
		                    parameterStructures = first;
		                }
		                let paramEnd = args.length;
		                if (cancellation_1.CancellationToken.is(last)) {
		                    paramEnd = paramEnd - 1;
		                    token = last;
		                }
		                const numberOfParams = paramEnd - paramStart;
		                switch (numberOfParams) {
		                    case 0:
		                        messageParams = undefined;
		                        break;
		                    case 1:
		                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
		                        break;
		                    default:
		                        if (parameterStructures === messages_1.ParameterStructures.byName) {
		                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
		                        }
		                        messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));
		                        break;
		                }
		            }
		            else {
		                const params = args;
		                method = type.method;
		                messageParams = computeMessageParams(type, params);
		                const numberOfParams = type.numberOfParams;
		                token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;
		            }
		            const id = sequenceNumber++;
		            let disposable;
		            if (token) {
		                disposable = token.onCancellationRequested(() => {
		                    const p = cancellationStrategy.sender.sendCancellation(connection, id);
		                    if (p === undefined) {
		                        logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
		                        return Promise.resolve();
		                    }
		                    else {
		                        return p.catch(() => {
		                            logger.log(`Sending cancellation messages for id ${id} failed`);
		                        });
		                    }
		                });
		            }
		            const requestMessage = {
		                jsonrpc: version,
		                id: id,
		                method: method,
		                params: messageParams
		            };
		            traceSendingRequest(requestMessage);
		            if (typeof cancellationStrategy.sender.enableCancellation === 'function') {
		                cancellationStrategy.sender.enableCancellation(requestMessage);
		            }
		            return new Promise(async (resolve, reject) => {
		                const resolveWithCleanup = (r) => {
		                    resolve(r);
		                    cancellationStrategy.sender.cleanup(id);
		                    disposable?.dispose();
		                };
		                const rejectWithCleanup = (r) => {
		                    reject(r);
		                    cancellationStrategy.sender.cleanup(id);
		                    disposable?.dispose();
		                };
		                const responsePromise = { method: method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
		                try {
		                    await messageWriter.write(requestMessage);
		                    responsePromises.set(id, responsePromise);
		                }
		                catch (error) {
		                    logger.error(`Sending request failed.`);
		                    // Writing the message failed. So we need to reject the promise.
		                    responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error.message ? error.message : 'Unknown reason'));
		                    throw error;
		                }
		            });
		        },
		        onRequest: (type, handler) => {
		            throwIfClosedOrDisposed();
		            let method = null;
		            if (StarRequestHandler.is(type)) {
		                method = undefined;
		                starRequestHandler = type;
		            }
		            else if (Is.string(type)) {
		                method = null;
		                if (handler !== undefined) {
		                    method = type;
		                    requestHandlers.set(type, { handler: handler, type: undefined });
		                }
		            }
		            else {
		                if (handler !== undefined) {
		                    method = type.method;
		                    requestHandlers.set(type.method, { type, handler });
		                }
		            }
		            return {
		                dispose: () => {
		                    if (method === null) {
		                        return;
		                    }
		                    if (method !== undefined) {
		                        requestHandlers.delete(method);
		                    }
		                    else {
		                        starRequestHandler = undefined;
		                    }
		                }
		            };
		        },
		        hasPendingResponse: () => {
		            return responsePromises.size > 0;
		        },
		        trace: async (_value, _tracer, sendNotificationOrTraceOptions) => {
		            let _sendNotification = false;
		            let _traceFormat = TraceFormat.Text;
		            if (sendNotificationOrTraceOptions !== undefined) {
		                if (Is.boolean(sendNotificationOrTraceOptions)) {
		                    _sendNotification = sendNotificationOrTraceOptions;
		                }
		                else {
		                    _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
		                    _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
		                }
		            }
		            trace = _value;
		            traceFormat = _traceFormat;
		            if (trace === Trace.Off) {
		                tracer = undefined;
		            }
		            else {
		                tracer = _tracer;
		            }
		            if (_sendNotification && !isClosed() && !isDisposed()) {
		                await connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
		            }
		        },
		        onError: errorEmitter.event,
		        onClose: closeEmitter.event,
		        onUnhandledNotification: unhandledNotificationEmitter.event,
		        onDispose: disposeEmitter.event,
		        end: () => {
		            messageWriter.end();
		        },
		        dispose: () => {
		            if (isDisposed()) {
		                return;
		            }
		            state = ConnectionState.Disposed;
		            disposeEmitter.fire(undefined);
		            const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, 'Pending response rejected since connection got disposed');
		            for (const promise of responsePromises.values()) {
		                promise.reject(error);
		            }
		            responsePromises = new Map();
		            requestTokens = new Map();
		            knownCanceledRequests = new Set();
		            messageQueue = new linkedMap_1.LinkedMap();
		            // Test for backwards compatibility
		            if (Is.func(messageWriter.dispose)) {
		                messageWriter.dispose();
		            }
		            if (Is.func(messageReader.dispose)) {
		                messageReader.dispose();
		            }
		        },
		        listen: () => {
		            throwIfClosedOrDisposed();
		            throwIfListening();
		            state = ConnectionState.Listening;
		            messageReader.listen(callback);
		        },
		        inspect: () => {
		            // eslint-disable-next-line no-console
		            (0, ral_1.default)().console.log('inspect');
		        }
		    };
		    connection.onNotification(LogTraceNotification.type, (params) => {
		        if (trace === Trace.Off || !tracer) {
		            return;
		        }
		        const verbose = trace === Trace.Verbose || trace === Trace.Compact;
		        tracer.log(params.message, verbose ? params.verbose : undefined);
		    });
		    connection.onNotification(ProgressNotification.type, (params) => {
		        const handler = progressHandlers.get(params.token);
		        if (handler) {
		            handler(params.value);
		        }
		        else {
		            unhandledProgressEmitter.fire(params);
		        }
		    });
		    return connection;
		}
		exports.createMessageConnection = createMessageConnection; 
	} (connection$1));
	return connection$1;
}

var hasRequiredApi;

function requireApi () {
	if (hasRequiredApi) return api$1;
	hasRequiredApi = 1;
	(function (exports) {
		/* --------------------------------------------------------------------------------------------
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License. See License.txt in the project root for license information.
		 * ------------------------------------------------------------------------------------------ */
		/// <reference path="../../typings/thenable.d.ts" />
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.ProgressType = exports.ProgressToken = exports.createMessageConnection = exports.NullLogger = exports.ConnectionOptions = exports.ConnectionStrategy = exports.AbstractMessageBuffer = exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = exports.SharedArrayReceiverStrategy = exports.SharedArraySenderStrategy = exports.CancellationToken = exports.CancellationTokenSource = exports.Emitter = exports.Event = exports.Disposable = exports.LRUCache = exports.Touch = exports.LinkedMap = exports.ParameterStructures = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.ErrorCodes = exports.ResponseError = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType0 = exports.RequestType = exports.Message = exports.RAL = void 0;
		exports.MessageStrategy = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = void 0;
		const messages_1 = requireMessages();
		Object.defineProperty(exports, "Message", { enumerable: true, get: function () { return messages_1.Message; } });
		Object.defineProperty(exports, "RequestType", { enumerable: true, get: function () { return messages_1.RequestType; } });
		Object.defineProperty(exports, "RequestType0", { enumerable: true, get: function () { return messages_1.RequestType0; } });
		Object.defineProperty(exports, "RequestType1", { enumerable: true, get: function () { return messages_1.RequestType1; } });
		Object.defineProperty(exports, "RequestType2", { enumerable: true, get: function () { return messages_1.RequestType2; } });
		Object.defineProperty(exports, "RequestType3", { enumerable: true, get: function () { return messages_1.RequestType3; } });
		Object.defineProperty(exports, "RequestType4", { enumerable: true, get: function () { return messages_1.RequestType4; } });
		Object.defineProperty(exports, "RequestType5", { enumerable: true, get: function () { return messages_1.RequestType5; } });
		Object.defineProperty(exports, "RequestType6", { enumerable: true, get: function () { return messages_1.RequestType6; } });
		Object.defineProperty(exports, "RequestType7", { enumerable: true, get: function () { return messages_1.RequestType7; } });
		Object.defineProperty(exports, "RequestType8", { enumerable: true, get: function () { return messages_1.RequestType8; } });
		Object.defineProperty(exports, "RequestType9", { enumerable: true, get: function () { return messages_1.RequestType9; } });
		Object.defineProperty(exports, "ResponseError", { enumerable: true, get: function () { return messages_1.ResponseError; } });
		Object.defineProperty(exports, "ErrorCodes", { enumerable: true, get: function () { return messages_1.ErrorCodes; } });
		Object.defineProperty(exports, "NotificationType", { enumerable: true, get: function () { return messages_1.NotificationType; } });
		Object.defineProperty(exports, "NotificationType0", { enumerable: true, get: function () { return messages_1.NotificationType0; } });
		Object.defineProperty(exports, "NotificationType1", { enumerable: true, get: function () { return messages_1.NotificationType1; } });
		Object.defineProperty(exports, "NotificationType2", { enumerable: true, get: function () { return messages_1.NotificationType2; } });
		Object.defineProperty(exports, "NotificationType3", { enumerable: true, get: function () { return messages_1.NotificationType3; } });
		Object.defineProperty(exports, "NotificationType4", { enumerable: true, get: function () { return messages_1.NotificationType4; } });
		Object.defineProperty(exports, "NotificationType5", { enumerable: true, get: function () { return messages_1.NotificationType5; } });
		Object.defineProperty(exports, "NotificationType6", { enumerable: true, get: function () { return messages_1.NotificationType6; } });
		Object.defineProperty(exports, "NotificationType7", { enumerable: true, get: function () { return messages_1.NotificationType7; } });
		Object.defineProperty(exports, "NotificationType8", { enumerable: true, get: function () { return messages_1.NotificationType8; } });
		Object.defineProperty(exports, "NotificationType9", { enumerable: true, get: function () { return messages_1.NotificationType9; } });
		Object.defineProperty(exports, "ParameterStructures", { enumerable: true, get: function () { return messages_1.ParameterStructures; } });
		const linkedMap_1 = requireLinkedMap();
		Object.defineProperty(exports, "LinkedMap", { enumerable: true, get: function () { return linkedMap_1.LinkedMap; } });
		Object.defineProperty(exports, "LRUCache", { enumerable: true, get: function () { return linkedMap_1.LRUCache; } });
		Object.defineProperty(exports, "Touch", { enumerable: true, get: function () { return linkedMap_1.Touch; } });
		const disposable_1 = requireDisposable();
		Object.defineProperty(exports, "Disposable", { enumerable: true, get: function () { return disposable_1.Disposable; } });
		const events_1 = requireEvents();
		Object.defineProperty(exports, "Event", { enumerable: true, get: function () { return events_1.Event; } });
		Object.defineProperty(exports, "Emitter", { enumerable: true, get: function () { return events_1.Emitter; } });
		const cancellation_1 = requireCancellation();
		Object.defineProperty(exports, "CancellationTokenSource", { enumerable: true, get: function () { return cancellation_1.CancellationTokenSource; } });
		Object.defineProperty(exports, "CancellationToken", { enumerable: true, get: function () { return cancellation_1.CancellationToken; } });
		const sharedArrayCancellation_1 = requireSharedArrayCancellation();
		Object.defineProperty(exports, "SharedArraySenderStrategy", { enumerable: true, get: function () { return sharedArrayCancellation_1.SharedArraySenderStrategy; } });
		Object.defineProperty(exports, "SharedArrayReceiverStrategy", { enumerable: true, get: function () { return sharedArrayCancellation_1.SharedArrayReceiverStrategy; } });
		const messageReader_1 = requireMessageReader();
		Object.defineProperty(exports, "MessageReader", { enumerable: true, get: function () { return messageReader_1.MessageReader; } });
		Object.defineProperty(exports, "AbstractMessageReader", { enumerable: true, get: function () { return messageReader_1.AbstractMessageReader; } });
		Object.defineProperty(exports, "ReadableStreamMessageReader", { enumerable: true, get: function () { return messageReader_1.ReadableStreamMessageReader; } });
		const messageWriter_1 = requireMessageWriter();
		Object.defineProperty(exports, "MessageWriter", { enumerable: true, get: function () { return messageWriter_1.MessageWriter; } });
		Object.defineProperty(exports, "AbstractMessageWriter", { enumerable: true, get: function () { return messageWriter_1.AbstractMessageWriter; } });
		Object.defineProperty(exports, "WriteableStreamMessageWriter", { enumerable: true, get: function () { return messageWriter_1.WriteableStreamMessageWriter; } });
		const messageBuffer_1 = requireMessageBuffer();
		Object.defineProperty(exports, "AbstractMessageBuffer", { enumerable: true, get: function () { return messageBuffer_1.AbstractMessageBuffer; } });
		const connection_1 = requireConnection();
		Object.defineProperty(exports, "ConnectionStrategy", { enumerable: true, get: function () { return connection_1.ConnectionStrategy; } });
		Object.defineProperty(exports, "ConnectionOptions", { enumerable: true, get: function () { return connection_1.ConnectionOptions; } });
		Object.defineProperty(exports, "NullLogger", { enumerable: true, get: function () { return connection_1.NullLogger; } });
		Object.defineProperty(exports, "createMessageConnection", { enumerable: true, get: function () { return connection_1.createMessageConnection; } });
		Object.defineProperty(exports, "ProgressToken", { enumerable: true, get: function () { return connection_1.ProgressToken; } });
		Object.defineProperty(exports, "ProgressType", { enumerable: true, get: function () { return connection_1.ProgressType; } });
		Object.defineProperty(exports, "Trace", { enumerable: true, get: function () { return connection_1.Trace; } });
		Object.defineProperty(exports, "TraceValues", { enumerable: true, get: function () { return connection_1.TraceValues; } });
		Object.defineProperty(exports, "TraceFormat", { enumerable: true, get: function () { return connection_1.TraceFormat; } });
		Object.defineProperty(exports, "SetTraceNotification", { enumerable: true, get: function () { return connection_1.SetTraceNotification; } });
		Object.defineProperty(exports, "LogTraceNotification", { enumerable: true, get: function () { return connection_1.LogTraceNotification; } });
		Object.defineProperty(exports, "ConnectionErrors", { enumerable: true, get: function () { return connection_1.ConnectionErrors; } });
		Object.defineProperty(exports, "ConnectionError", { enumerable: true, get: function () { return connection_1.ConnectionError; } });
		Object.defineProperty(exports, "CancellationReceiverStrategy", { enumerable: true, get: function () { return connection_1.CancellationReceiverStrategy; } });
		Object.defineProperty(exports, "CancellationSenderStrategy", { enumerable: true, get: function () { return connection_1.CancellationSenderStrategy; } });
		Object.defineProperty(exports, "CancellationStrategy", { enumerable: true, get: function () { return connection_1.CancellationStrategy; } });
		Object.defineProperty(exports, "MessageStrategy", { enumerable: true, get: function () { return connection_1.MessageStrategy; } });
		const ral_1 = requireRal();
		exports.RAL = ral_1.default; 
	} (api$1));
	return api$1;
}

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(ril, "__esModule", { value: true });
const api_1 = requireApi();
class MessageBuffer extends api_1.AbstractMessageBuffer {
    constructor(encoding = 'utf-8') {
        super(encoding);
        this.asciiDecoder = new TextDecoder('ascii');
    }
    emptyBuffer() {
        return MessageBuffer.emptyBuffer;
    }
    fromString(value, _encoding) {
        return (new TextEncoder()).encode(value);
    }
    toString(value, encoding) {
        if (encoding === 'ascii') {
            return this.asciiDecoder.decode(value);
        }
        else {
            return (new TextDecoder(encoding)).decode(value);
        }
    }
    asNative(buffer, length) {
        if (length === undefined) {
            return buffer;
        }
        else {
            return buffer.slice(0, length);
        }
    }
    allocNative(length) {
        return new Uint8Array(length);
    }
}
MessageBuffer.emptyBuffer = new Uint8Array(0);
class ReadableStreamWrapper {
    constructor(socket) {
        this.socket = socket;
        this._onData = new api_1.Emitter();
        this._messageListener = (event) => {
            const blob = event.data;
            blob.arrayBuffer().then((buffer) => {
                this._onData.fire(new Uint8Array(buffer));
            }, () => {
                (0, api_1.RAL)().console.error(`Converting blob to array buffer failed.`);
            });
        };
        this.socket.addEventListener('message', this._messageListener);
    }
    onClose(listener) {
        this.socket.addEventListener('close', listener);
        return api_1.Disposable.create(() => this.socket.removeEventListener('close', listener));
    }
    onError(listener) {
        this.socket.addEventListener('error', listener);
        return api_1.Disposable.create(() => this.socket.removeEventListener('error', listener));
    }
    onEnd(listener) {
        this.socket.addEventListener('end', listener);
        return api_1.Disposable.create(() => this.socket.removeEventListener('end', listener));
    }
    onData(listener) {
        return this._onData.event(listener);
    }
}
class WritableStreamWrapper {
    constructor(socket) {
        this.socket = socket;
    }
    onClose(listener) {
        this.socket.addEventListener('close', listener);
        return api_1.Disposable.create(() => this.socket.removeEventListener('close', listener));
    }
    onError(listener) {
        this.socket.addEventListener('error', listener);
        return api_1.Disposable.create(() => this.socket.removeEventListener('error', listener));
    }
    onEnd(listener) {
        this.socket.addEventListener('end', listener);
        return api_1.Disposable.create(() => this.socket.removeEventListener('end', listener));
    }
    write(data, encoding) {
        if (typeof data === 'string') {
            if (encoding !== undefined && encoding !== 'utf-8') {
                throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${encoding}`);
            }
            this.socket.send(data);
        }
        else {
            this.socket.send(data);
        }
        return Promise.resolve();
    }
    end() {
        this.socket.close();
    }
}
const _textEncoder = new TextEncoder();
const _ril = Object.freeze({
    messageBuffer: Object.freeze({
        create: (encoding) => new MessageBuffer(encoding)
    }),
    applicationJson: Object.freeze({
        encoder: Object.freeze({
            name: 'application/json',
            encode: (msg, options) => {
                if (options.charset !== 'utf-8') {
                    throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${options.charset}`);
                }
                return Promise.resolve(_textEncoder.encode(JSON.stringify(msg, undefined, 0)));
            }
        }),
        decoder: Object.freeze({
            name: 'application/json',
            decode: (buffer, options) => {
                if (!(buffer instanceof Uint8Array)) {
                    throw new Error(`In a Browser environments only Uint8Arrays are supported.`);
                }
                return Promise.resolve(JSON.parse(new TextDecoder(options.charset).decode(buffer)));
            }
        })
    }),
    stream: Object.freeze({
        asReadableStream: (socket) => new ReadableStreamWrapper(socket),
        asWritableStream: (socket) => new WritableStreamWrapper(socket)
    }),
    console: console,
    timer: Object.freeze({
        setTimeout(callback, ms, ...args) {
            const handle = setTimeout(callback, ms, ...args);
            return { dispose: () => clearTimeout(handle) };
        },
        setImmediate(callback, ...args) {
            const handle = setTimeout(callback, 0, ...args);
            return { dispose: () => clearTimeout(handle) };
        },
        setInterval(callback, ms, ...args) {
            const handle = setInterval(callback, ms, ...args);
            return { dispose: () => clearInterval(handle) };
        },
    })
});
function RIL() {
    return _ril;
}
(function (RIL) {
    function install() {
        api_1.RAL.install(_ril);
    }
    RIL.install = install;
})(RIL || (RIL = {}));
ril.default = RIL;

(function (exports) {
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createMessageConnection = exports.BrowserMessageWriter = exports.BrowserMessageReader = void 0;
	const ril_1 = ril;
	// Install the browser runtime abstract.
	ril_1.default.install();
	const api_1 = requireApi();
	__exportStar(requireApi(), exports);
	class BrowserMessageReader extends api_1.AbstractMessageReader {
	    constructor(port) {
	        super();
	        this._onData = new api_1.Emitter();
	        this._messageListener = (event) => {
	            this._onData.fire(event.data);
	        };
	        port.addEventListener('error', (event) => this.fireError(event));
	        port.onmessage = this._messageListener;
	    }
	    listen(callback) {
	        return this._onData.event(callback);
	    }
	}
	exports.BrowserMessageReader = BrowserMessageReader;
	class BrowserMessageWriter extends api_1.AbstractMessageWriter {
	    constructor(port) {
	        super();
	        this.port = port;
	        this.errorCount = 0;
	        port.addEventListener('error', (event) => this.fireError(event));
	    }
	    write(msg) {
	        try {
	            this.port.postMessage(msg);
	            return Promise.resolve();
	        }
	        catch (error) {
	            this.handleError(error, msg);
	            return Promise.reject(error);
	        }
	    }
	    handleError(error, msg) {
	        this.errorCount++;
	        this.fireError(error, msg, this.errorCount);
	    }
	    end() {
	    }
	}
	exports.BrowserMessageWriter = BrowserMessageWriter;
	function createMessageConnection(reader, writer, logger, options) {
	    if (logger === undefined) {
	        logger = api_1.NullLogger;
	    }
	    if (api_1.ConnectionStrategy.is(options)) {
	        options = { connectionStrategy: options };
	    }
	    return (0, api_1.createMessageConnection)(reader, writer, logger, options);
	}
	exports.createMessageConnection = createMessageConnection; 
} (main$1));

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */

var browser$1 = main$1;

var api = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var DocumentUri;
(function (DocumentUri) {
    function is(value) {
        return typeof value === 'string';
    }
    DocumentUri.is = is;
})(DocumentUri || (DocumentUri = {}));
var URI;
(function (URI) {
    function is(value) {
        return typeof value === 'string';
    }
    URI.is = is;
})(URI || (URI = {}));
var integer;
(function (integer) {
    integer.MIN_VALUE = -2147483648;
    integer.MAX_VALUE = 2147483647;
    function is(value) {
        return typeof value === 'number' && integer.MIN_VALUE <= value && value <= integer.MAX_VALUE;
    }
    integer.is = is;
})(integer || (integer = {}));
var uinteger;
(function (uinteger) {
    uinteger.MIN_VALUE = 0;
    uinteger.MAX_VALUE = 2147483647;
    function is(value) {
        return typeof value === 'number' && uinteger.MIN_VALUE <= value && value <= uinteger.MAX_VALUE;
    }
    uinteger.is = is;
})(uinteger || (uinteger = {}));
/**
 * The Position namespace provides helper functions to work with
 * {@link Position} literals.
 */
var Position;
(function (Position) {
    /**
     * Creates a new Position literal from the given line and character.
     * @param line The position's line.
     * @param character The position's character.
     */
    function create(line, character) {
        if (line === Number.MAX_VALUE) {
            line = uinteger.MAX_VALUE;
        }
        if (character === Number.MAX_VALUE) {
            character = uinteger.MAX_VALUE;
        }
        return { line, character };
    }
    Position.create = create;
    /**
     * Checks whether the given literal conforms to the {@link Position} interface.
     */
    function is(value) {
        let candidate = value;
        return Is$4.objectLiteral(candidate) && Is$4.uinteger(candidate.line) && Is$4.uinteger(candidate.character);
    }
    Position.is = is;
})(Position || (Position = {}));
/**
 * The Range namespace provides helper functions to work with
 * {@link Range} literals.
 */
var Range;
(function (Range) {
    function create(one, two, three, four) {
        if (Is$4.uinteger(one) && Is$4.uinteger(two) && Is$4.uinteger(three) && Is$4.uinteger(four)) {
            return { start: Position.create(one, two), end: Position.create(three, four) };
        }
        else if (Position.is(one) && Position.is(two)) {
            return { start: one, end: two };
        }
        else {
            throw new Error(`Range#create called with invalid arguments[${one}, ${two}, ${three}, ${four}]`);
        }
    }
    Range.create = create;
    /**
     * Checks whether the given literal conforms to the {@link Range} interface.
     */
    function is(value) {
        let candidate = value;
        return Is$4.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
    }
    Range.is = is;
})(Range || (Range = {}));
/**
 * The Location namespace provides helper functions to work with
 * {@link Location} literals.
 */
var Location;
(function (Location) {
    /**
     * Creates a Location literal.
     * @param uri The location's uri.
     * @param range The location's range.
     */
    function create(uri, range) {
        return { uri, range };
    }
    Location.create = create;
    /**
     * Checks whether the given literal conforms to the {@link Location} interface.
     */
    function is(value) {
        let candidate = value;
        return Is$4.objectLiteral(candidate) && Range.is(candidate.range) && (Is$4.string(candidate.uri) || Is$4.undefined(candidate.uri));
    }
    Location.is = is;
})(Location || (Location = {}));
/**
 * The LocationLink namespace provides helper functions to work with
 * {@link LocationLink} literals.
 */
var LocationLink;
(function (LocationLink) {
    /**
     * Creates a LocationLink literal.
     * @param targetUri The definition's uri.
     * @param targetRange The full range of the definition.
     * @param targetSelectionRange The span of the symbol definition at the target.
     * @param originSelectionRange The span of the symbol being defined in the originating source file.
     */
    function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
        return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
    }
    LocationLink.create = create;
    /**
     * Checks whether the given literal conforms to the {@link LocationLink} interface.
     */
    function is(value) {
        let candidate = value;
        return Is$4.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is$4.string(candidate.targetUri)
            && Range.is(candidate.targetSelectionRange)
            && (Range.is(candidate.originSelectionRange) || Is$4.undefined(candidate.originSelectionRange));
    }
    LocationLink.is = is;
})(LocationLink || (LocationLink = {}));
/**
 * The Color namespace provides helper functions to work with
 * {@link Color} literals.
 */
var Color;
(function (Color) {
    /**
     * Creates a new Color literal.
     */
    function create(red, green, blue, alpha) {
        return {
            red,
            green,
            blue,
            alpha,
        };
    }
    Color.create = create;
    /**
     * Checks whether the given literal conforms to the {@link Color} interface.
     */
    function is(value) {
        const candidate = value;
        return Is$4.objectLiteral(candidate) && Is$4.numberRange(candidate.red, 0, 1)
            && Is$4.numberRange(candidate.green, 0, 1)
            && Is$4.numberRange(candidate.blue, 0, 1)
            && Is$4.numberRange(candidate.alpha, 0, 1);
    }
    Color.is = is;
})(Color || (Color = {}));
/**
 * The ColorInformation namespace provides helper functions to work with
 * {@link ColorInformation} literals.
 */
var ColorInformation;
(function (ColorInformation) {
    /**
     * Creates a new ColorInformation literal.
     */
    function create(range, color) {
        return {
            range,
            color,
        };
    }
    ColorInformation.create = create;
    /**
     * Checks whether the given literal conforms to the {@link ColorInformation} interface.
     */
    function is(value) {
        const candidate = value;
        return Is$4.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);
    }
    ColorInformation.is = is;
})(ColorInformation || (ColorInformation = {}));
/**
 * The Color namespace provides helper functions to work with
 * {@link ColorPresentation} literals.
 */
var ColorPresentation;
(function (ColorPresentation) {
    /**
     * Creates a new ColorInformation literal.
     */
    function create(label, textEdit, additionalTextEdits) {
        return {
            label,
            textEdit,
            additionalTextEdits,
        };
    }
    ColorPresentation.create = create;
    /**
     * Checks whether the given literal conforms to the {@link ColorInformation} interface.
     */
    function is(value) {
        const candidate = value;
        return Is$4.objectLiteral(candidate) && Is$4.string(candidate.label)
            && (Is$4.undefined(candidate.textEdit) || TextEdit.is(candidate))
            && (Is$4.undefined(candidate.additionalTextEdits) || Is$4.typedArray(candidate.additionalTextEdits, TextEdit.is));
    }
    ColorPresentation.is = is;
})(ColorPresentation || (ColorPresentation = {}));
/**
 * A set of predefined range kinds.
 */
var FoldingRangeKind;
(function (FoldingRangeKind) {
    /**
     * Folding range for a comment
     */
    FoldingRangeKind.Comment = 'comment';
    /**
     * Folding range for an import or include
     */
    FoldingRangeKind.Imports = 'imports';
    /**
     * Folding range for a region (e.g. `#region`)
     */
    FoldingRangeKind.Region = 'region';
})(FoldingRangeKind || (FoldingRangeKind = {}));
/**
 * The folding range namespace provides helper functions to work with
 * {@link FoldingRange} literals.
 */
var FoldingRange;
(function (FoldingRange) {
    /**
     * Creates a new FoldingRange literal.
     */
    function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
        const result = {
            startLine,
            endLine
        };
        if (Is$4.defined(startCharacter)) {
            result.startCharacter = startCharacter;
        }
        if (Is$4.defined(endCharacter)) {
            result.endCharacter = endCharacter;
        }
        if (Is$4.defined(kind)) {
            result.kind = kind;
        }
        if (Is$4.defined(collapsedText)) {
            result.collapsedText = collapsedText;
        }
        return result;
    }
    FoldingRange.create = create;
    /**
     * Checks whether the given literal conforms to the {@link FoldingRange} interface.
     */
    function is(value) {
        const candidate = value;
        return Is$4.objectLiteral(candidate) && Is$4.uinteger(candidate.startLine) && Is$4.uinteger(candidate.startLine)
            && (Is$4.undefined(candidate.startCharacter) || Is$4.uinteger(candidate.startCharacter))
            && (Is$4.undefined(candidate.endCharacter) || Is$4.uinteger(candidate.endCharacter))
            && (Is$4.undefined(candidate.kind) || Is$4.string(candidate.kind));
    }
    FoldingRange.is = is;
})(FoldingRange || (FoldingRange = {}));
/**
 * The DiagnosticRelatedInformation namespace provides helper functions to work with
 * {@link DiagnosticRelatedInformation} literals.
 */
var DiagnosticRelatedInformation;
(function (DiagnosticRelatedInformation) {
    /**
     * Creates a new DiagnosticRelatedInformation literal.
     */
    function create(location, message) {
        return {
            location,
            message
        };
    }
    DiagnosticRelatedInformation.create = create;
    /**
     * Checks whether the given literal conforms to the {@link DiagnosticRelatedInformation} interface.
     */
    function is(value) {
        let candidate = value;
        return Is$4.defined(candidate) && Location.is(candidate.location) && Is$4.string(candidate.message);
    }
    DiagnosticRelatedInformation.is = is;
})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
/**
 * The diagnostic's severity.
 */
var DiagnosticSeverity;
(function (DiagnosticSeverity) {
    /**
     * Reports an error.
     */
    DiagnosticSeverity.Error = 1;
    /**
     * Reports a warning.
     */
    DiagnosticSeverity.Warning = 2;
    /**
     * Reports an information.
     */
    DiagnosticSeverity.Information = 3;
    /**
     * Reports a hint.
     */
    DiagnosticSeverity.Hint = 4;
})(DiagnosticSeverity || (DiagnosticSeverity = {}));
/**
 * The diagnostic tags.
 *
 * @since 3.15.0
 */
var DiagnosticTag;
(function (DiagnosticTag) {
    /**
     * Unused or unnecessary code.
     *
     * Clients are allowed to render diagnostics with this tag faded out instead of having
     * an error squiggle.
     */
    DiagnosticTag.Unnecessary = 1;
    /**
     * Deprecated or obsolete code.
     *
     * Clients are allowed to rendered diagnostics with this tag strike through.
     */
    DiagnosticTag.Deprecated = 2;
})(DiagnosticTag || (DiagnosticTag = {}));
/**
 * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.
 *
 * @since 3.16.0
 */
var CodeDescription;
(function (CodeDescription) {
    function is(value) {
        const candidate = value;
        return Is$4.objectLiteral(candidate) && Is$4.string(candidate.href);
    }
    CodeDescription.is = is;
})(CodeDescription || (CodeDescription = {}));
/**
 * The Diagnostic namespace provides helper functions to work with
 * {@link Diagnostic} literals.
 */
var Diagnostic;
(function (Diagnostic) {
    /**
     * Creates a new Diagnostic literal.
     */
    function create(range, message, severity, code, source, relatedInformation) {
        let result = { range, message };
        if (Is$4.defined(severity)) {
            result.severity = severity;
        }
        if (Is$4.defined(code)) {
            result.code = code;
        }
        if (Is$4.defined(source)) {
            result.source = source;
        }
        if (Is$4.defined(relatedInformation)) {
            result.relatedInformation = relatedInformation;
        }
        return result;
    }
    Diagnostic.create = create;
    /**
     * Checks whether the given literal conforms to the {@link Diagnostic} interface.
     */
    function is(value) {
        var _a;
        let candidate = value;
        return Is$4.defined(candidate)
            && Range.is(candidate.range)
            && Is$4.string(candidate.message)
            && (Is$4.number(candidate.severity) || Is$4.undefined(candidate.severity))
            && (Is$4.integer(candidate.code) || Is$4.string(candidate.code) || Is$4.undefined(candidate.code))
            && (Is$4.undefined(candidate.codeDescription) || (Is$4.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)))
            && (Is$4.string(candidate.source) || Is$4.undefined(candidate.source))
            && (Is$4.undefined(candidate.relatedInformation) || Is$4.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
    }
    Diagnostic.is = is;
})(Diagnostic || (Diagnostic = {}));
/**
 * The Command namespace provides helper functions to work with
 * {@link Command} literals.
 */
var Command;
(function (Command) {
    /**
     * Creates a new Command literal.
     */
    function create(title, command, ...args) {
        let result = { title, command };
        if (Is$4.defined(args) && args.length > 0) {
            result.arguments = args;
        }
        return result;
    }
    Command.create = create;
    /**
     * Checks whether the given literal conforms to the {@link Command} interface.
     */
    function is(value) {
        let candidate = value;
        return Is$4.defined(candidate) && Is$4.string(candidate.title) && Is$4.string(candidate.command);
    }
    Command.is = is;
})(Command || (Command = {}));
/**
 * The TextEdit namespace provides helper function to create replace,
 * insert and delete edits more easily.
 */
var TextEdit;
(function (TextEdit) {
    /**
     * Creates a replace text edit.
     * @param range The range of text to be replaced.
     * @param newText The new text.
     */
    function replace(range, newText) {
        return { range, newText };
    }
    TextEdit.replace = replace;
    /**
     * Creates an insert text edit.
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     */
    function insert(position, newText) {
        return { range: { start: position, end: position }, newText };
    }
    TextEdit.insert = insert;
    /**
     * Creates a delete text edit.
     * @param range The range of text to be deleted.
     */
    function del(range) {
        return { range, newText: '' };
    }
    TextEdit.del = del;
    function is(value) {
        const candidate = value;
        return Is$4.objectLiteral(candidate)
            && Is$4.string(candidate.newText)
            && Range.is(candidate.range);
    }
    TextEdit.is = is;
})(TextEdit || (TextEdit = {}));
var ChangeAnnotation;
(function (ChangeAnnotation) {
    function create(label, needsConfirmation, description) {
        const result = { label };
        if (needsConfirmation !== undefined) {
            result.needsConfirmation = needsConfirmation;
        }
        if (description !== undefined) {
            result.description = description;
        }
        return result;
    }
    ChangeAnnotation.create = create;
    function is(value) {
        const candidate = value;
        return Is$4.objectLiteral(candidate) && Is$4.string(candidate.label) &&
            (Is$4.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) &&
            (Is$4.string(candidate.description) || candidate.description === undefined);
    }
    ChangeAnnotation.is = is;
})(ChangeAnnotation || (ChangeAnnotation = {}));
var ChangeAnnotationIdentifier;
(function (ChangeAnnotationIdentifier) {
    function is(value) {
        const candidate = value;
        return Is$4.string(candidate);
    }
    ChangeAnnotationIdentifier.is = is;
})(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));
var AnnotatedTextEdit;
(function (AnnotatedTextEdit) {
    /**
     * Creates an annotated replace text edit.
     *
     * @param range The range of text to be replaced.
     * @param newText The new text.
     * @param annotation The annotation.
     */
    function replace(range, newText, annotation) {
        return { range, newText, annotationId: annotation };
    }
    AnnotatedTextEdit.replace = replace;
    /**
     * Creates an annotated insert text edit.
     *
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     * @param annotation The annotation.
     */
    function insert(position, newText, annotation) {
        return { range: { start: position, end: position }, newText, annotationId: annotation };
    }
    AnnotatedTextEdit.insert = insert;
    /**
     * Creates an annotated delete text edit.
     *
     * @param range The range of text to be deleted.
     * @param annotation The annotation.
     */
    function del(range, annotation) {
        return { range, newText: '', annotationId: annotation };
    }
    AnnotatedTextEdit.del = del;
    function is(value) {
        const candidate = value;
        return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    AnnotatedTextEdit.is = is;
})(AnnotatedTextEdit || (AnnotatedTextEdit = {}));
/**
 * The TextDocumentEdit namespace provides helper function to create
 * an edit that manipulates a text document.
 */
var TextDocumentEdit;
(function (TextDocumentEdit) {
    /**
     * Creates a new `TextDocumentEdit`
     */
    function create(textDocument, edits) {
        return { textDocument, edits };
    }
    TextDocumentEdit.create = create;
    function is(value) {
        let candidate = value;
        return Is$4.defined(candidate)
            && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument)
            && Array.isArray(candidate.edits);
    }
    TextDocumentEdit.is = is;
})(TextDocumentEdit || (TextDocumentEdit = {}));
var CreateFile;
(function (CreateFile) {
    function create(uri, options, annotation) {
        let result = {
            kind: 'create',
            uri
        };
        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
            result.options = options;
        }
        if (annotation !== undefined) {
            result.annotationId = annotation;
        }
        return result;
    }
    CreateFile.create = create;
    function is(value) {
        let candidate = value;
        return candidate && candidate.kind === 'create' && Is$4.string(candidate.uri) && (candidate.options === undefined ||
            ((candidate.options.overwrite === undefined || Is$4.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is$4.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    CreateFile.is = is;
})(CreateFile || (CreateFile = {}));
var RenameFile;
(function (RenameFile) {
    function create(oldUri, newUri, options, annotation) {
        let result = {
            kind: 'rename',
            oldUri,
            newUri
        };
        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
            result.options = options;
        }
        if (annotation !== undefined) {
            result.annotationId = annotation;
        }
        return result;
    }
    RenameFile.create = create;
    function is(value) {
        let candidate = value;
        return candidate && candidate.kind === 'rename' && Is$4.string(candidate.oldUri) && Is$4.string(candidate.newUri) && (candidate.options === undefined ||
            ((candidate.options.overwrite === undefined || Is$4.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is$4.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    RenameFile.is = is;
})(RenameFile || (RenameFile = {}));
var DeleteFile;
(function (DeleteFile) {
    function create(uri, options, annotation) {
        let result = {
            kind: 'delete',
            uri
        };
        if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {
            result.options = options;
        }
        if (annotation !== undefined) {
            result.annotationId = annotation;
        }
        return result;
    }
    DeleteFile.create = create;
    function is(value) {
        let candidate = value;
        return candidate && candidate.kind === 'delete' && Is$4.string(candidate.uri) && (candidate.options === undefined ||
            ((candidate.options.recursive === undefined || Is$4.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is$4.boolean(candidate.options.ignoreIfNotExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    DeleteFile.is = is;
})(DeleteFile || (DeleteFile = {}));
var WorkspaceEdit;
(function (WorkspaceEdit) {
    function is(value) {
        let candidate = value;
        return candidate &&
            (candidate.changes !== undefined || candidate.documentChanges !== undefined) &&
            (candidate.documentChanges === undefined || candidate.documentChanges.every((change) => {
                if (Is$4.string(change.kind)) {
                    return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
                }
                else {
                    return TextDocumentEdit.is(change);
                }
            }));
    }
    WorkspaceEdit.is = is;
})(WorkspaceEdit || (WorkspaceEdit = {}));
class TextEditChangeImpl {
    constructor(edits, changeAnnotations) {
        this.edits = edits;
        this.changeAnnotations = changeAnnotations;
    }
    insert(position, newText, annotation) {
        let edit;
        let id;
        if (annotation === undefined) {
            edit = TextEdit.insert(position, newText);
        }
        else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.insert(position, newText, annotation);
        }
        else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.insert(position, newText, id);
        }
        this.edits.push(edit);
        if (id !== undefined) {
            return id;
        }
    }
    replace(range, newText, annotation) {
        let edit;
        let id;
        if (annotation === undefined) {
            edit = TextEdit.replace(range, newText);
        }
        else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.replace(range, newText, annotation);
        }
        else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.replace(range, newText, id);
        }
        this.edits.push(edit);
        if (id !== undefined) {
            return id;
        }
    }
    delete(range, annotation) {
        let edit;
        let id;
        if (annotation === undefined) {
            edit = TextEdit.del(range);
        }
        else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.del(range, annotation);
        }
        else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.del(range, id);
        }
        this.edits.push(edit);
        if (id !== undefined) {
            return id;
        }
    }
    add(edit) {
        this.edits.push(edit);
    }
    all() {
        return this.edits;
    }
    clear() {
        this.edits.splice(0, this.edits.length);
    }
    assertChangeAnnotations(value) {
        if (value === undefined) {
            throw new Error(`Text edit change is not configured to manage change annotations.`);
        }
    }
}
/**
 * A helper class
 */
class ChangeAnnotations {
    constructor(annotations) {
        this._annotations = annotations === undefined ? Object.create(null) : annotations;
        this._counter = 0;
        this._size = 0;
    }
    all() {
        return this._annotations;
    }
    get size() {
        return this._size;
    }
    manage(idOrAnnotation, annotation) {
        let id;
        if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
            id = idOrAnnotation;
        }
        else {
            id = this.nextId();
            annotation = idOrAnnotation;
        }
        if (this._annotations[id] !== undefined) {
            throw new Error(`Id ${id} is already in use.`);
        }
        if (annotation === undefined) {
            throw new Error(`No annotation provided for id ${id}`);
        }
        this._annotations[id] = annotation;
        this._size++;
        return id;
    }
    nextId() {
        this._counter++;
        return this._counter.toString();
    }
}
/**
 * A workspace change helps constructing changes to a workspace.
 */
class WorkspaceChange {
    constructor(workspaceEdit) {
        this._textEditChanges = Object.create(null);
        if (workspaceEdit !== undefined) {
            this._workspaceEdit = workspaceEdit;
            if (workspaceEdit.documentChanges) {
                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
                workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                workspaceEdit.documentChanges.forEach((change) => {
                    if (TextDocumentEdit.is(change)) {
                        const textEditChange = new TextEditChangeImpl(change.edits, this._changeAnnotations);
                        this._textEditChanges[change.textDocument.uri] = textEditChange;
                    }
                });
            }
            else if (workspaceEdit.changes) {
                Object.keys(workspaceEdit.changes).forEach((key) => {
                    const textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                    this._textEditChanges[key] = textEditChange;
                });
            }
        }
        else {
            this._workspaceEdit = {};
        }
    }
    /**
     * Returns the underlying {@link WorkspaceEdit} literal
     * use to be returned from a workspace edit operation like rename.
     */
    get edit() {
        this.initDocumentChanges();
        if (this._changeAnnotations !== undefined) {
            if (this._changeAnnotations.size === 0) {
                this._workspaceEdit.changeAnnotations = undefined;
            }
            else {
                this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
            }
        }
        return this._workspaceEdit;
    }
    getTextEditChange(key) {
        if (OptionalVersionedTextDocumentIdentifier.is(key)) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === undefined) {
                throw new Error('Workspace edit is not configured for document changes.');
            }
            const textDocument = { uri: key.uri, version: key.version };
            let result = this._textEditChanges[textDocument.uri];
            if (!result) {
                const edits = [];
                const textDocumentEdit = {
                    textDocument,
                    edits
                };
                this._workspaceEdit.documentChanges.push(textDocumentEdit);
                result = new TextEditChangeImpl(edits, this._changeAnnotations);
                this._textEditChanges[textDocument.uri] = result;
            }
            return result;
        }
        else {
            this.initChanges();
            if (this._workspaceEdit.changes === undefined) {
                throw new Error('Workspace edit is not configured for normal text edit changes.');
            }
            let result = this._textEditChanges[key];
            if (!result) {
                let edits = [];
                this._workspaceEdit.changes[key] = edits;
                result = new TextEditChangeImpl(edits);
                this._textEditChanges[key] = result;
            }
            return result;
        }
    }
    initDocumentChanges() {
        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
            this._changeAnnotations = new ChangeAnnotations();
            this._workspaceEdit.documentChanges = [];
            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
        }
    }
    initChanges() {
        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
            this._workspaceEdit.changes = Object.create(null);
        }
    }
    createFile(uri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === undefined) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
        let annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
        }
        else {
            options = optionsOrAnnotation;
        }
        let operation;
        let id;
        if (annotation === undefined) {
            operation = CreateFile.create(uri, options);
        }
        else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = CreateFile.create(uri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== undefined) {
            return id;
        }
    }
    renameFile(oldUri, newUri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === undefined) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
        let annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
        }
        else {
            options = optionsOrAnnotation;
        }
        let operation;
        let id;
        if (annotation === undefined) {
            operation = RenameFile.create(oldUri, newUri, options);
        }
        else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = RenameFile.create(oldUri, newUri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== undefined) {
            return id;
        }
    }
    deleteFile(uri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === undefined) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
        let annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
        }
        else {
            options = optionsOrAnnotation;
        }
        let operation;
        let id;
        if (annotation === undefined) {
            operation = DeleteFile.create(uri, options);
        }
        else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = DeleteFile.create(uri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== undefined) {
            return id;
        }
    }
}
/**
 * The TextDocumentIdentifier namespace provides helper functions to work with
 * {@link TextDocumentIdentifier} literals.
 */
var TextDocumentIdentifier;
(function (TextDocumentIdentifier) {
    /**
     * Creates a new TextDocumentIdentifier literal.
     * @param uri The document's uri.
     */
    function create(uri) {
        return { uri };
    }
    TextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the {@link TextDocumentIdentifier} interface.
     */
    function is(value) {
        let candidate = value;
        return Is$4.defined(candidate) && Is$4.string(candidate.uri);
    }
    TextDocumentIdentifier.is = is;
})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
/**
 * The VersionedTextDocumentIdentifier namespace provides helper functions to work with
 * {@link VersionedTextDocumentIdentifier} literals.
 */
var VersionedTextDocumentIdentifier;
(function (VersionedTextDocumentIdentifier) {
    /**
     * Creates a new VersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param version The document's version.
     */
    function create(uri, version) {
        return { uri, version };
    }
    VersionedTextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the {@link VersionedTextDocumentIdentifier} interface.
     */
    function is(value) {
        let candidate = value;
        return Is$4.defined(candidate) && Is$4.string(candidate.uri) && Is$4.integer(candidate.version);
    }
    VersionedTextDocumentIdentifier.is = is;
})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
/**
 * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with
 * {@link OptionalVersionedTextDocumentIdentifier} literals.
 */
var OptionalVersionedTextDocumentIdentifier;
(function (OptionalVersionedTextDocumentIdentifier) {
    /**
     * Creates a new OptionalVersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param version The document's version.
     */
    function create(uri, version) {
        return { uri, version };
    }
    OptionalVersionedTextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the {@link OptionalVersionedTextDocumentIdentifier} interface.
     */
    function is(value) {
        let candidate = value;
        return Is$4.defined(candidate) && Is$4.string(candidate.uri) && (candidate.version === null || Is$4.integer(candidate.version));
    }
    OptionalVersionedTextDocumentIdentifier.is = is;
})(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));
/**
 * The TextDocumentItem namespace provides helper functions to work with
 * {@link TextDocumentItem} literals.
 */
var TextDocumentItem;
(function (TextDocumentItem) {
    /**
     * Creates a new TextDocumentItem literal.
     * @param uri The document's uri.
     * @param languageId The document's language identifier.
     * @param version The document's version number.
     * @param text The document's text.
     */
    function create(uri, languageId, version, text) {
        return { uri, languageId, version, text };
    }
    TextDocumentItem.create = create;
    /**
     * Checks whether the given literal conforms to the {@link TextDocumentItem} interface.
     */
    function is(value) {
        let candidate = value;
        return Is$4.defined(candidate) && Is$4.string(candidate.uri) && Is$4.string(candidate.languageId) && Is$4.integer(candidate.version) && Is$4.string(candidate.text);
    }
    TextDocumentItem.is = is;
})(TextDocumentItem || (TextDocumentItem = {}));
/**
 * Describes the content type that a client supports in various
 * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.
 *
 * Please note that `MarkupKinds` must not start with a `$`. This kinds
 * are reserved for internal usage.
 */
var MarkupKind;
(function (MarkupKind) {
    /**
     * Plain text is supported as a content format
     */
    MarkupKind.PlainText = 'plaintext';
    /**
     * Markdown is supported as a content format
     */
    MarkupKind.Markdown = 'markdown';
    /**
     * Checks whether the given value is a value of the {@link MarkupKind} type.
     */
    function is(value) {
        const candidate = value;
        return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;
    }
    MarkupKind.is = is;
})(MarkupKind || (MarkupKind = {}));
var MarkupContent;
(function (MarkupContent) {
    /**
     * Checks whether the given value conforms to the {@link MarkupContent} interface.
     */
    function is(value) {
        const candidate = value;
        return Is$4.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is$4.string(candidate.value);
    }
    MarkupContent.is = is;
})(MarkupContent || (MarkupContent = {}));
/**
 * The kind of a completion entry.
 */
var CompletionItemKind;
(function (CompletionItemKind) {
    CompletionItemKind.Text = 1;
    CompletionItemKind.Method = 2;
    CompletionItemKind.Function = 3;
    CompletionItemKind.Constructor = 4;
    CompletionItemKind.Field = 5;
    CompletionItemKind.Variable = 6;
    CompletionItemKind.Class = 7;
    CompletionItemKind.Interface = 8;
    CompletionItemKind.Module = 9;
    CompletionItemKind.Property = 10;
    CompletionItemKind.Unit = 11;
    CompletionItemKind.Value = 12;
    CompletionItemKind.Enum = 13;
    CompletionItemKind.Keyword = 14;
    CompletionItemKind.Snippet = 15;
    CompletionItemKind.Color = 16;
    CompletionItemKind.File = 17;
    CompletionItemKind.Reference = 18;
    CompletionItemKind.Folder = 19;
    CompletionItemKind.EnumMember = 20;
    CompletionItemKind.Constant = 21;
    CompletionItemKind.Struct = 22;
    CompletionItemKind.Event = 23;
    CompletionItemKind.Operator = 24;
    CompletionItemKind.TypeParameter = 25;
})(CompletionItemKind || (CompletionItemKind = {}));
/**
 * Defines whether the insert text in a completion item should be interpreted as
 * plain text or a snippet.
 */
var InsertTextFormat;
(function (InsertTextFormat) {
    /**
     * The primary text to be inserted is treated as a plain string.
     */
    InsertTextFormat.PlainText = 1;
    /**
     * The primary text to be inserted is treated as a snippet.
     *
     * A snippet can define tab stops and placeholders with `$1`, `$2`
     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to
     * the end of the snippet. Placeholders with equal identifiers are linked,
     * that is typing in one will update others too.
     *
     * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax
     */
    InsertTextFormat.Snippet = 2;
})(InsertTextFormat || (InsertTextFormat = {}));
/**
 * Completion item tags are extra annotations that tweak the rendering of a completion
 * item.
 *
 * @since 3.15.0
 */
var CompletionItemTag;
(function (CompletionItemTag) {
    /**
     * Render a completion as obsolete, usually using a strike-out.
     */
    CompletionItemTag.Deprecated = 1;
})(CompletionItemTag || (CompletionItemTag = {}));
/**
 * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.
 *
 * @since 3.16.0
 */
var InsertReplaceEdit;
(function (InsertReplaceEdit) {
    /**
     * Creates a new insert / replace edit
     */
    function create(newText, insert, replace) {
        return { newText, insert, replace };
    }
    InsertReplaceEdit.create = create;
    /**
     * Checks whether the given literal conforms to the {@link InsertReplaceEdit} interface.
     */
    function is(value) {
        const candidate = value;
        return candidate && Is$4.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
    }
    InsertReplaceEdit.is = is;
})(InsertReplaceEdit || (InsertReplaceEdit = {}));
/**
 * How whitespace and indentation is handled during completion
 * item insertion.
 *
 * @since 3.16.0
 */
var InsertTextMode;
(function (InsertTextMode) {
    /**
     * The insertion or replace strings is taken as it is. If the
     * value is multi line the lines below the cursor will be
     * inserted using the indentation defined in the string value.
     * The client will not apply any kind of adjustments to the
     * string.
     */
    InsertTextMode.asIs = 1;
    /**
     * The editor adjusts leading whitespace of new lines so that
     * they match the indentation up to the cursor of the line for
     * which the item is accepted.
     *
     * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a
     * multi line completion item is indented using 2 tabs and all
     * following lines inserted will be indented using 2 tabs as well.
     */
    InsertTextMode.adjustIndentation = 2;
})(InsertTextMode || (InsertTextMode = {}));
var CompletionItemLabelDetails;
(function (CompletionItemLabelDetails) {
    function is(value) {
        const candidate = value;
        return candidate && (Is$4.string(candidate.detail) || candidate.detail === undefined) &&
            (Is$4.string(candidate.description) || candidate.description === undefined);
    }
    CompletionItemLabelDetails.is = is;
})(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));
/**
 * The CompletionItem namespace provides functions to deal with
 * completion items.
 */
var CompletionItem;
(function (CompletionItem) {
    /**
     * Create a completion item and seed it with a label.
     * @param label The completion item's label
     */
    function create(label) {
        return { label };
    }
    CompletionItem.create = create;
})(CompletionItem || (CompletionItem = {}));
/**
 * The CompletionList namespace provides functions to deal with
 * completion lists.
 */
var CompletionList;
(function (CompletionList) {
    /**
     * Creates a new completion list.
     *
     * @param items The completion items.
     * @param isIncomplete The list is not complete.
     */
    function create(items, isIncomplete) {
        return { items: items ? items : [], isIncomplete: !!isIncomplete };
    }
    CompletionList.create = create;
})(CompletionList || (CompletionList = {}));
var MarkedString;
(function (MarkedString) {
    /**
     * Creates a marked string from plain text.
     *
     * @param plainText The plain text.
     */
    function fromPlainText(plainText) {
        return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, '\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
    }
    MarkedString.fromPlainText = fromPlainText;
    /**
     * Checks whether the given value conforms to the {@link MarkedString} type.
     */
    function is(value) {
        const candidate = value;
        return Is$4.string(candidate) || (Is$4.objectLiteral(candidate) && Is$4.string(candidate.language) && Is$4.string(candidate.value));
    }
    MarkedString.is = is;
})(MarkedString || (MarkedString = {}));
var Hover;
(function (Hover) {
    /**
     * Checks whether the given value conforms to the {@link Hover} interface.
     */
    function is(value) {
        let candidate = value;
        return !!candidate && Is$4.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) ||
            MarkedString.is(candidate.contents) ||
            Is$4.typedArray(candidate.contents, MarkedString.is)) && (value.range === undefined || Range.is(value.range));
    }
    Hover.is = is;
})(Hover || (Hover = {}));
/**
 * The ParameterInformation namespace provides helper functions to work with
 * {@link ParameterInformation} literals.
 */
var ParameterInformation;
(function (ParameterInformation) {
    /**
     * Creates a new parameter information literal.
     *
     * @param label A label string.
     * @param documentation A doc string.
     */
    function create(label, documentation) {
        return documentation ? { label, documentation } : { label };
    }
    ParameterInformation.create = create;
})(ParameterInformation || (ParameterInformation = {}));
/**
 * The SignatureInformation namespace provides helper functions to work with
 * {@link SignatureInformation} literals.
 */
var SignatureInformation;
(function (SignatureInformation) {
    function create(label, documentation, ...parameters) {
        let result = { label };
        if (Is$4.defined(documentation)) {
            result.documentation = documentation;
        }
        if (Is$4.defined(parameters)) {
            result.parameters = parameters;
        }
        else {
            result.parameters = [];
        }
        return result;
    }
    SignatureInformation.create = create;
})(SignatureInformation || (SignatureInformation = {}));
/**
 * A document highlight kind.
 */
var DocumentHighlightKind;
(function (DocumentHighlightKind) {
    /**
     * A textual occurrence.
     */
    DocumentHighlightKind.Text = 1;
    /**
     * Read-access of a symbol, like reading a variable.
     */
    DocumentHighlightKind.Read = 2;
    /**
     * Write-access of a symbol, like writing to a variable.
     */
    DocumentHighlightKind.Write = 3;
})(DocumentHighlightKind || (DocumentHighlightKind = {}));
/**
 * DocumentHighlight namespace to provide helper functions to work with
 * {@link DocumentHighlight} literals.
 */
var DocumentHighlight;
(function (DocumentHighlight) {
    /**
     * Create a DocumentHighlight object.
     * @param range The range the highlight applies to.
     * @param kind The highlight kind
     */
    function create(range, kind) {
        let result = { range };
        if (Is$4.number(kind)) {
            result.kind = kind;
        }
        return result;
    }
    DocumentHighlight.create = create;
})(DocumentHighlight || (DocumentHighlight = {}));
/**
 * A symbol kind.
 */
var SymbolKind;
(function (SymbolKind) {
    SymbolKind.File = 1;
    SymbolKind.Module = 2;
    SymbolKind.Namespace = 3;
    SymbolKind.Package = 4;
    SymbolKind.Class = 5;
    SymbolKind.Method = 6;
    SymbolKind.Property = 7;
    SymbolKind.Field = 8;
    SymbolKind.Constructor = 9;
    SymbolKind.Enum = 10;
    SymbolKind.Interface = 11;
    SymbolKind.Function = 12;
    SymbolKind.Variable = 13;
    SymbolKind.Constant = 14;
    SymbolKind.String = 15;
    SymbolKind.Number = 16;
    SymbolKind.Boolean = 17;
    SymbolKind.Array = 18;
    SymbolKind.Object = 19;
    SymbolKind.Key = 20;
    SymbolKind.Null = 21;
    SymbolKind.EnumMember = 22;
    SymbolKind.Struct = 23;
    SymbolKind.Event = 24;
    SymbolKind.Operator = 25;
    SymbolKind.TypeParameter = 26;
})(SymbolKind || (SymbolKind = {}));
/**
 * Symbol tags are extra annotations that tweak the rendering of a symbol.
 *
 * @since 3.16
 */
var SymbolTag;
(function (SymbolTag) {
    /**
     * Render a symbol as obsolete, usually using a strike-out.
     */
    SymbolTag.Deprecated = 1;
})(SymbolTag || (SymbolTag = {}));
var SymbolInformation;
(function (SymbolInformation) {
    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the location of the symbol.
     * @param uri The resource of the location of symbol.
     * @param containerName The name of the symbol containing the symbol.
     */
    function create(name, kind, range, uri, containerName) {
        let result = {
            name,
            kind,
            location: { uri, range }
        };
        if (containerName) {
            result.containerName = containerName;
        }
        return result;
    }
    SymbolInformation.create = create;
})(SymbolInformation || (SymbolInformation = {}));
var WorkspaceSymbol;
(function (WorkspaceSymbol) {
    /**
     * Create a new workspace symbol.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param uri The resource of the location of the symbol.
     * @param range An options range of the location.
     * @returns A WorkspaceSymbol.
     */
    function create(name, kind, uri, range) {
        return range !== undefined
            ? { name, kind, location: { uri, range } }
            : { name, kind, location: { uri } };
    }
    WorkspaceSymbol.create = create;
})(WorkspaceSymbol || (WorkspaceSymbol = {}));
var DocumentSymbol;
(function (DocumentSymbol) {
    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param detail The detail of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the symbol.
     * @param selectionRange The selectionRange of the symbol.
     * @param children Children of the symbol.
     */
    function create(name, detail, kind, range, selectionRange, children) {
        let result = {
            name,
            detail,
            kind,
            range,
            selectionRange
        };
        if (children !== undefined) {
            result.children = children;
        }
        return result;
    }
    DocumentSymbol.create = create;
    /**
     * Checks whether the given literal conforms to the {@link DocumentSymbol} interface.
     */
    function is(value) {
        let candidate = value;
        return candidate &&
            Is$4.string(candidate.name) && Is$4.number(candidate.kind) &&
            Range.is(candidate.range) && Range.is(candidate.selectionRange) &&
            (candidate.detail === undefined || Is$4.string(candidate.detail)) &&
            (candidate.deprecated === undefined || Is$4.boolean(candidate.deprecated)) &&
            (candidate.children === undefined || Array.isArray(candidate.children)) &&
            (candidate.tags === undefined || Array.isArray(candidate.tags));
    }
    DocumentSymbol.is = is;
})(DocumentSymbol || (DocumentSymbol = {}));
/**
 * A set of predefined code action kinds
 */
var CodeActionKind;
(function (CodeActionKind) {
    /**
     * Empty kind.
     */
    CodeActionKind.Empty = '';
    /**
     * Base kind for quickfix actions: 'quickfix'
     */
    CodeActionKind.QuickFix = 'quickfix';
    /**
     * Base kind for refactoring actions: 'refactor'
     */
    CodeActionKind.Refactor = 'refactor';
    /**
     * Base kind for refactoring extraction actions: 'refactor.extract'
     *
     * Example extract actions:
     *
     * - Extract method
     * - Extract function
     * - Extract variable
     * - Extract interface from class
     * - ...
     */
    CodeActionKind.RefactorExtract = 'refactor.extract';
    /**
     * Base kind for refactoring inline actions: 'refactor.inline'
     *
     * Example inline actions:
     *
     * - Inline function
     * - Inline variable
     * - Inline constant
     * - ...
     */
    CodeActionKind.RefactorInline = 'refactor.inline';
    /**
     * Base kind for refactoring rewrite actions: 'refactor.rewrite'
     *
     * Example rewrite actions:
     *
     * - Convert JavaScript function to class
     * - Add or remove parameter
     * - Encapsulate field
     * - Make method static
     * - Move method to base class
     * - ...
     */
    CodeActionKind.RefactorRewrite = 'refactor.rewrite';
    /**
     * Base kind for source actions: `source`
     *
     * Source code actions apply to the entire file.
     */
    CodeActionKind.Source = 'source';
    /**
     * Base kind for an organize imports source action: `source.organizeImports`
     */
    CodeActionKind.SourceOrganizeImports = 'source.organizeImports';
    /**
     * Base kind for auto-fix source actions: `source.fixAll`.
     *
     * Fix all actions automatically fix errors that have a clear fix that do not require user input.
     * They should not suppress errors or perform unsafe fixes such as generating new types or classes.
     *
     * @since 3.15.0
     */
    CodeActionKind.SourceFixAll = 'source.fixAll';
})(CodeActionKind || (CodeActionKind = {}));
/**
 * The reason why code actions were requested.
 *
 * @since 3.17.0
 */
var CodeActionTriggerKind;
(function (CodeActionTriggerKind) {
    /**
     * Code actions were explicitly requested by the user or by an extension.
     */
    CodeActionTriggerKind.Invoked = 1;
    /**
     * Code actions were requested automatically.
     *
     * This typically happens when current selection in a file changes, but can
     * also be triggered when file content changes.
     */
    CodeActionTriggerKind.Automatic = 2;
})(CodeActionTriggerKind || (CodeActionTriggerKind = {}));
/**
 * The CodeActionContext namespace provides helper functions to work with
 * {@link CodeActionContext} literals.
 */
var CodeActionContext;
(function (CodeActionContext) {
    /**
     * Creates a new CodeActionContext literal.
     */
    function create(diagnostics, only, triggerKind) {
        let result = { diagnostics };
        if (only !== undefined && only !== null) {
            result.only = only;
        }
        if (triggerKind !== undefined && triggerKind !== null) {
            result.triggerKind = triggerKind;
        }
        return result;
    }
    CodeActionContext.create = create;
    /**
     * Checks whether the given literal conforms to the {@link CodeActionContext} interface.
     */
    function is(value) {
        let candidate = value;
        return Is$4.defined(candidate) && Is$4.typedArray(candidate.diagnostics, Diagnostic.is)
            && (candidate.only === undefined || Is$4.typedArray(candidate.only, Is$4.string))
            && (candidate.triggerKind === undefined || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
    }
    CodeActionContext.is = is;
})(CodeActionContext || (CodeActionContext = {}));
var CodeAction;
(function (CodeAction) {
    function create(title, kindOrCommandOrEdit, kind) {
        let result = { title };
        let checkKind = true;
        if (typeof kindOrCommandOrEdit === 'string') {
            checkKind = false;
            result.kind = kindOrCommandOrEdit;
        }
        else if (Command.is(kindOrCommandOrEdit)) {
            result.command = kindOrCommandOrEdit;
        }
        else {
            result.edit = kindOrCommandOrEdit;
        }
        if (checkKind && kind !== undefined) {
            result.kind = kind;
        }
        return result;
    }
    CodeAction.create = create;
    function is(value) {
        let candidate = value;
        return candidate && Is$4.string(candidate.title) &&
            (candidate.diagnostics === undefined || Is$4.typedArray(candidate.diagnostics, Diagnostic.is)) &&
            (candidate.kind === undefined || Is$4.string(candidate.kind)) &&
            (candidate.edit !== undefined || candidate.command !== undefined) &&
            (candidate.command === undefined || Command.is(candidate.command)) &&
            (candidate.isPreferred === undefined || Is$4.boolean(candidate.isPreferred)) &&
            (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));
    }
    CodeAction.is = is;
})(CodeAction || (CodeAction = {}));
/**
 * The CodeLens namespace provides helper functions to work with
 * {@link CodeLens} literals.
 */
var CodeLens;
(function (CodeLens) {
    /**
     * Creates a new CodeLens literal.
     */
    function create(range, data) {
        let result = { range };
        if (Is$4.defined(data)) {
            result.data = data;
        }
        return result;
    }
    CodeLens.create = create;
    /**
     * Checks whether the given literal conforms to the {@link CodeLens} interface.
     */
    function is(value) {
        let candidate = value;
        return Is$4.defined(candidate) && Range.is(candidate.range) && (Is$4.undefined(candidate.command) || Command.is(candidate.command));
    }
    CodeLens.is = is;
})(CodeLens || (CodeLens = {}));
/**
 * The FormattingOptions namespace provides helper functions to work with
 * {@link FormattingOptions} literals.
 */
var FormattingOptions;
(function (FormattingOptions) {
    /**
     * Creates a new FormattingOptions literal.
     */
    function create(tabSize, insertSpaces) {
        return { tabSize, insertSpaces };
    }
    FormattingOptions.create = create;
    /**
     * Checks whether the given literal conforms to the {@link FormattingOptions} interface.
     */
    function is(value) {
        let candidate = value;
        return Is$4.defined(candidate) && Is$4.uinteger(candidate.tabSize) && Is$4.boolean(candidate.insertSpaces);
    }
    FormattingOptions.is = is;
})(FormattingOptions || (FormattingOptions = {}));
/**
 * The DocumentLink namespace provides helper functions to work with
 * {@link DocumentLink} literals.
 */
var DocumentLink;
(function (DocumentLink) {
    /**
     * Creates a new DocumentLink literal.
     */
    function create(range, target, data) {
        return { range, target, data };
    }
    DocumentLink.create = create;
    /**
     * Checks whether the given literal conforms to the {@link DocumentLink} interface.
     */
    function is(value) {
        let candidate = value;
        return Is$4.defined(candidate) && Range.is(candidate.range) && (Is$4.undefined(candidate.target) || Is$4.string(candidate.target));
    }
    DocumentLink.is = is;
})(DocumentLink || (DocumentLink = {}));
/**
 * The SelectionRange namespace provides helper function to work with
 * SelectionRange literals.
 */
var SelectionRange;
(function (SelectionRange) {
    /**
     * Creates a new SelectionRange
     * @param range the range.
     * @param parent an optional parent.
     */
    function create(range, parent) {
        return { range, parent };
    }
    SelectionRange.create = create;
    function is(value) {
        let candidate = value;
        return Is$4.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));
    }
    SelectionRange.is = is;
})(SelectionRange || (SelectionRange = {}));
/**
 * A set of predefined token types. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0
 */
var SemanticTokenTypes;
(function (SemanticTokenTypes) {
    SemanticTokenTypes["namespace"] = "namespace";
    /**
     * Represents a generic type. Acts as a fallback for types which can't be mapped to
     * a specific type like class or enum.
     */
    SemanticTokenTypes["type"] = "type";
    SemanticTokenTypes["class"] = "class";
    SemanticTokenTypes["enum"] = "enum";
    SemanticTokenTypes["interface"] = "interface";
    SemanticTokenTypes["struct"] = "struct";
    SemanticTokenTypes["typeParameter"] = "typeParameter";
    SemanticTokenTypes["parameter"] = "parameter";
    SemanticTokenTypes["variable"] = "variable";
    SemanticTokenTypes["property"] = "property";
    SemanticTokenTypes["enumMember"] = "enumMember";
    SemanticTokenTypes["event"] = "event";
    SemanticTokenTypes["function"] = "function";
    SemanticTokenTypes["method"] = "method";
    SemanticTokenTypes["macro"] = "macro";
    SemanticTokenTypes["keyword"] = "keyword";
    SemanticTokenTypes["modifier"] = "modifier";
    SemanticTokenTypes["comment"] = "comment";
    SemanticTokenTypes["string"] = "string";
    SemanticTokenTypes["number"] = "number";
    SemanticTokenTypes["regexp"] = "regexp";
    SemanticTokenTypes["operator"] = "operator";
    /**
     * @since 3.17.0
     */
    SemanticTokenTypes["decorator"] = "decorator";
})(SemanticTokenTypes || (SemanticTokenTypes = {}));
/**
 * A set of predefined token modifiers. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0
 */
var SemanticTokenModifiers;
(function (SemanticTokenModifiers) {
    SemanticTokenModifiers["declaration"] = "declaration";
    SemanticTokenModifiers["definition"] = "definition";
    SemanticTokenModifiers["readonly"] = "readonly";
    SemanticTokenModifiers["static"] = "static";
    SemanticTokenModifiers["deprecated"] = "deprecated";
    SemanticTokenModifiers["abstract"] = "abstract";
    SemanticTokenModifiers["async"] = "async";
    SemanticTokenModifiers["modification"] = "modification";
    SemanticTokenModifiers["documentation"] = "documentation";
    SemanticTokenModifiers["defaultLibrary"] = "defaultLibrary";
})(SemanticTokenModifiers || (SemanticTokenModifiers = {}));
/**
 * @since 3.16.0
 */
var SemanticTokens;
(function (SemanticTokens) {
    function is(value) {
        const candidate = value;
        return Is$4.objectLiteral(candidate) && (candidate.resultId === undefined || typeof candidate.resultId === 'string') &&
            Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');
    }
    SemanticTokens.is = is;
})(SemanticTokens || (SemanticTokens = {}));
/**
 * The InlineValueText namespace provides functions to deal with InlineValueTexts.
 *
 * @since 3.17.0
 */
var InlineValueText;
(function (InlineValueText) {
    /**
     * Creates a new InlineValueText literal.
     */
    function create(range, text) {
        return { range, text };
    }
    InlineValueText.create = create;
    function is(value) {
        const candidate = value;
        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is$4.string(candidate.text);
    }
    InlineValueText.is = is;
})(InlineValueText || (InlineValueText = {}));
/**
 * The InlineValueVariableLookup namespace provides functions to deal with InlineValueVariableLookups.
 *
 * @since 3.17.0
 */
var InlineValueVariableLookup;
(function (InlineValueVariableLookup) {
    /**
     * Creates a new InlineValueText literal.
     */
    function create(range, variableName, caseSensitiveLookup) {
        return { range, variableName, caseSensitiveLookup };
    }
    InlineValueVariableLookup.create = create;
    function is(value) {
        const candidate = value;
        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is$4.boolean(candidate.caseSensitiveLookup)
            && (Is$4.string(candidate.variableName) || candidate.variableName === undefined);
    }
    InlineValueVariableLookup.is = is;
})(InlineValueVariableLookup || (InlineValueVariableLookup = {}));
/**
 * The InlineValueEvaluatableExpression namespace provides functions to deal with InlineValueEvaluatableExpression.
 *
 * @since 3.17.0
 */
var InlineValueEvaluatableExpression;
(function (InlineValueEvaluatableExpression) {
    /**
     * Creates a new InlineValueEvaluatableExpression literal.
     */
    function create(range, expression) {
        return { range, expression };
    }
    InlineValueEvaluatableExpression.create = create;
    function is(value) {
        const candidate = value;
        return candidate !== undefined && candidate !== null && Range.is(candidate.range)
            && (Is$4.string(candidate.expression) || candidate.expression === undefined);
    }
    InlineValueEvaluatableExpression.is = is;
})(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));
/**
 * The InlineValueContext namespace provides helper functions to work with
 * {@link InlineValueContext} literals.
 *
 * @since 3.17.0
 */
var InlineValueContext;
(function (InlineValueContext) {
    /**
     * Creates a new InlineValueContext literal.
     */
    function create(frameId, stoppedLocation) {
        return { frameId, stoppedLocation };
    }
    InlineValueContext.create = create;
    /**
     * Checks whether the given literal conforms to the {@link InlineValueContext} interface.
     */
    function is(value) {
        const candidate = value;
        return Is$4.defined(candidate) && Range.is(value.stoppedLocation);
    }
    InlineValueContext.is = is;
})(InlineValueContext || (InlineValueContext = {}));
/**
 * Inlay hint kinds.
 *
 * @since 3.17.0
 */
var InlayHintKind;
(function (InlayHintKind) {
    /**
     * An inlay hint that for a type annotation.
     */
    InlayHintKind.Type = 1;
    /**
     * An inlay hint that is for a parameter.
     */
    InlayHintKind.Parameter = 2;
    function is(value) {
        return value === 1 || value === 2;
    }
    InlayHintKind.is = is;
})(InlayHintKind || (InlayHintKind = {}));
var InlayHintLabelPart;
(function (InlayHintLabelPart) {
    function create(value) {
        return { value };
    }
    InlayHintLabelPart.create = create;
    function is(value) {
        const candidate = value;
        return Is$4.objectLiteral(candidate)
            && (candidate.tooltip === undefined || Is$4.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))
            && (candidate.location === undefined || Location.is(candidate.location))
            && (candidate.command === undefined || Command.is(candidate.command));
    }
    InlayHintLabelPart.is = is;
})(InlayHintLabelPart || (InlayHintLabelPart = {}));
var InlayHint;
(function (InlayHint) {
    function create(position, label, kind) {
        const result = { position, label };
        if (kind !== undefined) {
            result.kind = kind;
        }
        return result;
    }
    InlayHint.create = create;
    function is(value) {
        const candidate = value;
        return Is$4.objectLiteral(candidate) && Position.is(candidate.position)
            && (Is$4.string(candidate.label) || Is$4.typedArray(candidate.label, InlayHintLabelPart.is))
            && (candidate.kind === undefined || InlayHintKind.is(candidate.kind))
            && (candidate.textEdits === undefined) || Is$4.typedArray(candidate.textEdits, TextEdit.is)
            && (candidate.tooltip === undefined || Is$4.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))
            && (candidate.paddingLeft === undefined || Is$4.boolean(candidate.paddingLeft))
            && (candidate.paddingRight === undefined || Is$4.boolean(candidate.paddingRight));
    }
    InlayHint.is = is;
})(InlayHint || (InlayHint = {}));
var StringValue;
(function (StringValue) {
    function createSnippet(value) {
        return { kind: 'snippet', value };
    }
    StringValue.createSnippet = createSnippet;
})(StringValue || (StringValue = {}));
var InlineCompletionItem;
(function (InlineCompletionItem) {
    function create(insertText, filterText, range, command) {
        return { insertText, filterText, range, command };
    }
    InlineCompletionItem.create = create;
})(InlineCompletionItem || (InlineCompletionItem = {}));
var InlineCompletionList;
(function (InlineCompletionList) {
    function create(items) {
        return { items };
    }
    InlineCompletionList.create = create;
})(InlineCompletionList || (InlineCompletionList = {}));
/**
 * Describes how an {@link InlineCompletionItemProvider inline completion provider} was triggered.
 *
 * @since 3.18.0
 * @proposed
 */
var InlineCompletionTriggerKind;
(function (InlineCompletionTriggerKind) {
    /**
     * Completion was triggered explicitly by a user gesture.
     */
    InlineCompletionTriggerKind.Invoked = 0;
    /**
     * Completion was triggered automatically while editing.
     */
    InlineCompletionTriggerKind.Automatic = 1;
})(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));
var SelectedCompletionInfo;
(function (SelectedCompletionInfo) {
    function create(range, text) {
        return { range, text };
    }
    SelectedCompletionInfo.create = create;
})(SelectedCompletionInfo || (SelectedCompletionInfo = {}));
var InlineCompletionContext;
(function (InlineCompletionContext) {
    function create(triggerKind, selectedCompletionInfo) {
        return { triggerKind, selectedCompletionInfo };
    }
    InlineCompletionContext.create = create;
})(InlineCompletionContext || (InlineCompletionContext = {}));
var WorkspaceFolder;
(function (WorkspaceFolder) {
    function is(value) {
        const candidate = value;
        return Is$4.objectLiteral(candidate) && URI.is(candidate.uri) && Is$4.string(candidate.name);
    }
    WorkspaceFolder.is = is;
})(WorkspaceFolder || (WorkspaceFolder = {}));
const EOL = ['\n', '\r\n', '\r'];
/**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */
var TextDocument;
(function (TextDocument) {
    /**
     * Creates a new ITextDocument literal from the given uri and content.
     * @param uri The document's uri.
     * @param languageId The document's language Id.
     * @param version The document's version.
     * @param content The document's content.
     */
    function create(uri, languageId, version, content) {
        return new FullTextDocument(uri, languageId, version, content);
    }
    TextDocument.create = create;
    /**
     * Checks whether the given literal conforms to the {@link ITextDocument} interface.
     */
    function is(value) {
        let candidate = value;
        return Is$4.defined(candidate) && Is$4.string(candidate.uri) && (Is$4.undefined(candidate.languageId) || Is$4.string(candidate.languageId)) && Is$4.uinteger(candidate.lineCount)
            && Is$4.func(candidate.getText) && Is$4.func(candidate.positionAt) && Is$4.func(candidate.offsetAt) ? true : false;
    }
    TextDocument.is = is;
    function applyEdits(document, edits) {
        let text = document.getText();
        let sortedEdits = mergeSort(edits, (a, b) => {
            let diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
                return a.range.start.character - b.range.start.character;
            }
            return diff;
        });
        let lastModifiedOffset = text.length;
        for (let i = sortedEdits.length - 1; i >= 0; i--) {
            let e = sortedEdits[i];
            let startOffset = document.offsetAt(e.range.start);
            let endOffset = document.offsetAt(e.range.end);
            if (endOffset <= lastModifiedOffset) {
                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
            }
            else {
                throw new Error('Overlapping edit');
            }
            lastModifiedOffset = startOffset;
        }
        return text;
    }
    TextDocument.applyEdits = applyEdits;
    function mergeSort(data, compare) {
        if (data.length <= 1) {
            // sorted
            return data;
        }
        const p = (data.length / 2) | 0;
        const left = data.slice(0, p);
        const right = data.slice(p);
        mergeSort(left, compare);
        mergeSort(right, compare);
        let leftIdx = 0;
        let rightIdx = 0;
        let i = 0;
        while (leftIdx < left.length && rightIdx < right.length) {
            let ret = compare(left[leftIdx], right[rightIdx]);
            if (ret <= 0) {
                // smaller_equal -> take left to preserve order
                data[i++] = left[leftIdx++];
            }
            else {
                // greater -> take right
                data[i++] = right[rightIdx++];
            }
        }
        while (leftIdx < left.length) {
            data[i++] = left[leftIdx++];
        }
        while (rightIdx < right.length) {
            data[i++] = right[rightIdx++];
        }
        return data;
    }
})(TextDocument || (TextDocument = {}));
/**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */
class FullTextDocument {
    constructor(uri, languageId, version, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version;
        this._content = content;
        this._lineOffsets = undefined;
    }
    get uri() {
        return this._uri;
    }
    get languageId() {
        return this._languageId;
    }
    get version() {
        return this._version;
    }
    getText(range) {
        if (range) {
            let start = this.offsetAt(range.start);
            let end = this.offsetAt(range.end);
            return this._content.substring(start, end);
        }
        return this._content;
    }
    update(event, version) {
        this._content = event.text;
        this._version = version;
        this._lineOffsets = undefined;
    }
    getLineOffsets() {
        if (this._lineOffsets === undefined) {
            let lineOffsets = [];
            let text = this._content;
            let isLineStart = true;
            for (let i = 0; i < text.length; i++) {
                if (isLineStart) {
                    lineOffsets.push(i);
                    isLineStart = false;
                }
                let ch = text.charAt(i);
                isLineStart = (ch === '\r' || ch === '\n');
                if (ch === '\r' && i + 1 < text.length && text.charAt(i + 1) === '\n') {
                    i++;
                }
            }
            if (isLineStart && text.length > 0) {
                lineOffsets.push(text.length);
            }
            this._lineOffsets = lineOffsets;
        }
        return this._lineOffsets;
    }
    positionAt(offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        let lineOffsets = this.getLineOffsets();
        let low = 0, high = lineOffsets.length;
        if (high === 0) {
            return Position.create(0, offset);
        }
        while (low < high) {
            let mid = Math.floor((low + high) / 2);
            if (lineOffsets[mid] > offset) {
                high = mid;
            }
            else {
                low = mid + 1;
            }
        }
        // low is the least x for which the line offset is larger than the current offset
        // or array.length if no line offset is larger than the current offset
        let line = low - 1;
        return Position.create(line, offset - lineOffsets[line]);
    }
    offsetAt(position) {
        let lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
            return this._content.length;
        }
        else if (position.line < 0) {
            return 0;
        }
        let lineOffset = lineOffsets[position.line];
        let nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
    }
    get lineCount() {
        return this.getLineOffsets().length;
    }
}
var Is$4;
(function (Is) {
    const toString = Object.prototype.toString;
    function defined(value) {
        return typeof value !== 'undefined';
    }
    Is.defined = defined;
    function undefined$1(value) {
        return typeof value === 'undefined';
    }
    Is.undefined = undefined$1;
    function boolean(value) {
        return value === true || value === false;
    }
    Is.boolean = boolean;
    function string(value) {
        return toString.call(value) === '[object String]';
    }
    Is.string = string;
    function number(value) {
        return toString.call(value) === '[object Number]';
    }
    Is.number = number;
    function numberRange(value, min, max) {
        return toString.call(value) === '[object Number]' && min <= value && value <= max;
    }
    Is.numberRange = numberRange;
    function integer(value) {
        return toString.call(value) === '[object Number]' && -2147483648 <= value && value <= 2147483647;
    }
    Is.integer = integer;
    function uinteger(value) {
        return toString.call(value) === '[object Number]' && 0 <= value && value <= 2147483647;
    }
    Is.uinteger = uinteger;
    function func(value) {
        return toString.call(value) === '[object Function]';
    }
    Is.func = func;
    function objectLiteral(value) {
        // Strictly speaking class instances pass this check as well. Since the LSP
        // doesn't use classes we ignore this for now. If we do we need to add something
        // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
        return value !== null && typeof value === 'object';
    }
    Is.objectLiteral = objectLiteral;
    function typedArray(value, check) {
        return Array.isArray(value) && value.every(check);
    }
    Is.typedArray = typedArray;
})(Is$4 || (Is$4 = {}));

var main = /*#__PURE__*/Object.freeze({
    __proto__: null,
    get AnnotatedTextEdit () { return AnnotatedTextEdit; },
    get ChangeAnnotation () { return ChangeAnnotation; },
    get ChangeAnnotationIdentifier () { return ChangeAnnotationIdentifier; },
    get CodeAction () { return CodeAction; },
    get CodeActionContext () { return CodeActionContext; },
    get CodeActionKind () { return CodeActionKind; },
    get CodeActionTriggerKind () { return CodeActionTriggerKind; },
    get CodeDescription () { return CodeDescription; },
    get CodeLens () { return CodeLens; },
    get Color () { return Color; },
    get ColorInformation () { return ColorInformation; },
    get ColorPresentation () { return ColorPresentation; },
    get Command () { return Command; },
    get CompletionItem () { return CompletionItem; },
    get CompletionItemKind () { return CompletionItemKind; },
    get CompletionItemLabelDetails () { return CompletionItemLabelDetails; },
    get CompletionItemTag () { return CompletionItemTag; },
    get CompletionList () { return CompletionList; },
    get CreateFile () { return CreateFile; },
    get DeleteFile () { return DeleteFile; },
    get Diagnostic () { return Diagnostic; },
    get DiagnosticRelatedInformation () { return DiagnosticRelatedInformation; },
    get DiagnosticSeverity () { return DiagnosticSeverity; },
    get DiagnosticTag () { return DiagnosticTag; },
    get DocumentHighlight () { return DocumentHighlight; },
    get DocumentHighlightKind () { return DocumentHighlightKind; },
    get DocumentLink () { return DocumentLink; },
    get DocumentSymbol () { return DocumentSymbol; },
    get DocumentUri () { return DocumentUri; },
    EOL: EOL,
    get FoldingRange () { return FoldingRange; },
    get FoldingRangeKind () { return FoldingRangeKind; },
    get FormattingOptions () { return FormattingOptions; },
    get Hover () { return Hover; },
    get InlayHint () { return InlayHint; },
    get InlayHintKind () { return InlayHintKind; },
    get InlayHintLabelPart () { return InlayHintLabelPart; },
    get InlineCompletionContext () { return InlineCompletionContext; },
    get InlineCompletionItem () { return InlineCompletionItem; },
    get InlineCompletionList () { return InlineCompletionList; },
    get InlineCompletionTriggerKind () { return InlineCompletionTriggerKind; },
    get InlineValueContext () { return InlineValueContext; },
    get InlineValueEvaluatableExpression () { return InlineValueEvaluatableExpression; },
    get InlineValueText () { return InlineValueText; },
    get InlineValueVariableLookup () { return InlineValueVariableLookup; },
    get InsertReplaceEdit () { return InsertReplaceEdit; },
    get InsertTextFormat () { return InsertTextFormat; },
    get InsertTextMode () { return InsertTextMode; },
    get Location () { return Location; },
    get LocationLink () { return LocationLink; },
    get MarkedString () { return MarkedString; },
    get MarkupContent () { return MarkupContent; },
    get MarkupKind () { return MarkupKind; },
    get OptionalVersionedTextDocumentIdentifier () { return OptionalVersionedTextDocumentIdentifier; },
    get ParameterInformation () { return ParameterInformation; },
    get Position () { return Position; },
    get Range () { return Range; },
    get RenameFile () { return RenameFile; },
    get SelectedCompletionInfo () { return SelectedCompletionInfo; },
    get SelectionRange () { return SelectionRange; },
    get SemanticTokenModifiers () { return SemanticTokenModifiers; },
    get SemanticTokenTypes () { return SemanticTokenTypes; },
    get SemanticTokens () { return SemanticTokens; },
    get SignatureInformation () { return SignatureInformation; },
    get StringValue () { return StringValue; },
    get SymbolInformation () { return SymbolInformation; },
    get SymbolKind () { return SymbolKind; },
    get SymbolTag () { return SymbolTag; },
    get TextDocument () { return TextDocument; },
    get TextDocumentEdit () { return TextDocumentEdit; },
    get TextDocumentIdentifier () { return TextDocumentIdentifier; },
    get TextDocumentItem () { return TextDocumentItem; },
    get TextEdit () { return TextEdit; },
    get URI () { return URI; },
    get VersionedTextDocumentIdentifier () { return VersionedTextDocumentIdentifier; },
    WorkspaceChange: WorkspaceChange,
    get WorkspaceEdit () { return WorkspaceEdit; },
    get WorkspaceFolder () { return WorkspaceFolder; },
    get WorkspaceSymbol () { return WorkspaceSymbol; },
    get integer () { return integer; },
    get uinteger () { return uinteger; }
});

var require$$1 = /*@__PURE__*/getAugmentedNamespace(main);

var messages = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(messages, "__esModule", { value: true });
messages.ProtocolNotificationType = messages.ProtocolNotificationType0 = messages.ProtocolRequestType = messages.ProtocolRequestType0 = messages.RegistrationType = messages.MessageDirection = void 0;
const vscode_jsonrpc_1$3 = main$1;
var MessageDirection;
(function (MessageDirection) {
    MessageDirection["clientToServer"] = "clientToServer";
    MessageDirection["serverToClient"] = "serverToClient";
    MessageDirection["both"] = "both";
})(MessageDirection || (messages.MessageDirection = MessageDirection = {}));
class RegistrationType {
    constructor(method) {
        this.method = method;
    }
}
messages.RegistrationType = RegistrationType;
class ProtocolRequestType0 extends vscode_jsonrpc_1$3.RequestType0 {
    constructor(method) {
        super(method);
    }
}
messages.ProtocolRequestType0 = ProtocolRequestType0;
class ProtocolRequestType extends vscode_jsonrpc_1$3.RequestType {
    constructor(method) {
        super(method, vscode_jsonrpc_1$3.ParameterStructures.byName);
    }
}
messages.ProtocolRequestType = ProtocolRequestType;
class ProtocolNotificationType0 extends vscode_jsonrpc_1$3.NotificationType0 {
    constructor(method) {
        super(method);
    }
}
messages.ProtocolNotificationType0 = ProtocolNotificationType0;
class ProtocolNotificationType extends vscode_jsonrpc_1$3.NotificationType {
    constructor(method) {
        super(method, vscode_jsonrpc_1$3.ParameterStructures.byName);
    }
}
messages.ProtocolNotificationType = ProtocolNotificationType;

var protocol = {};

var is$1 = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(is$1, "__esModule", { value: true });
is$1.objectLiteral = is$1.typedArray = is$1.stringArray = is$1.array = is$1.func = is$1.error = is$1.number = is$1.string = is$1.boolean = void 0;
function boolean$1(value) {
    return value === true || value === false;
}
is$1.boolean = boolean$1;
function string$1(value) {
    return typeof value === 'string' || value instanceof String;
}
is$1.string = string$1;
function number$1(value) {
    return typeof value === 'number' || value instanceof Number;
}
is$1.number = number$1;
function error$1(value) {
    return value instanceof Error;
}
is$1.error = error$1;
function func$1(value) {
    return typeof value === 'function';
}
is$1.func = func$1;
function array$1(value) {
    return Array.isArray(value);
}
is$1.array = array$1;
function stringArray$1(value) {
    return array$1(value) && value.every(elem => string$1(elem));
}
is$1.stringArray = stringArray$1;
function typedArray$1(value, check) {
    return Array.isArray(value) && value.every(check);
}
is$1.typedArray = typedArray$1;
function objectLiteral(value) {
    // Strictly speaking class instances pass this check as well. Since the LSP
    // doesn't use classes we ignore this for now. If we do we need to add something
    // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
    return value !== null && typeof value === 'object';
}
is$1.objectLiteral = objectLiteral;

var protocol_implementation = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(protocol_implementation, "__esModule", { value: true });
protocol_implementation.ImplementationRequest = void 0;
const messages_1$k = messages;
/**
 * A request to resolve the implementation locations of a symbol at a given text
 * document position. The request's parameter is of type {@link TextDocumentPositionParams}
 * the response is of type {@link Definition} or a Thenable that resolves to such.
 */
var ImplementationRequest;
(function (ImplementationRequest) {
    ImplementationRequest.method = 'textDocument/implementation';
    ImplementationRequest.messageDirection = messages_1$k.MessageDirection.clientToServer;
    ImplementationRequest.type = new messages_1$k.ProtocolRequestType(ImplementationRequest.method);
})(ImplementationRequest || (protocol_implementation.ImplementationRequest = ImplementationRequest = {}));

var protocol_typeDefinition = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(protocol_typeDefinition, "__esModule", { value: true });
protocol_typeDefinition.TypeDefinitionRequest = void 0;
const messages_1$j = messages;
/**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type {@link TextDocumentPositionParams}
 * the response is of type {@link Definition} or a Thenable that resolves to such.
 */
var TypeDefinitionRequest;
(function (TypeDefinitionRequest) {
    TypeDefinitionRequest.method = 'textDocument/typeDefinition';
    TypeDefinitionRequest.messageDirection = messages_1$j.MessageDirection.clientToServer;
    TypeDefinitionRequest.type = new messages_1$j.ProtocolRequestType(TypeDefinitionRequest.method);
})(TypeDefinitionRequest || (protocol_typeDefinition.TypeDefinitionRequest = TypeDefinitionRequest = {}));

var protocol_workspaceFolder = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(protocol_workspaceFolder, "__esModule", { value: true });
protocol_workspaceFolder.DidChangeWorkspaceFoldersNotification = protocol_workspaceFolder.WorkspaceFoldersRequest = void 0;
const messages_1$i = messages;
/**
 * The `workspace/workspaceFolders` is sent from the server to the client to fetch the open workspace folders.
 */
var WorkspaceFoldersRequest;
(function (WorkspaceFoldersRequest) {
    WorkspaceFoldersRequest.method = 'workspace/workspaceFolders';
    WorkspaceFoldersRequest.messageDirection = messages_1$i.MessageDirection.serverToClient;
    WorkspaceFoldersRequest.type = new messages_1$i.ProtocolRequestType0(WorkspaceFoldersRequest.method);
})(WorkspaceFoldersRequest || (protocol_workspaceFolder.WorkspaceFoldersRequest = WorkspaceFoldersRequest = {}));
/**
 * The `workspace/didChangeWorkspaceFolders` notification is sent from the client to the server when the workspace
 * folder configuration changes.
 */
var DidChangeWorkspaceFoldersNotification;
(function (DidChangeWorkspaceFoldersNotification) {
    DidChangeWorkspaceFoldersNotification.method = 'workspace/didChangeWorkspaceFolders';
    DidChangeWorkspaceFoldersNotification.messageDirection = messages_1$i.MessageDirection.clientToServer;
    DidChangeWorkspaceFoldersNotification.type = new messages_1$i.ProtocolNotificationType(DidChangeWorkspaceFoldersNotification.method);
})(DidChangeWorkspaceFoldersNotification || (protocol_workspaceFolder.DidChangeWorkspaceFoldersNotification = DidChangeWorkspaceFoldersNotification = {}));

var protocol_configuration = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(protocol_configuration, "__esModule", { value: true });
protocol_configuration.ConfigurationRequest = void 0;
const messages_1$h = messages;
//---- Get Configuration request ----
/**
 * The 'workspace/configuration' request is sent from the server to the client to fetch a certain
 * configuration setting.
 *
 * This pull model replaces the old push model were the client signaled configuration change via an
 * event. If the server still needs to react to configuration changes (since the server caches the
 * result of `workspace/configuration` requests) the server should register for an empty configuration
 * change event and empty the cache if such an event is received.
 */
var ConfigurationRequest;
(function (ConfigurationRequest) {
    ConfigurationRequest.method = 'workspace/configuration';
    ConfigurationRequest.messageDirection = messages_1$h.MessageDirection.serverToClient;
    ConfigurationRequest.type = new messages_1$h.ProtocolRequestType(ConfigurationRequest.method);
})(ConfigurationRequest || (protocol_configuration.ConfigurationRequest = ConfigurationRequest = {}));

var protocol_colorProvider = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(protocol_colorProvider, "__esModule", { value: true });
protocol_colorProvider.ColorPresentationRequest = protocol_colorProvider.DocumentColorRequest = void 0;
const messages_1$g = messages;
/**
 * A request to list all color symbols found in a given text document. The request's
 * parameter is of type {@link DocumentColorParams} the
 * response is of type {@link ColorInformation ColorInformation[]} or a Thenable
 * that resolves to such.
 */
var DocumentColorRequest;
(function (DocumentColorRequest) {
    DocumentColorRequest.method = 'textDocument/documentColor';
    DocumentColorRequest.messageDirection = messages_1$g.MessageDirection.clientToServer;
    DocumentColorRequest.type = new messages_1$g.ProtocolRequestType(DocumentColorRequest.method);
})(DocumentColorRequest || (protocol_colorProvider.DocumentColorRequest = DocumentColorRequest = {}));
/**
 * A request to list all presentation for a color. The request's
 * parameter is of type {@link ColorPresentationParams} the
 * response is of type {@link ColorInformation ColorInformation[]} or a Thenable
 * that resolves to such.
 */
var ColorPresentationRequest;
(function (ColorPresentationRequest) {
    ColorPresentationRequest.method = 'textDocument/colorPresentation';
    ColorPresentationRequest.messageDirection = messages_1$g.MessageDirection.clientToServer;
    ColorPresentationRequest.type = new messages_1$g.ProtocolRequestType(ColorPresentationRequest.method);
})(ColorPresentationRequest || (protocol_colorProvider.ColorPresentationRequest = ColorPresentationRequest = {}));

var protocol_foldingRange = {};

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(protocol_foldingRange, "__esModule", { value: true });
protocol_foldingRange.FoldingRangeRefreshRequest = protocol_foldingRange.FoldingRangeRequest = void 0;
const messages_1$f = messages;
/**
 * A request to provide folding ranges in a document. The request's
 * parameter is of type {@link FoldingRangeParams}, the
 * response is of type {@link FoldingRangeList} or a Thenable
 * that resolves to such.
 */
var FoldingRangeRequest;
(function (FoldingRangeRequest) {
    FoldingRangeRequest.method = 'textDocument/foldingRange';
    FoldingRangeRequest.messageDirection = messages_1$f.MessageDirection.clientToServer;
    FoldingRangeRequest.type = new messages_1$f.ProtocolRequestType(FoldingRangeRequest.method);
})(FoldingRangeRequest || (protocol_foldingRange.FoldingRangeRequest = FoldingRangeRequest = {}));
/**
 * @since 3.18.0
 * @proposed
 */
var FoldingRangeRefreshRequest;
(function (FoldingRangeRefreshRequest) {
    FoldingRangeRefreshRequest.method = `workspace/foldingRange/refresh`;
    FoldingRangeRefreshRequest.messageDirection = messages_1$f.MessageDirection.serverToClient;
    FoldingRangeRefreshRequest.type = new messages_1$f.ProtocolRequestType0(FoldingRangeRefreshRequest.method);
})(FoldingRangeRefreshRequest || (protocol_foldingRange.FoldingRangeRefreshRequest = FoldingRangeRefreshRequest = {}));

var protocol_declaration = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(protocol_declaration, "__esModule", { value: true });
protocol_declaration.DeclarationRequest = void 0;
const messages_1$e = messages;
/**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type {@link TextDocumentPositionParams}
 * the response is of type {@link Declaration} or a typed array of {@link DeclarationLink}
 * or a Thenable that resolves to such.
 */
var DeclarationRequest;
(function (DeclarationRequest) {
    DeclarationRequest.method = 'textDocument/declaration';
    DeclarationRequest.messageDirection = messages_1$e.MessageDirection.clientToServer;
    DeclarationRequest.type = new messages_1$e.ProtocolRequestType(DeclarationRequest.method);
})(DeclarationRequest || (protocol_declaration.DeclarationRequest = DeclarationRequest = {}));

var protocol_selectionRange = {};

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(protocol_selectionRange, "__esModule", { value: true });
protocol_selectionRange.SelectionRangeRequest = void 0;
const messages_1$d = messages;
/**
 * A request to provide selection ranges in a document. The request's
 * parameter is of type {@link SelectionRangeParams}, the
 * response is of type {@link SelectionRange SelectionRange[]} or a Thenable
 * that resolves to such.
 */
var SelectionRangeRequest;
(function (SelectionRangeRequest) {
    SelectionRangeRequest.method = 'textDocument/selectionRange';
    SelectionRangeRequest.messageDirection = messages_1$d.MessageDirection.clientToServer;
    SelectionRangeRequest.type = new messages_1$d.ProtocolRequestType(SelectionRangeRequest.method);
})(SelectionRangeRequest || (protocol_selectionRange.SelectionRangeRequest = SelectionRangeRequest = {}));

var protocol_progress = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(protocol_progress, "__esModule", { value: true });
protocol_progress.WorkDoneProgressCancelNotification = protocol_progress.WorkDoneProgressCreateRequest = protocol_progress.WorkDoneProgress = void 0;
const vscode_jsonrpc_1$2 = main$1;
const messages_1$c = messages;
var WorkDoneProgress;
(function (WorkDoneProgress) {
    WorkDoneProgress.type = new vscode_jsonrpc_1$2.ProgressType();
    function is(value) {
        return value === WorkDoneProgress.type;
    }
    WorkDoneProgress.is = is;
})(WorkDoneProgress || (protocol_progress.WorkDoneProgress = WorkDoneProgress = {}));
/**
 * The `window/workDoneProgress/create` request is sent from the server to the client to initiate progress
 * reporting from the server.
 */
var WorkDoneProgressCreateRequest;
(function (WorkDoneProgressCreateRequest) {
    WorkDoneProgressCreateRequest.method = 'window/workDoneProgress/create';
    WorkDoneProgressCreateRequest.messageDirection = messages_1$c.MessageDirection.serverToClient;
    WorkDoneProgressCreateRequest.type = new messages_1$c.ProtocolRequestType(WorkDoneProgressCreateRequest.method);
})(WorkDoneProgressCreateRequest || (protocol_progress.WorkDoneProgressCreateRequest = WorkDoneProgressCreateRequest = {}));
/**
 * The `window/workDoneProgress/cancel` notification is sent from  the client to the server to cancel a progress
 * initiated on the server side.
 */
var WorkDoneProgressCancelNotification;
(function (WorkDoneProgressCancelNotification) {
    WorkDoneProgressCancelNotification.method = 'window/workDoneProgress/cancel';
    WorkDoneProgressCancelNotification.messageDirection = messages_1$c.MessageDirection.clientToServer;
    WorkDoneProgressCancelNotification.type = new messages_1$c.ProtocolNotificationType(WorkDoneProgressCancelNotification.method);
})(WorkDoneProgressCancelNotification || (protocol_progress.WorkDoneProgressCancelNotification = WorkDoneProgressCancelNotification = {}));

var protocol_callHierarchy = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) TypeFox, Microsoft and others. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(protocol_callHierarchy, "__esModule", { value: true });
protocol_callHierarchy.CallHierarchyOutgoingCallsRequest = protocol_callHierarchy.CallHierarchyIncomingCallsRequest = protocol_callHierarchy.CallHierarchyPrepareRequest = void 0;
const messages_1$b = messages;
/**
 * A request to result a `CallHierarchyItem` in a document at a given position.
 * Can be used as an input to an incoming or outgoing call hierarchy.
 *
 * @since 3.16.0
 */
var CallHierarchyPrepareRequest;
(function (CallHierarchyPrepareRequest) {
    CallHierarchyPrepareRequest.method = 'textDocument/prepareCallHierarchy';
    CallHierarchyPrepareRequest.messageDirection = messages_1$b.MessageDirection.clientToServer;
    CallHierarchyPrepareRequest.type = new messages_1$b.ProtocolRequestType(CallHierarchyPrepareRequest.method);
})(CallHierarchyPrepareRequest || (protocol_callHierarchy.CallHierarchyPrepareRequest = CallHierarchyPrepareRequest = {}));
/**
 * A request to resolve the incoming calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0
 */
var CallHierarchyIncomingCallsRequest;
(function (CallHierarchyIncomingCallsRequest) {
    CallHierarchyIncomingCallsRequest.method = 'callHierarchy/incomingCalls';
    CallHierarchyIncomingCallsRequest.messageDirection = messages_1$b.MessageDirection.clientToServer;
    CallHierarchyIncomingCallsRequest.type = new messages_1$b.ProtocolRequestType(CallHierarchyIncomingCallsRequest.method);
})(CallHierarchyIncomingCallsRequest || (protocol_callHierarchy.CallHierarchyIncomingCallsRequest = CallHierarchyIncomingCallsRequest = {}));
/**
 * A request to resolve the outgoing calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0
 */
var CallHierarchyOutgoingCallsRequest;
(function (CallHierarchyOutgoingCallsRequest) {
    CallHierarchyOutgoingCallsRequest.method = 'callHierarchy/outgoingCalls';
    CallHierarchyOutgoingCallsRequest.messageDirection = messages_1$b.MessageDirection.clientToServer;
    CallHierarchyOutgoingCallsRequest.type = new messages_1$b.ProtocolRequestType(CallHierarchyOutgoingCallsRequest.method);
})(CallHierarchyOutgoingCallsRequest || (protocol_callHierarchy.CallHierarchyOutgoingCallsRequest = CallHierarchyOutgoingCallsRequest = {}));

var protocol_semanticTokens = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(protocol_semanticTokens, "__esModule", { value: true });
protocol_semanticTokens.SemanticTokensRefreshRequest = protocol_semanticTokens.SemanticTokensRangeRequest = protocol_semanticTokens.SemanticTokensDeltaRequest = protocol_semanticTokens.SemanticTokensRequest = protocol_semanticTokens.SemanticTokensRegistrationType = protocol_semanticTokens.TokenFormat = void 0;
const messages_1$a = messages;
//------- 'textDocument/semanticTokens' -----
var TokenFormat;
(function (TokenFormat) {
    TokenFormat.Relative = 'relative';
})(TokenFormat || (protocol_semanticTokens.TokenFormat = TokenFormat = {}));
var SemanticTokensRegistrationType;
(function (SemanticTokensRegistrationType) {
    SemanticTokensRegistrationType.method = 'textDocument/semanticTokens';
    SemanticTokensRegistrationType.type = new messages_1$a.RegistrationType(SemanticTokensRegistrationType.method);
})(SemanticTokensRegistrationType || (protocol_semanticTokens.SemanticTokensRegistrationType = SemanticTokensRegistrationType = {}));
/**
 * @since 3.16.0
 */
var SemanticTokensRequest;
(function (SemanticTokensRequest) {
    SemanticTokensRequest.method = 'textDocument/semanticTokens/full';
    SemanticTokensRequest.messageDirection = messages_1$a.MessageDirection.clientToServer;
    SemanticTokensRequest.type = new messages_1$a.ProtocolRequestType(SemanticTokensRequest.method);
    SemanticTokensRequest.registrationMethod = SemanticTokensRegistrationType.method;
})(SemanticTokensRequest || (protocol_semanticTokens.SemanticTokensRequest = SemanticTokensRequest = {}));
/**
 * @since 3.16.0
 */
var SemanticTokensDeltaRequest;
(function (SemanticTokensDeltaRequest) {
    SemanticTokensDeltaRequest.method = 'textDocument/semanticTokens/full/delta';
    SemanticTokensDeltaRequest.messageDirection = messages_1$a.MessageDirection.clientToServer;
    SemanticTokensDeltaRequest.type = new messages_1$a.ProtocolRequestType(SemanticTokensDeltaRequest.method);
    SemanticTokensDeltaRequest.registrationMethod = SemanticTokensRegistrationType.method;
})(SemanticTokensDeltaRequest || (protocol_semanticTokens.SemanticTokensDeltaRequest = SemanticTokensDeltaRequest = {}));
/**
 * @since 3.16.0
 */
var SemanticTokensRangeRequest;
(function (SemanticTokensRangeRequest) {
    SemanticTokensRangeRequest.method = 'textDocument/semanticTokens/range';
    SemanticTokensRangeRequest.messageDirection = messages_1$a.MessageDirection.clientToServer;
    SemanticTokensRangeRequest.type = new messages_1$a.ProtocolRequestType(SemanticTokensRangeRequest.method);
    SemanticTokensRangeRequest.registrationMethod = SemanticTokensRegistrationType.method;
})(SemanticTokensRangeRequest || (protocol_semanticTokens.SemanticTokensRangeRequest = SemanticTokensRangeRequest = {}));
/**
 * @since 3.16.0
 */
var SemanticTokensRefreshRequest;
(function (SemanticTokensRefreshRequest) {
    SemanticTokensRefreshRequest.method = `workspace/semanticTokens/refresh`;
    SemanticTokensRefreshRequest.messageDirection = messages_1$a.MessageDirection.serverToClient;
    SemanticTokensRefreshRequest.type = new messages_1$a.ProtocolRequestType0(SemanticTokensRefreshRequest.method);
})(SemanticTokensRefreshRequest || (protocol_semanticTokens.SemanticTokensRefreshRequest = SemanticTokensRefreshRequest = {}));

var protocol_showDocument = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(protocol_showDocument, "__esModule", { value: true });
protocol_showDocument.ShowDocumentRequest = void 0;
const messages_1$9 = messages;
/**
 * A request to show a document. This request might open an
 * external program depending on the value of the URI to open.
 * For example a request to open `https://code.visualstudio.com/`
 * will very likely open the URI in a WEB browser.
 *
 * @since 3.16.0
*/
var ShowDocumentRequest;
(function (ShowDocumentRequest) {
    ShowDocumentRequest.method = 'window/showDocument';
    ShowDocumentRequest.messageDirection = messages_1$9.MessageDirection.serverToClient;
    ShowDocumentRequest.type = new messages_1$9.ProtocolRequestType(ShowDocumentRequest.method);
})(ShowDocumentRequest || (protocol_showDocument.ShowDocumentRequest = ShowDocumentRequest = {}));

var protocol_linkedEditingRange = {};

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(protocol_linkedEditingRange, "__esModule", { value: true });
protocol_linkedEditingRange.LinkedEditingRangeRequest = void 0;
const messages_1$8 = messages;
/**
 * A request to provide ranges that can be edited together.
 *
 * @since 3.16.0
 */
var LinkedEditingRangeRequest;
(function (LinkedEditingRangeRequest) {
    LinkedEditingRangeRequest.method = 'textDocument/linkedEditingRange';
    LinkedEditingRangeRequest.messageDirection = messages_1$8.MessageDirection.clientToServer;
    LinkedEditingRangeRequest.type = new messages_1$8.ProtocolRequestType(LinkedEditingRangeRequest.method);
})(LinkedEditingRangeRequest || (protocol_linkedEditingRange.LinkedEditingRangeRequest = LinkedEditingRangeRequest = {}));

var protocol_fileOperations = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(protocol_fileOperations, "__esModule", { value: true });
protocol_fileOperations.WillDeleteFilesRequest = protocol_fileOperations.DidDeleteFilesNotification = protocol_fileOperations.DidRenameFilesNotification = protocol_fileOperations.WillRenameFilesRequest = protocol_fileOperations.DidCreateFilesNotification = protocol_fileOperations.WillCreateFilesRequest = protocol_fileOperations.FileOperationPatternKind = void 0;
const messages_1$7 = messages;
/**
 * A pattern kind describing if a glob pattern matches a file a folder or
 * both.
 *
 * @since 3.16.0
 */
var FileOperationPatternKind;
(function (FileOperationPatternKind) {
    /**
     * The pattern matches a file only.
     */
    FileOperationPatternKind.file = 'file';
    /**
     * The pattern matches a folder only.
     */
    FileOperationPatternKind.folder = 'folder';
})(FileOperationPatternKind || (protocol_fileOperations.FileOperationPatternKind = FileOperationPatternKind = {}));
/**
 * The will create files request is sent from the client to the server before files are actually
 * created as long as the creation is triggered from within the client.
 *
 * The request can return a `WorkspaceEdit` which will be applied to workspace before the
 * files are created. Hence the `WorkspaceEdit` can not manipulate the content of the file
 * to be created.
 *
 * @since 3.16.0
 */
var WillCreateFilesRequest;
(function (WillCreateFilesRequest) {
    WillCreateFilesRequest.method = 'workspace/willCreateFiles';
    WillCreateFilesRequest.messageDirection = messages_1$7.MessageDirection.clientToServer;
    WillCreateFilesRequest.type = new messages_1$7.ProtocolRequestType(WillCreateFilesRequest.method);
})(WillCreateFilesRequest || (protocol_fileOperations.WillCreateFilesRequest = WillCreateFilesRequest = {}));
/**
 * The did create files notification is sent from the client to the server when
 * files were created from within the client.
 *
 * @since 3.16.0
 */
var DidCreateFilesNotification;
(function (DidCreateFilesNotification) {
    DidCreateFilesNotification.method = 'workspace/didCreateFiles';
    DidCreateFilesNotification.messageDirection = messages_1$7.MessageDirection.clientToServer;
    DidCreateFilesNotification.type = new messages_1$7.ProtocolNotificationType(DidCreateFilesNotification.method);
})(DidCreateFilesNotification || (protocol_fileOperations.DidCreateFilesNotification = DidCreateFilesNotification = {}));
/**
 * The will rename files request is sent from the client to the server before files are actually
 * renamed as long as the rename is triggered from within the client.
 *
 * @since 3.16.0
 */
var WillRenameFilesRequest;
(function (WillRenameFilesRequest) {
    WillRenameFilesRequest.method = 'workspace/willRenameFiles';
    WillRenameFilesRequest.messageDirection = messages_1$7.MessageDirection.clientToServer;
    WillRenameFilesRequest.type = new messages_1$7.ProtocolRequestType(WillRenameFilesRequest.method);
})(WillRenameFilesRequest || (protocol_fileOperations.WillRenameFilesRequest = WillRenameFilesRequest = {}));
/**
 * The did rename files notification is sent from the client to the server when
 * files were renamed from within the client.
 *
 * @since 3.16.0
 */
var DidRenameFilesNotification;
(function (DidRenameFilesNotification) {
    DidRenameFilesNotification.method = 'workspace/didRenameFiles';
    DidRenameFilesNotification.messageDirection = messages_1$7.MessageDirection.clientToServer;
    DidRenameFilesNotification.type = new messages_1$7.ProtocolNotificationType(DidRenameFilesNotification.method);
})(DidRenameFilesNotification || (protocol_fileOperations.DidRenameFilesNotification = DidRenameFilesNotification = {}));
/**
 * The will delete files request is sent from the client to the server before files are actually
 * deleted as long as the deletion is triggered from within the client.
 *
 * @since 3.16.0
 */
var DidDeleteFilesNotification;
(function (DidDeleteFilesNotification) {
    DidDeleteFilesNotification.method = 'workspace/didDeleteFiles';
    DidDeleteFilesNotification.messageDirection = messages_1$7.MessageDirection.clientToServer;
    DidDeleteFilesNotification.type = new messages_1$7.ProtocolNotificationType(DidDeleteFilesNotification.method);
})(DidDeleteFilesNotification || (protocol_fileOperations.DidDeleteFilesNotification = DidDeleteFilesNotification = {}));
/**
 * The did delete files notification is sent from the client to the server when
 * files were deleted from within the client.
 *
 * @since 3.16.0
 */
var WillDeleteFilesRequest;
(function (WillDeleteFilesRequest) {
    WillDeleteFilesRequest.method = 'workspace/willDeleteFiles';
    WillDeleteFilesRequest.messageDirection = messages_1$7.MessageDirection.clientToServer;
    WillDeleteFilesRequest.type = new messages_1$7.ProtocolRequestType(WillDeleteFilesRequest.method);
})(WillDeleteFilesRequest || (protocol_fileOperations.WillDeleteFilesRequest = WillDeleteFilesRequest = {}));

var protocol_moniker = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(protocol_moniker, "__esModule", { value: true });
protocol_moniker.MonikerRequest = protocol_moniker.MonikerKind = protocol_moniker.UniquenessLevel = void 0;
const messages_1$6 = messages;
/**
 * Moniker uniqueness level to define scope of the moniker.
 *
 * @since 3.16.0
 */
var UniquenessLevel;
(function (UniquenessLevel) {
    /**
     * The moniker is only unique inside a document
     */
    UniquenessLevel.document = 'document';
    /**
     * The moniker is unique inside a project for which a dump got created
     */
    UniquenessLevel.project = 'project';
    /**
     * The moniker is unique inside the group to which a project belongs
     */
    UniquenessLevel.group = 'group';
    /**
     * The moniker is unique inside the moniker scheme.
     */
    UniquenessLevel.scheme = 'scheme';
    /**
     * The moniker is globally unique
     */
    UniquenessLevel.global = 'global';
})(UniquenessLevel || (protocol_moniker.UniquenessLevel = UniquenessLevel = {}));
/**
 * The moniker kind.
 *
 * @since 3.16.0
 */
var MonikerKind;
(function (MonikerKind) {
    /**
     * The moniker represent a symbol that is imported into a project
     */
    MonikerKind.$import = 'import';
    /**
     * The moniker represents a symbol that is exported from a project
     */
    MonikerKind.$export = 'export';
    /**
     * The moniker represents a symbol that is local to a project (e.g. a local
     * variable of a function, a class not visible outside the project, ...)
     */
    MonikerKind.local = 'local';
})(MonikerKind || (protocol_moniker.MonikerKind = MonikerKind = {}));
/**
 * A request to get the moniker of a symbol at a given text document position.
 * The request parameter is of type {@link TextDocumentPositionParams}.
 * The response is of type {@link Moniker Moniker[]} or `null`.
 */
var MonikerRequest;
(function (MonikerRequest) {
    MonikerRequest.method = 'textDocument/moniker';
    MonikerRequest.messageDirection = messages_1$6.MessageDirection.clientToServer;
    MonikerRequest.type = new messages_1$6.ProtocolRequestType(MonikerRequest.method);
})(MonikerRequest || (protocol_moniker.MonikerRequest = MonikerRequest = {}));

var protocol_typeHierarchy = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) TypeFox, Microsoft and others. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(protocol_typeHierarchy, "__esModule", { value: true });
protocol_typeHierarchy.TypeHierarchySubtypesRequest = protocol_typeHierarchy.TypeHierarchySupertypesRequest = protocol_typeHierarchy.TypeHierarchyPrepareRequest = void 0;
const messages_1$5 = messages;
/**
 * A request to result a `TypeHierarchyItem` in a document at a given position.
 * Can be used as an input to a subtypes or supertypes type hierarchy.
 *
 * @since 3.17.0
 */
var TypeHierarchyPrepareRequest;
(function (TypeHierarchyPrepareRequest) {
    TypeHierarchyPrepareRequest.method = 'textDocument/prepareTypeHierarchy';
    TypeHierarchyPrepareRequest.messageDirection = messages_1$5.MessageDirection.clientToServer;
    TypeHierarchyPrepareRequest.type = new messages_1$5.ProtocolRequestType(TypeHierarchyPrepareRequest.method);
})(TypeHierarchyPrepareRequest || (protocol_typeHierarchy.TypeHierarchyPrepareRequest = TypeHierarchyPrepareRequest = {}));
/**
 * A request to resolve the supertypes for a given `TypeHierarchyItem`.
 *
 * @since 3.17.0
 */
var TypeHierarchySupertypesRequest;
(function (TypeHierarchySupertypesRequest) {
    TypeHierarchySupertypesRequest.method = 'typeHierarchy/supertypes';
    TypeHierarchySupertypesRequest.messageDirection = messages_1$5.MessageDirection.clientToServer;
    TypeHierarchySupertypesRequest.type = new messages_1$5.ProtocolRequestType(TypeHierarchySupertypesRequest.method);
})(TypeHierarchySupertypesRequest || (protocol_typeHierarchy.TypeHierarchySupertypesRequest = TypeHierarchySupertypesRequest = {}));
/**
 * A request to resolve the subtypes for a given `TypeHierarchyItem`.
 *
 * @since 3.17.0
 */
var TypeHierarchySubtypesRequest;
(function (TypeHierarchySubtypesRequest) {
    TypeHierarchySubtypesRequest.method = 'typeHierarchy/subtypes';
    TypeHierarchySubtypesRequest.messageDirection = messages_1$5.MessageDirection.clientToServer;
    TypeHierarchySubtypesRequest.type = new messages_1$5.ProtocolRequestType(TypeHierarchySubtypesRequest.method);
})(TypeHierarchySubtypesRequest || (protocol_typeHierarchy.TypeHierarchySubtypesRequest = TypeHierarchySubtypesRequest = {}));

var protocol_inlineValue = {};

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(protocol_inlineValue, "__esModule", { value: true });
protocol_inlineValue.InlineValueRefreshRequest = protocol_inlineValue.InlineValueRequest = void 0;
const messages_1$4 = messages;
/**
 * A request to provide inline values in a document. The request's parameter is of
 * type {@link InlineValueParams}, the response is of type
 * {@link InlineValue InlineValue[]} or a Thenable that resolves to such.
 *
 * @since 3.17.0
 */
var InlineValueRequest;
(function (InlineValueRequest) {
    InlineValueRequest.method = 'textDocument/inlineValue';
    InlineValueRequest.messageDirection = messages_1$4.MessageDirection.clientToServer;
    InlineValueRequest.type = new messages_1$4.ProtocolRequestType(InlineValueRequest.method);
})(InlineValueRequest || (protocol_inlineValue.InlineValueRequest = InlineValueRequest = {}));
/**
 * @since 3.17.0
 */
var InlineValueRefreshRequest;
(function (InlineValueRefreshRequest) {
    InlineValueRefreshRequest.method = `workspace/inlineValue/refresh`;
    InlineValueRefreshRequest.messageDirection = messages_1$4.MessageDirection.serverToClient;
    InlineValueRefreshRequest.type = new messages_1$4.ProtocolRequestType0(InlineValueRefreshRequest.method);
})(InlineValueRefreshRequest || (protocol_inlineValue.InlineValueRefreshRequest = InlineValueRefreshRequest = {}));

var protocol_inlayHint = {};

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(protocol_inlayHint, "__esModule", { value: true });
protocol_inlayHint.InlayHintRefreshRequest = protocol_inlayHint.InlayHintResolveRequest = protocol_inlayHint.InlayHintRequest = void 0;
const messages_1$3 = messages;
/**
 * A request to provide inlay hints in a document. The request's parameter is of
 * type {@link InlayHintsParams}, the response is of type
 * {@link InlayHint InlayHint[]} or a Thenable that resolves to such.
 *
 * @since 3.17.0
 */
var InlayHintRequest;
(function (InlayHintRequest) {
    InlayHintRequest.method = 'textDocument/inlayHint';
    InlayHintRequest.messageDirection = messages_1$3.MessageDirection.clientToServer;
    InlayHintRequest.type = new messages_1$3.ProtocolRequestType(InlayHintRequest.method);
})(InlayHintRequest || (protocol_inlayHint.InlayHintRequest = InlayHintRequest = {}));
/**
 * A request to resolve additional properties for an inlay hint.
 * The request's parameter is of type {@link InlayHint}, the response is
 * of type {@link InlayHint} or a Thenable that resolves to such.
 *
 * @since 3.17.0
 */
var InlayHintResolveRequest;
(function (InlayHintResolveRequest) {
    InlayHintResolveRequest.method = 'inlayHint/resolve';
    InlayHintResolveRequest.messageDirection = messages_1$3.MessageDirection.clientToServer;
    InlayHintResolveRequest.type = new messages_1$3.ProtocolRequestType(InlayHintResolveRequest.method);
})(InlayHintResolveRequest || (protocol_inlayHint.InlayHintResolveRequest = InlayHintResolveRequest = {}));
/**
 * @since 3.17.0
 */
var InlayHintRefreshRequest;
(function (InlayHintRefreshRequest) {
    InlayHintRefreshRequest.method = `workspace/inlayHint/refresh`;
    InlayHintRefreshRequest.messageDirection = messages_1$3.MessageDirection.serverToClient;
    InlayHintRefreshRequest.type = new messages_1$3.ProtocolRequestType0(InlayHintRefreshRequest.method);
})(InlayHintRefreshRequest || (protocol_inlayHint.InlayHintRefreshRequest = InlayHintRefreshRequest = {}));

var protocol_diagnostic = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(protocol_diagnostic, "__esModule", { value: true });
protocol_diagnostic.DiagnosticRefreshRequest = protocol_diagnostic.WorkspaceDiagnosticRequest = protocol_diagnostic.DocumentDiagnosticRequest = protocol_diagnostic.DocumentDiagnosticReportKind = protocol_diagnostic.DiagnosticServerCancellationData = void 0;
const vscode_jsonrpc_1$1 = main$1;
const Is$3 = is$1;
const messages_1$2 = messages;
/**
 * @since 3.17.0
 */
var DiagnosticServerCancellationData;
(function (DiagnosticServerCancellationData) {
    function is(value) {
        const candidate = value;
        return candidate && Is$3.boolean(candidate.retriggerRequest);
    }
    DiagnosticServerCancellationData.is = is;
})(DiagnosticServerCancellationData || (protocol_diagnostic.DiagnosticServerCancellationData = DiagnosticServerCancellationData = {}));
/**
 * The document diagnostic report kinds.
 *
 * @since 3.17.0
 */
var DocumentDiagnosticReportKind;
(function (DocumentDiagnosticReportKind) {
    /**
     * A diagnostic report with a full
     * set of problems.
     */
    DocumentDiagnosticReportKind.Full = 'full';
    /**
     * A report indicating that the last
     * returned report is still accurate.
     */
    DocumentDiagnosticReportKind.Unchanged = 'unchanged';
})(DocumentDiagnosticReportKind || (protocol_diagnostic.DocumentDiagnosticReportKind = DocumentDiagnosticReportKind = {}));
/**
 * The document diagnostic request definition.
 *
 * @since 3.17.0
 */
var DocumentDiagnosticRequest;
(function (DocumentDiagnosticRequest) {
    DocumentDiagnosticRequest.method = 'textDocument/diagnostic';
    DocumentDiagnosticRequest.messageDirection = messages_1$2.MessageDirection.clientToServer;
    DocumentDiagnosticRequest.type = new messages_1$2.ProtocolRequestType(DocumentDiagnosticRequest.method);
    DocumentDiagnosticRequest.partialResult = new vscode_jsonrpc_1$1.ProgressType();
})(DocumentDiagnosticRequest || (protocol_diagnostic.DocumentDiagnosticRequest = DocumentDiagnosticRequest = {}));
/**
 * The workspace diagnostic request definition.
 *
 * @since 3.17.0
 */
var WorkspaceDiagnosticRequest;
(function (WorkspaceDiagnosticRequest) {
    WorkspaceDiagnosticRequest.method = 'workspace/diagnostic';
    WorkspaceDiagnosticRequest.messageDirection = messages_1$2.MessageDirection.clientToServer;
    WorkspaceDiagnosticRequest.type = new messages_1$2.ProtocolRequestType(WorkspaceDiagnosticRequest.method);
    WorkspaceDiagnosticRequest.partialResult = new vscode_jsonrpc_1$1.ProgressType();
})(WorkspaceDiagnosticRequest || (protocol_diagnostic.WorkspaceDiagnosticRequest = WorkspaceDiagnosticRequest = {}));
/**
 * The diagnostic refresh request definition.
 *
 * @since 3.17.0
 */
var DiagnosticRefreshRequest;
(function (DiagnosticRefreshRequest) {
    DiagnosticRefreshRequest.method = `workspace/diagnostic/refresh`;
    DiagnosticRefreshRequest.messageDirection = messages_1$2.MessageDirection.serverToClient;
    DiagnosticRefreshRequest.type = new messages_1$2.ProtocolRequestType0(DiagnosticRefreshRequest.method);
})(DiagnosticRefreshRequest || (protocol_diagnostic.DiagnosticRefreshRequest = DiagnosticRefreshRequest = {}));

var protocol_notebook = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(protocol_notebook, "__esModule", { value: true });
protocol_notebook.DidCloseNotebookDocumentNotification = protocol_notebook.DidSaveNotebookDocumentNotification = protocol_notebook.DidChangeNotebookDocumentNotification = protocol_notebook.NotebookCellArrayChange = protocol_notebook.DidOpenNotebookDocumentNotification = protocol_notebook.NotebookDocumentSyncRegistrationType = protocol_notebook.NotebookDocument = protocol_notebook.NotebookCell = protocol_notebook.ExecutionSummary = protocol_notebook.NotebookCellKind = void 0;
const vscode_languageserver_types_1 = require$$1;
const Is$2 = is$1;
const messages_1$1 = messages;
/**
 * A notebook cell kind.
 *
 * @since 3.17.0
 */
var NotebookCellKind;
(function (NotebookCellKind) {
    /**
     * A markup-cell is formatted source that is used for display.
     */
    NotebookCellKind.Markup = 1;
    /**
     * A code-cell is source code.
     */
    NotebookCellKind.Code = 2;
    function is(value) {
        return value === 1 || value === 2;
    }
    NotebookCellKind.is = is;
})(NotebookCellKind || (protocol_notebook.NotebookCellKind = NotebookCellKind = {}));
var ExecutionSummary;
(function (ExecutionSummary) {
    function create(executionOrder, success) {
        const result = { executionOrder };
        if (success === true || success === false) {
            result.success = success;
        }
        return result;
    }
    ExecutionSummary.create = create;
    function is(value) {
        const candidate = value;
        return Is$2.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === undefined || Is$2.boolean(candidate.success));
    }
    ExecutionSummary.is = is;
    function equals(one, other) {
        if (one === other) {
            return true;
        }
        if (one === null || one === undefined || other === null || other === undefined) {
            return false;
        }
        return one.executionOrder === other.executionOrder && one.success === other.success;
    }
    ExecutionSummary.equals = equals;
})(ExecutionSummary || (protocol_notebook.ExecutionSummary = ExecutionSummary = {}));
var NotebookCell;
(function (NotebookCell) {
    function create(kind, document) {
        return { kind, document };
    }
    NotebookCell.create = create;
    function is(value) {
        const candidate = value;
        return Is$2.objectLiteral(candidate) && NotebookCellKind.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) &&
            (candidate.metadata === undefined || Is$2.objectLiteral(candidate.metadata));
    }
    NotebookCell.is = is;
    function diff(one, two) {
        const result = new Set();
        if (one.document !== two.document) {
            result.add('document');
        }
        if (one.kind !== two.kind) {
            result.add('kind');
        }
        if (one.executionSummary !== two.executionSummary) {
            result.add('executionSummary');
        }
        if ((one.metadata !== undefined || two.metadata !== undefined) && !equalsMetadata(one.metadata, two.metadata)) {
            result.add('metadata');
        }
        if ((one.executionSummary !== undefined || two.executionSummary !== undefined) && !ExecutionSummary.equals(one.executionSummary, two.executionSummary)) {
            result.add('executionSummary');
        }
        return result;
    }
    NotebookCell.diff = diff;
    function equalsMetadata(one, other) {
        if (one === other) {
            return true;
        }
        if (one === null || one === undefined || other === null || other === undefined) {
            return false;
        }
        if (typeof one !== typeof other) {
            return false;
        }
        if (typeof one !== 'object') {
            return false;
        }
        const oneArray = Array.isArray(one);
        const otherArray = Array.isArray(other);
        if (oneArray !== otherArray) {
            return false;
        }
        if (oneArray && otherArray) {
            if (one.length !== other.length) {
                return false;
            }
            for (let i = 0; i < one.length; i++) {
                if (!equalsMetadata(one[i], other[i])) {
                    return false;
                }
            }
        }
        if (Is$2.objectLiteral(one) && Is$2.objectLiteral(other)) {
            const oneKeys = Object.keys(one);
            const otherKeys = Object.keys(other);
            if (oneKeys.length !== otherKeys.length) {
                return false;
            }
            oneKeys.sort();
            otherKeys.sort();
            if (!equalsMetadata(oneKeys, otherKeys)) {
                return false;
            }
            for (let i = 0; i < oneKeys.length; i++) {
                const prop = oneKeys[i];
                if (!equalsMetadata(one[prop], other[prop])) {
                    return false;
                }
            }
        }
        return true;
    }
})(NotebookCell || (protocol_notebook.NotebookCell = NotebookCell = {}));
var NotebookDocument;
(function (NotebookDocument) {
    function create(uri, notebookType, version, cells) {
        return { uri, notebookType, version, cells };
    }
    NotebookDocument.create = create;
    function is(value) {
        const candidate = value;
        return Is$2.objectLiteral(candidate) && Is$2.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is$2.typedArray(candidate.cells, NotebookCell.is);
    }
    NotebookDocument.is = is;
})(NotebookDocument || (protocol_notebook.NotebookDocument = NotebookDocument = {}));
var NotebookDocumentSyncRegistrationType;
(function (NotebookDocumentSyncRegistrationType) {
    NotebookDocumentSyncRegistrationType.method = 'notebookDocument/sync';
    NotebookDocumentSyncRegistrationType.messageDirection = messages_1$1.MessageDirection.clientToServer;
    NotebookDocumentSyncRegistrationType.type = new messages_1$1.RegistrationType(NotebookDocumentSyncRegistrationType.method);
})(NotebookDocumentSyncRegistrationType || (protocol_notebook.NotebookDocumentSyncRegistrationType = NotebookDocumentSyncRegistrationType = {}));
/**
 * A notification sent when a notebook opens.
 *
 * @since 3.17.0
 */
var DidOpenNotebookDocumentNotification;
(function (DidOpenNotebookDocumentNotification) {
    DidOpenNotebookDocumentNotification.method = 'notebookDocument/didOpen';
    DidOpenNotebookDocumentNotification.messageDirection = messages_1$1.MessageDirection.clientToServer;
    DidOpenNotebookDocumentNotification.type = new messages_1$1.ProtocolNotificationType(DidOpenNotebookDocumentNotification.method);
    DidOpenNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
})(DidOpenNotebookDocumentNotification || (protocol_notebook.DidOpenNotebookDocumentNotification = DidOpenNotebookDocumentNotification = {}));
var NotebookCellArrayChange;
(function (NotebookCellArrayChange) {
    function is(value) {
        const candidate = value;
        return Is$2.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === undefined || Is$2.typedArray(candidate.cells, NotebookCell.is));
    }
    NotebookCellArrayChange.is = is;
    function create(start, deleteCount, cells) {
        const result = { start, deleteCount };
        if (cells !== undefined) {
            result.cells = cells;
        }
        return result;
    }
    NotebookCellArrayChange.create = create;
})(NotebookCellArrayChange || (protocol_notebook.NotebookCellArrayChange = NotebookCellArrayChange = {}));
var DidChangeNotebookDocumentNotification;
(function (DidChangeNotebookDocumentNotification) {
    DidChangeNotebookDocumentNotification.method = 'notebookDocument/didChange';
    DidChangeNotebookDocumentNotification.messageDirection = messages_1$1.MessageDirection.clientToServer;
    DidChangeNotebookDocumentNotification.type = new messages_1$1.ProtocolNotificationType(DidChangeNotebookDocumentNotification.method);
    DidChangeNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
})(DidChangeNotebookDocumentNotification || (protocol_notebook.DidChangeNotebookDocumentNotification = DidChangeNotebookDocumentNotification = {}));
/**
 * A notification sent when a notebook document is saved.
 *
 * @since 3.17.0
 */
var DidSaveNotebookDocumentNotification;
(function (DidSaveNotebookDocumentNotification) {
    DidSaveNotebookDocumentNotification.method = 'notebookDocument/didSave';
    DidSaveNotebookDocumentNotification.messageDirection = messages_1$1.MessageDirection.clientToServer;
    DidSaveNotebookDocumentNotification.type = new messages_1$1.ProtocolNotificationType(DidSaveNotebookDocumentNotification.method);
    DidSaveNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
})(DidSaveNotebookDocumentNotification || (protocol_notebook.DidSaveNotebookDocumentNotification = DidSaveNotebookDocumentNotification = {}));
/**
 * A notification sent when a notebook closes.
 *
 * @since 3.17.0
 */
var DidCloseNotebookDocumentNotification;
(function (DidCloseNotebookDocumentNotification) {
    DidCloseNotebookDocumentNotification.method = 'notebookDocument/didClose';
    DidCloseNotebookDocumentNotification.messageDirection = messages_1$1.MessageDirection.clientToServer;
    DidCloseNotebookDocumentNotification.type = new messages_1$1.ProtocolNotificationType(DidCloseNotebookDocumentNotification.method);
    DidCloseNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
})(DidCloseNotebookDocumentNotification || (protocol_notebook.DidCloseNotebookDocumentNotification = DidCloseNotebookDocumentNotification = {}));

var protocol_inlineCompletion = {};

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(protocol_inlineCompletion, "__esModule", { value: true });
protocol_inlineCompletion.InlineCompletionRequest = void 0;
const messages_1 = messages;
/**
 * A request to provide inline completions in a document. The request's parameter is of
 * type {@link InlineCompletionParams}, the response is of type
 * {@link InlineCompletion InlineCompletion[]} or a Thenable that resolves to such.
 *
 * @since 3.18.0
 * @proposed
 */
var InlineCompletionRequest;
(function (InlineCompletionRequest) {
    InlineCompletionRequest.method = 'textDocument/inlineCompletion';
    InlineCompletionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    InlineCompletionRequest.type = new messages_1.ProtocolRequestType(InlineCompletionRequest.method);
})(InlineCompletionRequest || (protocol_inlineCompletion.InlineCompletionRequest = InlineCompletionRequest = {}));

(function (exports) {
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.WorkspaceSymbolRequest = exports.CodeActionResolveRequest = exports.CodeActionRequest = exports.DocumentSymbolRequest = exports.DocumentHighlightRequest = exports.ReferencesRequest = exports.DefinitionRequest = exports.SignatureHelpRequest = exports.SignatureHelpTriggerKind = exports.HoverRequest = exports.CompletionResolveRequest = exports.CompletionRequest = exports.CompletionTriggerKind = exports.PublishDiagnosticsNotification = exports.WatchKind = exports.RelativePattern = exports.FileChangeType = exports.DidChangeWatchedFilesNotification = exports.WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentNotification = exports.TextDocumentSaveReason = exports.DidSaveTextDocumentNotification = exports.DidCloseTextDocumentNotification = exports.DidChangeTextDocumentNotification = exports.TextDocumentContentChangeEvent = exports.DidOpenTextDocumentNotification = exports.TextDocumentSyncKind = exports.TelemetryEventNotification = exports.LogMessageNotification = exports.ShowMessageRequest = exports.ShowMessageNotification = exports.MessageType = exports.DidChangeConfigurationNotification = exports.ExitNotification = exports.ShutdownRequest = exports.InitializedNotification = exports.InitializeErrorCodes = exports.InitializeRequest = exports.WorkDoneProgressOptions = exports.TextDocumentRegistrationOptions = exports.StaticRegistrationOptions = exports.PositionEncodingKind = exports.FailureHandlingKind = exports.ResourceOperationKind = exports.UnregistrationRequest = exports.RegistrationRequest = exports.DocumentSelector = exports.NotebookCellTextDocumentFilter = exports.NotebookDocumentFilter = exports.TextDocumentFilter = void 0;
	exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.WillRenameFilesRequest = exports.DidRenameFilesNotification = exports.WillCreateFilesRequest = exports.DidCreateFilesNotification = exports.FileOperationPatternKind = exports.LinkedEditingRangeRequest = exports.ShowDocumentRequest = exports.SemanticTokensRegistrationType = exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.TokenFormat = exports.CallHierarchyPrepareRequest = exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = exports.SelectionRangeRequest = exports.DeclarationRequest = exports.FoldingRangeRefreshRequest = exports.FoldingRangeRequest = exports.ColorPresentationRequest = exports.DocumentColorRequest = exports.ConfigurationRequest = exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = exports.TypeDefinitionRequest = exports.ImplementationRequest = exports.ApplyWorkspaceEditRequest = exports.ExecuteCommandRequest = exports.PrepareRenameRequest = exports.RenameRequest = exports.PrepareSupportDefaultBehavior = exports.DocumentOnTypeFormattingRequest = exports.DocumentRangesFormattingRequest = exports.DocumentRangeFormattingRequest = exports.DocumentFormattingRequest = exports.DocumentLinkResolveRequest = exports.DocumentLinkRequest = exports.CodeLensRefreshRequest = exports.CodeLensResolveRequest = exports.CodeLensRequest = exports.WorkspaceSymbolResolveRequest = void 0;
	exports.InlineCompletionRequest = exports.DidCloseNotebookDocumentNotification = exports.DidSaveNotebookDocumentNotification = exports.DidChangeNotebookDocumentNotification = exports.NotebookCellArrayChange = exports.DidOpenNotebookDocumentNotification = exports.NotebookDocumentSyncRegistrationType = exports.NotebookDocument = exports.NotebookCell = exports.ExecutionSummary = exports.NotebookCellKind = exports.DiagnosticRefreshRequest = exports.WorkspaceDiagnosticRequest = exports.DocumentDiagnosticRequest = exports.DocumentDiagnosticReportKind = exports.DiagnosticServerCancellationData = exports.InlayHintRefreshRequest = exports.InlayHintResolveRequest = exports.InlayHintRequest = exports.InlineValueRefreshRequest = exports.InlineValueRequest = exports.TypeHierarchySupertypesRequest = exports.TypeHierarchySubtypesRequest = exports.TypeHierarchyPrepareRequest = void 0;
	const messages_1 = messages;
	const vscode_languageserver_types_1 = require$$1;
	const Is = is$1;
	const protocol_implementation_1 = protocol_implementation;
	Object.defineProperty(exports, "ImplementationRequest", { enumerable: true, get: function () { return protocol_implementation_1.ImplementationRequest; } });
	const protocol_typeDefinition_1 = protocol_typeDefinition;
	Object.defineProperty(exports, "TypeDefinitionRequest", { enumerable: true, get: function () { return protocol_typeDefinition_1.TypeDefinitionRequest; } });
	const protocol_workspaceFolder_1 = protocol_workspaceFolder;
	Object.defineProperty(exports, "WorkspaceFoldersRequest", { enumerable: true, get: function () { return protocol_workspaceFolder_1.WorkspaceFoldersRequest; } });
	Object.defineProperty(exports, "DidChangeWorkspaceFoldersNotification", { enumerable: true, get: function () { return protocol_workspaceFolder_1.DidChangeWorkspaceFoldersNotification; } });
	const protocol_configuration_1 = protocol_configuration;
	Object.defineProperty(exports, "ConfigurationRequest", { enumerable: true, get: function () { return protocol_configuration_1.ConfigurationRequest; } });
	const protocol_colorProvider_1 = protocol_colorProvider;
	Object.defineProperty(exports, "DocumentColorRequest", { enumerable: true, get: function () { return protocol_colorProvider_1.DocumentColorRequest; } });
	Object.defineProperty(exports, "ColorPresentationRequest", { enumerable: true, get: function () { return protocol_colorProvider_1.ColorPresentationRequest; } });
	const protocol_foldingRange_1 = protocol_foldingRange;
	Object.defineProperty(exports, "FoldingRangeRequest", { enumerable: true, get: function () { return protocol_foldingRange_1.FoldingRangeRequest; } });
	Object.defineProperty(exports, "FoldingRangeRefreshRequest", { enumerable: true, get: function () { return protocol_foldingRange_1.FoldingRangeRefreshRequest; } });
	const protocol_declaration_1 = protocol_declaration;
	Object.defineProperty(exports, "DeclarationRequest", { enumerable: true, get: function () { return protocol_declaration_1.DeclarationRequest; } });
	const protocol_selectionRange_1 = protocol_selectionRange;
	Object.defineProperty(exports, "SelectionRangeRequest", { enumerable: true, get: function () { return protocol_selectionRange_1.SelectionRangeRequest; } });
	const protocol_progress_1 = protocol_progress;
	Object.defineProperty(exports, "WorkDoneProgress", { enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgress; } });
	Object.defineProperty(exports, "WorkDoneProgressCreateRequest", { enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgressCreateRequest; } });
	Object.defineProperty(exports, "WorkDoneProgressCancelNotification", { enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgressCancelNotification; } });
	const protocol_callHierarchy_1 = protocol_callHierarchy;
	Object.defineProperty(exports, "CallHierarchyIncomingCallsRequest", { enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest; } });
	Object.defineProperty(exports, "CallHierarchyOutgoingCallsRequest", { enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest; } });
	Object.defineProperty(exports, "CallHierarchyPrepareRequest", { enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyPrepareRequest; } });
	const protocol_semanticTokens_1 = protocol_semanticTokens;
	Object.defineProperty(exports, "TokenFormat", { enumerable: true, get: function () { return protocol_semanticTokens_1.TokenFormat; } });
	Object.defineProperty(exports, "SemanticTokensRequest", { enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRequest; } });
	Object.defineProperty(exports, "SemanticTokensDeltaRequest", { enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensDeltaRequest; } });
	Object.defineProperty(exports, "SemanticTokensRangeRequest", { enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRangeRequest; } });
	Object.defineProperty(exports, "SemanticTokensRefreshRequest", { enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRefreshRequest; } });
	Object.defineProperty(exports, "SemanticTokensRegistrationType", { enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRegistrationType; } });
	const protocol_showDocument_1 = protocol_showDocument;
	Object.defineProperty(exports, "ShowDocumentRequest", { enumerable: true, get: function () { return protocol_showDocument_1.ShowDocumentRequest; } });
	const protocol_linkedEditingRange_1 = protocol_linkedEditingRange;
	Object.defineProperty(exports, "LinkedEditingRangeRequest", { enumerable: true, get: function () { return protocol_linkedEditingRange_1.LinkedEditingRangeRequest; } });
	const protocol_fileOperations_1 = protocol_fileOperations;
	Object.defineProperty(exports, "FileOperationPatternKind", { enumerable: true, get: function () { return protocol_fileOperations_1.FileOperationPatternKind; } });
	Object.defineProperty(exports, "DidCreateFilesNotification", { enumerable: true, get: function () { return protocol_fileOperations_1.DidCreateFilesNotification; } });
	Object.defineProperty(exports, "WillCreateFilesRequest", { enumerable: true, get: function () { return protocol_fileOperations_1.WillCreateFilesRequest; } });
	Object.defineProperty(exports, "DidRenameFilesNotification", { enumerable: true, get: function () { return protocol_fileOperations_1.DidRenameFilesNotification; } });
	Object.defineProperty(exports, "WillRenameFilesRequest", { enumerable: true, get: function () { return protocol_fileOperations_1.WillRenameFilesRequest; } });
	Object.defineProperty(exports, "DidDeleteFilesNotification", { enumerable: true, get: function () { return protocol_fileOperations_1.DidDeleteFilesNotification; } });
	Object.defineProperty(exports, "WillDeleteFilesRequest", { enumerable: true, get: function () { return protocol_fileOperations_1.WillDeleteFilesRequest; } });
	const protocol_moniker_1 = protocol_moniker;
	Object.defineProperty(exports, "UniquenessLevel", { enumerable: true, get: function () { return protocol_moniker_1.UniquenessLevel; } });
	Object.defineProperty(exports, "MonikerKind", { enumerable: true, get: function () { return protocol_moniker_1.MonikerKind; } });
	Object.defineProperty(exports, "MonikerRequest", { enumerable: true, get: function () { return protocol_moniker_1.MonikerRequest; } });
	const protocol_typeHierarchy_1 = protocol_typeHierarchy;
	Object.defineProperty(exports, "TypeHierarchyPrepareRequest", { enumerable: true, get: function () { return protocol_typeHierarchy_1.TypeHierarchyPrepareRequest; } });
	Object.defineProperty(exports, "TypeHierarchySubtypesRequest", { enumerable: true, get: function () { return protocol_typeHierarchy_1.TypeHierarchySubtypesRequest; } });
	Object.defineProperty(exports, "TypeHierarchySupertypesRequest", { enumerable: true, get: function () { return protocol_typeHierarchy_1.TypeHierarchySupertypesRequest; } });
	const protocol_inlineValue_1 = protocol_inlineValue;
	Object.defineProperty(exports, "InlineValueRequest", { enumerable: true, get: function () { return protocol_inlineValue_1.InlineValueRequest; } });
	Object.defineProperty(exports, "InlineValueRefreshRequest", { enumerable: true, get: function () { return protocol_inlineValue_1.InlineValueRefreshRequest; } });
	const protocol_inlayHint_1 = protocol_inlayHint;
	Object.defineProperty(exports, "InlayHintRequest", { enumerable: true, get: function () { return protocol_inlayHint_1.InlayHintRequest; } });
	Object.defineProperty(exports, "InlayHintResolveRequest", { enumerable: true, get: function () { return protocol_inlayHint_1.InlayHintResolveRequest; } });
	Object.defineProperty(exports, "InlayHintRefreshRequest", { enumerable: true, get: function () { return protocol_inlayHint_1.InlayHintRefreshRequest; } });
	const protocol_diagnostic_1 = protocol_diagnostic;
	Object.defineProperty(exports, "DiagnosticServerCancellationData", { enumerable: true, get: function () { return protocol_diagnostic_1.DiagnosticServerCancellationData; } });
	Object.defineProperty(exports, "DocumentDiagnosticReportKind", { enumerable: true, get: function () { return protocol_diagnostic_1.DocumentDiagnosticReportKind; } });
	Object.defineProperty(exports, "DocumentDiagnosticRequest", { enumerable: true, get: function () { return protocol_diagnostic_1.DocumentDiagnosticRequest; } });
	Object.defineProperty(exports, "WorkspaceDiagnosticRequest", { enumerable: true, get: function () { return protocol_diagnostic_1.WorkspaceDiagnosticRequest; } });
	Object.defineProperty(exports, "DiagnosticRefreshRequest", { enumerable: true, get: function () { return protocol_diagnostic_1.DiagnosticRefreshRequest; } });
	const protocol_notebook_1 = protocol_notebook;
	Object.defineProperty(exports, "NotebookCellKind", { enumerable: true, get: function () { return protocol_notebook_1.NotebookCellKind; } });
	Object.defineProperty(exports, "ExecutionSummary", { enumerable: true, get: function () { return protocol_notebook_1.ExecutionSummary; } });
	Object.defineProperty(exports, "NotebookCell", { enumerable: true, get: function () { return protocol_notebook_1.NotebookCell; } });
	Object.defineProperty(exports, "NotebookDocument", { enumerable: true, get: function () { return protocol_notebook_1.NotebookDocument; } });
	Object.defineProperty(exports, "NotebookDocumentSyncRegistrationType", { enumerable: true, get: function () { return protocol_notebook_1.NotebookDocumentSyncRegistrationType; } });
	Object.defineProperty(exports, "DidOpenNotebookDocumentNotification", { enumerable: true, get: function () { return protocol_notebook_1.DidOpenNotebookDocumentNotification; } });
	Object.defineProperty(exports, "NotebookCellArrayChange", { enumerable: true, get: function () { return protocol_notebook_1.NotebookCellArrayChange; } });
	Object.defineProperty(exports, "DidChangeNotebookDocumentNotification", { enumerable: true, get: function () { return protocol_notebook_1.DidChangeNotebookDocumentNotification; } });
	Object.defineProperty(exports, "DidSaveNotebookDocumentNotification", { enumerable: true, get: function () { return protocol_notebook_1.DidSaveNotebookDocumentNotification; } });
	Object.defineProperty(exports, "DidCloseNotebookDocumentNotification", { enumerable: true, get: function () { return protocol_notebook_1.DidCloseNotebookDocumentNotification; } });
	const protocol_inlineCompletion_1 = protocol_inlineCompletion;
	Object.defineProperty(exports, "InlineCompletionRequest", { enumerable: true, get: function () { return protocol_inlineCompletion_1.InlineCompletionRequest; } });
	/**
	 * The TextDocumentFilter namespace provides helper functions to work with
	 * {@link TextDocumentFilter} literals.
	 *
	 * @since 3.17.0
	 */
	var TextDocumentFilter;
	(function (TextDocumentFilter) {
	    function is(value) {
	        const candidate = value;
	        return Is.string(candidate) || (Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern));
	    }
	    TextDocumentFilter.is = is;
	})(TextDocumentFilter || (exports.TextDocumentFilter = TextDocumentFilter = {}));
	/**
	 * The NotebookDocumentFilter namespace provides helper functions to work with
	 * {@link NotebookDocumentFilter} literals.
	 *
	 * @since 3.17.0
	 */
	var NotebookDocumentFilter;
	(function (NotebookDocumentFilter) {
	    function is(value) {
	        const candidate = value;
	        return Is.objectLiteral(candidate) && (Is.string(candidate.notebookType) || Is.string(candidate.scheme) || Is.string(candidate.pattern));
	    }
	    NotebookDocumentFilter.is = is;
	})(NotebookDocumentFilter || (exports.NotebookDocumentFilter = NotebookDocumentFilter = {}));
	/**
	 * The NotebookCellTextDocumentFilter namespace provides helper functions to work with
	 * {@link NotebookCellTextDocumentFilter} literals.
	 *
	 * @since 3.17.0
	 */
	var NotebookCellTextDocumentFilter;
	(function (NotebookCellTextDocumentFilter) {
	    function is(value) {
	        const candidate = value;
	        return Is.objectLiteral(candidate)
	            && (Is.string(candidate.notebook) || NotebookDocumentFilter.is(candidate.notebook))
	            && (candidate.language === undefined || Is.string(candidate.language));
	    }
	    NotebookCellTextDocumentFilter.is = is;
	})(NotebookCellTextDocumentFilter || (exports.NotebookCellTextDocumentFilter = NotebookCellTextDocumentFilter = {}));
	/**
	 * The DocumentSelector namespace provides helper functions to work with
	 * {@link DocumentSelector}s.
	 */
	var DocumentSelector;
	(function (DocumentSelector) {
	    function is(value) {
	        if (!Array.isArray(value)) {
	            return false;
	        }
	        for (let elem of value) {
	            if (!Is.string(elem) && !TextDocumentFilter.is(elem) && !NotebookCellTextDocumentFilter.is(elem)) {
	                return false;
	            }
	        }
	        return true;
	    }
	    DocumentSelector.is = is;
	})(DocumentSelector || (exports.DocumentSelector = DocumentSelector = {}));
	/**
	 * The `client/registerCapability` request is sent from the server to the client to register a new capability
	 * handler on the client side.
	 */
	var RegistrationRequest;
	(function (RegistrationRequest) {
	    RegistrationRequest.method = 'client/registerCapability';
	    RegistrationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
	    RegistrationRequest.type = new messages_1.ProtocolRequestType(RegistrationRequest.method);
	})(RegistrationRequest || (exports.RegistrationRequest = RegistrationRequest = {}));
	/**
	 * The `client/unregisterCapability` request is sent from the server to the client to unregister a previously registered capability
	 * handler on the client side.
	 */
	var UnregistrationRequest;
	(function (UnregistrationRequest) {
	    UnregistrationRequest.method = 'client/unregisterCapability';
	    UnregistrationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
	    UnregistrationRequest.type = new messages_1.ProtocolRequestType(UnregistrationRequest.method);
	})(UnregistrationRequest || (exports.UnregistrationRequest = UnregistrationRequest = {}));
	var ResourceOperationKind;
	(function (ResourceOperationKind) {
	    /**
	     * Supports creating new files and folders.
	     */
	    ResourceOperationKind.Create = 'create';
	    /**
	     * Supports renaming existing files and folders.
	     */
	    ResourceOperationKind.Rename = 'rename';
	    /**
	     * Supports deleting existing files and folders.
	     */
	    ResourceOperationKind.Delete = 'delete';
	})(ResourceOperationKind || (exports.ResourceOperationKind = ResourceOperationKind = {}));
	var FailureHandlingKind;
	(function (FailureHandlingKind) {
	    /**
	     * Applying the workspace change is simply aborted if one of the changes provided
	     * fails. All operations executed before the failing operation stay executed.
	     */
	    FailureHandlingKind.Abort = 'abort';
	    /**
	     * All operations are executed transactional. That means they either all
	     * succeed or no changes at all are applied to the workspace.
	     */
	    FailureHandlingKind.Transactional = 'transactional';
	    /**
	     * If the workspace edit contains only textual file changes they are executed transactional.
	     * If resource changes (create, rename or delete file) are part of the change the failure
	     * handling strategy is abort.
	     */
	    FailureHandlingKind.TextOnlyTransactional = 'textOnlyTransactional';
	    /**
	     * The client tries to undo the operations already executed. But there is no
	     * guarantee that this is succeeding.
	     */
	    FailureHandlingKind.Undo = 'undo';
	})(FailureHandlingKind || (exports.FailureHandlingKind = FailureHandlingKind = {}));
	/**
	 * A set of predefined position encoding kinds.
	 *
	 * @since 3.17.0
	 */
	var PositionEncodingKind;
	(function (PositionEncodingKind) {
	    /**
	     * Character offsets count UTF-8 code units (e.g. bytes).
	     */
	    PositionEncodingKind.UTF8 = 'utf-8';
	    /**
	     * Character offsets count UTF-16 code units.
	     *
	     * This is the default and must always be supported
	     * by servers
	     */
	    PositionEncodingKind.UTF16 = 'utf-16';
	    /**
	     * Character offsets count UTF-32 code units.
	     *
	     * Implementation note: these are the same as Unicode codepoints,
	     * so this `PositionEncodingKind` may also be used for an
	     * encoding-agnostic representation of character offsets.
	     */
	    PositionEncodingKind.UTF32 = 'utf-32';
	})(PositionEncodingKind || (exports.PositionEncodingKind = PositionEncodingKind = {}));
	/**
	 * The StaticRegistrationOptions namespace provides helper functions to work with
	 * {@link StaticRegistrationOptions} literals.
	 */
	var StaticRegistrationOptions;
	(function (StaticRegistrationOptions) {
	    function hasId(value) {
	        const candidate = value;
	        return candidate && Is.string(candidate.id) && candidate.id.length > 0;
	    }
	    StaticRegistrationOptions.hasId = hasId;
	})(StaticRegistrationOptions || (exports.StaticRegistrationOptions = StaticRegistrationOptions = {}));
	/**
	 * The TextDocumentRegistrationOptions namespace provides helper functions to work with
	 * {@link TextDocumentRegistrationOptions} literals.
	 */
	var TextDocumentRegistrationOptions;
	(function (TextDocumentRegistrationOptions) {
	    function is(value) {
	        const candidate = value;
	        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
	    }
	    TextDocumentRegistrationOptions.is = is;
	})(TextDocumentRegistrationOptions || (exports.TextDocumentRegistrationOptions = TextDocumentRegistrationOptions = {}));
	/**
	 * The WorkDoneProgressOptions namespace provides helper functions to work with
	 * {@link WorkDoneProgressOptions} literals.
	 */
	var WorkDoneProgressOptions;
	(function (WorkDoneProgressOptions) {
	    function is(value) {
	        const candidate = value;
	        return Is.objectLiteral(candidate) && (candidate.workDoneProgress === undefined || Is.boolean(candidate.workDoneProgress));
	    }
	    WorkDoneProgressOptions.is = is;
	    function hasWorkDoneProgress(value) {
	        const candidate = value;
	        return candidate && Is.boolean(candidate.workDoneProgress);
	    }
	    WorkDoneProgressOptions.hasWorkDoneProgress = hasWorkDoneProgress;
	})(WorkDoneProgressOptions || (exports.WorkDoneProgressOptions = WorkDoneProgressOptions = {}));
	/**
	 * The initialize request is sent from the client to the server.
	 * It is sent once as the request after starting up the server.
	 * The requests parameter is of type {@link InitializeParams}
	 * the response if of type {@link InitializeResult} of a Thenable that
	 * resolves to such.
	 */
	var InitializeRequest;
	(function (InitializeRequest) {
	    InitializeRequest.method = 'initialize';
	    InitializeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    InitializeRequest.type = new messages_1.ProtocolRequestType(InitializeRequest.method);
	})(InitializeRequest || (exports.InitializeRequest = InitializeRequest = {}));
	/**
	 * Known error codes for an `InitializeErrorCodes`;
	 */
	var InitializeErrorCodes;
	(function (InitializeErrorCodes) {
	    /**
	     * If the protocol version provided by the client can't be handled by the server.
	     *
	     * @deprecated This initialize error got replaced by client capabilities. There is
	     * no version handshake in version 3.0x
	     */
	    InitializeErrorCodes.unknownProtocolVersion = 1;
	})(InitializeErrorCodes || (exports.InitializeErrorCodes = InitializeErrorCodes = {}));
	/**
	 * The initialized notification is sent from the client to the
	 * server after the client is fully initialized and the server
	 * is allowed to send requests from the server to the client.
	 */
	var InitializedNotification;
	(function (InitializedNotification) {
	    InitializedNotification.method = 'initialized';
	    InitializedNotification.messageDirection = messages_1.MessageDirection.clientToServer;
	    InitializedNotification.type = new messages_1.ProtocolNotificationType(InitializedNotification.method);
	})(InitializedNotification || (exports.InitializedNotification = InitializedNotification = {}));
	//---- Shutdown Method ----
	/**
	 * A shutdown request is sent from the client to the server.
	 * It is sent once when the client decides to shutdown the
	 * server. The only notification that is sent after a shutdown request
	 * is the exit event.
	 */
	var ShutdownRequest;
	(function (ShutdownRequest) {
	    ShutdownRequest.method = 'shutdown';
	    ShutdownRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    ShutdownRequest.type = new messages_1.ProtocolRequestType0(ShutdownRequest.method);
	})(ShutdownRequest || (exports.ShutdownRequest = ShutdownRequest = {}));
	//---- Exit Notification ----
	/**
	 * The exit event is sent from the client to the server to
	 * ask the server to exit its process.
	 */
	var ExitNotification;
	(function (ExitNotification) {
	    ExitNotification.method = 'exit';
	    ExitNotification.messageDirection = messages_1.MessageDirection.clientToServer;
	    ExitNotification.type = new messages_1.ProtocolNotificationType0(ExitNotification.method);
	})(ExitNotification || (exports.ExitNotification = ExitNotification = {}));
	/**
	 * The configuration change notification is sent from the client to the server
	 * when the client's configuration has changed. The notification contains
	 * the changed configuration as defined by the language client.
	 */
	var DidChangeConfigurationNotification;
	(function (DidChangeConfigurationNotification) {
	    DidChangeConfigurationNotification.method = 'workspace/didChangeConfiguration';
	    DidChangeConfigurationNotification.messageDirection = messages_1.MessageDirection.clientToServer;
	    DidChangeConfigurationNotification.type = new messages_1.ProtocolNotificationType(DidChangeConfigurationNotification.method);
	})(DidChangeConfigurationNotification || (exports.DidChangeConfigurationNotification = DidChangeConfigurationNotification = {}));
	//---- Message show and log notifications ----
	/**
	 * The message type
	 */
	var MessageType;
	(function (MessageType) {
	    /**
	     * An error message.
	     */
	    MessageType.Error = 1;
	    /**
	     * A warning message.
	     */
	    MessageType.Warning = 2;
	    /**
	     * An information message.
	     */
	    MessageType.Info = 3;
	    /**
	     * A log message.
	     */
	    MessageType.Log = 4;
	    /**
	     * A debug message.
	     *
	     * @since 3.18.0
	     */
	    MessageType.Debug = 5;
	})(MessageType || (exports.MessageType = MessageType = {}));
	/**
	 * The show message notification is sent from a server to a client to ask
	 * the client to display a particular message in the user interface.
	 */
	var ShowMessageNotification;
	(function (ShowMessageNotification) {
	    ShowMessageNotification.method = 'window/showMessage';
	    ShowMessageNotification.messageDirection = messages_1.MessageDirection.serverToClient;
	    ShowMessageNotification.type = new messages_1.ProtocolNotificationType(ShowMessageNotification.method);
	})(ShowMessageNotification || (exports.ShowMessageNotification = ShowMessageNotification = {}));
	/**
	 * The show message request is sent from the server to the client to show a message
	 * and a set of options actions to the user.
	 */
	var ShowMessageRequest;
	(function (ShowMessageRequest) {
	    ShowMessageRequest.method = 'window/showMessageRequest';
	    ShowMessageRequest.messageDirection = messages_1.MessageDirection.serverToClient;
	    ShowMessageRequest.type = new messages_1.ProtocolRequestType(ShowMessageRequest.method);
	})(ShowMessageRequest || (exports.ShowMessageRequest = ShowMessageRequest = {}));
	/**
	 * The log message notification is sent from the server to the client to ask
	 * the client to log a particular message.
	 */
	var LogMessageNotification;
	(function (LogMessageNotification) {
	    LogMessageNotification.method = 'window/logMessage';
	    LogMessageNotification.messageDirection = messages_1.MessageDirection.serverToClient;
	    LogMessageNotification.type = new messages_1.ProtocolNotificationType(LogMessageNotification.method);
	})(LogMessageNotification || (exports.LogMessageNotification = LogMessageNotification = {}));
	//---- Telemetry notification
	/**
	 * The telemetry event notification is sent from the server to the client to ask
	 * the client to log telemetry data.
	 */
	var TelemetryEventNotification;
	(function (TelemetryEventNotification) {
	    TelemetryEventNotification.method = 'telemetry/event';
	    TelemetryEventNotification.messageDirection = messages_1.MessageDirection.serverToClient;
	    TelemetryEventNotification.type = new messages_1.ProtocolNotificationType(TelemetryEventNotification.method);
	})(TelemetryEventNotification || (exports.TelemetryEventNotification = TelemetryEventNotification = {}));
	/**
	 * Defines how the host (editor) should sync
	 * document changes to the language server.
	 */
	var TextDocumentSyncKind;
	(function (TextDocumentSyncKind) {
	    /**
	     * Documents should not be synced at all.
	     */
	    TextDocumentSyncKind.None = 0;
	    /**
	     * Documents are synced by always sending the full content
	     * of the document.
	     */
	    TextDocumentSyncKind.Full = 1;
	    /**
	     * Documents are synced by sending the full content on open.
	     * After that only incremental updates to the document are
	     * send.
	     */
	    TextDocumentSyncKind.Incremental = 2;
	})(TextDocumentSyncKind || (exports.TextDocumentSyncKind = TextDocumentSyncKind = {}));
	/**
	 * The document open notification is sent from the client to the server to signal
	 * newly opened text documents. The document's truth is now managed by the client
	 * and the server must not try to read the document's truth using the document's
	 * uri. Open in this sense means it is managed by the client. It doesn't necessarily
	 * mean that its content is presented in an editor. An open notification must not
	 * be sent more than once without a corresponding close notification send before.
	 * This means open and close notification must be balanced and the max open count
	 * is one.
	 */
	var DidOpenTextDocumentNotification;
	(function (DidOpenTextDocumentNotification) {
	    DidOpenTextDocumentNotification.method = 'textDocument/didOpen';
	    DidOpenTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
	    DidOpenTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification.method);
	})(DidOpenTextDocumentNotification || (exports.DidOpenTextDocumentNotification = DidOpenTextDocumentNotification = {}));
	var TextDocumentContentChangeEvent;
	(function (TextDocumentContentChangeEvent) {
	    /**
	     * Checks whether the information describes a delta event.
	     */
	    function isIncremental(event) {
	        let candidate = event;
	        return candidate !== undefined && candidate !== null &&
	            typeof candidate.text === 'string' && candidate.range !== undefined &&
	            (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');
	    }
	    TextDocumentContentChangeEvent.isIncremental = isIncremental;
	    /**
	     * Checks whether the information describes a full replacement event.
	     */
	    function isFull(event) {
	        let candidate = event;
	        return candidate !== undefined && candidate !== null &&
	            typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;
	    }
	    TextDocumentContentChangeEvent.isFull = isFull;
	})(TextDocumentContentChangeEvent || (exports.TextDocumentContentChangeEvent = TextDocumentContentChangeEvent = {}));
	/**
	 * The document change notification is sent from the client to the server to signal
	 * changes to a text document.
	 */
	var DidChangeTextDocumentNotification;
	(function (DidChangeTextDocumentNotification) {
	    DidChangeTextDocumentNotification.method = 'textDocument/didChange';
	    DidChangeTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
	    DidChangeTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification.method);
	})(DidChangeTextDocumentNotification || (exports.DidChangeTextDocumentNotification = DidChangeTextDocumentNotification = {}));
	/**
	 * The document close notification is sent from the client to the server when
	 * the document got closed in the client. The document's truth now exists where
	 * the document's uri points to (e.g. if the document's uri is a file uri the
	 * truth now exists on disk). As with the open notification the close notification
	 * is about managing the document's content. Receiving a close notification
	 * doesn't mean that the document was open in an editor before. A close
	 * notification requires a previous open notification to be sent.
	 */
	var DidCloseTextDocumentNotification;
	(function (DidCloseTextDocumentNotification) {
	    DidCloseTextDocumentNotification.method = 'textDocument/didClose';
	    DidCloseTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
	    DidCloseTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification.method);
	})(DidCloseTextDocumentNotification || (exports.DidCloseTextDocumentNotification = DidCloseTextDocumentNotification = {}));
	/**
	 * The document save notification is sent from the client to the server when
	 * the document got saved in the client.
	 */
	var DidSaveTextDocumentNotification;
	(function (DidSaveTextDocumentNotification) {
	    DidSaveTextDocumentNotification.method = 'textDocument/didSave';
	    DidSaveTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
	    DidSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification.method);
	})(DidSaveTextDocumentNotification || (exports.DidSaveTextDocumentNotification = DidSaveTextDocumentNotification = {}));
	/**
	 * Represents reasons why a text document is saved.
	 */
	var TextDocumentSaveReason;
	(function (TextDocumentSaveReason) {
	    /**
	     * Manually triggered, e.g. by the user pressing save, by starting debugging,
	     * or by an API call.
	     */
	    TextDocumentSaveReason.Manual = 1;
	    /**
	     * Automatic after a delay.
	     */
	    TextDocumentSaveReason.AfterDelay = 2;
	    /**
	     * When the editor lost focus.
	     */
	    TextDocumentSaveReason.FocusOut = 3;
	})(TextDocumentSaveReason || (exports.TextDocumentSaveReason = TextDocumentSaveReason = {}));
	/**
	 * A document will save notification is sent from the client to the server before
	 * the document is actually saved.
	 */
	var WillSaveTextDocumentNotification;
	(function (WillSaveTextDocumentNotification) {
	    WillSaveTextDocumentNotification.method = 'textDocument/willSave';
	    WillSaveTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
	    WillSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification.method);
	})(WillSaveTextDocumentNotification || (exports.WillSaveTextDocumentNotification = WillSaveTextDocumentNotification = {}));
	/**
	 * A document will save request is sent from the client to the server before
	 * the document is actually saved. The request can return an array of TextEdits
	 * which will be applied to the text document before it is saved. Please note that
	 * clients might drop results if computing the text edits took too long or if a
	 * server constantly fails on this request. This is done to keep the save fast and
	 * reliable.
	 */
	var WillSaveTextDocumentWaitUntilRequest;
	(function (WillSaveTextDocumentWaitUntilRequest) {
	    WillSaveTextDocumentWaitUntilRequest.method = 'textDocument/willSaveWaitUntil';
	    WillSaveTextDocumentWaitUntilRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    WillSaveTextDocumentWaitUntilRequest.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest.method);
	})(WillSaveTextDocumentWaitUntilRequest || (exports.WillSaveTextDocumentWaitUntilRequest = WillSaveTextDocumentWaitUntilRequest = {}));
	/**
	 * The watched files notification is sent from the client to the server when
	 * the client detects changes to file watched by the language client.
	 */
	var DidChangeWatchedFilesNotification;
	(function (DidChangeWatchedFilesNotification) {
	    DidChangeWatchedFilesNotification.method = 'workspace/didChangeWatchedFiles';
	    DidChangeWatchedFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
	    DidChangeWatchedFilesNotification.type = new messages_1.ProtocolNotificationType(DidChangeWatchedFilesNotification.method);
	})(DidChangeWatchedFilesNotification || (exports.DidChangeWatchedFilesNotification = DidChangeWatchedFilesNotification = {}));
	/**
	 * The file event type
	 */
	var FileChangeType;
	(function (FileChangeType) {
	    /**
	     * The file got created.
	     */
	    FileChangeType.Created = 1;
	    /**
	     * The file got changed.
	     */
	    FileChangeType.Changed = 2;
	    /**
	     * The file got deleted.
	     */
	    FileChangeType.Deleted = 3;
	})(FileChangeType || (exports.FileChangeType = FileChangeType = {}));
	var RelativePattern;
	(function (RelativePattern) {
	    function is(value) {
	        const candidate = value;
	        return Is.objectLiteral(candidate) && (vscode_languageserver_types_1.URI.is(candidate.baseUri) || vscode_languageserver_types_1.WorkspaceFolder.is(candidate.baseUri)) && Is.string(candidate.pattern);
	    }
	    RelativePattern.is = is;
	})(RelativePattern || (exports.RelativePattern = RelativePattern = {}));
	var WatchKind;
	(function (WatchKind) {
	    /**
	     * Interested in create events.
	     */
	    WatchKind.Create = 1;
	    /**
	     * Interested in change events
	     */
	    WatchKind.Change = 2;
	    /**
	     * Interested in delete events
	     */
	    WatchKind.Delete = 4;
	})(WatchKind || (exports.WatchKind = WatchKind = {}));
	/**
	 * Diagnostics notification are sent from the server to the client to signal
	 * results of validation runs.
	 */
	var PublishDiagnosticsNotification;
	(function (PublishDiagnosticsNotification) {
	    PublishDiagnosticsNotification.method = 'textDocument/publishDiagnostics';
	    PublishDiagnosticsNotification.messageDirection = messages_1.MessageDirection.serverToClient;
	    PublishDiagnosticsNotification.type = new messages_1.ProtocolNotificationType(PublishDiagnosticsNotification.method);
	})(PublishDiagnosticsNotification || (exports.PublishDiagnosticsNotification = PublishDiagnosticsNotification = {}));
	/**
	 * How a completion was triggered
	 */
	var CompletionTriggerKind;
	(function (CompletionTriggerKind) {
	    /**
	     * Completion was triggered by typing an identifier (24x7 code
	     * complete), manual invocation (e.g Ctrl+Space) or via API.
	     */
	    CompletionTriggerKind.Invoked = 1;
	    /**
	     * Completion was triggered by a trigger character specified by
	     * the `triggerCharacters` properties of the `CompletionRegistrationOptions`.
	     */
	    CompletionTriggerKind.TriggerCharacter = 2;
	    /**
	     * Completion was re-triggered as current completion list is incomplete
	     */
	    CompletionTriggerKind.TriggerForIncompleteCompletions = 3;
	})(CompletionTriggerKind || (exports.CompletionTriggerKind = CompletionTriggerKind = {}));
	/**
	 * Request to request completion at a given text document position. The request's
	 * parameter is of type {@link TextDocumentPosition} the response
	 * is of type {@link CompletionItem CompletionItem[]} or {@link CompletionList}
	 * or a Thenable that resolves to such.
	 *
	 * The request can delay the computation of the {@link CompletionItem.detail `detail`}
	 * and {@link CompletionItem.documentation `documentation`} properties to the `completionItem/resolve`
	 * request. However, properties that are needed for the initial sorting and filtering, like `sortText`,
	 * `filterText`, `insertText`, and `textEdit`, must not be changed during resolve.
	 */
	var CompletionRequest;
	(function (CompletionRequest) {
	    CompletionRequest.method = 'textDocument/completion';
	    CompletionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    CompletionRequest.type = new messages_1.ProtocolRequestType(CompletionRequest.method);
	})(CompletionRequest || (exports.CompletionRequest = CompletionRequest = {}));
	/**
	 * Request to resolve additional information for a given completion item.The request's
	 * parameter is of type {@link CompletionItem} the response
	 * is of type {@link CompletionItem} or a Thenable that resolves to such.
	 */
	var CompletionResolveRequest;
	(function (CompletionResolveRequest) {
	    CompletionResolveRequest.method = 'completionItem/resolve';
	    CompletionResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    CompletionResolveRequest.type = new messages_1.ProtocolRequestType(CompletionResolveRequest.method);
	})(CompletionResolveRequest || (exports.CompletionResolveRequest = CompletionResolveRequest = {}));
	/**
	 * Request to request hover information at a given text document position. The request's
	 * parameter is of type {@link TextDocumentPosition} the response is of
	 * type {@link Hover} or a Thenable that resolves to such.
	 */
	var HoverRequest;
	(function (HoverRequest) {
	    HoverRequest.method = 'textDocument/hover';
	    HoverRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    HoverRequest.type = new messages_1.ProtocolRequestType(HoverRequest.method);
	})(HoverRequest || (exports.HoverRequest = HoverRequest = {}));
	/**
	 * How a signature help was triggered.
	 *
	 * @since 3.15.0
	 */
	var SignatureHelpTriggerKind;
	(function (SignatureHelpTriggerKind) {
	    /**
	     * Signature help was invoked manually by the user or by a command.
	     */
	    SignatureHelpTriggerKind.Invoked = 1;
	    /**
	     * Signature help was triggered by a trigger character.
	     */
	    SignatureHelpTriggerKind.TriggerCharacter = 2;
	    /**
	     * Signature help was triggered by the cursor moving or by the document content changing.
	     */
	    SignatureHelpTriggerKind.ContentChange = 3;
	})(SignatureHelpTriggerKind || (exports.SignatureHelpTriggerKind = SignatureHelpTriggerKind = {}));
	var SignatureHelpRequest;
	(function (SignatureHelpRequest) {
	    SignatureHelpRequest.method = 'textDocument/signatureHelp';
	    SignatureHelpRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    SignatureHelpRequest.type = new messages_1.ProtocolRequestType(SignatureHelpRequest.method);
	})(SignatureHelpRequest || (exports.SignatureHelpRequest = SignatureHelpRequest = {}));
	/**
	 * A request to resolve the definition location of a symbol at a given text
	 * document position. The request's parameter is of type {@link TextDocumentPosition}
	 * the response is of either type {@link Definition} or a typed array of
	 * {@link DefinitionLink} or a Thenable that resolves to such.
	 */
	var DefinitionRequest;
	(function (DefinitionRequest) {
	    DefinitionRequest.method = 'textDocument/definition';
	    DefinitionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    DefinitionRequest.type = new messages_1.ProtocolRequestType(DefinitionRequest.method);
	})(DefinitionRequest || (exports.DefinitionRequest = DefinitionRequest = {}));
	/**
	 * A request to resolve project-wide references for the symbol denoted
	 * by the given text document position. The request's parameter is of
	 * type {@link ReferenceParams} the response is of type
	 * {@link Location Location[]} or a Thenable that resolves to such.
	 */
	var ReferencesRequest;
	(function (ReferencesRequest) {
	    ReferencesRequest.method = 'textDocument/references';
	    ReferencesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    ReferencesRequest.type = new messages_1.ProtocolRequestType(ReferencesRequest.method);
	})(ReferencesRequest || (exports.ReferencesRequest = ReferencesRequest = {}));
	/**
	 * Request to resolve a {@link DocumentHighlight} for a given
	 * text document position. The request's parameter is of type {@link TextDocumentPosition}
	 * the request response is an array of type {@link DocumentHighlight}
	 * or a Thenable that resolves to such.
	 */
	var DocumentHighlightRequest;
	(function (DocumentHighlightRequest) {
	    DocumentHighlightRequest.method = 'textDocument/documentHighlight';
	    DocumentHighlightRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    DocumentHighlightRequest.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest.method);
	})(DocumentHighlightRequest || (exports.DocumentHighlightRequest = DocumentHighlightRequest = {}));
	/**
	 * A request to list all symbols found in a given text document. The request's
	 * parameter is of type {@link TextDocumentIdentifier} the
	 * response is of type {@link SymbolInformation SymbolInformation[]} or a Thenable
	 * that resolves to such.
	 */
	var DocumentSymbolRequest;
	(function (DocumentSymbolRequest) {
	    DocumentSymbolRequest.method = 'textDocument/documentSymbol';
	    DocumentSymbolRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    DocumentSymbolRequest.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest.method);
	})(DocumentSymbolRequest || (exports.DocumentSymbolRequest = DocumentSymbolRequest = {}));
	/**
	 * A request to provide commands for the given text document and range.
	 */
	var CodeActionRequest;
	(function (CodeActionRequest) {
	    CodeActionRequest.method = 'textDocument/codeAction';
	    CodeActionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    CodeActionRequest.type = new messages_1.ProtocolRequestType(CodeActionRequest.method);
	})(CodeActionRequest || (exports.CodeActionRequest = CodeActionRequest = {}));
	/**
	 * Request to resolve additional information for a given code action.The request's
	 * parameter is of type {@link CodeAction} the response
	 * is of type {@link CodeAction} or a Thenable that resolves to such.
	 */
	var CodeActionResolveRequest;
	(function (CodeActionResolveRequest) {
	    CodeActionResolveRequest.method = 'codeAction/resolve';
	    CodeActionResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    CodeActionResolveRequest.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest.method);
	})(CodeActionResolveRequest || (exports.CodeActionResolveRequest = CodeActionResolveRequest = {}));
	/**
	 * A request to list project-wide symbols matching the query string given
	 * by the {@link WorkspaceSymbolParams}. The response is
	 * of type {@link SymbolInformation SymbolInformation[]} or a Thenable that
	 * resolves to such.
	 *
	 * @since 3.17.0 - support for WorkspaceSymbol in the returned data. Clients
	 *  need to advertise support for WorkspaceSymbols via the client capability
	 *  `workspace.symbol.resolveSupport`.
	 *
	 */
	var WorkspaceSymbolRequest;
	(function (WorkspaceSymbolRequest) {
	    WorkspaceSymbolRequest.method = 'workspace/symbol';
	    WorkspaceSymbolRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    WorkspaceSymbolRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest.method);
	})(WorkspaceSymbolRequest || (exports.WorkspaceSymbolRequest = WorkspaceSymbolRequest = {}));
	/**
	 * A request to resolve the range inside the workspace
	 * symbol's location.
	 *
	 * @since 3.17.0
	 */
	var WorkspaceSymbolResolveRequest;
	(function (WorkspaceSymbolResolveRequest) {
	    WorkspaceSymbolResolveRequest.method = 'workspaceSymbol/resolve';
	    WorkspaceSymbolResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    WorkspaceSymbolResolveRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest.method);
	})(WorkspaceSymbolResolveRequest || (exports.WorkspaceSymbolResolveRequest = WorkspaceSymbolResolveRequest = {}));
	/**
	 * A request to provide code lens for the given text document.
	 */
	var CodeLensRequest;
	(function (CodeLensRequest) {
	    CodeLensRequest.method = 'textDocument/codeLens';
	    CodeLensRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    CodeLensRequest.type = new messages_1.ProtocolRequestType(CodeLensRequest.method);
	})(CodeLensRequest || (exports.CodeLensRequest = CodeLensRequest = {}));
	/**
	 * A request to resolve a command for a given code lens.
	 */
	var CodeLensResolveRequest;
	(function (CodeLensResolveRequest) {
	    CodeLensResolveRequest.method = 'codeLens/resolve';
	    CodeLensResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    CodeLensResolveRequest.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest.method);
	})(CodeLensResolveRequest || (exports.CodeLensResolveRequest = CodeLensResolveRequest = {}));
	/**
	 * A request to refresh all code actions
	 *
	 * @since 3.16.0
	 */
	var CodeLensRefreshRequest;
	(function (CodeLensRefreshRequest) {
	    CodeLensRefreshRequest.method = `workspace/codeLens/refresh`;
	    CodeLensRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
	    CodeLensRefreshRequest.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest.method);
	})(CodeLensRefreshRequest || (exports.CodeLensRefreshRequest = CodeLensRefreshRequest = {}));
	/**
	 * A request to provide document links
	 */
	var DocumentLinkRequest;
	(function (DocumentLinkRequest) {
	    DocumentLinkRequest.method = 'textDocument/documentLink';
	    DocumentLinkRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    DocumentLinkRequest.type = new messages_1.ProtocolRequestType(DocumentLinkRequest.method);
	})(DocumentLinkRequest || (exports.DocumentLinkRequest = DocumentLinkRequest = {}));
	/**
	 * Request to resolve additional information for a given document link. The request's
	 * parameter is of type {@link DocumentLink} the response
	 * is of type {@link DocumentLink} or a Thenable that resolves to such.
	 */
	var DocumentLinkResolveRequest;
	(function (DocumentLinkResolveRequest) {
	    DocumentLinkResolveRequest.method = 'documentLink/resolve';
	    DocumentLinkResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    DocumentLinkResolveRequest.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest.method);
	})(DocumentLinkResolveRequest || (exports.DocumentLinkResolveRequest = DocumentLinkResolveRequest = {}));
	/**
	 * A request to format a whole document.
	 */
	var DocumentFormattingRequest;
	(function (DocumentFormattingRequest) {
	    DocumentFormattingRequest.method = 'textDocument/formatting';
	    DocumentFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    DocumentFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest.method);
	})(DocumentFormattingRequest || (exports.DocumentFormattingRequest = DocumentFormattingRequest = {}));
	/**
	 * A request to format a range in a document.
	 */
	var DocumentRangeFormattingRequest;
	(function (DocumentRangeFormattingRequest) {
	    DocumentRangeFormattingRequest.method = 'textDocument/rangeFormatting';
	    DocumentRangeFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    DocumentRangeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest.method);
	})(DocumentRangeFormattingRequest || (exports.DocumentRangeFormattingRequest = DocumentRangeFormattingRequest = {}));
	/**
	 * A request to format ranges in a document.
	 *
	 * @since 3.18.0
	 * @proposed
	 */
	var DocumentRangesFormattingRequest;
	(function (DocumentRangesFormattingRequest) {
	    DocumentRangesFormattingRequest.method = 'textDocument/rangesFormatting';
	    DocumentRangesFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    DocumentRangesFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentRangesFormattingRequest.method);
	})(DocumentRangesFormattingRequest || (exports.DocumentRangesFormattingRequest = DocumentRangesFormattingRequest = {}));
	/**
	 * A request to format a document on type.
	 */
	var DocumentOnTypeFormattingRequest;
	(function (DocumentOnTypeFormattingRequest) {
	    DocumentOnTypeFormattingRequest.method = 'textDocument/onTypeFormatting';
	    DocumentOnTypeFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    DocumentOnTypeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest.method);
	})(DocumentOnTypeFormattingRequest || (exports.DocumentOnTypeFormattingRequest = DocumentOnTypeFormattingRequest = {}));
	//---- Rename ----------------------------------------------
	var PrepareSupportDefaultBehavior;
	(function (PrepareSupportDefaultBehavior) {
	    /**
	     * The client's default behavior is to select the identifier
	     * according the to language's syntax rule.
	     */
	    PrepareSupportDefaultBehavior.Identifier = 1;
	})(PrepareSupportDefaultBehavior || (exports.PrepareSupportDefaultBehavior = PrepareSupportDefaultBehavior = {}));
	/**
	 * A request to rename a symbol.
	 */
	var RenameRequest;
	(function (RenameRequest) {
	    RenameRequest.method = 'textDocument/rename';
	    RenameRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    RenameRequest.type = new messages_1.ProtocolRequestType(RenameRequest.method);
	})(RenameRequest || (exports.RenameRequest = RenameRequest = {}));
	/**
	 * A request to test and perform the setup necessary for a rename.
	 *
	 * @since 3.16 - support for default behavior
	 */
	var PrepareRenameRequest;
	(function (PrepareRenameRequest) {
	    PrepareRenameRequest.method = 'textDocument/prepareRename';
	    PrepareRenameRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    PrepareRenameRequest.type = new messages_1.ProtocolRequestType(PrepareRenameRequest.method);
	})(PrepareRenameRequest || (exports.PrepareRenameRequest = PrepareRenameRequest = {}));
	/**
	 * A request send from the client to the server to execute a command. The request might return
	 * a workspace edit which the client will apply to the workspace.
	 */
	var ExecuteCommandRequest;
	(function (ExecuteCommandRequest) {
	    ExecuteCommandRequest.method = 'workspace/executeCommand';
	    ExecuteCommandRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    ExecuteCommandRequest.type = new messages_1.ProtocolRequestType(ExecuteCommandRequest.method);
	})(ExecuteCommandRequest || (exports.ExecuteCommandRequest = ExecuteCommandRequest = {}));
	/**
	 * A request sent from the server to the client to modified certain resources.
	 */
	var ApplyWorkspaceEditRequest;
	(function (ApplyWorkspaceEditRequest) {
	    ApplyWorkspaceEditRequest.method = 'workspace/applyEdit';
	    ApplyWorkspaceEditRequest.messageDirection = messages_1.MessageDirection.serverToClient;
	    ApplyWorkspaceEditRequest.type = new messages_1.ProtocolRequestType('workspace/applyEdit');
	})(ApplyWorkspaceEditRequest || (exports.ApplyWorkspaceEditRequest = ApplyWorkspaceEditRequest = {})); 
} (protocol));

var connection = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(connection, "__esModule", { value: true });
connection.createProtocolConnection = void 0;
const vscode_jsonrpc_1 = main$1;
function createProtocolConnection(input, output, logger, options) {
    if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
    }
    return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger, options);
}
connection.createProtocolConnection = createProtocolConnection;

(function (exports) {
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.LSPErrorCodes = exports.createProtocolConnection = void 0;
	__exportStar(main$1, exports);
	__exportStar(require$$1, exports);
	__exportStar(messages, exports);
	__exportStar(protocol, exports);
	var connection_1 = connection;
	Object.defineProperty(exports, "createProtocolConnection", { enumerable: true, get: function () { return connection_1.createProtocolConnection; } });
	var LSPErrorCodes;
	(function (LSPErrorCodes) {
	    /**
	    * This is the start range of LSP reserved error codes.
	    * It doesn't denote a real error code.
	    *
	    * @since 3.16.0
	    */
	    LSPErrorCodes.lspReservedErrorRangeStart = -32899;
	    /**
	     * A request failed but it was syntactically correct, e.g the
	     * method name was known and the parameters were valid. The error
	     * message should contain human readable information about why
	     * the request failed.
	     *
	     * @since 3.17.0
	     */
	    LSPErrorCodes.RequestFailed = -32803;
	    /**
	     * The server cancelled the request. This error code should
	     * only be used for requests that explicitly support being
	     * server cancellable.
	     *
	     * @since 3.17.0
	     */
	    LSPErrorCodes.ServerCancelled = -32802;
	    /**
	     * The server detected that the content of a document got
	     * modified outside normal conditions. A server should
	     * NOT send this error code if it detects a content change
	     * in it unprocessed messages. The result even computed
	     * on an older state might still be useful for the client.
	     *
	     * If a client decides that a result is not of any use anymore
	     * the client should cancel the request.
	     */
	    LSPErrorCodes.ContentModified = -32801;
	    /**
	     * The client has canceled a request and a server as detected
	     * the cancel.
	     */
	    LSPErrorCodes.RequestCancelled = -32800;
	    /**
	    * This is the end range of LSP reserved error codes.
	    * It doesn't denote a real error code.
	    *
	    * @since 3.16.0
	    */
	    LSPErrorCodes.lspReservedErrorRangeEnd = -32800;
	})(LSPErrorCodes || (exports.LSPErrorCodes = LSPErrorCodes = {})); 
} (api));

(function (exports) {
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createProtocolConnection = void 0;
	const browser_1 = browser$1;
	__exportStar(browser$1, exports);
	__exportStar(api, exports);
	function createProtocolConnection(reader, writer, logger, options) {
	    return (0, browser_1.createMessageConnection)(reader, writer, logger, options);
	}
	exports.createProtocolConnection = createProtocolConnection; 
} (main$2));

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(semanticTokens, "__esModule", { value: true });
semanticTokens.SemanticTokensBuilder = semanticTokens.SemanticTokensDiff = semanticTokens.SemanticTokensFeature = void 0;
const vscode_languageserver_protocol_1$h = main$2;
const SemanticTokensFeature = (Base) => {
    return class extends Base {
        get semanticTokens() {
            return {
                refresh: () => {
                    return this.connection.sendRequest(vscode_languageserver_protocol_1$h.SemanticTokensRefreshRequest.type);
                },
                on: (handler) => {
                    const type = vscode_languageserver_protocol_1$h.SemanticTokensRequest.type;
                    return this.connection.onRequest(type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                    });
                },
                onDelta: (handler) => {
                    const type = vscode_languageserver_protocol_1$h.SemanticTokensDeltaRequest.type;
                    return this.connection.onRequest(type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                    });
                },
                onRange: (handler) => {
                    const type = vscode_languageserver_protocol_1$h.SemanticTokensRangeRequest.type;
                    return this.connection.onRequest(type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                    });
                }
            };
        }
    };
};
semanticTokens.SemanticTokensFeature = SemanticTokensFeature;
class SemanticTokensDiff {
    constructor(originalSequence, modifiedSequence) {
        this.originalSequence = originalSequence;
        this.modifiedSequence = modifiedSequence;
    }
    computeDiff() {
        const originalLength = this.originalSequence.length;
        const modifiedLength = this.modifiedSequence.length;
        let startIndex = 0;
        while (startIndex < modifiedLength && startIndex < originalLength && this.originalSequence[startIndex] === this.modifiedSequence[startIndex]) {
            startIndex++;
        }
        if (startIndex < modifiedLength && startIndex < originalLength) {
            let originalEndIndex = originalLength - 1;
            let modifiedEndIndex = modifiedLength - 1;
            while (originalEndIndex >= startIndex && modifiedEndIndex >= startIndex && this.originalSequence[originalEndIndex] === this.modifiedSequence[modifiedEndIndex]) {
                originalEndIndex--;
                modifiedEndIndex--;
            }
            // if one moved behind the start index move them forward again
            if (originalEndIndex < startIndex || modifiedEndIndex < startIndex) {
                originalEndIndex++;
                modifiedEndIndex++;
            }
            const deleteCount = originalEndIndex - startIndex + 1;
            const newData = this.modifiedSequence.slice(startIndex, modifiedEndIndex + 1);
            // If we moved behind the start index we could have missed a simple delete.
            if (newData.length === 1 && newData[0] === this.originalSequence[originalEndIndex]) {
                return [
                    { start: startIndex, deleteCount: deleteCount - 1 }
                ];
            }
            else {
                return [
                    { start: startIndex, deleteCount, data: newData }
                ];
            }
        }
        else if (startIndex < modifiedLength) {
            return [
                { start: startIndex, deleteCount: 0, data: this.modifiedSequence.slice(startIndex) }
            ];
        }
        else if (startIndex < originalLength) {
            return [
                { start: startIndex, deleteCount: originalLength - startIndex }
            ];
        }
        else {
            // The two arrays are the same.
            return [];
        }
    }
}
semanticTokens.SemanticTokensDiff = SemanticTokensDiff;
class SemanticTokensBuilder {
    constructor() {
        this._prevData = undefined;
        this.initialize();
    }
    initialize() {
        this._id = Date.now();
        this._prevLine = 0;
        this._prevChar = 0;
        this._data = [];
        this._dataLen = 0;
    }
    push(line, char, length, tokenType, tokenModifiers) {
        let pushLine = line;
        let pushChar = char;
        if (this._dataLen > 0) {
            pushLine -= this._prevLine;
            if (pushLine === 0) {
                pushChar -= this._prevChar;
            }
        }
        this._data[this._dataLen++] = pushLine;
        this._data[this._dataLen++] = pushChar;
        this._data[this._dataLen++] = length;
        this._data[this._dataLen++] = tokenType;
        this._data[this._dataLen++] = tokenModifiers;
        this._prevLine = line;
        this._prevChar = char;
    }
    get id() {
        return this._id.toString();
    }
    previousResult(id) {
        if (this.id === id) {
            this._prevData = this._data;
        }
        this.initialize();
    }
    build() {
        this._prevData = undefined;
        return {
            resultId: this.id,
            data: this._data
        };
    }
    canBuildEdits() {
        return this._prevData !== undefined;
    }
    buildEdits() {
        if (this._prevData !== undefined) {
            return {
                resultId: this.id,
                edits: (new SemanticTokensDiff(this._prevData, this._data)).computeDiff()
            };
        }
        else {
            return this.build();
        }
    }
}
semanticTokens.SemanticTokensBuilder = SemanticTokensBuilder;

var inlineCompletion_proposed = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(inlineCompletion_proposed, "__esModule", { value: true });
inlineCompletion_proposed.InlineCompletionFeature = void 0;
const vscode_languageserver_protocol_1$g = main$2;
const InlineCompletionFeature = (Base) => {
    return class extends Base {
        get inlineCompletion() {
            return {
                on: (handler) => {
                    return this.connection.onRequest(vscode_languageserver_protocol_1$g.InlineCompletionRequest.type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params));
                    });
                }
            };
        }
    };
};
inlineCompletion_proposed.InlineCompletionFeature = InlineCompletionFeature;

var textDocuments = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(textDocuments, "__esModule", { value: true });
textDocuments.TextDocuments = void 0;
const vscode_languageserver_protocol_1$f = main$2;
/**
 * A manager for simple text documents. The manager requires at a minimum that
 * the server registered for the following text document sync events in the
 * initialize handler or via dynamic registration:
 *
 * - open and close events.
 * - change events.
 *
 * Registering for save and will save events is optional.
 */
class TextDocuments {
    /**
     * Create a new text document manager.
     */
    constructor(configuration) {
        this._configuration = configuration;
        this._syncedDocuments = new Map();
        this._onDidChangeContent = new vscode_languageserver_protocol_1$f.Emitter();
        this._onDidOpen = new vscode_languageserver_protocol_1$f.Emitter();
        this._onDidClose = new vscode_languageserver_protocol_1$f.Emitter();
        this._onDidSave = new vscode_languageserver_protocol_1$f.Emitter();
        this._onWillSave = new vscode_languageserver_protocol_1$f.Emitter();
    }
    /**
     * An event that fires when a text document managed by this manager
     * has been opened.
     */
    get onDidOpen() {
        return this._onDidOpen.event;
    }
    /**
     * An event that fires when a text document managed by this manager
     * has been opened or the content changes.
     */
    get onDidChangeContent() {
        return this._onDidChangeContent.event;
    }
    /**
     * An event that fires when a text document managed by this manager
     * will be saved.
     */
    get onWillSave() {
        return this._onWillSave.event;
    }
    /**
     * Sets a handler that will be called if a participant wants to provide
     * edits during a text document save.
     */
    onWillSaveWaitUntil(handler) {
        this._willSaveWaitUntil = handler;
    }
    /**
     * An event that fires when a text document managed by this manager
     * has been saved.
     */
    get onDidSave() {
        return this._onDidSave.event;
    }
    /**
     * An event that fires when a text document managed by this manager
     * has been closed.
     */
    get onDidClose() {
        return this._onDidClose.event;
    }
    /**
     * Returns the document for the given URI. Returns undefined if
     * the document is not managed by this instance.
     *
     * @param uri The text document's URI to retrieve.
     * @return the text document or `undefined`.
     */
    get(uri) {
        return this._syncedDocuments.get(uri);
    }
    /**
     * Returns all text documents managed by this instance.
     *
     * @return all text documents.
     */
    all() {
        return Array.from(this._syncedDocuments.values());
    }
    /**
     * Returns the URIs of all text documents managed by this instance.
     *
     * @return the URI's of all text documents.
     */
    keys() {
        return Array.from(this._syncedDocuments.keys());
    }
    /**
     * Listens for `low level` notification on the given connection to
     * update the text documents managed by this instance.
     *
     * Please note that the connection only provides handlers not an event model. Therefore
     * listening on a connection will overwrite the following handlers on a connection:
     * `onDidOpenTextDocument`, `onDidChangeTextDocument`, `onDidCloseTextDocument`,
     * `onWillSaveTextDocument`, `onWillSaveTextDocumentWaitUntil` and `onDidSaveTextDocument`.
     *
     * Use the corresponding events on the TextDocuments instance instead.
     *
     * @param connection The connection to listen on.
     */
    listen(connection) {
        connection.__textDocumentSync = vscode_languageserver_protocol_1$f.TextDocumentSyncKind.Incremental;
        const disposables = [];
        disposables.push(connection.onDidOpenTextDocument((event) => {
            const td = event.textDocument;
            const document = this._configuration.create(td.uri, td.languageId, td.version, td.text);
            this._syncedDocuments.set(td.uri, document);
            const toFire = Object.freeze({ document });
            this._onDidOpen.fire(toFire);
            this._onDidChangeContent.fire(toFire);
        }));
        disposables.push(connection.onDidChangeTextDocument((event) => {
            const td = event.textDocument;
            const changes = event.contentChanges;
            if (changes.length === 0) {
                return;
            }
            const { version } = td;
            if (version === null || version === undefined) {
                throw new Error(`Received document change event for ${td.uri} without valid version identifier`);
            }
            let syncedDocument = this._syncedDocuments.get(td.uri);
            if (syncedDocument !== undefined) {
                syncedDocument = this._configuration.update(syncedDocument, changes, version);
                this._syncedDocuments.set(td.uri, syncedDocument);
                this._onDidChangeContent.fire(Object.freeze({ document: syncedDocument }));
            }
        }));
        disposables.push(connection.onDidCloseTextDocument((event) => {
            let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
            if (syncedDocument !== undefined) {
                this._syncedDocuments.delete(event.textDocument.uri);
                this._onDidClose.fire(Object.freeze({ document: syncedDocument }));
            }
        }));
        disposables.push(connection.onWillSaveTextDocument((event) => {
            let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
            if (syncedDocument !== undefined) {
                this._onWillSave.fire(Object.freeze({ document: syncedDocument, reason: event.reason }));
            }
        }));
        disposables.push(connection.onWillSaveTextDocumentWaitUntil((event, token) => {
            let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
            if (syncedDocument !== undefined && this._willSaveWaitUntil) {
                return this._willSaveWaitUntil(Object.freeze({ document: syncedDocument, reason: event.reason }), token);
            }
            else {
                return [];
            }
        }));
        disposables.push(connection.onDidSaveTextDocument((event) => {
            let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
            if (syncedDocument !== undefined) {
                this._onDidSave.fire(Object.freeze({ document: syncedDocument }));
            }
        }));
        return vscode_languageserver_protocol_1$f.Disposable.create(() => { disposables.forEach(disposable => disposable.dispose()); });
    }
}
textDocuments.TextDocuments = TextDocuments;

var notebook = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(notebook, "__esModule", { value: true });
notebook.NotebookDocuments = notebook.NotebookSyncFeature = void 0;
const vscode_languageserver_protocol_1$e = main$2;
const textDocuments_1 = textDocuments;
const NotebookSyncFeature = (Base) => {
    return class extends Base {
        get synchronization() {
            return {
                onDidOpenNotebookDocument: (handler) => {
                    return this.connection.onNotification(vscode_languageserver_protocol_1$e.DidOpenNotebookDocumentNotification.type, (params) => {
                        handler(params);
                    });
                },
                onDidChangeNotebookDocument: (handler) => {
                    return this.connection.onNotification(vscode_languageserver_protocol_1$e.DidChangeNotebookDocumentNotification.type, (params) => {
                        handler(params);
                    });
                },
                onDidSaveNotebookDocument: (handler) => {
                    return this.connection.onNotification(vscode_languageserver_protocol_1$e.DidSaveNotebookDocumentNotification.type, (params) => {
                        handler(params);
                    });
                },
                onDidCloseNotebookDocument: (handler) => {
                    return this.connection.onNotification(vscode_languageserver_protocol_1$e.DidCloseNotebookDocumentNotification.type, (params) => {
                        handler(params);
                    });
                }
            };
        }
    };
};
notebook.NotebookSyncFeature = NotebookSyncFeature;
class CellTextDocumentConnection {
    onDidOpenTextDocument(handler) {
        this.openHandler = handler;
        return vscode_languageserver_protocol_1$e.Disposable.create(() => { this.openHandler = undefined; });
    }
    openTextDocument(params) {
        this.openHandler && this.openHandler(params);
    }
    onDidChangeTextDocument(handler) {
        this.changeHandler = handler;
        return vscode_languageserver_protocol_1$e.Disposable.create(() => { this.changeHandler = handler; });
    }
    changeTextDocument(params) {
        this.changeHandler && this.changeHandler(params);
    }
    onDidCloseTextDocument(handler) {
        this.closeHandler = handler;
        return vscode_languageserver_protocol_1$e.Disposable.create(() => { this.closeHandler = undefined; });
    }
    closeTextDocument(params) {
        this.closeHandler && this.closeHandler(params);
    }
    onWillSaveTextDocument() {
        return CellTextDocumentConnection.NULL_DISPOSE;
    }
    onWillSaveTextDocumentWaitUntil() {
        return CellTextDocumentConnection.NULL_DISPOSE;
    }
    onDidSaveTextDocument() {
        return CellTextDocumentConnection.NULL_DISPOSE;
    }
}
CellTextDocumentConnection.NULL_DISPOSE = Object.freeze({ dispose: () => { } });
class NotebookDocuments {
    constructor(configurationOrTextDocuments) {
        if (configurationOrTextDocuments instanceof textDocuments_1.TextDocuments) {
            this._cellTextDocuments = configurationOrTextDocuments;
        }
        else {
            this._cellTextDocuments = new textDocuments_1.TextDocuments(configurationOrTextDocuments);
        }
        this.notebookDocuments = new Map();
        this.notebookCellMap = new Map();
        this._onDidOpen = new vscode_languageserver_protocol_1$e.Emitter();
        this._onDidChange = new vscode_languageserver_protocol_1$e.Emitter();
        this._onDidSave = new vscode_languageserver_protocol_1$e.Emitter();
        this._onDidClose = new vscode_languageserver_protocol_1$e.Emitter();
    }
    get cellTextDocuments() {
        return this._cellTextDocuments;
    }
    getCellTextDocument(cell) {
        return this._cellTextDocuments.get(cell.document);
    }
    getNotebookDocument(uri) {
        return this.notebookDocuments.get(uri);
    }
    getNotebookCell(uri) {
        const value = this.notebookCellMap.get(uri);
        return value && value[0];
    }
    findNotebookDocumentForCell(cell) {
        const key = typeof cell === 'string' ? cell : cell.document;
        const value = this.notebookCellMap.get(key);
        return value && value[1];
    }
    get onDidOpen() {
        return this._onDidOpen.event;
    }
    get onDidSave() {
        return this._onDidSave.event;
    }
    get onDidChange() {
        return this._onDidChange.event;
    }
    get onDidClose() {
        return this._onDidClose.event;
    }
    /**
     * Listens for `low level` notification on the given connection to
     * update the notebook documents managed by this instance.
     *
     * Please note that the connection only provides handlers not an event model. Therefore
     * listening on a connection will overwrite the following handlers on a connection:
     * `onDidOpenNotebookDocument`, `onDidChangeNotebookDocument`, `onDidSaveNotebookDocument`,
     *  and `onDidCloseNotebookDocument`.
     *
     * @param connection The connection to listen on.
     */
    listen(connection) {
        const cellTextDocumentConnection = new CellTextDocumentConnection();
        const disposables = [];
        disposables.push(this.cellTextDocuments.listen(cellTextDocumentConnection));
        disposables.push(connection.notebooks.synchronization.onDidOpenNotebookDocument((params) => {
            this.notebookDocuments.set(params.notebookDocument.uri, params.notebookDocument);
            for (const cellTextDocument of params.cellTextDocuments) {
                cellTextDocumentConnection.openTextDocument({ textDocument: cellTextDocument });
            }
            this.updateCellMap(params.notebookDocument);
            this._onDidOpen.fire(params.notebookDocument);
        }));
        disposables.push(connection.notebooks.synchronization.onDidChangeNotebookDocument((params) => {
            const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
            if (notebookDocument === undefined) {
                return;
            }
            notebookDocument.version = params.notebookDocument.version;
            const oldMetadata = notebookDocument.metadata;
            let metadataChanged = false;
            const change = params.change;
            if (change.metadata !== undefined) {
                metadataChanged = true;
                notebookDocument.metadata = change.metadata;
            }
            const opened = [];
            const closed = [];
            const data = [];
            const text = [];
            if (change.cells !== undefined) {
                const changedCells = change.cells;
                if (changedCells.structure !== undefined) {
                    const array = changedCells.structure.array;
                    notebookDocument.cells.splice(array.start, array.deleteCount, ...(array.cells !== undefined ? array.cells : []));
                    // Additional open cell text documents.
                    if (changedCells.structure.didOpen !== undefined) {
                        for (const open of changedCells.structure.didOpen) {
                            cellTextDocumentConnection.openTextDocument({ textDocument: open });
                            opened.push(open.uri);
                        }
                    }
                    // Additional closed cell test documents.
                    if (changedCells.structure.didClose) {
                        for (const close of changedCells.structure.didClose) {
                            cellTextDocumentConnection.closeTextDocument({ textDocument: close });
                            closed.push(close.uri);
                        }
                    }
                }
                if (changedCells.data !== undefined) {
                    const cellUpdates = new Map(changedCells.data.map(cell => [cell.document, cell]));
                    for (let i = 0; i <= notebookDocument.cells.length; i++) {
                        const change = cellUpdates.get(notebookDocument.cells[i].document);
                        if (change !== undefined) {
                            const old = notebookDocument.cells.splice(i, 1, change);
                            data.push({ old: old[0], new: change });
                            cellUpdates.delete(change.document);
                            if (cellUpdates.size === 0) {
                                break;
                            }
                        }
                    }
                }
                if (changedCells.textContent !== undefined) {
                    for (const cellTextDocument of changedCells.textContent) {
                        cellTextDocumentConnection.changeTextDocument({ textDocument: cellTextDocument.document, contentChanges: cellTextDocument.changes });
                        text.push(cellTextDocument.document.uri);
                    }
                }
            }
            // Update internal data structure.
            this.updateCellMap(notebookDocument);
            const changeEvent = { notebookDocument };
            if (metadataChanged) {
                changeEvent.metadata = { old: oldMetadata, new: notebookDocument.metadata };
            }
            const added = [];
            for (const open of opened) {
                added.push(this.getNotebookCell(open));
            }
            const removed = [];
            for (const close of closed) {
                removed.push(this.getNotebookCell(close));
            }
            const textContent = [];
            for (const change of text) {
                textContent.push(this.getNotebookCell(change));
            }
            if (added.length > 0 || removed.length > 0 || data.length > 0 || textContent.length > 0) {
                changeEvent.cells = { added, removed, changed: { data, textContent } };
            }
            if (changeEvent.metadata !== undefined || changeEvent.cells !== undefined) {
                this._onDidChange.fire(changeEvent);
            }
        }));
        disposables.push(connection.notebooks.synchronization.onDidSaveNotebookDocument((params) => {
            const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
            if (notebookDocument === undefined) {
                return;
            }
            this._onDidSave.fire(notebookDocument);
        }));
        disposables.push(connection.notebooks.synchronization.onDidCloseNotebookDocument((params) => {
            const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
            if (notebookDocument === undefined) {
                return;
            }
            this._onDidClose.fire(notebookDocument);
            for (const cellTextDocument of params.cellTextDocuments) {
                cellTextDocumentConnection.closeTextDocument({ textDocument: cellTextDocument });
            }
            this.notebookDocuments.delete(params.notebookDocument.uri);
            for (const cell of notebookDocument.cells) {
                this.notebookCellMap.delete(cell.document);
            }
        }));
        return vscode_languageserver_protocol_1$e.Disposable.create(() => { disposables.forEach(disposable => disposable.dispose()); });
    }
    updateCellMap(notebookDocument) {
        for (const cell of notebookDocument.cells) {
            this.notebookCellMap.set(cell.document, [cell, notebookDocument]);
        }
    }
}
notebook.NotebookDocuments = NotebookDocuments;

var server = {};

var is = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(is, "__esModule", { value: true });
is.thenable = is.typedArray = is.stringArray = is.array = is.func = is.error = is.number = is.string = is.boolean = void 0;
function boolean(value) {
    return value === true || value === false;
}
is.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
is.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
is.number = number;
function error(value) {
    return value instanceof Error;
}
is.error = error;
function func(value) {
    return typeof value === 'function';
}
is.func = func;
function array(value) {
    return Array.isArray(value);
}
is.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
is.stringArray = stringArray;
function typedArray(value, check) {
    return Array.isArray(value) && value.every(check);
}
is.typedArray = typedArray;
function thenable(value) {
    return value && func(value.then);
}
is.thenable = thenable;

var uuid = {};

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(uuid, "__esModule", { value: true });
uuid.generateUuid = uuid.parse = uuid.isUUID = uuid.v4 = uuid.empty = void 0;
class ValueUUID {
    constructor(_value) {
        this._value = _value;
        // empty
    }
    asHex() {
        return this._value;
    }
    equals(other) {
        return this.asHex() === other.asHex();
    }
}
class V4UUID extends ValueUUID {
    static _oneOf(array) {
        return array[Math.floor(array.length * Math.random())];
    }
    static _randomHex() {
        return V4UUID._oneOf(V4UUID._chars);
    }
    constructor() {
        super([
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            '4',
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            V4UUID._oneOf(V4UUID._timeHighBits),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
        ].join(''));
    }
}
V4UUID._chars = ['0', '1', '2', '3', '4', '5', '6', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
V4UUID._timeHighBits = ['8', '9', 'a', 'b'];
/**
 * An empty UUID that contains only zeros.
 */
uuid.empty = new ValueUUID('00000000-0000-0000-0000-000000000000');
function v4() {
    return new V4UUID();
}
uuid.v4 = v4;
const _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
function isUUID(value) {
    return _UUIDPattern.test(value);
}
uuid.isUUID = isUUID;
/**
 * Parses a UUID that is of the format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.
 * @param value A uuid string.
 */
function parse(value) {
    if (!isUUID(value)) {
        throw new Error('invalid uuid');
    }
    return new ValueUUID(value);
}
uuid.parse = parse;
function generateUuid() {
    return v4().asHex();
}
uuid.generateUuid = generateUuid;

var progress = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(progress, "__esModule", { value: true });
progress.attachPartialResult = progress.ProgressFeature = progress.attachWorkDone = void 0;
const vscode_languageserver_protocol_1$d = main$2;
const uuid_1 = uuid;
class WorkDoneProgressReporterImpl {
    constructor(_connection, _token) {
        this._connection = _connection;
        this._token = _token;
        WorkDoneProgressReporterImpl.Instances.set(this._token, this);
    }
    begin(title, percentage, message, cancellable) {
        let param = {
            kind: 'begin',
            title,
            percentage,
            message,
            cancellable
        };
        this._connection.sendProgress(vscode_languageserver_protocol_1$d.WorkDoneProgress.type, this._token, param);
    }
    report(arg0, arg1) {
        let param = {
            kind: 'report'
        };
        if (typeof arg0 === 'number') {
            param.percentage = arg0;
            if (arg1 !== undefined) {
                param.message = arg1;
            }
        }
        else {
            param.message = arg0;
        }
        this._connection.sendProgress(vscode_languageserver_protocol_1$d.WorkDoneProgress.type, this._token, param);
    }
    done() {
        WorkDoneProgressReporterImpl.Instances.delete(this._token);
        this._connection.sendProgress(vscode_languageserver_protocol_1$d.WorkDoneProgress.type, this._token, { kind: 'end' });
    }
}
WorkDoneProgressReporterImpl.Instances = new Map();
class WorkDoneProgressServerReporterImpl extends WorkDoneProgressReporterImpl {
    constructor(connection, token) {
        super(connection, token);
        this._source = new vscode_languageserver_protocol_1$d.CancellationTokenSource();
    }
    get token() {
        return this._source.token;
    }
    done() {
        this._source.dispose();
        super.done();
    }
    cancel() {
        this._source.cancel();
    }
}
class NullProgressReporter {
    constructor() {
    }
    begin() {
    }
    report() {
    }
    done() {
    }
}
class NullProgressServerReporter extends NullProgressReporter {
    constructor() {
        super();
        this._source = new vscode_languageserver_protocol_1$d.CancellationTokenSource();
    }
    get token() {
        return this._source.token;
    }
    done() {
        this._source.dispose();
    }
    cancel() {
        this._source.cancel();
    }
}
function attachWorkDone(connection, params) {
    if (params === undefined || params.workDoneToken === undefined) {
        return new NullProgressReporter();
    }
    const token = params.workDoneToken;
    delete params.workDoneToken;
    return new WorkDoneProgressReporterImpl(connection, token);
}
progress.attachWorkDone = attachWorkDone;
const ProgressFeature = (Base) => {
    return class extends Base {
        constructor() {
            super();
            this._progressSupported = false;
        }
        initialize(capabilities) {
            super.initialize(capabilities);
            if (capabilities?.window?.workDoneProgress === true) {
                this._progressSupported = true;
                this.connection.onNotification(vscode_languageserver_protocol_1$d.WorkDoneProgressCancelNotification.type, (params) => {
                    let progress = WorkDoneProgressReporterImpl.Instances.get(params.token);
                    if (progress instanceof WorkDoneProgressServerReporterImpl || progress instanceof NullProgressServerReporter) {
                        progress.cancel();
                    }
                });
            }
        }
        attachWorkDoneProgress(token) {
            if (token === undefined) {
                return new NullProgressReporter();
            }
            else {
                return new WorkDoneProgressReporterImpl(this.connection, token);
            }
        }
        createWorkDoneProgress() {
            if (this._progressSupported) {
                const token = (0, uuid_1.generateUuid)();
                return this.connection.sendRequest(vscode_languageserver_protocol_1$d.WorkDoneProgressCreateRequest.type, { token }).then(() => {
                    const result = new WorkDoneProgressServerReporterImpl(this.connection, token);
                    return result;
                });
            }
            else {
                return Promise.resolve(new NullProgressServerReporter());
            }
        }
    };
};
progress.ProgressFeature = ProgressFeature;
var ResultProgress;
(function (ResultProgress) {
    ResultProgress.type = new vscode_languageserver_protocol_1$d.ProgressType();
})(ResultProgress || (ResultProgress = {}));
class ResultProgressReporterImpl {
    constructor(_connection, _token) {
        this._connection = _connection;
        this._token = _token;
    }
    report(data) {
        this._connection.sendProgress(ResultProgress.type, this._token, data);
    }
}
function attachPartialResult(connection, params) {
    if (params === undefined || params.partialResultToken === undefined) {
        return undefined;
    }
    const token = params.partialResultToken;
    delete params.partialResultToken;
    return new ResultProgressReporterImpl(connection, token);
}
progress.attachPartialResult = attachPartialResult;

var configuration = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(configuration, "__esModule", { value: true });
configuration.ConfigurationFeature = void 0;
const vscode_languageserver_protocol_1$c = main$2;
const Is$1 = is;
const ConfigurationFeature = (Base) => {
    return class extends Base {
        getConfiguration(arg) {
            if (!arg) {
                return this._getConfiguration({});
            }
            else if (Is$1.string(arg)) {
                return this._getConfiguration({ section: arg });
            }
            else {
                return this._getConfiguration(arg);
            }
        }
        _getConfiguration(arg) {
            let params = {
                items: Array.isArray(arg) ? arg : [arg]
            };
            return this.connection.sendRequest(vscode_languageserver_protocol_1$c.ConfigurationRequest.type, params).then((result) => {
                if (Array.isArray(result)) {
                    return Array.isArray(arg) ? result : result[0];
                }
                else {
                    return Array.isArray(arg) ? [] : null;
                }
            });
        }
    };
};
configuration.ConfigurationFeature = ConfigurationFeature;

var workspaceFolder = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(workspaceFolder, "__esModule", { value: true });
workspaceFolder.WorkspaceFoldersFeature = void 0;
const vscode_languageserver_protocol_1$b = main$2;
const WorkspaceFoldersFeature = (Base) => {
    return class extends Base {
        constructor() {
            super();
            this._notificationIsAutoRegistered = false;
        }
        initialize(capabilities) {
            super.initialize(capabilities);
            let workspaceCapabilities = capabilities.workspace;
            if (workspaceCapabilities && workspaceCapabilities.workspaceFolders) {
                this._onDidChangeWorkspaceFolders = new vscode_languageserver_protocol_1$b.Emitter();
                this.connection.onNotification(vscode_languageserver_protocol_1$b.DidChangeWorkspaceFoldersNotification.type, (params) => {
                    this._onDidChangeWorkspaceFolders.fire(params.event);
                });
            }
        }
        fillServerCapabilities(capabilities) {
            super.fillServerCapabilities(capabilities);
            const changeNotifications = capabilities.workspace?.workspaceFolders?.changeNotifications;
            this._notificationIsAutoRegistered = changeNotifications === true || typeof changeNotifications === 'string';
        }
        getWorkspaceFolders() {
            return this.connection.sendRequest(vscode_languageserver_protocol_1$b.WorkspaceFoldersRequest.type);
        }
        get onDidChangeWorkspaceFolders() {
            if (!this._onDidChangeWorkspaceFolders) {
                throw new Error('Client doesn\'t support sending workspace folder change events.');
            }
            if (!this._notificationIsAutoRegistered && !this._unregistration) {
                this._unregistration = this.connection.client.register(vscode_languageserver_protocol_1$b.DidChangeWorkspaceFoldersNotification.type);
            }
            return this._onDidChangeWorkspaceFolders.event;
        }
    };
};
workspaceFolder.WorkspaceFoldersFeature = WorkspaceFoldersFeature;

var callHierarchy = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(callHierarchy, "__esModule", { value: true });
callHierarchy.CallHierarchyFeature = void 0;
const vscode_languageserver_protocol_1$a = main$2;
const CallHierarchyFeature = (Base) => {
    return class extends Base {
        get callHierarchy() {
            return {
                onPrepare: (handler) => {
                    return this.connection.onRequest(vscode_languageserver_protocol_1$a.CallHierarchyPrepareRequest.type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), undefined);
                    });
                },
                onIncomingCalls: (handler) => {
                    const type = vscode_languageserver_protocol_1$a.CallHierarchyIncomingCallsRequest.type;
                    return this.connection.onRequest(type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                    });
                },
                onOutgoingCalls: (handler) => {
                    const type = vscode_languageserver_protocol_1$a.CallHierarchyOutgoingCallsRequest.type;
                    return this.connection.onRequest(type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                    });
                }
            };
        }
    };
};
callHierarchy.CallHierarchyFeature = CallHierarchyFeature;

var showDocument = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(showDocument, "__esModule", { value: true });
showDocument.ShowDocumentFeature = void 0;
const vscode_languageserver_protocol_1$9 = main$2;
const ShowDocumentFeature = (Base) => {
    return class extends Base {
        showDocument(params) {
            return this.connection.sendRequest(vscode_languageserver_protocol_1$9.ShowDocumentRequest.type, params);
        }
    };
};
showDocument.ShowDocumentFeature = ShowDocumentFeature;

var fileOperations = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(fileOperations, "__esModule", { value: true });
fileOperations.FileOperationsFeature = void 0;
const vscode_languageserver_protocol_1$8 = main$2;
const FileOperationsFeature = (Base) => {
    return class extends Base {
        onDidCreateFiles(handler) {
            return this.connection.onNotification(vscode_languageserver_protocol_1$8.DidCreateFilesNotification.type, (params) => {
                handler(params);
            });
        }
        onDidRenameFiles(handler) {
            return this.connection.onNotification(vscode_languageserver_protocol_1$8.DidRenameFilesNotification.type, (params) => {
                handler(params);
            });
        }
        onDidDeleteFiles(handler) {
            return this.connection.onNotification(vscode_languageserver_protocol_1$8.DidDeleteFilesNotification.type, (params) => {
                handler(params);
            });
        }
        onWillCreateFiles(handler) {
            return this.connection.onRequest(vscode_languageserver_protocol_1$8.WillCreateFilesRequest.type, (params, cancel) => {
                return handler(params, cancel);
            });
        }
        onWillRenameFiles(handler) {
            return this.connection.onRequest(vscode_languageserver_protocol_1$8.WillRenameFilesRequest.type, (params, cancel) => {
                return handler(params, cancel);
            });
        }
        onWillDeleteFiles(handler) {
            return this.connection.onRequest(vscode_languageserver_protocol_1$8.WillDeleteFilesRequest.type, (params, cancel) => {
                return handler(params, cancel);
            });
        }
    };
};
fileOperations.FileOperationsFeature = FileOperationsFeature;

var linkedEditingRange = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(linkedEditingRange, "__esModule", { value: true });
linkedEditingRange.LinkedEditingRangeFeature = void 0;
const vscode_languageserver_protocol_1$7 = main$2;
const LinkedEditingRangeFeature = (Base) => {
    return class extends Base {
        onLinkedEditingRange(handler) {
            return this.connection.onRequest(vscode_languageserver_protocol_1$7.LinkedEditingRangeRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), undefined);
            });
        }
    };
};
linkedEditingRange.LinkedEditingRangeFeature = LinkedEditingRangeFeature;

var typeHierarchy = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(typeHierarchy, "__esModule", { value: true });
typeHierarchy.TypeHierarchyFeature = void 0;
const vscode_languageserver_protocol_1$6 = main$2;
const TypeHierarchyFeature = (Base) => {
    return class extends Base {
        get typeHierarchy() {
            return {
                onPrepare: (handler) => {
                    return this.connection.onRequest(vscode_languageserver_protocol_1$6.TypeHierarchyPrepareRequest.type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), undefined);
                    });
                },
                onSupertypes: (handler) => {
                    const type = vscode_languageserver_protocol_1$6.TypeHierarchySupertypesRequest.type;
                    return this.connection.onRequest(type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                    });
                },
                onSubtypes: (handler) => {
                    const type = vscode_languageserver_protocol_1$6.TypeHierarchySubtypesRequest.type;
                    return this.connection.onRequest(type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                    });
                }
            };
        }
    };
};
typeHierarchy.TypeHierarchyFeature = TypeHierarchyFeature;

var inlineValue = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(inlineValue, "__esModule", { value: true });
inlineValue.InlineValueFeature = void 0;
const vscode_languageserver_protocol_1$5 = main$2;
const InlineValueFeature = (Base) => {
    return class extends Base {
        get inlineValue() {
            return {
                refresh: () => {
                    return this.connection.sendRequest(vscode_languageserver_protocol_1$5.InlineValueRefreshRequest.type);
                },
                on: (handler) => {
                    return this.connection.onRequest(vscode_languageserver_protocol_1$5.InlineValueRequest.type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params));
                    });
                }
            };
        }
    };
};
inlineValue.InlineValueFeature = InlineValueFeature;

var foldingRange = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(foldingRange, "__esModule", { value: true });
foldingRange.FoldingRangeFeature = void 0;
const vscode_languageserver_protocol_1$4 = main$2;
const FoldingRangeFeature = (Base) => {
    return class extends Base {
        get foldingRange() {
            return {
                refresh: () => {
                    return this.connection.sendRequest(vscode_languageserver_protocol_1$4.FoldingRangeRefreshRequest.type);
                },
                on: (handler) => {
                    const type = vscode_languageserver_protocol_1$4.FoldingRangeRequest.type;
                    return this.connection.onRequest(type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                    });
                }
            };
        }
    };
};
foldingRange.FoldingRangeFeature = FoldingRangeFeature;

var inlayHint = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(inlayHint, "__esModule", { value: true });
inlayHint.InlayHintFeature = void 0;
const vscode_languageserver_protocol_1$3 = main$2;
const InlayHintFeature = (Base) => {
    return class extends Base {
        get inlayHint() {
            return {
                refresh: () => {
                    return this.connection.sendRequest(vscode_languageserver_protocol_1$3.InlayHintRefreshRequest.type);
                },
                on: (handler) => {
                    return this.connection.onRequest(vscode_languageserver_protocol_1$3.InlayHintRequest.type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params));
                    });
                },
                resolve: (handler) => {
                    return this.connection.onRequest(vscode_languageserver_protocol_1$3.InlayHintResolveRequest.type, (params, cancel) => {
                        return handler(params, cancel);
                    });
                }
            };
        }
    };
};
inlayHint.InlayHintFeature = InlayHintFeature;

var diagnostic = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(diagnostic, "__esModule", { value: true });
diagnostic.DiagnosticFeature = void 0;
const vscode_languageserver_protocol_1$2 = main$2;
const DiagnosticFeature = (Base) => {
    return class extends Base {
        get diagnostics() {
            return {
                refresh: () => {
                    return this.connection.sendRequest(vscode_languageserver_protocol_1$2.DiagnosticRefreshRequest.type);
                },
                on: (handler) => {
                    return this.connection.onRequest(vscode_languageserver_protocol_1$2.DocumentDiagnosticRequest.type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1$2.DocumentDiagnosticRequest.partialResult, params));
                    });
                },
                onWorkspace: (handler) => {
                    return this.connection.onRequest(vscode_languageserver_protocol_1$2.WorkspaceDiagnosticRequest.type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1$2.WorkspaceDiagnosticRequest.partialResult, params));
                    });
                }
            };
        }
    };
};
diagnostic.DiagnosticFeature = DiagnosticFeature;

var moniker = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(moniker, "__esModule", { value: true });
moniker.MonikerFeature = void 0;
const vscode_languageserver_protocol_1$1 = main$2;
const MonikerFeature = (Base) => {
    return class extends Base {
        get moniker() {
            return {
                on: (handler) => {
                    const type = vscode_languageserver_protocol_1$1.MonikerRequest.type;
                    return this.connection.onRequest(type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                    });
                },
            };
        }
    };
};
moniker.MonikerFeature = MonikerFeature;

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(server, "__esModule", { value: true });
server.createConnection = server.combineFeatures = server.combineNotebooksFeatures = server.combineLanguagesFeatures = server.combineWorkspaceFeatures = server.combineWindowFeatures = server.combineClientFeatures = server.combineTracerFeatures = server.combineTelemetryFeatures = server.combineConsoleFeatures = server._NotebooksImpl = server._LanguagesImpl = server.BulkUnregistration = server.BulkRegistration = server.ErrorMessageTracker = void 0;
const vscode_languageserver_protocol_1 = main$2;
const Is = is;
const UUID = uuid;
const progress_1 = progress;
const configuration_1 = configuration;
const workspaceFolder_1 = workspaceFolder;
const callHierarchy_1 = callHierarchy;
const semanticTokens_1 = semanticTokens;
const showDocument_1 = showDocument;
const fileOperations_1 = fileOperations;
const linkedEditingRange_1 = linkedEditingRange;
const typeHierarchy_1 = typeHierarchy;
const inlineValue_1 = inlineValue;
const foldingRange_1 = foldingRange;
// import { InlineCompletionFeatureShape, InlineCompletionFeature } from './inlineCompletion.proposed';
const inlayHint_1 = inlayHint;
const diagnostic_1 = diagnostic;
const notebook_1 = notebook;
const moniker_1 = moniker;
function null2Undefined(value) {
    if (value === null) {
        return undefined;
    }
    return value;
}
/**
 * Helps tracking error message. Equal occurrences of the same
 * message are only stored once. This class is for example
 * useful if text documents are validated in a loop and equal
 * error message should be folded into one.
 */
class ErrorMessageTracker {
    constructor() {
        this._messages = Object.create(null);
    }
    /**
     * Add a message to the tracker.
     *
     * @param message The message to add.
     */
    add(message) {
        let count = this._messages[message];
        if (!count) {
            count = 0;
        }
        count++;
        this._messages[message] = count;
    }
    /**
     * Send all tracked messages to the connection's window.
     *
     * @param connection The connection established between client and server.
     */
    sendErrors(connection) {
        Object.keys(this._messages).forEach(message => {
            connection.window.showErrorMessage(message);
        });
    }
}
server.ErrorMessageTracker = ErrorMessageTracker;
class RemoteConsoleImpl {
    constructor() {
    }
    rawAttach(connection) {
        this._rawConnection = connection;
    }
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    fillServerCapabilities(_capabilities) {
    }
    initialize(_capabilities) {
    }
    error(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Error, message);
    }
    warn(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Warning, message);
    }
    info(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Info, message);
    }
    log(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Log, message);
    }
    debug(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Debug, message);
    }
    send(type, message) {
        if (this._rawConnection) {
            this._rawConnection.sendNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, { type, message }).catch(() => {
                (0, vscode_languageserver_protocol_1.RAL)().console.error(`Sending log message failed`);
            });
        }
    }
}
class _RemoteWindowImpl {
    constructor() {
    }
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    showErrorMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Error, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
    }
    showWarningMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Warning, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
    }
    showInformationMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Info, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
    }
}
const RemoteWindowImpl = (0, showDocument_1.ShowDocumentFeature)((0, progress_1.ProgressFeature)(_RemoteWindowImpl));
var BulkRegistration;
(function (BulkRegistration) {
    /**
     * Creates a new bulk registration.
     * @return an empty bulk registration.
     */
    function create() {
        return new BulkRegistrationImpl();
    }
    BulkRegistration.create = create;
})(BulkRegistration || (server.BulkRegistration = BulkRegistration = {}));
class BulkRegistrationImpl {
    constructor() {
        this._registrations = [];
        this._registered = new Set();
    }
    add(type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        if (this._registered.has(method)) {
            throw new Error(`${method} is already added to this registration`);
        }
        const id = UUID.generateUuid();
        this._registrations.push({
            id: id,
            method: method,
            registerOptions: registerOptions || {}
        });
        this._registered.add(method);
    }
    asRegistrationParams() {
        return {
            registrations: this._registrations
        };
    }
}
var BulkUnregistration;
(function (BulkUnregistration) {
    function create() {
        return new BulkUnregistrationImpl(undefined, []);
    }
    BulkUnregistration.create = create;
})(BulkUnregistration || (server.BulkUnregistration = BulkUnregistration = {}));
class BulkUnregistrationImpl {
    constructor(_connection, unregistrations) {
        this._connection = _connection;
        this._unregistrations = new Map();
        unregistrations.forEach(unregistration => {
            this._unregistrations.set(unregistration.method, unregistration);
        });
    }
    get isAttached() {
        return !!this._connection;
    }
    attach(connection) {
        this._connection = connection;
    }
    add(unregistration) {
        this._unregistrations.set(unregistration.method, unregistration);
    }
    dispose() {
        let unregistrations = [];
        for (let unregistration of this._unregistrations.values()) {
            unregistrations.push(unregistration);
        }
        let params = {
            unregisterations: unregistrations
        };
        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).catch(() => {
            this._connection.console.info(`Bulk unregistration failed.`);
        });
    }
    disposeSingle(arg) {
        const method = Is.string(arg) ? arg : arg.method;
        const unregistration = this._unregistrations.get(method);
        if (!unregistration) {
            return false;
        }
        let params = {
            unregisterations: [unregistration]
        };
        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(() => {
            this._unregistrations.delete(method);
        }, (_error) => {
            this._connection.console.info(`Un-registering request handler for ${unregistration.id} failed.`);
        });
        return true;
    }
}
class RemoteClientImpl {
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    register(typeOrRegistrations, registerOptionsOrType, registerOptions) {
        if (typeOrRegistrations instanceof BulkRegistrationImpl) {
            return this.registerMany(typeOrRegistrations);
        }
        else if (typeOrRegistrations instanceof BulkUnregistrationImpl) {
            return this.registerSingle1(typeOrRegistrations, registerOptionsOrType, registerOptions);
        }
        else {
            return this.registerSingle2(typeOrRegistrations, registerOptionsOrType);
        }
    }
    registerSingle1(unregistration, type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        const id = UUID.generateUuid();
        let params = {
            registrations: [{ id, method, registerOptions: registerOptions || {} }]
        };
        if (!unregistration.isAttached) {
            unregistration.attach(this.connection);
        }
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
            unregistration.add({ id: id, method: method });
            return unregistration;
        }, (_error) => {
            this.connection.console.info(`Registering request handler for ${method} failed.`);
            return Promise.reject(_error);
        });
    }
    registerSingle2(type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        const id = UUID.generateUuid();
        let params = {
            registrations: [{ id, method, registerOptions: registerOptions || {} }]
        };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
            return vscode_languageserver_protocol_1.Disposable.create(() => {
                this.unregisterSingle(id, method).catch(() => { this.connection.console.info(`Un-registering capability with id ${id} failed.`); });
            });
        }, (_error) => {
            this.connection.console.info(`Registering request handler for ${method} failed.`);
            return Promise.reject(_error);
        });
    }
    unregisterSingle(id, method) {
        let params = {
            unregisterations: [{ id, method }]
        };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).catch(() => {
            this.connection.console.info(`Un-registering request handler for ${id} failed.`);
        });
    }
    registerMany(registrations) {
        let params = registrations.asRegistrationParams();
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then(() => {
            return new BulkUnregistrationImpl(this._connection, params.registrations.map(registration => { return { id: registration.id, method: registration.method }; }));
        }, (_error) => {
            this.connection.console.info(`Bulk registration failed.`);
            return Promise.reject(_error);
        });
    }
}
class _RemoteWorkspaceImpl {
    constructor() {
    }
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    applyEdit(paramOrEdit) {
        function isApplyWorkspaceEditParams(value) {
            return value && !!value.edit;
        }
        let params = isApplyWorkspaceEditParams(paramOrEdit) ? paramOrEdit : { edit: paramOrEdit };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, params);
    }
}
const RemoteWorkspaceImpl = (0, fileOperations_1.FileOperationsFeature)((0, workspaceFolder_1.WorkspaceFoldersFeature)((0, configuration_1.ConfigurationFeature)(_RemoteWorkspaceImpl)));
class TracerImpl {
    constructor() {
        this._trace = vscode_languageserver_protocol_1.Trace.Off;
    }
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    set trace(value) {
        this._trace = value;
    }
    log(message, verbose) {
        if (this._trace === vscode_languageserver_protocol_1.Trace.Off) {
            return;
        }
        this.connection.sendNotification(vscode_languageserver_protocol_1.LogTraceNotification.type, {
            message: message,
            verbose: this._trace === vscode_languageserver_protocol_1.Trace.Verbose ? verbose : undefined
        }).catch(() => {
            // Very hard to decide what to do. We tried to send a log
            // message which failed so we can't simply send another :-(.
        });
    }
}
class TelemetryImpl {
    constructor() {
    }
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    logEvent(data) {
        this.connection.sendNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, data).catch(() => {
            this.connection.console.log(`Sending TelemetryEventNotification failed`);
        });
    }
}
class _LanguagesImpl {
    constructor() {
    }
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    attachWorkDoneProgress(params) {
        return (0, progress_1.attachWorkDone)(this.connection, params);
    }
    attachPartialResultProgress(_type, params) {
        return (0, progress_1.attachPartialResult)(this.connection, params);
    }
}
server._LanguagesImpl = _LanguagesImpl;
const LanguagesImpl = (0, foldingRange_1.FoldingRangeFeature)((0, moniker_1.MonikerFeature)((0, diagnostic_1.DiagnosticFeature)((0, inlayHint_1.InlayHintFeature)((0, inlineValue_1.InlineValueFeature)((0, typeHierarchy_1.TypeHierarchyFeature)((0, linkedEditingRange_1.LinkedEditingRangeFeature)((0, semanticTokens_1.SemanticTokensFeature)((0, callHierarchy_1.CallHierarchyFeature)(_LanguagesImpl)))))))));
class _NotebooksImpl {
    constructor() {
    }
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    attachWorkDoneProgress(params) {
        return (0, progress_1.attachWorkDone)(this.connection, params);
    }
    attachPartialResultProgress(_type, params) {
        return (0, progress_1.attachPartialResult)(this.connection, params);
    }
}
server._NotebooksImpl = _NotebooksImpl;
const NotebooksImpl = (0, notebook_1.NotebookSyncFeature)(_NotebooksImpl);
function combineConsoleFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
server.combineConsoleFeatures = combineConsoleFeatures;
function combineTelemetryFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
server.combineTelemetryFeatures = combineTelemetryFeatures;
function combineTracerFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
server.combineTracerFeatures = combineTracerFeatures;
function combineClientFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
server.combineClientFeatures = combineClientFeatures;
function combineWindowFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
server.combineWindowFeatures = combineWindowFeatures;
function combineWorkspaceFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
server.combineWorkspaceFeatures = combineWorkspaceFeatures;
function combineLanguagesFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
server.combineLanguagesFeatures = combineLanguagesFeatures;
function combineNotebooksFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
server.combineNotebooksFeatures = combineNotebooksFeatures;
function combineFeatures(one, two) {
    function combine(one, two, func) {
        if (one && two) {
            return func(one, two);
        }
        else if (one) {
            return one;
        }
        else {
            return two;
        }
    }
    let result = {
        __brand: 'features',
        console: combine(one.console, two.console, combineConsoleFeatures),
        tracer: combine(one.tracer, two.tracer, combineTracerFeatures),
        telemetry: combine(one.telemetry, two.telemetry, combineTelemetryFeatures),
        client: combine(one.client, two.client, combineClientFeatures),
        window: combine(one.window, two.window, combineWindowFeatures),
        workspace: combine(one.workspace, two.workspace, combineWorkspaceFeatures),
        languages: combine(one.languages, two.languages, combineLanguagesFeatures),
        notebooks: combine(one.notebooks, two.notebooks, combineNotebooksFeatures)
    };
    return result;
}
server.combineFeatures = combineFeatures;
function createConnection(connectionFactory, watchDog, factories) {
    const logger = (factories && factories.console ? new (factories.console(RemoteConsoleImpl))() : new RemoteConsoleImpl());
    const connection = connectionFactory(logger);
    logger.rawAttach(connection);
    const tracer = (factories && factories.tracer ? new (factories.tracer(TracerImpl))() : new TracerImpl());
    const telemetry = (factories && factories.telemetry ? new (factories.telemetry(TelemetryImpl))() : new TelemetryImpl());
    const client = (factories && factories.client ? new (factories.client(RemoteClientImpl))() : new RemoteClientImpl());
    const remoteWindow = (factories && factories.window ? new (factories.window(RemoteWindowImpl))() : new RemoteWindowImpl());
    const workspace = (factories && factories.workspace ? new (factories.workspace(RemoteWorkspaceImpl))() : new RemoteWorkspaceImpl());
    const languages = (factories && factories.languages ? new (factories.languages(LanguagesImpl))() : new LanguagesImpl());
    const notebooks = (factories && factories.notebooks ? new (factories.notebooks(NotebooksImpl))() : new NotebooksImpl());
    const allRemotes = [logger, tracer, telemetry, client, remoteWindow, workspace, languages, notebooks];
    function asPromise(value) {
        if (value instanceof Promise) {
            return value;
        }
        else if (Is.thenable(value)) {
            return new Promise((resolve, reject) => {
                value.then((resolved) => resolve(resolved), (error) => reject(error));
            });
        }
        else {
            return Promise.resolve(value);
        }
    }
    let shutdownHandler = undefined;
    let initializeHandler = undefined;
    let exitHandler = undefined;
    let protocolConnection = {
        listen: () => connection.listen(),
        sendRequest: (type, ...params) => connection.sendRequest(Is.string(type) ? type : type.method, ...params),
        onRequest: (type, handler) => connection.onRequest(type, handler),
        sendNotification: (type, param) => {
            const method = Is.string(type) ? type : type.method;
            return connection.sendNotification(method, param);
        },
        onNotification: (type, handler) => connection.onNotification(type, handler),
        onProgress: connection.onProgress,
        sendProgress: connection.sendProgress,
        onInitialize: (handler) => {
            initializeHandler = handler;
            return {
                dispose: () => {
                    initializeHandler = undefined;
                }
            };
        },
        onInitialized: (handler) => connection.onNotification(vscode_languageserver_protocol_1.InitializedNotification.type, handler),
        onShutdown: (handler) => {
            shutdownHandler = handler;
            return {
                dispose: () => {
                    shutdownHandler = undefined;
                }
            };
        },
        onExit: (handler) => {
            exitHandler = handler;
            return {
                dispose: () => {
                    exitHandler = undefined;
                }
            };
        },
        get console() { return logger; },
        get telemetry() { return telemetry; },
        get tracer() { return tracer; },
        get client() { return client; },
        get window() { return remoteWindow; },
        get workspace() { return workspace; },
        get languages() { return languages; },
        get notebooks() { return notebooks; },
        onDidChangeConfiguration: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, handler),
        onDidChangeWatchedFiles: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, handler),
        __textDocumentSync: undefined,
        onDidOpenTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, handler),
        onDidChangeTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, handler),
        onDidCloseTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, handler),
        onWillSaveTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, handler),
        onWillSaveTextDocumentWaitUntil: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, handler),
        onDidSaveTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, handler),
        sendDiagnostics: (params) => connection.sendNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, params),
        onHover: (handler) => connection.onRequest(vscode_languageserver_protocol_1.HoverRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), undefined);
        }),
        onCompletion: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CompletionRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onCompletionResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, handler),
        onSignatureHelp: (handler) => connection.onRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), undefined);
        }),
        onDeclaration: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onDefinition: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onTypeDefinition: (handler) => connection.onRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onImplementation: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onReferences: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onDocumentHighlight: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onDocumentSymbol: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onWorkspaceSymbol: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onWorkspaceSymbolResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolResolveRequest.type, handler),
        onCodeAction: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onCodeActionResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, (params, cancel) => {
            return handler(params, cancel);
        }),
        onCodeLens: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onCodeLensResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, (params, cancel) => {
            return handler(params, cancel);
        }),
        onDocumentFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), undefined);
        }),
        onDocumentRangeFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), undefined);
        }),
        onDocumentOnTypeFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, (params, cancel) => {
            return handler(params, cancel);
        }),
        onRenameRequest: (handler) => connection.onRequest(vscode_languageserver_protocol_1.RenameRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), undefined);
        }),
        onPrepareRename: (handler) => connection.onRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, (params, cancel) => {
            return handler(params, cancel);
        }),
        onDocumentLinks: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onDocumentLinkResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, (params, cancel) => {
            return handler(params, cancel);
        }),
        onDocumentColor: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onColorPresentation: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onFoldingRanges: (handler) => connection.onRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onSelectionRanges: (handler) => connection.onRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onExecuteCommand: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), undefined);
        }),
        dispose: () => connection.dispose()
    };
    for (let remote of allRemotes) {
        remote.attach(protocolConnection);
    }
    connection.onRequest(vscode_languageserver_protocol_1.InitializeRequest.type, (params) => {
        watchDog.initialize(params);
        if (Is.string(params.trace)) {
            tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.trace);
        }
        for (let remote of allRemotes) {
            remote.initialize(params.capabilities);
        }
        if (initializeHandler) {
            let result = initializeHandler(params, new vscode_languageserver_protocol_1.CancellationTokenSource().token, (0, progress_1.attachWorkDone)(connection, params), undefined);
            return asPromise(result).then((value) => {
                if (value instanceof vscode_languageserver_protocol_1.ResponseError) {
                    return value;
                }
                let result = value;
                if (!result) {
                    result = { capabilities: {} };
                }
                let capabilities = result.capabilities;
                if (!capabilities) {
                    capabilities = {};
                    result.capabilities = capabilities;
                }
                if (capabilities.textDocumentSync === undefined || capabilities.textDocumentSync === null) {
                    capabilities.textDocumentSync = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
                }
                else if (!Is.number(capabilities.textDocumentSync) && !Is.number(capabilities.textDocumentSync.change)) {
                    capabilities.textDocumentSync.change = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
                }
                for (let remote of allRemotes) {
                    remote.fillServerCapabilities(capabilities);
                }
                return result;
            });
        }
        else {
            let result = { capabilities: { textDocumentSync: vscode_languageserver_protocol_1.TextDocumentSyncKind.None } };
            for (let remote of allRemotes) {
                remote.fillServerCapabilities(result.capabilities);
            }
            return result;
        }
    });
    connection.onRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, () => {
        watchDog.shutdownReceived = true;
        if (shutdownHandler) {
            return shutdownHandler(new vscode_languageserver_protocol_1.CancellationTokenSource().token);
        }
        else {
            return undefined;
        }
    });
    connection.onNotification(vscode_languageserver_protocol_1.ExitNotification.type, () => {
        try {
            if (exitHandler) {
                exitHandler();
            }
        }
        finally {
            if (watchDog.shutdownReceived) {
                watchDog.exit(0);
            }
            else {
                watchDog.exit(1);
            }
        }
    });
    connection.onNotification(vscode_languageserver_protocol_1.SetTraceNotification.type, (params) => {
        tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.value);
    });
    return protocolConnection;
}
server.createConnection = createConnection;

(function (exports) {
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ProposedFeatures = exports.NotebookDocuments = exports.TextDocuments = exports.SemanticTokensBuilder = void 0;
	const semanticTokens_1 = semanticTokens;
	Object.defineProperty(exports, "SemanticTokensBuilder", { enumerable: true, get: function () { return semanticTokens_1.SemanticTokensBuilder; } });
	const ic = inlineCompletion_proposed;
	__exportStar(main$2, exports);
	const textDocuments_1 = textDocuments;
	Object.defineProperty(exports, "TextDocuments", { enumerable: true, get: function () { return textDocuments_1.TextDocuments; } });
	const notebook_1 = notebook;
	Object.defineProperty(exports, "NotebookDocuments", { enumerable: true, get: function () { return notebook_1.NotebookDocuments; } });
	__exportStar(server, exports);
	var ProposedFeatures;
	(function (ProposedFeatures) {
	    ProposedFeatures.all = {
	        __brand: 'features',
	        languages: ic.InlineCompletionFeature
	    };
	})(ProposedFeatures || (exports.ProposedFeatures = ProposedFeatures = {})); 
} (api$2));

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */

var browser = main$2;

(function (exports) {
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createConnection = void 0;
	const api_1 = api$2;
	__exportStar(browser, exports);
	__exportStar(api$2, exports);
	let _shutdownReceived = false;
	const watchDog = {
	    initialize: (_params) => {
	    },
	    get shutdownReceived() {
	        return _shutdownReceived;
	    },
	    set shutdownReceived(value) {
	        _shutdownReceived = value;
	    },
	    exit: (_code) => {
	    }
	};
	function createConnection(arg1, arg2, arg3, arg4) {
	    let factories;
	    let reader;
	    let writer;
	    let options;
	    if (arg1 !== void 0 && arg1.__brand === 'features') {
	        factories = arg1;
	        arg1 = arg2;
	        arg2 = arg3;
	        arg3 = arg4;
	    }
	    if (api_1.ConnectionStrategy.is(arg1) || api_1.ConnectionOptions.is(arg1)) {
	        options = arg1;
	    }
	    else {
	        reader = arg1;
	        writer = arg2;
	        options = arg3;
	    }
	    const connectionFactory = (logger) => {
	        return (0, api_1.createProtocolConnection)(reader, writer, logger, options);
	    };
	    return (0, api_1.createConnection)(connectionFactory, watchDog, factories);
	}
	exports.createConnection = createConnection; 
} (main$3));

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */

var node = main$3;

/** @internal */
function getSymbolSignature(program, sym) {
    var _a;
    const decl = sym.declarations[0];
    switch (decl === null || decl === void 0 ? void 0 : decl.kind) {
        case SyntaxKind.AliasStatement:
            return fence(`alias ${getAliasSignature(decl)}`);
    }
    const type = (_a = sym.type) !== null && _a !== void 0 ? _a : program.checker.getTypeForNode(decl);
    return getTypeSignature(type);
}
function getTypeSignature(type) {
    switch (type.kind) {
        case "Scalar":
        case "Enum":
        case "Union":
        case "Interface":
        case "Model":
        case "Namespace":
            return fence(`${type.kind.toLowerCase()} ${getPrintableTypeName(type)}`);
        case "Decorator":
            return fence(getDecoratorSignature(type));
        case "Function":
            return fence(getFunctionSignature(type));
        case "Operation":
            return fence(getOperationSignature(type));
        case "Value":
            return `valueof ${getTypeSignature(type)}`;
        case "String":
            // BUG: https://github.com/microsoft/typespec/issues/1350 - should escape string literal values
            return `(string)\n${fence(`"${type.value}"`)}`;
        case "Boolean":
            return `(boolean)\n${fence(type.value ? "true" : "false")}`;
        case "Number":
            return `(number)\n${fence(type.value.toString())}`;
        case "StringTemplate":
            return `(string template)\n${fence(getStringTemplateSignature(type))}`;
        case "StringTemplateSpan":
            return `(string template span)\n${fence(getTypeName(type.type))}`;
        case "Intrinsic":
            return "";
        case "FunctionParameter":
            return `(function parameter)\n${fence(getFunctionParameterSignature(type))}`;
        case "ModelProperty":
            return `(model property)\n${fence(getModelPropertySignature(type))}`;
        case "EnumMember":
            return `(enum member)\n${fence(getEnumMemberSignature(type))}`;
        case "TemplateParameter":
            return `(template parameter)\n${fence(type.node.id.sv)}`;
        case "UnionVariant":
            return `(union variant)\n${fence(getUnionVariantSignature(type))}`;
        case "Tuple":
            return `(tuple)\n[${fence(type.values.map(getTypeSignature).join(", "))}]`;
        case "Projection":
            return "(projection)";
        case "Object":
            return "(object)";
        default:
            compilerAssert(false, "Unexpected type kind");
    }
}
function getDecoratorSignature(type) {
    const ns = getQualifier(type.namespace);
    const name = type.name.slice(1);
    const parameters = [type.target, ...type.parameters].map((x) => getFunctionParameterSignature(x));
    return `dec ${ns}${name}(${parameters.join(", ")})`;
}
function getFunctionSignature(type) {
    const ns = getQualifier(type.namespace);
    const parameters = type.parameters.map((x) => getFunctionParameterSignature(x));
    return `fn ${ns}${printId(type.name)}(${parameters.join(", ")}): ${getPrintableTypeName(type.returnType)}`;
}
function getOperationSignature(type) {
    const ns = getQualifier(type.namespace) || getQualifier(type.interface);
    const parameters = [...type.parameters.properties.values()].map(getModelPropertySignature);
    return `op ${ns}${type.name}(${parameters.join(", ")}): ${getPrintableTypeName(type.returnType)}`;
}
function getFunctionParameterSignature(parameter) {
    const rest = parameter.rest ? "..." : "";
    const optional = parameter.optional ? "?" : "";
    return `${rest}${printId(parameter.name)}${optional}: ${getTypeName(parameter.type)}`;
}
function getStringTemplateSignature(stringTemplate) {
    return ("`" +
        [
            stringTemplate.spans.map((span) => {
                return span.isInterpolated ? "${" + getTypeName(span.type) + "}" : span.type.value;
            }),
        ].join("") +
        "`");
}
function getModelPropertySignature(property) {
    const ns = getQualifier(property.model);
    return `${ns}${printId(property.name)}: ${getPrintableTypeName(property.type)}`;
}
function getUnionVariantSignature(variant) {
    if (typeof variant.name !== "string") {
        return getPrintableTypeName(variant.type);
    }
    const ns = getQualifier(variant.union);
    return `${ns}${printId(variant.name)}: ${getPrintableTypeName(variant.type)}`;
}
function getEnumMemberSignature(member) {
    const ns = getQualifier(member.enum);
    const value = typeof member.value === "string" ? `"${member.value}"` : member.value;
    return value === undefined
        ? `${ns}${printId(member.name)}`
        : `${ns}${printId(member.name)}: ${value}`;
}
function getAliasSignature(alias) {
    const fullName = getFullyQualifiedSymbolName(alias.symbol);
    const args = alias.templateParameters.map((t) => t.id.sv);
    return args.length === 0 ? fullName : `${fullName}<${args.join(", ")}>`;
}
function getQualifier(parent) {
    if (!(parent === null || parent === void 0 ? void 0 : parent.name) ||
        typeof parent.name !== "string" ||
        (parent.kind === "Namespace" && isStdNamespace(parent))) {
        return "";
    }
    const parentName = getPrintableTypeName(parent);
    if (!parentName) {
        return "";
    }
    return parentName + ".";
}
function getPrintableTypeName(type) {
    return getTypeName(type, {
        printable: true,
    });
}
function fence(code) {
    return `\`\`\`typespec\n${code}\n\`\`\``;
}

/**
 * Get the detailed documentation for a symbol.
 * @param program The program
 * @internal
 */
function getSymbolDetails(program, symbol, options = {
    includeSignature: true,
    includeParameterTags: true,
}) {
    var _a;
    const lines = [];
    if (options.includeSignature) {
        lines.push(getSymbolSignature(program, symbol));
    }
    const doc = getSymbolDocumentation(program, symbol);
    if (doc) {
        lines.push(doc);
    }
    for (const node of symbol.declarations) {
        for (const doc of (_a = node === null || node === void 0 ? void 0 : node.docs) !== null && _a !== void 0 ? _a : []) {
            for (const tag of doc.tags) {
                if (!options.includeParameterTags &&
                    (tag.kind === SyntaxKind.DocParamTag || tag.kind === SyntaxKind.DocTemplateTag)) {
                    continue;
                }
                lines.push(
                //prettier-ignore
                `_@${tag.tagName.sv}_${"paramName" in tag ? ` \`${tag.paramName.sv}\`` : ""} \n${getDocContent(tag.content)}`);
            }
        }
    }
    return lines.join("\n\n");
}
function getSymbolDocumentation(program, symbol) {
    var _a, _b;
    const docs = [];
    for (const node of symbol.declarations) {
        // Add /** ... */ developer docs
        for (const d of (_a = node.docs) !== null && _a !== void 0 ? _a : []) {
            docs.push(getDocContent(d.content));
        }
    }
    // Add @doc(...) API docs
    const type = (_b = symbol.type) !== null && _b !== void 0 ? _b : program.checker.getTypeForNode(symbol.declarations[0]);
    const apiDocs = getDocData(program, type);
    // The doc comment is already included above we don't want to duplicate
    if (apiDocs && apiDocs.source === "comment") {
        docs.push(apiDocs.value);
    }
    return docs.join("\n\n");
}
/** @internal */
function getParameterDocumentation(program, type) {
    var _a, _b;
    const map = new Map();
    for (const d of (_b = (_a = type === null || type === void 0 ? void 0 : type.node) === null || _a === void 0 ? void 0 : _a.docs) !== null && _b !== void 0 ? _b : []) {
        for (const tag of d.tags) {
            if (tag.kind === SyntaxKind.DocParamTag) {
                map.set(tag.paramName.sv, getDocContent(tag.content));
            }
        }
    }
    return map;
}
/** @internal */
function getTemplateParameterDocumentation(node) {
    var _a;
    const map = new Map();
    for (const d of (_a = node === null || node === void 0 ? void 0 : node.docs) !== null && _a !== void 0 ? _a : []) {
        for (const tag of d.tags) {
            if (tag.kind === SyntaxKind.DocTemplateTag) {
                map.set(tag.paramName.sv, getDocContent(tag.content));
            }
        }
    }
    return map;
}
function getDocContent(content) {
    const docs = [];
    for (const node of content) {
        compilerAssert(node.kind === SyntaxKind.DocText, "No other doc content node kinds exist yet. Update this code appropriately when more are added.");
        docs.push(node.text);
    }
    return docs.join("");
}

async function resolveCompletion(context, node) {
    const completions = {
        isIncomplete: false,
        items: [],
    };
    if (node === undefined) {
        addKeywordCompletion("root", completions);
    }
    else {
        switch (node.kind) {
            case SyntaxKind.NamespaceStatement:
                addKeywordCompletion("namespace", completions);
                break;
            case SyntaxKind.Identifier:
                addIdentifierCompletion(context, node);
                break;
            case SyntaxKind.StringLiteral:
                if (node.parent && node.parent.kind === SyntaxKind.ImportStatement) {
                    await addImportCompletion(context, node);
                }
                break;
        }
    }
    return completions;
}
const keywords = [
    // Root only
    ["import", { root: true }],
    // Root and namespace
    ["using", { root: true, namespace: true }],
    ["model", { root: true, namespace: true }],
    ["scalar", { root: true, namespace: true }],
    ["namespace", { root: true, namespace: true }],
    ["interface", { root: true, namespace: true }],
    ["union", { root: true, namespace: true }],
    ["enum", { root: true, namespace: true }],
    ["alias", { root: true, namespace: true }],
    ["op", { root: true, namespace: true }],
    ["dec", { root: true, namespace: true }],
    ["fn", { root: true, namespace: true }],
    // On model `model Foo <keyword> ...`
    ["extends", { model: true }],
    ["is", { model: true }],
    // On identifier
    ["true", { identifier: true }],
    ["false", { identifier: true }],
    ["unknown", { identifier: true }],
    ["void", { identifier: true }],
    ["never", { identifier: true }],
    // Modifiers
    ["extern", { root: true, namespace: true }],
];
function addKeywordCompletion(area, completions) {
    const filteredKeywords = keywords.filter(([_, x]) => area in x);
    for (const [keyword] of filteredKeywords) {
        completions.items.push({
            label: keyword,
            kind: main$3.CompletionItemKind.Keyword,
        });
    }
}
async function addLibraryImportCompletion({ program, file, completions }, node) {
    const documentPath = file.file.path;
    const projectRoot = await findProjectRoot(program.host, documentPath);
    if (projectRoot !== undefined) {
        const [packagejson] = await loadFile(program.host, resolvePath(projectRoot, "package.json"), JSON.parse, program.reportDiagnostic);
        let dependencies = [];
        if (packagejson.dependencies !== undefined) {
            dependencies = dependencies.concat(Object.keys(packagejson.dependencies));
        }
        if (packagejson.peerDependencies !== undefined) {
            dependencies = dependencies.concat(Object.keys(packagejson.peerDependencies));
        }
        for (const dependency of dependencies) {
            const nodeProjectRoot = resolvePath(projectRoot, "node_modules", dependency);
            const [libPackageJson] = await loadFile(program.host, resolvePath(nodeProjectRoot, "package.json"), JSON.parse, program.reportDiagnostic);
            if (resolveTspMain(libPackageJson) !== undefined) {
                const range = {
                    start: file.file.getLineAndCharacterOfPosition(node.pos + 1),
                    end: file.file.getLineAndCharacterOfPosition(node.end - 1),
                };
                completions.items.push({
                    textEdit: main$3.TextEdit.replace(range, dependency),
                    label: dependency,
                    kind: main$3.CompletionItemKind.Module,
                });
            }
        }
    }
}
async function addImportCompletion(context, node) {
    if (node.value.startsWith("./") || node.value.startsWith("../")) {
        await addRelativePathCompletion(context, node);
    }
    else if (!node.value.startsWith(".")) {
        await addLibraryImportCompletion(context, node);
    }
}
async function addRelativePathCompletion({ program, completions, file }, node) {
    const documentPath = file.file.path;
    const documentFile = getBaseFileName(documentPath);
    const documentDir = getDirectoryPath(documentPath);
    const nodevalueDir = hasTrailingDirectorySeparator(node.value)
        ? node.value
        : getDirectoryPath(node.value);
    const mainTypeSpec = resolvePath(documentDir, nodevalueDir);
    const files = (await program.host.readDir(mainTypeSpec)).filter((x) => x !== documentFile && x !== "node_modules");
    for (const file of files) {
        const extension = getAnyExtensionFromPath(file);
        switch (extension) {
            case ".tsp":
            case ".js":
            case ".mjs":
                completions.items.push({
                    label: file,
                    commitCharacters: [],
                    kind: main$3.CompletionItemKind.File,
                });
                break;
            case "":
                completions.items.push({
                    label: file,
                    commitCharacters: [],
                    kind: main$3.CompletionItemKind.Folder,
                });
                break;
        }
    }
}
/**
 * Add completion options for an identifier.
 */
function addIdentifierCompletion({ program, completions }, node) {
    var _a, _b, _c;
    const result = program.checker.resolveCompletions(node);
    if (result.size === 0) {
        return;
    }
    for (const [key, { sym, label }] of result) {
        let kind;
        let deprecated = false;
        const type = (_a = sym.type) !== null && _a !== void 0 ? _a : program.checker.getTypeForNode(sym.declarations[0]);
        if (sym.flags & (131072 /* SymbolFlags.Function */ | 16384 /* SymbolFlags.Decorator */)) {
            kind = main$3.CompletionItemKind.Function;
        }
        else if (sym.flags & 4096 /* SymbolFlags.Namespace */ &&
            sym.declarations[0].kind !== SyntaxKind.NamespaceStatement) {
            kind = main$3.CompletionItemKind.Module;
        }
        else if (((_b = sym.declarations[0]) === null || _b === void 0 ? void 0 : _b.kind) === SyntaxKind.AliasStatement) {
            kind = main$3.CompletionItemKind.Variable;
            deprecated = getDeprecationDetails(program, sym.declarations[0]) !== undefined;
        }
        else {
            kind = getCompletionItemKind(program, type);
            deprecated = getDeprecationDetails(program, type) !== undefined;
        }
        const documentation = getSymbolDetails(program, sym);
        const item = {
            label: label !== null && label !== void 0 ? label : key,
            documentation: documentation
                ? {
                    kind: main$3.MarkupKind.Markdown,
                    value: documentation,
                }
                : undefined,
            kind,
            insertText: printId(key),
        };
        if (deprecated) {
            item.tags = [main$3.CompletionItemTag.Deprecated];
        }
        completions.items.push(item);
    }
    if (((_c = node.parent) === null || _c === void 0 ? void 0 : _c.kind) === SyntaxKind.TypeReference) {
        addKeywordCompletion("identifier", completions);
    }
}
function getCompletionItemKind(program, target) {
    var _a;
    switch ((_a = target.node) === null || _a === void 0 ? void 0 : _a.kind) {
        case SyntaxKind.EnumStatement:
        case SyntaxKind.UnionStatement:
            return main$3.CompletionItemKind.Enum;
        case SyntaxKind.EnumMember:
        case SyntaxKind.UnionVariant:
            return main$3.CompletionItemKind.EnumMember;
        case SyntaxKind.AliasStatement:
            return main$3.CompletionItemKind.Variable;
        case SyntaxKind.ModelStatement:
            return main$3.CompletionItemKind.Class;
        case SyntaxKind.ScalarStatement:
            return main$3.CompletionItemKind.Unit;
        case SyntaxKind.ModelProperty:
            return main$3.CompletionItemKind.Field;
        case SyntaxKind.OperationStatement:
            return main$3.CompletionItemKind.Method;
        case SyntaxKind.NamespaceStatement:
            return main$3.CompletionItemKind.Module;
        default:
            return main$3.CompletionItemKind.Struct;
    }
}

/**
 * Find the comment that is at given position, if any.
 *
 * A comment is at the given position if {@link Comment.pos} <= position <
 * {@link Comment.end}. Unlike {@link getNodeAtPosition}, the end node is
 * not included since comments can be adjacent to each other with no trivia
 * or punctuation between them.
 *
 * @internal
 */
function getCommentAtPosition(script, pos) {
    if (!script.parseOptions.comments) {
        // Not an assert since we might make this public and it would be external caller's responsibility.
        throw new Error("ParseOptions.comments must be enabled to use getCommentAtPosition.");
    }
    // Comments are ordered by increasing position, use binary search
    let low = 0;
    let high = script.comments.length - 1;
    while (low <= high) {
        const middle = low + ((high - low) >> 1);
        const candidate = script.comments[middle];
        if (pos >= candidate.end) {
            low = middle + 1;
        }
        else if (pos < candidate.pos) {
            high = middle - 1;
        }
        else {
            return candidate;
        }
    }
    return undefined;
}
/**
 * Adjust the given postion backwards before any trivia.
 *
 * @internal
 */
function getPositionBeforeTrivia(script, pos) {
    if (!script.parseOptions.comments) {
        // Not an assert since we might make this public and it would be external caller's responsibility.
        throw new Error("ParseOptions.comments must be enabled to use getPositionBeforeTrivia.");
    }
    let comment;
    while (pos > 0) {
        if (isWhiteSpace(script.file.text.charCodeAt(pos - 1))) {
            do {
                pos--;
            } while (isWhiteSpace(script.file.text.charCodeAt(pos - 1)));
        }
        else if ((comment = getCommentAtPosition(script, pos - 1))) {
            pos = comment.pos;
        }
        else {
            // note at whitespace or comment
            break;
        }
    }
    return pos;
}

function getSymbolStructure(ast) {
    const file = ast.file;
    const fileNamespace = findFileNamespace(ast);
    if (fileNamespace === undefined) {
        return getForStatements(ast.statements);
    }
    const fileNamespaceSymbol = getForNamespace(fileNamespace);
    fileNamespaceSymbol.children = getForStatements(ast.statements.filter((x) => x !== fileNamespace));
    return [fileNamespaceSymbol];
    function findFileNamespace(ast) {
        var _a;
        const firstNamespace = ast.statements.find((x) => x.kind === SyntaxKind.NamespaceStatement);
        if (firstNamespace === undefined) {
            return undefined;
        }
        let current = firstNamespace;
        while (current.statements !== undefined &&
            !isArray(current.statements) &&
            ((_a = current.statements) === null || _a === void 0 ? void 0 : _a.kind) === SyntaxKind.NamespaceStatement) {
            current = current.statements;
        }
        return current.statements === undefined ? firstNamespace : undefined;
    }
    function getDocumentSymbolsForNode(node) {
        switch (node.kind) {
            case SyntaxKind.NamespaceStatement:
                return getForNamespace(node);
            case SyntaxKind.ModelStatement:
                return getForModel(node);
            case SyntaxKind.ModelProperty:
                return createDocumentSymbol(node, getName(node.id), main$3.SymbolKind.Property);
            case SyntaxKind.ModelSpreadProperty:
                return getForModelSpread(node);
            case SyntaxKind.UnionStatement:
                return getForUnion(node);
            case SyntaxKind.UnionVariant:
                return node.id === undefined
                    ? undefined
                    : createDocumentSymbol(node, getName(node.id), main$3.SymbolKind.EnumMember);
            case SyntaxKind.EnumStatement:
                return getForEnum(node);
            case SyntaxKind.EnumMember:
                return createDocumentSymbol(node, getName(node.id), main$3.SymbolKind.EnumMember);
            case SyntaxKind.EnumSpreadMember:
                return getForEnumSpread(node);
            case SyntaxKind.InterfaceStatement:
                return getForInterface(node);
            case SyntaxKind.OperationStatement:
                return createDocumentSymbol(node, node.id.sv, main$3.SymbolKind.Function);
            case SyntaxKind.AliasStatement:
                return createDocumentSymbol(node, node.id.sv, main$3.SymbolKind.Variable);
            default:
                return undefined;
        }
    }
    function getForStatements(statements) {
        return statements.map(getDocumentSymbolsForNode).filter(isDefined);
    }
    function getForNamespace(namespace) {
        var _a;
        const names = [namespace.id.sv];
        let current = namespace;
        while (current.statements !== undefined &&
            !isArray(current.statements) &&
            ((_a = current.statements) === null || _a === void 0 ? void 0 : _a.kind) === SyntaxKind.NamespaceStatement) {
            current = current.statements;
            names.push(current.id.sv);
        }
        const statementSymbols = current.statements ? getForStatements(current.statements) : [];
        return createDocumentSymbol(namespace, names.join("."), main$3.SymbolKind.Namespace, statementSymbols);
    }
    function createDocumentSymbol(node, name, kind, symbols) {
        const start = file.getLineAndCharacterOfPosition(node.pos);
        const end = file.getLineAndCharacterOfPosition(node.end);
        const range = main$3.Range.create(start, end);
        return main$3.DocumentSymbol.create(name, undefined, kind, range, range, symbols);
    }
    function getName(id) {
        return id.kind === SyntaxKind.Identifier ? id.sv : id.value;
    }
    function getForModel(node) {
        const properties = [...node.properties.values()]
            .map(getDocumentSymbolsForNode)
            .filter(isDefined);
        return createDocumentSymbol(node, node.id.sv, main$3.SymbolKind.Struct, properties);
    }
    function getForModelSpread(node) {
        const target = node.target.target;
        if (target.kind === SyntaxKind.Identifier) {
            return createDocumentSymbol(node, target.sv, main$3.SymbolKind.Property);
        }
        return getDocumentSymbolsForNode(target);
    }
    function getForEnum(node) {
        const members = [...node.members.values()]
            .map(getDocumentSymbolsForNode)
            .filter(isDefined);
        return createDocumentSymbol(node, node.id.sv, main$3.SymbolKind.Enum, members);
    }
    function getForEnumSpread(node) {
        const target = node.target.target;
        if (target.kind === SyntaxKind.Identifier) {
            return createDocumentSymbol(node, target.sv, main$3.SymbolKind.EnumMember);
        }
        return getDocumentSymbolsForNode(target);
    }
    function getForInterface(node) {
        const operations = [...node.operations.values()]
            .map(getDocumentSymbolsForNode)
            .filter(isDefined);
        return createDocumentSymbol(node, node.id.sv, main$3.SymbolKind.Interface, operations);
    }
    function getForUnion(node) {
        const variants = [...node.options.values()]
            .map(getDocumentSymbolsForNode)
            .filter(isDefined);
        return createDocumentSymbol(node, node.id.sv, main$3.SymbolKind.Enum, variants);
    }
}

var SemanticTokenKind;
(function (SemanticTokenKind) {
    SemanticTokenKind[SemanticTokenKind["Namespace"] = 0] = "Namespace";
    SemanticTokenKind[SemanticTokenKind["Type"] = 1] = "Type";
    SemanticTokenKind[SemanticTokenKind["Class"] = 2] = "Class";
    SemanticTokenKind[SemanticTokenKind["Enum"] = 3] = "Enum";
    SemanticTokenKind[SemanticTokenKind["Interface"] = 4] = "Interface";
    SemanticTokenKind[SemanticTokenKind["Struct"] = 5] = "Struct";
    SemanticTokenKind[SemanticTokenKind["TypeParameter"] = 6] = "TypeParameter";
    SemanticTokenKind[SemanticTokenKind["Parameter"] = 7] = "Parameter";
    SemanticTokenKind[SemanticTokenKind["Variable"] = 8] = "Variable";
    SemanticTokenKind[SemanticTokenKind["Property"] = 9] = "Property";
    SemanticTokenKind[SemanticTokenKind["EnumMember"] = 10] = "EnumMember";
    SemanticTokenKind[SemanticTokenKind["Event"] = 11] = "Event";
    SemanticTokenKind[SemanticTokenKind["Function"] = 12] = "Function";
    SemanticTokenKind[SemanticTokenKind["Method"] = 13] = "Method";
    SemanticTokenKind[SemanticTokenKind["Macro"] = 14] = "Macro";
    SemanticTokenKind[SemanticTokenKind["Keyword"] = 15] = "Keyword";
    SemanticTokenKind[SemanticTokenKind["Comment"] = 16] = "Comment";
    SemanticTokenKind[SemanticTokenKind["String"] = 17] = "String";
    SemanticTokenKind[SemanticTokenKind["Number"] = 18] = "Number";
    SemanticTokenKind[SemanticTokenKind["Regexp"] = 19] = "Regexp";
    SemanticTokenKind[SemanticTokenKind["Operator"] = 20] = "Operator";
    SemanticTokenKind[SemanticTokenKind["DocCommentTag"] = 21] = "DocCommentTag";
})(SemanticTokenKind || (SemanticTokenKind = {}));
const serverOptions = {
    noEmit: true,
    designTimeBuild: true,
    parseOptions: {
        comments: true,
        docs: true,
    },
};
function createServer(host) {
    // Remember original URL when we convert it to a local path so that we can
    // get it back. We can't convert it back because things like URL-encoding
    // could give us back an equivalent but non-identical URL but the original
    // URL is used as a key into the opened documents and so we must reproduce
    // it exactly.
    const pathToURLMap = new Map();
    // Cache all file I/O. Only open documents are sent over the LSP pipe. When
    // the compiler reads a file that isn't open, we use this cache to avoid
    // hitting the disk. Entries are invalidated when LSP client notifies us of
    // a file change.
    const fileSystemCache = createFileSystemCache();
    const compilerHost = createCompilerHost();
    const oldPrograms = new Map();
    let workspaceFolders = [];
    let isInitialized = false;
    let pendingMessages = [];
    return {
        get pendingMessages() {
            return pendingMessages;
        },
        get workspaceFolders() {
            return workspaceFolders;
        },
        compile: compile$1,
        initialize,
        initialized,
        workspaceFoldersChanged,
        watchedFilesChanged,
        formatDocument,
        gotoDefinition,
        documentClosed,
        complete,
        findReferences,
        findDocumentHighlight,
        prepareRename,
        rename,
        getSemanticTokens,
        buildSemanticTokens,
        checkChange,
        getFoldingRanges,
        getHover,
        getSignatureHelp,
        getDocumentSymbols,
        log,
    };
    async function initialize(params) {
        var _a, _b;
        const tokenLegend = {
            tokenTypes: Object.keys(SemanticTokenKind)
                .filter((x) => Number.isNaN(Number(x)))
                .map((x) => x.slice(0, 1).toLocaleLowerCase() + x.slice(1)),
            tokenModifiers: [],
        };
        const capabilities = {
            textDocumentSync: node.TextDocumentSyncKind.Incremental,
            definitionProvider: true,
            foldingRangeProvider: true,
            hoverProvider: true,
            documentSymbolProvider: true,
            documentHighlightProvider: true,
            completionProvider: {
                resolveProvider: false,
                triggerCharacters: [".", "@", "/"],
            },
            semanticTokensProvider: {
                full: true,
                legend: tokenLegend,
            },
            referencesProvider: true,
            renameProvider: {
                prepareProvider: true,
            },
            documentFormattingProvider: true,
            signatureHelpProvider: {
                triggerCharacters: ["(", ",", "<"],
                retriggerCharacters: [")"],
            },
        };
        if ((_a = params.capabilities.workspace) === null || _a === void 0 ? void 0 : _a.workspaceFolders) {
            for (const w of (_b = params.workspaceFolders) !== null && _b !== void 0 ? _b : []) {
                workspaceFolders.push({
                    ...w,
                    path: ensureTrailingDirectorySeparator(await fileURLToRealPath(w.uri)),
                });
            }
            capabilities.workspace = {
                workspaceFolders: {
                    supported: true,
                    changeNotifications: true,
                },
            };
            // eslint-disable-next-line deprecation/deprecation
        }
        else if (params.rootUri) {
            workspaceFolders = [
                {
                    name: "<root>",
                    // eslint-disable-next-line deprecation/deprecation
                    uri: params.rootUri,
                    // eslint-disable-next-line deprecation/deprecation
                    path: ensureTrailingDirectorySeparator(await fileURLToRealPath(params.rootUri)),
                },
            ];
            // eslint-disable-next-line deprecation/deprecation
        }
        else if (params.rootPath) {
            workspaceFolders = [
                {
                    name: "<root>",
                    // eslint-disable-next-line deprecation/deprecation
                    uri: compilerHost.pathToFileURL(params.rootPath),
                    path: ensureTrailingDirectorySeparator(
                    // eslint-disable-next-line deprecation/deprecation
                    await getNormalizedRealPath(compilerHost, params.rootPath)),
                },
            ];
        }
        log("Workspace Folders", workspaceFolders);
        return { capabilities };
    }
    function initialized(params) {
        isInitialized = true;
        log("Initialization complete.");
    }
    async function workspaceFoldersChanged(e) {
        log("Workspace Folders Changed", e);
        const map = new Map(workspaceFolders.map((f) => [f.uri, f]));
        for (const folder of e.removed) {
            map.delete(folder.uri);
        }
        for (const folder of e.added) {
            map.set(folder.uri, {
                ...folder,
                path: ensureTrailingDirectorySeparator(await fileURLToRealPath(folder.uri)),
            });
        }
        workspaceFolders = Array.from(map.values());
        log("Workspace Folders", workspaceFolders);
    }
    function watchedFilesChanged(params) {
        fileSystemCache.notify(params.changes);
    }
    async function compile$1(document, callback) {
        const path = await getPath(document);
        const mainFile = await getMainFileForDocument(path);
        const config = await getConfig(mainFile);
        const [optionsFromConfig, _] = resolveOptionsFromConfig(config, { cwd: path });
        const options = {
            ...optionsFromConfig,
            ...serverOptions,
        };
        if (!upToDate(document)) {
            return undefined;
        }
        let program;
        try {
            program = await compile(compilerHost, mainFile, options, oldPrograms.get(mainFile));
            oldPrograms.set(mainFile, program);
            if (!upToDate(document)) {
                return undefined;
            }
            if (mainFile !== path && !program.sourceFiles.has(path)) {
                // If the file that changed wasn't imported by anything from the main
                // file, retry using the file itself as the main file.
                program = await compile(compilerHost, path, options, oldPrograms.get(path));
                oldPrograms.set(path, program);
            }
            if (!upToDate(document)) {
                return undefined;
            }
            if (callback) {
                const doc = "version" in document ? document : host.getOpenDocumentByURL(document.uri);
                compilerAssert(doc, "Failed to get document.");
                const path = await getPath(doc);
                const script = program.sourceFiles.get(path);
                compilerAssert(script, "Failed to get script.");
                return await callback(program, doc, script);
            }
            return program;
        }
        catch (err) {
            if (host.throwInternalErrors) {
                throw err;
            }
            host.sendDiagnostics({
                uri: document.uri,
                diagnostics: [
                    {
                        severity: node.DiagnosticSeverity.Error,
                        range: node.Range.create(0, 0, 0, 0),
                        message: `Internal compiler error!\nFile issue at https://github.com/microsoft/typespec\n\n` +
                            err.stack,
                    },
                ],
            });
            return undefined;
        }
    }
    async function getConfig(mainFile) {
        const entrypointStat = await host.compilerHost.stat(mainFile);
        const lookupDir = entrypointStat.isDirectory() ? mainFile : getDirectoryPath(mainFile);
        const configPath = await findTypeSpecConfigPath(compilerHost, lookupDir, true);
        if (!configPath) {
            return { ...defaultConfig, projectRoot: getDirectoryPath(mainFile) };
        }
        const cached = await fileSystemCache.get(configPath);
        if (cached === null || cached === void 0 ? void 0 : cached.data) {
            return cached.data;
        }
        const config = await loadTypeSpecConfigFile(compilerHost, configPath);
        await fileSystemCache.setData(configPath, config);
        return config;
    }
    async function getScript(document) {
        var _a;
        const file = await compilerHost.readFile(await getPath(document));
        const cached = (_a = compilerHost.parseCache) === null || _a === void 0 ? void 0 : _a.get(file);
        return cached !== null && cached !== void 0 ? cached : (await compile$1(document, (_, __, script) => script));
    }
    async function getFoldingRanges(params) {
        const ast = await getScript(params.textDocument);
        if (!ast) {
            return [];
        }
        const file = ast.file;
        const ranges = [];
        let rangeStartSingleLines = -1;
        for (let i = 0; i < ast.comments.length; i++) {
            const comment = ast.comments[i];
            if (comment.kind === SyntaxKind.LineComment &&
                i + 1 < ast.comments.length &&
                ast.comments[i + 1].kind === SyntaxKind.LineComment &&
                ast.comments[i + 1].pos === skipWhiteSpace(file.text, comment.end)) {
                if (rangeStartSingleLines === -1) {
                    rangeStartSingleLines = comment.pos;
                }
            }
            else if (rangeStartSingleLines !== -1) {
                addRange(rangeStartSingleLines, comment.end);
                rangeStartSingleLines = -1;
            }
            else {
                addRange(comment.pos, comment.end);
            }
        }
        visitChildren(ast, addRangesForNode);
        function addRangesForNode(node) {
            if (node.kind === SyntaxKind.Doc) {
                return; // fold doc comments as regular comments
            }
            let nodeStart = node.pos;
            if ("decorators" in node && node.decorators.length > 0) {
                const decoratorEnd = node.decorators[node.decorators.length - 1].end;
                addRange(nodeStart, decoratorEnd);
                nodeStart = skipTrivia(file.text, decoratorEnd);
            }
            addRange(nodeStart, node.end);
            visitChildren(node, addRangesForNode);
        }
        return ranges;
        function addRange(startPos, endPos) {
            const start = file.getLineAndCharacterOfPosition(startPos);
            const end = file.getLineAndCharacterOfPosition(endPos);
            if (start.line !== end.line) {
                ranges.push({
                    startLine: start.line,
                    startCharacter: start.character,
                    endLine: end.line,
                    endCharacter: end.character,
                });
            }
        }
    }
    async function getDocumentSymbols(params) {
        const ast = await getScript(params.textDocument);
        if (!ast) {
            return [];
        }
        return getSymbolStructure(ast);
    }
    async function findDocumentHighlight(params) {
        let highlights = [];
        await compile$1(params.textDocument, (program, document, file) => {
            const identifiers = findReferenceIdentifiers(program, file, document.offsetAt(params.position), [file]);
            highlights = identifiers.map((identifier) => ({
                range: getRange(identifier, file.file),
                kind: node.DocumentHighlightKind.Read,
            }));
        });
        return highlights;
    }
    async function checkChange(change) {
        var _a, _b, _c;
        const program = await compile$1(change.document);
        if (!program) {
            return;
        }
        // Group diagnostics by file.
        //
        // Initialize diagnostics for all source files in program to empty array
        // as we must send an empty array when a file has no diagnostics or else
        // stale diagnostics from a previous run will stick around in the IDE.
        //
        const diagnosticMap = new Map();
        diagnosticMap.set(change.document, []);
        for (const each of program.sourceFiles.values()) {
            const document = (_a = each.file) === null || _a === void 0 ? void 0 : _a.document;
            if (document) {
                diagnosticMap.set(document, []);
            }
        }
        for (const each of program.diagnostics) {
            let document;
            const location = getSourceLocation(each.target, { locateId: true });
            if (location === null || location === void 0 ? void 0 : location.file) {
                document = location.file.document;
            }
            else {
                // https://github.com/microsoft/language-server-protocol/issues/256
                //
                // LSP does not currently allow sending a diagnostic with no location so
                // we report diagnostics with no location on the document that changed to
                // trigger.
                document = change.document;
            }
            if (!document || !upToDate(document)) {
                continue;
            }
            const start = document.positionAt((_b = location === null || location === void 0 ? void 0 : location.pos) !== null && _b !== void 0 ? _b : 0);
            const end = document.positionAt((_c = location === null || location === void 0 ? void 0 : location.end) !== null && _c !== void 0 ? _c : 0);
            const range = node.Range.create(start, end);
            const severity = convertSeverity(each.severity);
            const diagnostic = node.Diagnostic.create(range, each.message, severity, each.code, "TypeSpec");
            if (each.code === "deprecated") {
                diagnostic.tags = [node.DiagnosticTag.Deprecated];
            }
            const diagnostics = diagnosticMap.get(document);
            compilerAssert(diagnostics, "Diagnostic reported against a source file that was not added to the program.");
            diagnostics.push(diagnostic);
        }
        for (const [document, diagnostics] of diagnosticMap) {
            sendDiagnostics(document, diagnostics);
        }
    }
    async function getHover(params) {
        const docString = await compile$1(params.textDocument, (program, document, file) => {
            const id = getNodeAtPosition(file, document.offsetAt(params.position));
            const sym = (id === null || id === void 0 ? void 0 : id.kind) === SyntaxKind.Identifier ? program.checker.resolveIdentifier(id) : undefined;
            if (sym) {
                return getSymbolDetails(program, sym);
            }
            return undefined;
        });
        const markdown = {
            kind: node.MarkupKind.Markdown,
            value: docString !== null && docString !== void 0 ? docString : "",
        };
        return {
            contents: markdown,
        };
    }
    async function getSignatureHelp(params) {
        return await compile$1(params.textDocument, (program, document, file) => {
            const data = getSignatureHelpNodeAtPosition(file, document.offsetAt(params.position));
            if (data === undefined) {
                return undefined;
            }
            const { node, argumentIndex } = data;
            switch (node.kind) {
                case SyntaxKind.TypeReference:
                    return getSignatureHelpForTemplate(program, node, argumentIndex);
                case SyntaxKind.DecoratorExpression:
                case SyntaxKind.AugmentDecoratorStatement:
                    return getSignatureHelpForDecorator(program, node, argumentIndex);
                default:
                    const _assertNever = node;
                    compilerAssert(false, "Unreachable");
            }
        });
    }
    function getSignatureHelpForTemplate(program, node$1, argumentIndex) {
        const sym = program.checker.resolveIdentifier(node$1.target.kind === SyntaxKind.MemberExpression ? node$1.target.id : node$1.target);
        const templateDeclNode = sym === null || sym === void 0 ? void 0 : sym.declarations[0];
        if (!templateDeclNode ||
            !("templateParameters" in templateDeclNode) ||
            templateDeclNode.templateParameters.length === 0) {
            return undefined;
        }
        const parameterDocs = getTemplateParameterDocumentation(templateDeclNode);
        const parameters = templateDeclNode.templateParameters.map((x) => {
            const info = { label: x.id.sv };
            const doc = parameterDocs.get(x.id.sv);
            if (doc) {
                info.documentation = { kind: node.MarkupKind.Markdown, value: doc };
            }
            return info;
        });
        const help = {
            signatures: [
                {
                    label: `${sym.name}<${parameters.map((x) => x.label).join(", ")}>`,
                    parameters,
                    activeParameter: Math.min(parameters.length - 1, argumentIndex),
                },
            ],
            activeSignature: 0,
            activeParameter: 0,
        };
        const doc = getSymbolDetails(program, sym, {
            includeSignature: false,
            includeParameterTags: false,
        });
        if (doc) {
            help.signatures[0].documentation = { kind: node.MarkupKind.Markdown, value: doc };
        }
        return help;
    }
    function getSignatureHelpForDecorator(program, node$1, argumentIndex) {
        const sym = program.checker.resolveIdentifier(node$1.target.kind === SyntaxKind.MemberExpression ? node$1.target.id : node$1.target);
        if (!sym) {
            return undefined;
        }
        const decoratorDeclNode = sym.declarations.find((x) => x.kind === SyntaxKind.DecoratorDeclarationStatement);
        if (decoratorDeclNode === undefined) {
            return undefined;
        }
        const type = program.checker.getTypeForNode(decoratorDeclNode);
        compilerAssert(type.kind === "Decorator", "Expected type to be a decorator.");
        const parameterDocs = getParameterDocumentation(program, type);
        let labelPrefix = "";
        const parameters = [];
        if (node$1.kind === SyntaxKind.AugmentDecoratorStatement) {
            const targetType = decoratorDeclNode.target.type
                ? program.checker.getTypeForNode(decoratorDeclNode.target.type)
                : undefined;
            parameters.push({
                label: `${decoratorDeclNode.target.id.sv}: ${targetType ? getTypeName(targetType) : "unknown"}`,
            });
            labelPrefix = "@";
        }
        parameters.push(...type.parameters.map((x) => {
            const info = {
                // prettier-ignore
                label: `${x.rest ? "..." : ""}${x.name}${x.optional ? "?" : ""}: ${getTypeName(x.type)}`,
            };
            const doc = parameterDocs.get(x.name);
            if (doc) {
                info.documentation = { kind: node.MarkupKind.Markdown, value: doc };
            }
            return info;
        }));
        const help = {
            signatures: [
                {
                    label: `${labelPrefix}${type.name}(${parameters.map((x) => x.label).join(", ")})`,
                    parameters,
                    activeParameter: Math.min(parameters.length - 1, argumentIndex),
                },
            ],
            activeSignature: 0,
            activeParameter: 0,
        };
        const doc = getSymbolDetails(program, sym, {
            includeSignature: false,
            includeParameterTags: false,
        });
        if (doc) {
            help.signatures[0].documentation = { kind: node.MarkupKind.Markdown, value: doc };
        }
        return help;
    }
    async function formatDocument(params) {
        const document = host.getOpenDocumentByURL(params.textDocument.uri);
        if (document === undefined) {
            return [];
        }
        const formattedText = await formatTypeSpec(document.getText(), {
            tabWidth: params.options.tabSize,
            useTabs: !params.options.insertSpaces,
        });
        return [minimalEdit(document, formattedText)];
    }
    function minimalEdit(document, string1) {
        const string0 = document.getText();
        // length of common prefix
        let i = 0;
        while (i < string0.length && i < string1.length && string0[i] === string1[i]) {
            ++i;
        }
        // length of common suffix
        let j = 0;
        while (i + j < string0.length &&
            i + j < string1.length &&
            string0[string0.length - j - 1] === string1[string1.length - j - 1]) {
            ++j;
        }
        const newText = string1.substring(i, string1.length - j);
        const pos0 = document.positionAt(i);
        const pos1 = document.positionAt(string0.length - j);
        return node.TextEdit.replace(node.Range.create(pos0, pos1), newText);
    }
    async function gotoDefinition(params) {
        const sym = await compile$1(params.textDocument, (program, document, file) => {
            const id = getNodeAtPosition(file, document.offsetAt(params.position));
            return (id === null || id === void 0 ? void 0 : id.kind) === SyntaxKind.Identifier ? program.checker.resolveIdentifier(id) : undefined;
        });
        return getLocations(sym === null || sym === void 0 ? void 0 : sym.declarations);
    }
    async function complete(params) {
        const completions = {
            isIncomplete: false,
            items: [],
        };
        await compile$1(params.textDocument, async (program, document, file) => {
            const node = getCompletionNodeAtPosition(file, document.offsetAt(params.position));
            await resolveCompletion({
                program,
                file,
                completions,
                params,
            }, node);
        });
        return completions;
    }
    async function findReferences(params) {
        const identifiers = await compile$1(params.textDocument, (program, document, file) => findReferenceIdentifiers(program, file, document.offsetAt(params.position)));
        return getLocations(identifiers);
    }
    async function prepareRename(params) {
        return await compile$1(params.textDocument, (_, document, file) => {
            var _a;
            const id = getNodeAtPosition(file, document.offsetAt(params.position));
            return (id === null || id === void 0 ? void 0 : id.kind) === SyntaxKind.Identifier ? (_a = getLocation(id)) === null || _a === void 0 ? void 0 : _a.range : undefined;
        });
    }
    async function rename(params) {
        const changes = {};
        await compile$1(params.textDocument, (program, document, file) => {
            const identifiers = findReferenceIdentifiers(program, file, document.offsetAt(params.position));
            for (const id of identifiers) {
                const location = getLocation(id);
                if (!location) {
                    continue;
                }
                const change = node.TextEdit.replace(location.range, params.newName);
                if (location.uri in changes) {
                    changes[location.uri].push(change);
                }
                else {
                    changes[location.uri] = [change];
                }
            }
        });
        return { changes };
    }
    function findReferenceIdentifiers(program, file, pos, searchFiles = program.sourceFiles.values()) {
        const id = getNodeAtPosition(file, pos);
        if ((id === null || id === void 0 ? void 0 : id.kind) !== SyntaxKind.Identifier) {
            return [];
        }
        const sym = program.checker.resolveIdentifier(id);
        if (!sym) {
            return [id];
        }
        const references = [];
        for (const searchFile of searchFiles) {
            visitChildren(searchFile, function visit(node) {
                if (node.kind === SyntaxKind.Identifier) {
                    const s = program.checker.resolveIdentifier(node);
                    if (s === sym || (sym.type && (s === null || s === void 0 ? void 0 : s.type) === sym.type)) {
                        references.push(node);
                    }
                }
                visitChildren(node, visit);
            });
        }
        return references;
    }
    async function getSemanticTokens(params) {
        const ignore = -1;
        const defer = -2;
        const ast = await getScript(params.textDocument);
        if (!ast) {
            return [];
        }
        const file = ast.file;
        const tokens = mapTokens();
        classifyNode(ast);
        return Array.from(tokens.values()).filter((t) => t.kind !== undefined);
        function mapTokens() {
            const tokens = new Map();
            const scanner = createScanner(file, () => { });
            const templateStack = [];
            while (scanner.scan() !== Token.EndOfFile) {
                if (scanner.tokenFlags & TokenFlags.DocComment) {
                    classifyDocComment({ pos: scanner.tokenPosition, end: scanner.position });
                }
                else {
                    handleToken(scanner.token, scanner.tokenFlags, {
                        pos: scanner.tokenPosition,
                        end: scanner.position,
                    });
                }
            }
            return tokens;
            function classifyDocComment(range) {
                scanner.scanRange(range, () => {
                    while (scanner.scanDoc() !== Token.EndOfFile) {
                        const kind = classifyDocToken(scanner.token);
                        if (kind === ignore) {
                            continue;
                        }
                        tokens.set(scanner.tokenPosition, {
                            kind: kind === defer ? undefined : kind,
                            pos: scanner.tokenPosition,
                            end: scanner.position,
                        });
                    }
                });
            }
            function handleToken(token, tokenFlags, range) {
                switch (token) {
                    case Token.StringTemplateHead:
                        templateStack.push([token, tokenFlags]);
                        classifyStringTemplate(token, range);
                        break;
                    case Token.OpenBrace:
                        // If we don't have anything on the template stack,
                        // then we aren't trying to keep track of a previously scanned template head.
                        if (templateStack.length > 0) {
                            templateStack.push([token, tokenFlags]);
                        }
                        handleSimpleToken(token, range);
                        break;
                    case Token.CloseBrace:
                        // If we don't have anything on the template stack,
                        // then we aren't trying to keep track of a previously scanned template head.
                        if (templateStack.length > 0) {
                            const [lastToken, lastTokenFlags] = templateStack[templateStack.length - 1];
                            if (lastToken === Token.StringTemplateHead) {
                                token = scanner.reScanStringTemplate(lastTokenFlags);
                                // Only pop on a TemplateTail; a TemplateMiddle indicates there is more for us.
                                if (token === Token.StringTemplateTail) {
                                    templateStack.pop();
                                    classifyStringTemplate(token, {
                                        pos: scanner.tokenPosition,
                                        end: scanner.position,
                                    });
                                }
                                else {
                                    compilerAssert(token === Token.StringTemplateMiddle, "Should have been a template middle.");
                                    classifyStringTemplate(token, {
                                        pos: scanner.tokenPosition,
                                        end: scanner.position,
                                    });
                                }
                            }
                            else {
                                compilerAssert(lastToken === Token.OpenBrace, "Should have been an open brace");
                                templateStack.pop();
                            }
                            break;
                        }
                        handleSimpleToken(token, range);
                        break;
                    default:
                        handleSimpleToken(token, range);
                }
            }
            function handleSimpleToken(token, range) {
                const kind = classifyToken(scanner.token);
                if (kind === ignore) {
                    return;
                }
                tokens.set(range.pos, {
                    kind: kind === defer ? undefined : kind,
                    ...range,
                });
            }
            function classifyStringTemplate(token, range) {
                const stringStart = token === Token.StringTemplateHead ? range.pos : range.pos + 1;
                const stringEnd = token === Token.StringTemplateTail ? range.end : range.end - 2;
                if (stringStart !== range.pos) {
                    tokens.set(range.pos, {
                        kind: SemanticTokenKind.Operator,
                        pos: range.pos,
                        end: stringStart,
                    });
                }
                tokens.set(stringStart, {
                    kind: SemanticTokenKind.String,
                    pos: stringStart,
                    end: stringEnd,
                });
                if (stringEnd !== range.end) {
                    tokens.set(stringEnd, {
                        kind: SemanticTokenKind.Operator,
                        pos: stringEnd,
                        end: range.end,
                    });
                }
            }
        }
        function classifyToken(token) {
            switch (token) {
                case Token.Identifier:
                    return defer;
                case Token.StringLiteral:
                    return SemanticTokenKind.String;
                case Token.NumericLiteral:
                    return SemanticTokenKind.Number;
                case Token.MultiLineComment:
                case Token.SingleLineComment:
                    return SemanticTokenKind.Comment;
                default:
                    if (isKeyword(token)) {
                        return SemanticTokenKind.Keyword;
                    }
                    if (isPunctuation(token)) {
                        return SemanticTokenKind.Operator;
                    }
                    return ignore;
            }
        }
        /** Classify tokens when scanning doc comment. */
        function classifyDocToken(token) {
            switch (token) {
                case Token.NewLine:
                case Token.Whitespace:
                    return ignore;
                case Token.DocText:
                case Token.Star:
                case Token.Identifier:
                    return SemanticTokenKind.Comment;
                case Token.At:
                    return defer;
                default:
                    return ignore;
            }
        }
        function classifyNode(node) {
            switch (node.kind) {
                case SyntaxKind.DirectiveExpression:
                    classify(node.target, SemanticTokenKind.Keyword);
                    break;
                case SyntaxKind.TemplateParameterDeclaration:
                    classify(node.id, SemanticTokenKind.TypeParameter);
                    break;
                case SyntaxKind.ModelProperty:
                case SyntaxKind.UnionVariant:
                    if (node.id) {
                        classify(node.id, SemanticTokenKind.Property);
                    }
                    break;
                case SyntaxKind.AliasStatement:
                    classify(node.id, SemanticTokenKind.Struct);
                    break;
                case SyntaxKind.ModelStatement:
                    classify(node.id, SemanticTokenKind.Struct);
                    break;
                case SyntaxKind.ScalarStatement:
                    classify(node.id, SemanticTokenKind.Type);
                    break;
                case SyntaxKind.EnumStatement:
                    classify(node.id, SemanticTokenKind.Enum);
                    break;
                case SyntaxKind.EnumMember:
                    classify(node.id, SemanticTokenKind.EnumMember);
                    break;
                case SyntaxKind.NamespaceStatement:
                    classify(node.id, SemanticTokenKind.Namespace);
                    break;
                case SyntaxKind.InterfaceStatement:
                    classify(node.id, SemanticTokenKind.Interface);
                    break;
                case SyntaxKind.OperationStatement:
                    classify(node.id, SemanticTokenKind.Function);
                    break;
                case SyntaxKind.DecoratorDeclarationStatement:
                    classify(node.id, SemanticTokenKind.Function);
                    break;
                case SyntaxKind.FunctionDeclarationStatement:
                    classify(node.id, SemanticTokenKind.Function);
                    break;
                case SyntaxKind.FunctionParameter:
                    classify(node.id, SemanticTokenKind.Parameter);
                    break;
                case SyntaxKind.AugmentDecoratorStatement:
                    classifyReference(node.targetType, SemanticTokenKind.Type);
                    classifyReference(node.target, SemanticTokenKind.Macro);
                    break;
                case SyntaxKind.DecoratorExpression:
                    classifyReference(node.target, SemanticTokenKind.Macro);
                    break;
                case SyntaxKind.TypeReference:
                    classifyReference(node.target);
                    break;
                case SyntaxKind.MemberExpression:
                    classifyReference(node);
                    break;
                case SyntaxKind.ProjectionStatement:
                    classifyReference(node.selector);
                    classify(node.id, SemanticTokenKind.Variable);
                    break;
                case SyntaxKind.Projection:
                    classify(node.directionId, SemanticTokenKind.Keyword);
                    for (const modifierId of node.modifierIds) {
                        classify(modifierId, SemanticTokenKind.Keyword);
                    }
                    break;
                case SyntaxKind.ProjectionParameterDeclaration:
                    classifyReference(node.id, SemanticTokenKind.Parameter);
                    break;
                case SyntaxKind.ProjectionCallExpression:
                    classifyReference(node.target, SemanticTokenKind.Function);
                    for (const arg of node.arguments) {
                        classifyReference(arg);
                    }
                    break;
                case SyntaxKind.ProjectionMemberExpression:
                    classifyReference(node.id);
                    break;
                case SyntaxKind.DocParamTag:
                case SyntaxKind.DocTemplateTag:
                    classifyDocTag(node.tagName, SemanticTokenKind.DocCommentTag);
                    classifyOverride(node.paramName, SemanticTokenKind.Variable);
                    break;
                case SyntaxKind.DocReturnsTag:
                    classifyDocTag(node.tagName, SemanticTokenKind.DocCommentTag);
                    break;
                case SyntaxKind.DocUnknownTag:
                    classifyDocTag(node.tagName, SemanticTokenKind.Macro);
                    break;
            }
            visitChildren(node, classifyNode);
        }
        function classifyDocTag(node, kind) {
            classifyOverride(node, kind);
            const token = tokens.get(node.pos - 1); // Get the `@` token
            if (token) {
                token.kind = kind;
            }
        }
        function classify(node, kind) {
            const token = tokens.get(node.pos);
            if (token && token.kind === undefined) {
                token.kind = kind;
            }
        }
        function classifyOverride(node, kind) {
            const token = tokens.get(node.pos);
            if (token) {
                token.kind = kind;
            }
        }
        function classifyReference(node, kind = SemanticTokenKind.Type) {
            switch (node.kind) {
                case SyntaxKind.MemberExpression:
                    classifyIdentifier(node.base, SemanticTokenKind.Namespace);
                    classifyIdentifier(node.id, kind);
                    break;
                case SyntaxKind.ProjectionMemberExpression:
                    classifyReference(node.base, SemanticTokenKind.Namespace);
                    classifyIdentifier(node.id, kind);
                    break;
                case SyntaxKind.TypeReference:
                    classifyIdentifier(node.target, kind);
                    break;
                case SyntaxKind.Identifier:
                    classify(node, kind);
                    break;
            }
        }
        function classifyIdentifier(node, kind) {
            if (node.kind === SyntaxKind.Identifier) {
                classify(node, kind);
            }
        }
    }
    async function buildSemanticTokens(params) {
        const builder = new node.SemanticTokensBuilder();
        const tokens = await getSemanticTokens(params);
        const file = await compilerHost.readFile(await getPath(params.textDocument));
        const starts = file.getLineStarts();
        for (const token of tokens) {
            const start = file.getLineAndCharacterOfPosition(token.pos);
            const end = file.getLineAndCharacterOfPosition(token.end);
            for (let pos = token.pos, line = start.line; line <= end.line; line++) {
                const endPos = line === end.line ? token.end : starts[line + 1];
                const character = line === start.line ? start.character : 0;
                builder.push(line, character, endPos - pos, token.kind, 0);
                pos = endPos;
            }
        }
        return builder.build();
    }
    function documentClosed(change) {
        // clear diagnostics on file close
        sendDiagnostics(change.document, []);
    }
    function getLocations(targets) {
        var _a;
        return (_a = targets === null || targets === void 0 ? void 0 : targets.map(getLocation).filter((x) => !!x)) !== null && _a !== void 0 ? _a : [];
    }
    function getLocation(target) {
        const location = getSourceLocation(target);
        if (location.isSynthetic) {
            return undefined;
        }
        return {
            uri: getURL(location.file.path),
            range: getRange(location, location.file),
        };
    }
    function getRange(location, file) {
        const start = file.getLineAndCharacterOfPosition(location.pos);
        const end = file.getLineAndCharacterOfPosition(location.end);
        return node.Range.create(start, end);
    }
    function convertSeverity(severity) {
        switch (severity) {
            case "warning":
                return node.DiagnosticSeverity.Warning;
            case "error":
                return node.DiagnosticSeverity.Error;
        }
    }
    function log(message, details = undefined) {
        message = `[${new Date().toLocaleTimeString()}] ${message}`;
        if (details) {
            message += ": " + JSON.stringify(details, undefined, 2);
        }
        if (!isInitialized) {
            pendingMessages.push(message);
            return;
        }
        for (const pending of pendingMessages) {
            host.log(pending);
        }
        pendingMessages = [];
        host.log(message);
    }
    function sendDiagnostics(document, diagnostics) {
        host.sendDiagnostics({
            uri: document.uri,
            version: document.version,
            diagnostics,
        });
    }
    /**
     * Determine if the given document is the latest version.
     *
     * A document can become out-of-date if a change comes in during an async
     * operation.
     */
    function upToDate(document) {
        var _a;
        if (!("version" in document)) {
            return true;
        }
        return document.version === ((_a = host.getOpenDocumentByURL(document.uri)) === null || _a === void 0 ? void 0 : _a.version);
    }
    /**
     * Infer the appropriate entry point (a.k.a. "main file") for analyzing a
     * change to the file at the given path. This is necessary because different
     * results can be obtained from compiling the same file with different entry
     * points.
     *
     * Walk directory structure upwards looking for package.json with tspMain or
     * main.tsp file. Stop search when reaching a workspace root. If a root is
     * reached without finding an entry point, use the given path as its own
     * entry point.
     *
     * Untitled documents are always treated as their own entry points as they
     * do not exist in a directory that could pull them in via another entry
     * point.
     */
    async function getMainFileForDocument(path) {
        if (path.startsWith("untitled:")) {
            return path;
        }
        let dir = getDirectoryPath(path);
        const options = { allowFileNotFound: true };
        while (true) {
            let mainFile = "main.tsp";
            let pkg;
            const pkgPath = joinPaths(dir, "package.json");
            const cached = await fileSystemCache.get(pkgPath);
            if (cached === null || cached === void 0 ? void 0 : cached.data) {
                pkg = cached.data;
            }
            else {
                [pkg] = await loadFile(compilerHost, pkgPath, JSON.parse, logMainFileSearchDiagnostic, options);
                await fileSystemCache.setData(pkgPath, pkg !== null && pkg !== void 0 ? pkg : {});
            }
            const tspMain = resolveTspMain(pkg);
            if (typeof tspMain === "string") {
                mainFile = tspMain;
            }
            const candidate = joinPaths(dir, mainFile);
            const stat = await doIO(() => compilerHost.stat(candidate), candidate, logMainFileSearchDiagnostic, options);
            if (stat === null || stat === void 0 ? void 0 : stat.isFile()) {
                return candidate;
            }
            const parentDir = getDirectoryPath(dir);
            if (parentDir === dir) {
                break;
            }
            dir = parentDir;
        }
        return path;
        function logMainFileSearchDiagnostic(diagnostic) {
            log(`Unexpected diagnostic while looking for main file of ${path}`, formatDiagnostic(diagnostic));
        }
    }
    async function getPath(document) {
        if (isUntitled(document.uri)) {
            return document.uri;
        }
        const path = await fileURLToRealPath(document.uri);
        pathToURLMap.set(path, document.uri);
        return path;
    }
    function getURL(path) {
        var _a;
        if (isUntitled(path)) {
            return path;
        }
        return (_a = pathToURLMap.get(path)) !== null && _a !== void 0 ? _a : compilerHost.pathToFileURL(path);
    }
    function isUntitled(pathOrUrl) {
        return pathOrUrl.startsWith("untitled:");
    }
    function getOpenDocument(path) {
        const url = getURL(path);
        return url ? host.getOpenDocumentByURL(url) : undefined;
    }
    async function fileURLToRealPath(url) {
        return getNormalizedRealPath(compilerHost, compilerHost.fileURLToPath(url));
    }
    function createFileSystemCache() {
        const cache = new Map();
        let changes = [];
        return {
            async get(path) {
                for (const change of changes) {
                    const path = await fileURLToRealPath(change.uri);
                    cache.delete(path);
                }
                changes = [];
                return cache.get(path);
            },
            set(path, entry) {
                cache.set(path, entry);
            },
            async setData(path, data) {
                const entry = await this.get(path);
                if (entry) {
                    entry.data = data;
                }
            },
            notify(changes) {
                changes.push(...changes);
            },
        };
    }
    function createCompilerHost() {
        const base = host.compilerHost;
        return {
            ...base,
            parseCache: new WeakMap(),
            readFile,
            stat,
            getSourceFileKind,
        };
        async function readFile(path) {
            const document = getOpenDocument(path);
            const cached = await fileSystemCache.get(path);
            // Try cache
            if (cached && (!document || document.version === cached.version)) {
                if (cached.type === "error") {
                    throw cached.error;
                }
                return cached.file;
            }
            // Try open document, although this is cheap, the instance still needs
            // to be cached so that the compiler can reuse parse and bind results.
            if (document) {
                const file = {
                    document,
                    ...createSourceFile(document.getText(), path),
                };
                fileSystemCache.set(path, { type: "file", file, version: document.version });
                return file;
            }
            // Hit the disk and cache
            try {
                const file = await base.readFile(path);
                fileSystemCache.set(path, { type: "file", file });
                return file;
            }
            catch (error) {
                fileSystemCache.set(path, { type: "error", error });
                throw error;
            }
        }
        async function stat(path) {
            var _a;
            // if we have an open document for the path or a cache entry, then we know
            // it's a file and not a directory and needn't hit the disk.
            if (getOpenDocument(path) || ((_a = (await fileSystemCache.get(path))) === null || _a === void 0 ? void 0 : _a.type) === "file") {
                return {
                    isFile() {
                        return true;
                    },
                    isDirectory() {
                        return false;
                    },
                };
            }
            return await base.stat(path);
        }
        function getSourceFileKind(path) {
            const document = getOpenDocument(path);
            if ((document === null || document === void 0 ? void 0 : document.languageId) === "typespec") {
                return "typespec";
            }
            return getSourceFileKindFromExt(path);
        }
    }
}
function getSignatureHelpNodeAtPosition(script, position) {
    // Move back over any trailing trivia. Otherwise, if there is no
    // closing paren/angle bracket, we can find ourselves outside the desired
    // node altogether in cases like `@dec(test, |`.
    position = getPositionBeforeTrivia(script, position);
    const node = getNodeAtPosition(script, position, (n) => {
        switch (n.kind) {
            case SyntaxKind.DecoratorExpression:
            case SyntaxKind.AugmentDecoratorStatement:
            case SyntaxKind.TypeReference:
                // Do not consider node if positioned before the argument list.
                // This is the standard behavior for signature help and further
                // deals with nesting such as `Outer<Inner|> where we do not want
                // we want help with the `Outer` arguments, not the `Inner` ones.
                if (position <= n.target.end) {
                    return false;
                }
                // Likewise, no signature help at the end of argument list unless the
                // it has no closing paren/angle bracket.
                if (position === n.end) {
                    const endChar = script.file.text.charCodeAt(position - 1);
                    const closeChar = n.kind === SyntaxKind.TypeReference ? 62 /* CharCode.GreaterThan */ : 41 /* CharCode.CloseParen */;
                    if (endChar === closeChar) {
                        return false;
                    }
                }
                return true;
            default:
                return false;
        }
    });
    if (!node) {
        return undefined;
    }
    const argumentIndex = getSignatureHelpArgumentIndex(script, node, position);
    if (argumentIndex < 0) {
        return undefined;
    }
    return { node, argumentIndex };
}
function getSignatureHelpArgumentIndex(script, node, position) {
    // Normalize arguments into a single list to avoid special case for
    // augment decorators.
    const args = node.kind === SyntaxKind.AugmentDecoratorStatement
        ? [node.targetType, ...node.arguments]
        : node.arguments;
    // Find the first argument that ends after the position. We don't look at
    // the argument start position since the cursor might be in leading
    // trivia, and we skip trivia to get the effective argument end position
    // since the cursor might be in trailing trivia.
    for (let i = 0; i < args.length; i++) {
        if (position <= skipTrivia(script.file.text, args[i].end)) {
            return i;
        }
    }
    // If we reach here, we must be at the next argument after any that are in
    // the syntax tree. There won't be a missing identifier for this argument
    // in the tree since the parser error recovery will have assumed a
    // trailing delimiter or empty list.
    return args.length;
}
/**
 * Resolve the node that should be auto completed at the given position.
 * It will try to guess what node it could be as during auto complete the ast might not be complete.
 * @internal
 */
function getCompletionNodeAtPosition(script, position, filter = (node) => true) {
    const realNode = getNodeAtPosition(script, position, filter);
    if ((realNode === null || realNode === void 0 ? void 0 : realNode.kind) === SyntaxKind.StringLiteral) {
        return realNode;
    }
    // If we're not immediately after an identifier character, then advance
    // the position past any trivia. This is done because a zero-width
    // inserted missing identifier that the user is now trying to complete
    // starts after the trivia following the cursor.
    const cp = codePointBefore(script.file.text, position);
    if (!cp || !isIdentifierContinue(cp)) {
        const newPosition = skipTrivia(script.file.text, position);
        if (newPosition !== position) {
            return getNodeAtPosition(script, newPosition, filter);
        }
    }
    return realNode;
}

export { emitFile as $, isTypeSpecValueTypeOf as A, validateDecoratorParamType as B, createDecoratorDefinition as C, DuplicateTracker as D, validateDecoratorParamCount as E, cadlTypeToJson as F, typespecTypeToJson as G, validateDecoratorUniqueOnNode as H, validateDecoratorNotOnType as I, isDeprecated as J, getDeprecationDetails as K, markDeprecated as L, MANIFEST as M, createDiagnosticCreator as N, logDiagnostics as O, ProjectionError as P, Queue as Q, formatDiagnostic as R, createSourceFile as S, TwoLevelMap as T, getSourceLocation as U, logVerboseTestOutput as V, compilerAssert as W, assertType as X, reportDeprecated as Y, createDiagnosticCollector as Z, ignoreDiagnostics as _, isTemplateDeclarationOrInstance as a, getDocDataInternal as a$, formatTypeSpec as a0, checkFormatCadl as a1, checkFormatTypeSpec as a2, printId as a3, getDiscriminatedUnion as a4, getLocationContext as a5, stringTemplateToString as a6, getTypeName as a7, isStdNamespace as a8, getNamespaceFullName as a9, navigateProgram as aA, navigateType as aB, scopeNavigationToNamespace as aC, navigateTypesInNamespace as aD, mapEventEmitterToNodeListener as aE, getProperty as aF, EventEmitter as aG, isErrorType$1 as aH, isVoidType as aI, isNeverType as aJ, isUnknownType as aK, isNullType as aL, getParentTemplateNode as aM, isTemplateInstance as aN, isDeclaredType as aO, isGlobalNamespace as aP, isDeclaredInNamespace as aQ, getFullyQualifiedSymbolName as aR, SyntaxKind as aS, IdentifierKind as aT, NoTarget as aU, ListenerFlow as aV, namespace as aW, $summary as aX, getSummary as aY, $doc as aZ, $docFromComment as a_, UsageFlags as aa, resolveUsages as ab, parse$2 as ac, parseStandaloneTypeReference as ad, visitChildren as ae, getNodeAtPosition as af, hasParseError as ag, isImportStatement as ah, getFirstAncestor as ai, getIdentifierContext as aj, isProjectedProgram as ak, compile as al, createStateAccessors as am, Token as an, TokenDisplay as ao, Keywords as ap, TokenFlags as aq, isTrivia as ar, isComment as as, isKeyword as at, isPunctuation as au, isModifier as av, isStatementKeyword as aw, createScanner as ax, skipTrivia as ay, skipWhiteSpace as az, f0 as b, getKeyName as b$, getDocData as b0, getDoc as b1, $returnsDoc as b2, getReturnsDocData as b3, getReturnsDoc as b4, $errorsDoc as b5, getErrorsDocData as b6, getErrorsDoc as b7, $inspectType as b8, $inspectTypeName as b9, getMinValueExclusive as bA, $maxValueExclusive as bB, getMaxValueExclusive as bC, $secret as bD, isSecret as bE, $encode as bF, getEncode as bG, $visibility as bH, getVisibility as bI, $withVisibility as bJ, isVisible as bK, $withOptionalProperties as bL, $withUpdateableProperties as bM, $withoutOmittedProperties as bN, $withoutDefaultValues as bO, $list as bP, getListOperationType as bQ, isListOperation as bR, $tag as bS, getTags as bT, getAllTags as bU, $friendlyName as bV, getFriendlyName as bW, $knownValues as bX, getKnownValues as bY, $key as bZ, isKey as b_, $indexer as ba, getIndexer as bb, isStringType as bc, isNumericType as bd, isArrayModelType as be, isRecordModelType as bf, getPropertyType as bg, $error as bh, isErrorModel as bi, $format as bj, getFormat as bk, $pattern as bl, getPattern as bm, $minLength as bn, getMinLength as bo, $maxLength as bp, getMaxLength as bq, $minItems as br, getMinItems as bs, $maxItems as bt, getMaxItems as bu, $minValue as bv, getMinValue as bw, $maxValue as bx, getMaxValue as by, $minValueExclusive as bz, createCadlLibrary as c, $withDefaultKeyVisibility as c0, $deprecated as c1, getDeprecated as c2, $overload as c3, getOverloads as c4, getOverloadedOperation as c5, $projectedName as c6, getProjectedNames as c7, getProjectedName as c8, hasProjectedName as c9, $discriminator as ca, getDiscriminator as cb, getDiscriminatedTypes as cc, $parameterVisibility as cd, getParameterVisibility as ce, $returnTypeVisibility as cf, getReturnTypeVisibility as cg, listServices as ch, getService as ci, isService as cj, addService as ck, $service as cl, SemanticTokenKind as cm, createServer as cn, getCompletionNodeAtPosition as co, EmitterResult as cp, Placeholder as cq, resolveDeclarationReferenceScope as cr, ReferenceCycle as cs, createAssetEmitter as ct, Declaration as cu, RawCode as cv, NoEmit as cw, CircularEmit as cx, createLinterRule as d, createTypeSpecLibrary as e, formatter as f, paramMessage as g, setTypeSpecNamespace as h, isTemplateDeclaration as i, createRekeyableMap as j, getSourceFileKindFromExt as k, cadlVersion as l, createChecker as m, getEffectiveModelType as n, filterModelProperties as o, projectProgram as p, getOverriddenProperty as q, resolveCompilerOptions as r, setCadlNamespace as s, typespecVersion as t, finishTypeForProgram as u, validateDecoratorTarget as v, walkPropertiesInherited as w, isIntrinsicType as x, validateDecoratorTargetIntrinsic as y, isCadlValueTypeOf as z };
